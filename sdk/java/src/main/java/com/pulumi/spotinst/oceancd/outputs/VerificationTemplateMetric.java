// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.spotinst.oceancd.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.spotinst.oceancd.outputs.VerificationTemplateMetricBaseline;
import com.pulumi.spotinst.oceancd.outputs.VerificationTemplateMetricProvider;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class VerificationTemplateMetric {
    /**
     * @return Baseline Object.
     * 
     */
    private @Nullable VerificationTemplateMetricBaseline baseline;
    /**
     * @return The maximum number of times the measurement is allowed to error in succession, before the metric is considered error.Default is 4.When choosing `Jenkins` as the provider, there is no need to send this variable.
     * 
     */
    private @Nullable Integer consecutiveErrorLimit;
    /**
     * @return The number of times to run the measurement. If both interval and count are omitted, the effective count is 1. If only interval is specified, metric runs indefinitely. If count &gt; 1, interval must be specified. When choosing `Jenkins` as the provider, there is no need to send this variable.
     * 
     */
    private @Nullable Integer count;
    /**
     * @return Defines whether the metric should have an impact on the result of the rollout.
     * 
     */
    private @Nullable Boolean dryRun;
    /**
     * @return An expression which determines if a measurement is considered failed.If failureCondition is set, then successCondition is not allowed. When choosing Jenkins as the provider, there is no need to send this variable.
     * 
     */
    private @Nullable String failureCondition;
    /**
     * @return The maximum number of times the measurement is allowed to fail, before the entire metric is considered failed.Default is 0. When choosing `Jenkins` as the provider, there is no need to send this variable.
     * 
     */
    private @Nullable Integer failureLimit;
    /**
     * @return How long to wait before starting this metric measurements. When choosing Jenkins as the provider, there is no need to send this variable.
     * 
     */
    private @Nullable String initialDelay;
    /**
     * @return Defines an interval string (30s, 5m, 1h) between each verification measurements. If omitted, will perform a single measurement.When choosing Jenkins as the provider, there is no need to send this variable.
     * 
     */
    private @Nullable String interval;
    /**
     * @return The name of the verification metric.
     * 
     */
    private String metricsName;
    /**
     * @return The name of the monitoring tool chosen for the metric.
     * 
     */
    private List<VerificationTemplateMetricProvider> providers;
    /**
     * @return An expression which determines if a measurement is considered successful. The keyword `result` is a variable reference to the value of measurement. Results can be both structured data or primitive. If successCondition is set, then failureCondition is not allowed. When choosing `Jenkins` as the provider, there is no need to send this variable.
     * 
     */
    private @Nullable String successCondition;

    private VerificationTemplateMetric() {}
    /**
     * @return Baseline Object.
     * 
     */
    public Optional<VerificationTemplateMetricBaseline> baseline() {
        return Optional.ofNullable(this.baseline);
    }
    /**
     * @return The maximum number of times the measurement is allowed to error in succession, before the metric is considered error.Default is 4.When choosing `Jenkins` as the provider, there is no need to send this variable.
     * 
     */
    public Optional<Integer> consecutiveErrorLimit() {
        return Optional.ofNullable(this.consecutiveErrorLimit);
    }
    /**
     * @return The number of times to run the measurement. If both interval and count are omitted, the effective count is 1. If only interval is specified, metric runs indefinitely. If count &gt; 1, interval must be specified. When choosing `Jenkins` as the provider, there is no need to send this variable.
     * 
     */
    public Optional<Integer> count() {
        return Optional.ofNullable(this.count);
    }
    /**
     * @return Defines whether the metric should have an impact on the result of the rollout.
     * 
     */
    public Optional<Boolean> dryRun() {
        return Optional.ofNullable(this.dryRun);
    }
    /**
     * @return An expression which determines if a measurement is considered failed.If failureCondition is set, then successCondition is not allowed. When choosing Jenkins as the provider, there is no need to send this variable.
     * 
     */
    public Optional<String> failureCondition() {
        return Optional.ofNullable(this.failureCondition);
    }
    /**
     * @return The maximum number of times the measurement is allowed to fail, before the entire metric is considered failed.Default is 0. When choosing `Jenkins` as the provider, there is no need to send this variable.
     * 
     */
    public Optional<Integer> failureLimit() {
        return Optional.ofNullable(this.failureLimit);
    }
    /**
     * @return How long to wait before starting this metric measurements. When choosing Jenkins as the provider, there is no need to send this variable.
     * 
     */
    public Optional<String> initialDelay() {
        return Optional.ofNullable(this.initialDelay);
    }
    /**
     * @return Defines an interval string (30s, 5m, 1h) between each verification measurements. If omitted, will perform a single measurement.When choosing Jenkins as the provider, there is no need to send this variable.
     * 
     */
    public Optional<String> interval() {
        return Optional.ofNullable(this.interval);
    }
    /**
     * @return The name of the verification metric.
     * 
     */
    public String metricsName() {
        return this.metricsName;
    }
    /**
     * @return The name of the monitoring tool chosen for the metric.
     * 
     */
    public List<VerificationTemplateMetricProvider> providers() {
        return this.providers;
    }
    /**
     * @return An expression which determines if a measurement is considered successful. The keyword `result` is a variable reference to the value of measurement. Results can be both structured data or primitive. If successCondition is set, then failureCondition is not allowed. When choosing `Jenkins` as the provider, there is no need to send this variable.
     * 
     */
    public Optional<String> successCondition() {
        return Optional.ofNullable(this.successCondition);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(VerificationTemplateMetric defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable VerificationTemplateMetricBaseline baseline;
        private @Nullable Integer consecutiveErrorLimit;
        private @Nullable Integer count;
        private @Nullable Boolean dryRun;
        private @Nullable String failureCondition;
        private @Nullable Integer failureLimit;
        private @Nullable String initialDelay;
        private @Nullable String interval;
        private String metricsName;
        private List<VerificationTemplateMetricProvider> providers;
        private @Nullable String successCondition;
        public Builder() {}
        public Builder(VerificationTemplateMetric defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.baseline = defaults.baseline;
    	      this.consecutiveErrorLimit = defaults.consecutiveErrorLimit;
    	      this.count = defaults.count;
    	      this.dryRun = defaults.dryRun;
    	      this.failureCondition = defaults.failureCondition;
    	      this.failureLimit = defaults.failureLimit;
    	      this.initialDelay = defaults.initialDelay;
    	      this.interval = defaults.interval;
    	      this.metricsName = defaults.metricsName;
    	      this.providers = defaults.providers;
    	      this.successCondition = defaults.successCondition;
        }

        @CustomType.Setter
        public Builder baseline(@Nullable VerificationTemplateMetricBaseline baseline) {

            this.baseline = baseline;
            return this;
        }
        @CustomType.Setter
        public Builder consecutiveErrorLimit(@Nullable Integer consecutiveErrorLimit) {

            this.consecutiveErrorLimit = consecutiveErrorLimit;
            return this;
        }
        @CustomType.Setter
        public Builder count(@Nullable Integer count) {

            this.count = count;
            return this;
        }
        @CustomType.Setter
        public Builder dryRun(@Nullable Boolean dryRun) {

            this.dryRun = dryRun;
            return this;
        }
        @CustomType.Setter
        public Builder failureCondition(@Nullable String failureCondition) {

            this.failureCondition = failureCondition;
            return this;
        }
        @CustomType.Setter
        public Builder failureLimit(@Nullable Integer failureLimit) {

            this.failureLimit = failureLimit;
            return this;
        }
        @CustomType.Setter
        public Builder initialDelay(@Nullable String initialDelay) {

            this.initialDelay = initialDelay;
            return this;
        }
        @CustomType.Setter
        public Builder interval(@Nullable String interval) {

            this.interval = interval;
            return this;
        }
        @CustomType.Setter
        public Builder metricsName(String metricsName) {
            if (metricsName == null) {
              throw new MissingRequiredPropertyException("VerificationTemplateMetric", "metricsName");
            }
            this.metricsName = metricsName;
            return this;
        }
        @CustomType.Setter
        public Builder providers(List<VerificationTemplateMetricProvider> providers) {
            if (providers == null) {
              throw new MissingRequiredPropertyException("VerificationTemplateMetric", "providers");
            }
            this.providers = providers;
            return this;
        }
        public Builder providers(VerificationTemplateMetricProvider... providers) {
            return providers(List.of(providers));
        }
        @CustomType.Setter
        public Builder successCondition(@Nullable String successCondition) {

            this.successCondition = successCondition;
            return this;
        }
        public VerificationTemplateMetric build() {
            final var _resultValue = new VerificationTemplateMetric();
            _resultValue.baseline = baseline;
            _resultValue.consecutiveErrorLimit = consecutiveErrorLimit;
            _resultValue.count = count;
            _resultValue.dryRun = dryRun;
            _resultValue.failureCondition = failureCondition;
            _resultValue.failureLimit = failureLimit;
            _resultValue.initialDelay = initialDelay;
            _resultValue.interval = interval;
            _resultValue.metricsName = metricsName;
            _resultValue.providers = providers;
            _resultValue.successCondition = successCondition;
            return _resultValue;
        }
    }
}
