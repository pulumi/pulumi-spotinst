// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.spotinst.aws.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.spotinst.aws.inputs.OceanAutoscalerArgs;
import com.pulumi.spotinst.aws.inputs.OceanInstanceMetadataOptionsArgs;
import com.pulumi.spotinst.aws.inputs.OceanLoadBalancerArgs;
import com.pulumi.spotinst.aws.inputs.OceanLoggingArgs;
import com.pulumi.spotinst.aws.inputs.OceanScheduledTaskArgs;
import com.pulumi.spotinst.aws.inputs.OceanTagArgs;
import com.pulumi.spotinst.aws.inputs.OceanUpdatePolicyArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class OceanState extends com.pulumi.resources.ResourceArgs {

    public static final OceanState Empty = new OceanState();

    /**
     * Configure public IP address allocation.
     * 
     */
    @Import(name="associatePublicIpAddress")
    private @Nullable Output<Boolean> associatePublicIpAddress;

    /**
     * @return Configure public IP address allocation.
     * 
     */
    public Optional<Output<Boolean>> associatePublicIpAddress() {
        return Optional.ofNullable(this.associatePublicIpAddress);
    }

    /**
     * Describes the Ocean Kubernetes Auto Scaler.
     * 
     */
    @Import(name="autoscaler")
    private @Nullable Output<OceanAutoscalerArgs> autoscaler;

    /**
     * @return Describes the Ocean Kubernetes Auto Scaler.
     * 
     */
    public Optional<Output<OceanAutoscalerArgs>> autoscaler() {
        return Optional.ofNullable(this.autoscaler);
    }

    /**
     * Instance types not allowed in the Ocean cluster. Cannot be configured if `whitelist` is configured.
     * 
     */
    @Import(name="blacklists")
    private @Nullable Output<List<String>> blacklists;

    /**
     * @return Instance types not allowed in the Ocean cluster. Cannot be configured if `whitelist` is configured.
     * 
     */
    public Optional<Output<List<String>>> blacklists() {
        return Optional.ofNullable(this.blacklists);
    }

    /**
     * A unique identifier used for connecting the Ocean SaaS platform and the Kubernetes cluster. Typically, the cluster name is used as its identifier.
     * 
     */
    @Import(name="controllerId")
    private @Nullable Output<String> controllerId;

    /**
     * @return A unique identifier used for connecting the Ocean SaaS platform and the Kubernetes cluster. Typically, the cluster name is used as its identifier.
     * 
     */
    public Optional<Output<String>> controllerId() {
        return Optional.ofNullable(this.controllerId);
    }

    /**
     * The number of instances to launch and maintain in the cluster.
     * 
     */
    @Import(name="desiredCapacity")
    private @Nullable Output<Integer> desiredCapacity;

    /**
     * @return The number of instances to launch and maintain in the cluster.
     * 
     */
    public Optional<Output<Integer>> desiredCapacity() {
        return Optional.ofNullable(this.desiredCapacity);
    }

    /**
     * The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
     * 
     */
    @Import(name="drainingTimeout")
    private @Nullable Output<Integer> drainingTimeout;

    /**
     * @return The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
     * 
     */
    public Optional<Output<Integer>> drainingTimeout() {
        return Optional.ofNullable(this.drainingTimeout);
    }

    /**
     * Enable EBS optimized for cluster. Flag will enable optimized capacity for high bandwidth connectivity to the EB service for non EBS optimized instance types. For instances that are EBS optimized this flag will be ignored.
     * 
     */
    @Import(name="ebsOptimized")
    private @Nullable Output<Boolean> ebsOptimized;

    /**
     * @return Enable EBS optimized for cluster. Flag will enable optimized capacity for high bandwidth connectivity to the EB service for non EBS optimized instance types. For instances that are EBS optimized this flag will be ignored.
     * 
     */
    public Optional<Output<Boolean>> ebsOptimized() {
        return Optional.ofNullable(this.ebsOptimized);
    }

    /**
     * If not Spot instance markets are available, enable Ocean to launch On-Demand instances instead.
     * 
     */
    @Import(name="fallbackToOndemand")
    private @Nullable Output<Boolean> fallbackToOndemand;

    /**
     * @return If not Spot instance markets are available, enable Ocean to launch On-Demand instances instead.
     * 
     */
    public Optional<Output<Boolean>> fallbackToOndemand() {
        return Optional.ofNullable(this.fallbackToOndemand);
    }

    /**
     * The amount of time, in seconds, after the instance has launched to start checking its health.
     * 
     */
    @Import(name="gracePeriod")
    private @Nullable Output<Integer> gracePeriod;

    /**
     * @return The amount of time, in seconds, after the instance has launched to start checking its health.
     * 
     */
    public Optional<Output<Integer>> gracePeriod() {
        return Optional.ofNullable(this.gracePeriod);
    }

    /**
     * The instance profile iam role.
     * 
     */
    @Import(name="iamInstanceProfile")
    private @Nullable Output<String> iamInstanceProfile;

    /**
     * @return The instance profile iam role.
     * 
     */
    public Optional<Output<String>> iamInstanceProfile() {
        return Optional.ofNullable(this.iamInstanceProfile);
    }

    /**
     * ID of the image used to launch the instances.
     * 
     */
    @Import(name="imageId")
    private @Nullable Output<String> imageId;

    /**
     * @return ID of the image used to launch the instances.
     * 
     */
    public Optional<Output<String>> imageId() {
        return Optional.ofNullable(this.imageId);
    }

    /**
     * Ocean instance metadata options object for IMDSv2.
     * 
     */
    @Import(name="instanceMetadataOptions")
    private @Nullable Output<OceanInstanceMetadataOptionsArgs> instanceMetadataOptions;

    /**
     * @return Ocean instance metadata options object for IMDSv2.
     * 
     */
    public Optional<Output<OceanInstanceMetadataOptionsArgs>> instanceMetadataOptions() {
        return Optional.ofNullable(this.instanceMetadataOptions);
    }

    /**
     * The key pair to attach the instances.
     * 
     */
    @Import(name="keyName")
    private @Nullable Output<String> keyName;

    /**
     * @return The key pair to attach the instances.
     * 
     */
    public Optional<Output<String>> keyName() {
        return Optional.ofNullable(this.keyName);
    }

    /**
     * - Array of load balancer objects to add to ocean cluster
     * 
     */
    @Import(name="loadBalancers")
    private @Nullable Output<List<OceanLoadBalancerArgs>> loadBalancers;

    /**
     * @return - Array of load balancer objects to add to ocean cluster
     * 
     */
    public Optional<Output<List<OceanLoadBalancerArgs>>> loadBalancers() {
        return Optional.ofNullable(this.loadBalancers);
    }

    /**
     * Logging configuration.
     * 
     */
    @Import(name="logging")
    private @Nullable Output<OceanLoggingArgs> logging;

    /**
     * @return Logging configuration.
     * 
     */
    public Optional<Output<OceanLoggingArgs>> logging() {
        return Optional.ofNullable(this.logging);
    }

    /**
     * The upper limit of instances the cluster can scale up to.
     * 
     */
    @Import(name="maxSize")
    private @Nullable Output<Integer> maxSize;

    /**
     * @return The upper limit of instances the cluster can scale up to.
     * 
     */
    public Optional<Output<Integer>> maxSize() {
        return Optional.ofNullable(this.maxSize);
    }

    /**
     * The lower limit of instances the cluster can scale down to.
     * 
     */
    @Import(name="minSize")
    private @Nullable Output<Integer> minSize;

    /**
     * @return The lower limit of instances the cluster can scale down to.
     * 
     */
    public Optional<Output<Integer>> minSize() {
        return Optional.ofNullable(this.minSize);
    }

    /**
     * Enable detailed monitoring for cluster. Flag will enable Cloud Watch detailed monitoring (one minute increments). Note: there are additional hourly costs for this service based on the region used.
     * 
     */
    @Import(name="monitoring")
    private @Nullable Output<Boolean> monitoring;

    /**
     * @return Enable detailed monitoring for cluster. Flag will enable Cloud Watch detailed monitoring (one minute increments). Note: there are additional hourly costs for this service based on the region used.
     * 
     */
    public Optional<Output<Boolean>> monitoring() {
        return Optional.ofNullable(this.monitoring);
    }

    /**
     * Required if type is set to `CLASSIC`
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return Required if type is set to `CLASSIC`
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The region the cluster will run in.
     * 
     */
    @Import(name="region")
    private @Nullable Output<String> region;

    /**
     * @return The region the cluster will run in.
     * 
     */
    public Optional<Output<String>> region() {
        return Optional.ofNullable(this.region);
    }

    /**
     * The size (in Gb) to allocate for the root volume. Minimum `20`.
     * 
     */
    @Import(name="rootVolumeSize")
    private @Nullable Output<Integer> rootVolumeSize;

    /**
     * @return The size (in Gb) to allocate for the root volume. Minimum `20`.
     * 
     */
    public Optional<Output<Integer>> rootVolumeSize() {
        return Optional.ofNullable(this.rootVolumeSize);
    }

    /**
     * Set scheduling object.
     * 
     */
    @Import(name="scheduledTasks")
    private @Nullable Output<List<OceanScheduledTaskArgs>> scheduledTasks;

    /**
     * @return Set scheduling object.
     * 
     */
    public Optional<Output<List<OceanScheduledTaskArgs>>> scheduledTasks() {
        return Optional.ofNullable(this.scheduledTasks);
    }

    /**
     * One or more security group ids.
     * 
     */
    @Import(name="securityGroups")
    private @Nullable Output<List<String>> securityGroups;

    /**
     * @return One or more security group ids.
     * 
     */
    public Optional<Output<List<String>>> securityGroups() {
        return Optional.ofNullable(this.securityGroups);
    }

    /**
     * The percentage of Spot instances that would spin up from the `desired_capacity` number.
     * 
     */
    @Import(name="spotPercentage")
    private @Nullable Output<Integer> spotPercentage;

    /**
     * @return The percentage of Spot instances that would spin up from the `desired_capacity` number.
     * 
     */
    public Optional<Output<Integer>> spotPercentage() {
        return Optional.ofNullable(this.spotPercentage);
    }

    /**
     * A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public IP.
     * 
     */
    @Import(name="subnetIds")
    private @Nullable Output<List<String>> subnetIds;

    /**
     * @return A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public IP.
     * 
     */
    public Optional<Output<List<String>>> subnetIds() {
        return Optional.ofNullable(this.subnetIds);
    }

    /**
     * Optionally adds tags to instances launched in an Ocean cluster.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<List<OceanTagArgs>> tags;

    /**
     * @return Optionally adds tags to instances launched in an Ocean cluster.
     * 
     */
    public Optional<Output<List<OceanTagArgs>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    @Import(name="updatePolicy")
    private @Nullable Output<OceanUpdatePolicyArgs> updatePolicy;

    public Optional<Output<OceanUpdatePolicyArgs>> updatePolicy() {
        return Optional.ofNullable(this.updatePolicy);
    }

    /**
     * launch specification defined on the Ocean object will function only as a template for virtual node groups.
     * When set to true, on Ocean resource creation please make sure your custom VNG has an initial_nodes parameter to create nodes for your VNG.
     * 
     */
    @Import(name="useAsTemplateOnly")
    private @Nullable Output<Boolean> useAsTemplateOnly;

    /**
     * @return launch specification defined on the Ocean object will function only as a template for virtual node groups.
     * When set to true, on Ocean resource creation please make sure your custom VNG has an initial_nodes parameter to create nodes for your VNG.
     * 
     */
    public Optional<Output<Boolean>> useAsTemplateOnly() {
        return Optional.ofNullable(this.useAsTemplateOnly);
    }

    /**
     * Base64-encoded MIME user data to make available to the instances.
     * 
     */
    @Import(name="userData")
    private @Nullable Output<String> userData;

    /**
     * @return Base64-encoded MIME user data to make available to the instances.
     * 
     */
    public Optional<Output<String>> userData() {
        return Optional.ofNullable(this.userData);
    }

    /**
     * If savings plans exist, Ocean will utilize them before launching Spot instances.
     * 
     */
    @Import(name="utilizeCommitments")
    private @Nullable Output<Boolean> utilizeCommitments;

    /**
     * @return If savings plans exist, Ocean will utilize them before launching Spot instances.
     * 
     */
    public Optional<Output<Boolean>> utilizeCommitments() {
        return Optional.ofNullable(this.utilizeCommitments);
    }

    /**
     * If Reserved instances exist, Ocean will utilize them before launching Spot instances.
     * 
     */
    @Import(name="utilizeReservedInstances")
    private @Nullable Output<Boolean> utilizeReservedInstances;

    /**
     * @return If Reserved instances exist, Ocean will utilize them before launching Spot instances.
     * 
     */
    public Optional<Output<Boolean>> utilizeReservedInstances() {
        return Optional.ofNullable(this.utilizeReservedInstances);
    }

    /**
     * Instance types allowed in the Ocean cluster. Cannot be configured if `blacklist` is configured.
     * 
     */
    @Import(name="whitelists")
    private @Nullable Output<List<String>> whitelists;

    /**
     * @return Instance types allowed in the Ocean cluster. Cannot be configured if `blacklist` is configured.
     * 
     */
    public Optional<Output<List<String>>> whitelists() {
        return Optional.ofNullable(this.whitelists);
    }

    private OceanState() {}

    private OceanState(OceanState $) {
        this.associatePublicIpAddress = $.associatePublicIpAddress;
        this.autoscaler = $.autoscaler;
        this.blacklists = $.blacklists;
        this.controllerId = $.controllerId;
        this.desiredCapacity = $.desiredCapacity;
        this.drainingTimeout = $.drainingTimeout;
        this.ebsOptimized = $.ebsOptimized;
        this.fallbackToOndemand = $.fallbackToOndemand;
        this.gracePeriod = $.gracePeriod;
        this.iamInstanceProfile = $.iamInstanceProfile;
        this.imageId = $.imageId;
        this.instanceMetadataOptions = $.instanceMetadataOptions;
        this.keyName = $.keyName;
        this.loadBalancers = $.loadBalancers;
        this.logging = $.logging;
        this.maxSize = $.maxSize;
        this.minSize = $.minSize;
        this.monitoring = $.monitoring;
        this.name = $.name;
        this.region = $.region;
        this.rootVolumeSize = $.rootVolumeSize;
        this.scheduledTasks = $.scheduledTasks;
        this.securityGroups = $.securityGroups;
        this.spotPercentage = $.spotPercentage;
        this.subnetIds = $.subnetIds;
        this.tags = $.tags;
        this.updatePolicy = $.updatePolicy;
        this.useAsTemplateOnly = $.useAsTemplateOnly;
        this.userData = $.userData;
        this.utilizeCommitments = $.utilizeCommitments;
        this.utilizeReservedInstances = $.utilizeReservedInstances;
        this.whitelists = $.whitelists;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(OceanState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private OceanState $;

        public Builder() {
            $ = new OceanState();
        }

        public Builder(OceanState defaults) {
            $ = new OceanState(Objects.requireNonNull(defaults));
        }

        /**
         * @param associatePublicIpAddress Configure public IP address allocation.
         * 
         * @return builder
         * 
         */
        public Builder associatePublicIpAddress(@Nullable Output<Boolean> associatePublicIpAddress) {
            $.associatePublicIpAddress = associatePublicIpAddress;
            return this;
        }

        /**
         * @param associatePublicIpAddress Configure public IP address allocation.
         * 
         * @return builder
         * 
         */
        public Builder associatePublicIpAddress(Boolean associatePublicIpAddress) {
            return associatePublicIpAddress(Output.of(associatePublicIpAddress));
        }

        /**
         * @param autoscaler Describes the Ocean Kubernetes Auto Scaler.
         * 
         * @return builder
         * 
         */
        public Builder autoscaler(@Nullable Output<OceanAutoscalerArgs> autoscaler) {
            $.autoscaler = autoscaler;
            return this;
        }

        /**
         * @param autoscaler Describes the Ocean Kubernetes Auto Scaler.
         * 
         * @return builder
         * 
         */
        public Builder autoscaler(OceanAutoscalerArgs autoscaler) {
            return autoscaler(Output.of(autoscaler));
        }

        /**
         * @param blacklists Instance types not allowed in the Ocean cluster. Cannot be configured if `whitelist` is configured.
         * 
         * @return builder
         * 
         */
        public Builder blacklists(@Nullable Output<List<String>> blacklists) {
            $.blacklists = blacklists;
            return this;
        }

        /**
         * @param blacklists Instance types not allowed in the Ocean cluster. Cannot be configured if `whitelist` is configured.
         * 
         * @return builder
         * 
         */
        public Builder blacklists(List<String> blacklists) {
            return blacklists(Output.of(blacklists));
        }

        /**
         * @param blacklists Instance types not allowed in the Ocean cluster. Cannot be configured if `whitelist` is configured.
         * 
         * @return builder
         * 
         */
        public Builder blacklists(String... blacklists) {
            return blacklists(List.of(blacklists));
        }

        /**
         * @param controllerId A unique identifier used for connecting the Ocean SaaS platform and the Kubernetes cluster. Typically, the cluster name is used as its identifier.
         * 
         * @return builder
         * 
         */
        public Builder controllerId(@Nullable Output<String> controllerId) {
            $.controllerId = controllerId;
            return this;
        }

        /**
         * @param controllerId A unique identifier used for connecting the Ocean SaaS platform and the Kubernetes cluster. Typically, the cluster name is used as its identifier.
         * 
         * @return builder
         * 
         */
        public Builder controllerId(String controllerId) {
            return controllerId(Output.of(controllerId));
        }

        /**
         * @param desiredCapacity The number of instances to launch and maintain in the cluster.
         * 
         * @return builder
         * 
         */
        public Builder desiredCapacity(@Nullable Output<Integer> desiredCapacity) {
            $.desiredCapacity = desiredCapacity;
            return this;
        }

        /**
         * @param desiredCapacity The number of instances to launch and maintain in the cluster.
         * 
         * @return builder
         * 
         */
        public Builder desiredCapacity(Integer desiredCapacity) {
            return desiredCapacity(Output.of(desiredCapacity));
        }

        /**
         * @param drainingTimeout The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
         * 
         * @return builder
         * 
         */
        public Builder drainingTimeout(@Nullable Output<Integer> drainingTimeout) {
            $.drainingTimeout = drainingTimeout;
            return this;
        }

        /**
         * @param drainingTimeout The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
         * 
         * @return builder
         * 
         */
        public Builder drainingTimeout(Integer drainingTimeout) {
            return drainingTimeout(Output.of(drainingTimeout));
        }

        /**
         * @param ebsOptimized Enable EBS optimized for cluster. Flag will enable optimized capacity for high bandwidth connectivity to the EB service for non EBS optimized instance types. For instances that are EBS optimized this flag will be ignored.
         * 
         * @return builder
         * 
         */
        public Builder ebsOptimized(@Nullable Output<Boolean> ebsOptimized) {
            $.ebsOptimized = ebsOptimized;
            return this;
        }

        /**
         * @param ebsOptimized Enable EBS optimized for cluster. Flag will enable optimized capacity for high bandwidth connectivity to the EB service for non EBS optimized instance types. For instances that are EBS optimized this flag will be ignored.
         * 
         * @return builder
         * 
         */
        public Builder ebsOptimized(Boolean ebsOptimized) {
            return ebsOptimized(Output.of(ebsOptimized));
        }

        /**
         * @param fallbackToOndemand If not Spot instance markets are available, enable Ocean to launch On-Demand instances instead.
         * 
         * @return builder
         * 
         */
        public Builder fallbackToOndemand(@Nullable Output<Boolean> fallbackToOndemand) {
            $.fallbackToOndemand = fallbackToOndemand;
            return this;
        }

        /**
         * @param fallbackToOndemand If not Spot instance markets are available, enable Ocean to launch On-Demand instances instead.
         * 
         * @return builder
         * 
         */
        public Builder fallbackToOndemand(Boolean fallbackToOndemand) {
            return fallbackToOndemand(Output.of(fallbackToOndemand));
        }

        /**
         * @param gracePeriod The amount of time, in seconds, after the instance has launched to start checking its health.
         * 
         * @return builder
         * 
         */
        public Builder gracePeriod(@Nullable Output<Integer> gracePeriod) {
            $.gracePeriod = gracePeriod;
            return this;
        }

        /**
         * @param gracePeriod The amount of time, in seconds, after the instance has launched to start checking its health.
         * 
         * @return builder
         * 
         */
        public Builder gracePeriod(Integer gracePeriod) {
            return gracePeriod(Output.of(gracePeriod));
        }

        /**
         * @param iamInstanceProfile The instance profile iam role.
         * 
         * @return builder
         * 
         */
        public Builder iamInstanceProfile(@Nullable Output<String> iamInstanceProfile) {
            $.iamInstanceProfile = iamInstanceProfile;
            return this;
        }

        /**
         * @param iamInstanceProfile The instance profile iam role.
         * 
         * @return builder
         * 
         */
        public Builder iamInstanceProfile(String iamInstanceProfile) {
            return iamInstanceProfile(Output.of(iamInstanceProfile));
        }

        /**
         * @param imageId ID of the image used to launch the instances.
         * 
         * @return builder
         * 
         */
        public Builder imageId(@Nullable Output<String> imageId) {
            $.imageId = imageId;
            return this;
        }

        /**
         * @param imageId ID of the image used to launch the instances.
         * 
         * @return builder
         * 
         */
        public Builder imageId(String imageId) {
            return imageId(Output.of(imageId));
        }

        /**
         * @param instanceMetadataOptions Ocean instance metadata options object for IMDSv2.
         * 
         * @return builder
         * 
         */
        public Builder instanceMetadataOptions(@Nullable Output<OceanInstanceMetadataOptionsArgs> instanceMetadataOptions) {
            $.instanceMetadataOptions = instanceMetadataOptions;
            return this;
        }

        /**
         * @param instanceMetadataOptions Ocean instance metadata options object for IMDSv2.
         * 
         * @return builder
         * 
         */
        public Builder instanceMetadataOptions(OceanInstanceMetadataOptionsArgs instanceMetadataOptions) {
            return instanceMetadataOptions(Output.of(instanceMetadataOptions));
        }

        /**
         * @param keyName The key pair to attach the instances.
         * 
         * @return builder
         * 
         */
        public Builder keyName(@Nullable Output<String> keyName) {
            $.keyName = keyName;
            return this;
        }

        /**
         * @param keyName The key pair to attach the instances.
         * 
         * @return builder
         * 
         */
        public Builder keyName(String keyName) {
            return keyName(Output.of(keyName));
        }

        /**
         * @param loadBalancers - Array of load balancer objects to add to ocean cluster
         * 
         * @return builder
         * 
         */
        public Builder loadBalancers(@Nullable Output<List<OceanLoadBalancerArgs>> loadBalancers) {
            $.loadBalancers = loadBalancers;
            return this;
        }

        /**
         * @param loadBalancers - Array of load balancer objects to add to ocean cluster
         * 
         * @return builder
         * 
         */
        public Builder loadBalancers(List<OceanLoadBalancerArgs> loadBalancers) {
            return loadBalancers(Output.of(loadBalancers));
        }

        /**
         * @param loadBalancers - Array of load balancer objects to add to ocean cluster
         * 
         * @return builder
         * 
         */
        public Builder loadBalancers(OceanLoadBalancerArgs... loadBalancers) {
            return loadBalancers(List.of(loadBalancers));
        }

        /**
         * @param logging Logging configuration.
         * 
         * @return builder
         * 
         */
        public Builder logging(@Nullable Output<OceanLoggingArgs> logging) {
            $.logging = logging;
            return this;
        }

        /**
         * @param logging Logging configuration.
         * 
         * @return builder
         * 
         */
        public Builder logging(OceanLoggingArgs logging) {
            return logging(Output.of(logging));
        }

        /**
         * @param maxSize The upper limit of instances the cluster can scale up to.
         * 
         * @return builder
         * 
         */
        public Builder maxSize(@Nullable Output<Integer> maxSize) {
            $.maxSize = maxSize;
            return this;
        }

        /**
         * @param maxSize The upper limit of instances the cluster can scale up to.
         * 
         * @return builder
         * 
         */
        public Builder maxSize(Integer maxSize) {
            return maxSize(Output.of(maxSize));
        }

        /**
         * @param minSize The lower limit of instances the cluster can scale down to.
         * 
         * @return builder
         * 
         */
        public Builder minSize(@Nullable Output<Integer> minSize) {
            $.minSize = minSize;
            return this;
        }

        /**
         * @param minSize The lower limit of instances the cluster can scale down to.
         * 
         * @return builder
         * 
         */
        public Builder minSize(Integer minSize) {
            return minSize(Output.of(minSize));
        }

        /**
         * @param monitoring Enable detailed monitoring for cluster. Flag will enable Cloud Watch detailed monitoring (one minute increments). Note: there are additional hourly costs for this service based on the region used.
         * 
         * @return builder
         * 
         */
        public Builder monitoring(@Nullable Output<Boolean> monitoring) {
            $.monitoring = monitoring;
            return this;
        }

        /**
         * @param monitoring Enable detailed monitoring for cluster. Flag will enable Cloud Watch detailed monitoring (one minute increments). Note: there are additional hourly costs for this service based on the region used.
         * 
         * @return builder
         * 
         */
        public Builder monitoring(Boolean monitoring) {
            return monitoring(Output.of(monitoring));
        }

        /**
         * @param name Required if type is set to `CLASSIC`
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name Required if type is set to `CLASSIC`
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param region The region the cluster will run in.
         * 
         * @return builder
         * 
         */
        public Builder region(@Nullable Output<String> region) {
            $.region = region;
            return this;
        }

        /**
         * @param region The region the cluster will run in.
         * 
         * @return builder
         * 
         */
        public Builder region(String region) {
            return region(Output.of(region));
        }

        /**
         * @param rootVolumeSize The size (in Gb) to allocate for the root volume. Minimum `20`.
         * 
         * @return builder
         * 
         */
        public Builder rootVolumeSize(@Nullable Output<Integer> rootVolumeSize) {
            $.rootVolumeSize = rootVolumeSize;
            return this;
        }

        /**
         * @param rootVolumeSize The size (in Gb) to allocate for the root volume. Minimum `20`.
         * 
         * @return builder
         * 
         */
        public Builder rootVolumeSize(Integer rootVolumeSize) {
            return rootVolumeSize(Output.of(rootVolumeSize));
        }

        /**
         * @param scheduledTasks Set scheduling object.
         * 
         * @return builder
         * 
         */
        public Builder scheduledTasks(@Nullable Output<List<OceanScheduledTaskArgs>> scheduledTasks) {
            $.scheduledTasks = scheduledTasks;
            return this;
        }

        /**
         * @param scheduledTasks Set scheduling object.
         * 
         * @return builder
         * 
         */
        public Builder scheduledTasks(List<OceanScheduledTaskArgs> scheduledTasks) {
            return scheduledTasks(Output.of(scheduledTasks));
        }

        /**
         * @param scheduledTasks Set scheduling object.
         * 
         * @return builder
         * 
         */
        public Builder scheduledTasks(OceanScheduledTaskArgs... scheduledTasks) {
            return scheduledTasks(List.of(scheduledTasks));
        }

        /**
         * @param securityGroups One or more security group ids.
         * 
         * @return builder
         * 
         */
        public Builder securityGroups(@Nullable Output<List<String>> securityGroups) {
            $.securityGroups = securityGroups;
            return this;
        }

        /**
         * @param securityGroups One or more security group ids.
         * 
         * @return builder
         * 
         */
        public Builder securityGroups(List<String> securityGroups) {
            return securityGroups(Output.of(securityGroups));
        }

        /**
         * @param securityGroups One or more security group ids.
         * 
         * @return builder
         * 
         */
        public Builder securityGroups(String... securityGroups) {
            return securityGroups(List.of(securityGroups));
        }

        /**
         * @param spotPercentage The percentage of Spot instances that would spin up from the `desired_capacity` number.
         * 
         * @return builder
         * 
         */
        public Builder spotPercentage(@Nullable Output<Integer> spotPercentage) {
            $.spotPercentage = spotPercentage;
            return this;
        }

        /**
         * @param spotPercentage The percentage of Spot instances that would spin up from the `desired_capacity` number.
         * 
         * @return builder
         * 
         */
        public Builder spotPercentage(Integer spotPercentage) {
            return spotPercentage(Output.of(spotPercentage));
        }

        /**
         * @param subnetIds A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public IP.
         * 
         * @return builder
         * 
         */
        public Builder subnetIds(@Nullable Output<List<String>> subnetIds) {
            $.subnetIds = subnetIds;
            return this;
        }

        /**
         * @param subnetIds A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public IP.
         * 
         * @return builder
         * 
         */
        public Builder subnetIds(List<String> subnetIds) {
            return subnetIds(Output.of(subnetIds));
        }

        /**
         * @param subnetIds A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public IP.
         * 
         * @return builder
         * 
         */
        public Builder subnetIds(String... subnetIds) {
            return subnetIds(List.of(subnetIds));
        }

        /**
         * @param tags Optionally adds tags to instances launched in an Ocean cluster.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<List<OceanTagArgs>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags Optionally adds tags to instances launched in an Ocean cluster.
         * 
         * @return builder
         * 
         */
        public Builder tags(List<OceanTagArgs> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param tags Optionally adds tags to instances launched in an Ocean cluster.
         * 
         * @return builder
         * 
         */
        public Builder tags(OceanTagArgs... tags) {
            return tags(List.of(tags));
        }

        public Builder updatePolicy(@Nullable Output<OceanUpdatePolicyArgs> updatePolicy) {
            $.updatePolicy = updatePolicy;
            return this;
        }

        public Builder updatePolicy(OceanUpdatePolicyArgs updatePolicy) {
            return updatePolicy(Output.of(updatePolicy));
        }

        /**
         * @param useAsTemplateOnly launch specification defined on the Ocean object will function only as a template for virtual node groups.
         * When set to true, on Ocean resource creation please make sure your custom VNG has an initial_nodes parameter to create nodes for your VNG.
         * 
         * @return builder
         * 
         */
        public Builder useAsTemplateOnly(@Nullable Output<Boolean> useAsTemplateOnly) {
            $.useAsTemplateOnly = useAsTemplateOnly;
            return this;
        }

        /**
         * @param useAsTemplateOnly launch specification defined on the Ocean object will function only as a template for virtual node groups.
         * When set to true, on Ocean resource creation please make sure your custom VNG has an initial_nodes parameter to create nodes for your VNG.
         * 
         * @return builder
         * 
         */
        public Builder useAsTemplateOnly(Boolean useAsTemplateOnly) {
            return useAsTemplateOnly(Output.of(useAsTemplateOnly));
        }

        /**
         * @param userData Base64-encoded MIME user data to make available to the instances.
         * 
         * @return builder
         * 
         */
        public Builder userData(@Nullable Output<String> userData) {
            $.userData = userData;
            return this;
        }

        /**
         * @param userData Base64-encoded MIME user data to make available to the instances.
         * 
         * @return builder
         * 
         */
        public Builder userData(String userData) {
            return userData(Output.of(userData));
        }

        /**
         * @param utilizeCommitments If savings plans exist, Ocean will utilize them before launching Spot instances.
         * 
         * @return builder
         * 
         */
        public Builder utilizeCommitments(@Nullable Output<Boolean> utilizeCommitments) {
            $.utilizeCommitments = utilizeCommitments;
            return this;
        }

        /**
         * @param utilizeCommitments If savings plans exist, Ocean will utilize them before launching Spot instances.
         * 
         * @return builder
         * 
         */
        public Builder utilizeCommitments(Boolean utilizeCommitments) {
            return utilizeCommitments(Output.of(utilizeCommitments));
        }

        /**
         * @param utilizeReservedInstances If Reserved instances exist, Ocean will utilize them before launching Spot instances.
         * 
         * @return builder
         * 
         */
        public Builder utilizeReservedInstances(@Nullable Output<Boolean> utilizeReservedInstances) {
            $.utilizeReservedInstances = utilizeReservedInstances;
            return this;
        }

        /**
         * @param utilizeReservedInstances If Reserved instances exist, Ocean will utilize them before launching Spot instances.
         * 
         * @return builder
         * 
         */
        public Builder utilizeReservedInstances(Boolean utilizeReservedInstances) {
            return utilizeReservedInstances(Output.of(utilizeReservedInstances));
        }

        /**
         * @param whitelists Instance types allowed in the Ocean cluster. Cannot be configured if `blacklist` is configured.
         * 
         * @return builder
         * 
         */
        public Builder whitelists(@Nullable Output<List<String>> whitelists) {
            $.whitelists = whitelists;
            return this;
        }

        /**
         * @param whitelists Instance types allowed in the Ocean cluster. Cannot be configured if `blacklist` is configured.
         * 
         * @return builder
         * 
         */
        public Builder whitelists(List<String> whitelists) {
            return whitelists(Output.of(whitelists));
        }

        /**
         * @param whitelists Instance types allowed in the Ocean cluster. Cannot be configured if `blacklist` is configured.
         * 
         * @return builder
         * 
         */
        public Builder whitelists(String... whitelists) {
            return whitelists(List.of(whitelists));
        }

        public OceanState build() {
            return $;
        }
    }

}
