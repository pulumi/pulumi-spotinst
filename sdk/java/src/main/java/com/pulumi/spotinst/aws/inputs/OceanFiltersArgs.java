// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.spotinst.aws.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class OceanFiltersArgs extends com.pulumi.resources.ResourceArgs {

    public static final OceanFiltersArgs Empty = new OceanFiltersArgs();

    /**
     * The filtered instance types will support at least one of the architectures from this list.
     * 
     */
    @Import(name="architectures")
    private @Nullable Output<List<String>> architectures;

    /**
     * @return The filtered instance types will support at least one of the architectures from this list.
     * 
     */
    public Optional<Output<List<String>>> architectures() {
        return Optional.ofNullable(this.architectures);
    }

    /**
     * The filtered instance types will belong to one of the categories types from this list.
     * 
     */
    @Import(name="categories")
    private @Nullable Output<List<String>> categories;

    /**
     * @return The filtered instance types will belong to one of the categories types from this list.
     * 
     */
    public Optional<Output<List<String>>> categories() {
        return Optional.ofNullable(this.categories);
    }

    /**
     * The filtered instance types will have one of the disk type from this list.
     * 
     */
    @Import(name="diskTypes")
    private @Nullable Output<List<String>> diskTypes;

    /**
     * @return The filtered instance types will have one of the disk type from this list.
     * 
     */
    public Optional<Output<List<String>>> diskTypes() {
        return Optional.ofNullable(this.diskTypes);
    }

    /**
     * Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
     * 
     */
    @Import(name="excludeFamilies")
    private @Nullable Output<List<String>> excludeFamilies;

    /**
     * @return Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
     * 
     */
    public Optional<Output<List<String>>> excludeFamilies() {
        return Optional.ofNullable(this.excludeFamilies);
    }

    /**
     * In case excludeMetal is set to true, metal types will not be available for scaling.
     * 
     */
    @Import(name="excludeMetal")
    private @Nullable Output<Boolean> excludeMetal;

    /**
     * @return In case excludeMetal is set to true, metal types will not be available for scaling.
     * 
     */
    public Optional<Output<Boolean>> excludeMetal() {
        return Optional.ofNullable(this.excludeMetal);
    }

    /**
     * The filtered instance types will have a hypervisor type from this list.
     * 
     */
    @Import(name="hypervisors")
    private @Nullable Output<List<String>> hypervisors;

    /**
     * @return The filtered instance types will have a hypervisor type from this list.
     * 
     */
    public Optional<Output<List<String>>> hypervisors() {
        return Optional.ofNullable(this.hypervisors);
    }

    /**
     * Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
     * 
     */
    @Import(name="includeFamilies")
    private @Nullable Output<List<String>> includeFamilies;

    /**
     * @return Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
     * 
     */
    public Optional<Output<List<String>>> includeFamilies() {
        return Optional.ofNullable(this.includeFamilies);
    }

    /**
     * Ena is supported or not.
     * 
     */
    @Import(name="isEnaSupported")
    private @Nullable Output<String> isEnaSupported;

    /**
     * @return Ena is supported or not.
     * 
     */
    public Optional<Output<String>> isEnaSupported() {
        return Optional.ofNullable(this.isEnaSupported);
    }

    /**
     * Maximum total number of GPUs.
     * 
     */
    @Import(name="maxGpu")
    private @Nullable Output<Integer> maxGpu;

    /**
     * @return Maximum total number of GPUs.
     * 
     */
    public Optional<Output<Integer>> maxGpu() {
        return Optional.ofNullable(this.maxGpu);
    }

    /**
     * Maximum amount of Memory (GiB).
     * 
     */
    @Import(name="maxMemoryGib")
    private @Nullable Output<Double> maxMemoryGib;

    /**
     * @return Maximum amount of Memory (GiB).
     * 
     */
    public Optional<Output<Double>> maxMemoryGib() {
        return Optional.ofNullable(this.maxMemoryGib);
    }

    /**
     * Maximum Bandwidth in Gib/s of network performance.
     * 
     */
    @Import(name="maxNetworkPerformance")
    private @Nullable Output<Integer> maxNetworkPerformance;

    /**
     * @return Maximum Bandwidth in Gib/s of network performance.
     * 
     */
    public Optional<Output<Integer>> maxNetworkPerformance() {
        return Optional.ofNullable(this.maxNetworkPerformance);
    }

    /**
     * Maximum number of vcpus available.
     * 
     */
    @Import(name="maxVcpu")
    private @Nullable Output<Integer> maxVcpu;

    /**
     * @return Maximum number of vcpus available.
     * 
     */
    public Optional<Output<Integer>> maxVcpu() {
        return Optional.ofNullable(this.maxVcpu);
    }

    /**
     * Minimum number of network interfaces (ENIs).
     * 
     */
    @Import(name="minEnis")
    private @Nullable Output<Integer> minEnis;

    /**
     * @return Minimum number of network interfaces (ENIs).
     * 
     */
    public Optional<Output<Integer>> minEnis() {
        return Optional.ofNullable(this.minEnis);
    }

    /**
     * Minimum total number of GPUs.
     * 
     */
    @Import(name="minGpu")
    private @Nullable Output<Integer> minGpu;

    /**
     * @return Minimum total number of GPUs.
     * 
     */
    public Optional<Output<Integer>> minGpu() {
        return Optional.ofNullable(this.minGpu);
    }

    /**
     * Minimum amount of Memory (GiB).
     * 
     */
    @Import(name="minMemoryGib")
    private @Nullable Output<Double> minMemoryGib;

    /**
     * @return Minimum amount of Memory (GiB).
     * 
     */
    public Optional<Output<Double>> minMemoryGib() {
        return Optional.ofNullable(this.minMemoryGib);
    }

    /**
     * Minimum Bandwidth in Gib/s of network performance.
     * 
     */
    @Import(name="minNetworkPerformance")
    private @Nullable Output<Integer> minNetworkPerformance;

    /**
     * @return Minimum Bandwidth in Gib/s of network performance.
     * 
     */
    public Optional<Output<Integer>> minNetworkPerformance() {
        return Optional.ofNullable(this.minNetworkPerformance);
    }

    /**
     * Minimum number of vcpus available.
     * 
     */
    @Import(name="minVcpu")
    private @Nullable Output<Integer> minVcpu;

    /**
     * @return Minimum number of vcpus available.
     * 
     */
    public Optional<Output<Integer>> minVcpu() {
        return Optional.ofNullable(this.minVcpu);
    }

    /**
     * The filtered instance types will have a root device types from this list.
     * 
     */
    @Import(name="rootDeviceTypes")
    private @Nullable Output<List<String>> rootDeviceTypes;

    /**
     * @return The filtered instance types will have a root device types from this list.
     * 
     */
    public Optional<Output<List<String>>> rootDeviceTypes() {
        return Optional.ofNullable(this.rootDeviceTypes);
    }

    /**
     * The filtered instance types will support at least one of the virtualization types from this list.
     * 
     */
    @Import(name="virtualizationTypes")
    private @Nullable Output<List<String>> virtualizationTypes;

    /**
     * @return The filtered instance types will support at least one of the virtualization types from this list.
     * 
     */
    public Optional<Output<List<String>>> virtualizationTypes() {
        return Optional.ofNullable(this.virtualizationTypes);
    }

    private OceanFiltersArgs() {}

    private OceanFiltersArgs(OceanFiltersArgs $) {
        this.architectures = $.architectures;
        this.categories = $.categories;
        this.diskTypes = $.diskTypes;
        this.excludeFamilies = $.excludeFamilies;
        this.excludeMetal = $.excludeMetal;
        this.hypervisors = $.hypervisors;
        this.includeFamilies = $.includeFamilies;
        this.isEnaSupported = $.isEnaSupported;
        this.maxGpu = $.maxGpu;
        this.maxMemoryGib = $.maxMemoryGib;
        this.maxNetworkPerformance = $.maxNetworkPerformance;
        this.maxVcpu = $.maxVcpu;
        this.minEnis = $.minEnis;
        this.minGpu = $.minGpu;
        this.minMemoryGib = $.minMemoryGib;
        this.minNetworkPerformance = $.minNetworkPerformance;
        this.minVcpu = $.minVcpu;
        this.rootDeviceTypes = $.rootDeviceTypes;
        this.virtualizationTypes = $.virtualizationTypes;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(OceanFiltersArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private OceanFiltersArgs $;

        public Builder() {
            $ = new OceanFiltersArgs();
        }

        public Builder(OceanFiltersArgs defaults) {
            $ = new OceanFiltersArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param architectures The filtered instance types will support at least one of the architectures from this list.
         * 
         * @return builder
         * 
         */
        public Builder architectures(@Nullable Output<List<String>> architectures) {
            $.architectures = architectures;
            return this;
        }

        /**
         * @param architectures The filtered instance types will support at least one of the architectures from this list.
         * 
         * @return builder
         * 
         */
        public Builder architectures(List<String> architectures) {
            return architectures(Output.of(architectures));
        }

        /**
         * @param architectures The filtered instance types will support at least one of the architectures from this list.
         * 
         * @return builder
         * 
         */
        public Builder architectures(String... architectures) {
            return architectures(List.of(architectures));
        }

        /**
         * @param categories The filtered instance types will belong to one of the categories types from this list.
         * 
         * @return builder
         * 
         */
        public Builder categories(@Nullable Output<List<String>> categories) {
            $.categories = categories;
            return this;
        }

        /**
         * @param categories The filtered instance types will belong to one of the categories types from this list.
         * 
         * @return builder
         * 
         */
        public Builder categories(List<String> categories) {
            return categories(Output.of(categories));
        }

        /**
         * @param categories The filtered instance types will belong to one of the categories types from this list.
         * 
         * @return builder
         * 
         */
        public Builder categories(String... categories) {
            return categories(List.of(categories));
        }

        /**
         * @param diskTypes The filtered instance types will have one of the disk type from this list.
         * 
         * @return builder
         * 
         */
        public Builder diskTypes(@Nullable Output<List<String>> diskTypes) {
            $.diskTypes = diskTypes;
            return this;
        }

        /**
         * @param diskTypes The filtered instance types will have one of the disk type from this list.
         * 
         * @return builder
         * 
         */
        public Builder diskTypes(List<String> diskTypes) {
            return diskTypes(Output.of(diskTypes));
        }

        /**
         * @param diskTypes The filtered instance types will have one of the disk type from this list.
         * 
         * @return builder
         * 
         */
        public Builder diskTypes(String... diskTypes) {
            return diskTypes(List.of(diskTypes));
        }

        /**
         * @param excludeFamilies Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
         * 
         * @return builder
         * 
         */
        public Builder excludeFamilies(@Nullable Output<List<String>> excludeFamilies) {
            $.excludeFamilies = excludeFamilies;
            return this;
        }

        /**
         * @param excludeFamilies Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
         * 
         * @return builder
         * 
         */
        public Builder excludeFamilies(List<String> excludeFamilies) {
            return excludeFamilies(Output.of(excludeFamilies));
        }

        /**
         * @param excludeFamilies Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
         * 
         * @return builder
         * 
         */
        public Builder excludeFamilies(String... excludeFamilies) {
            return excludeFamilies(List.of(excludeFamilies));
        }

        /**
         * @param excludeMetal In case excludeMetal is set to true, metal types will not be available for scaling.
         * 
         * @return builder
         * 
         */
        public Builder excludeMetal(@Nullable Output<Boolean> excludeMetal) {
            $.excludeMetal = excludeMetal;
            return this;
        }

        /**
         * @param excludeMetal In case excludeMetal is set to true, metal types will not be available for scaling.
         * 
         * @return builder
         * 
         */
        public Builder excludeMetal(Boolean excludeMetal) {
            return excludeMetal(Output.of(excludeMetal));
        }

        /**
         * @param hypervisors The filtered instance types will have a hypervisor type from this list.
         * 
         * @return builder
         * 
         */
        public Builder hypervisors(@Nullable Output<List<String>> hypervisors) {
            $.hypervisors = hypervisors;
            return this;
        }

        /**
         * @param hypervisors The filtered instance types will have a hypervisor type from this list.
         * 
         * @return builder
         * 
         */
        public Builder hypervisors(List<String> hypervisors) {
            return hypervisors(Output.of(hypervisors));
        }

        /**
         * @param hypervisors The filtered instance types will have a hypervisor type from this list.
         * 
         * @return builder
         * 
         */
        public Builder hypervisors(String... hypervisors) {
            return hypervisors(List.of(hypervisors));
        }

        /**
         * @param includeFamilies Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
         * 
         * @return builder
         * 
         */
        public Builder includeFamilies(@Nullable Output<List<String>> includeFamilies) {
            $.includeFamilies = includeFamilies;
            return this;
        }

        /**
         * @param includeFamilies Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
         * 
         * @return builder
         * 
         */
        public Builder includeFamilies(List<String> includeFamilies) {
            return includeFamilies(Output.of(includeFamilies));
        }

        /**
         * @param includeFamilies Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
         * 
         * @return builder
         * 
         */
        public Builder includeFamilies(String... includeFamilies) {
            return includeFamilies(List.of(includeFamilies));
        }

        /**
         * @param isEnaSupported Ena is supported or not.
         * 
         * @return builder
         * 
         */
        public Builder isEnaSupported(@Nullable Output<String> isEnaSupported) {
            $.isEnaSupported = isEnaSupported;
            return this;
        }

        /**
         * @param isEnaSupported Ena is supported or not.
         * 
         * @return builder
         * 
         */
        public Builder isEnaSupported(String isEnaSupported) {
            return isEnaSupported(Output.of(isEnaSupported));
        }

        /**
         * @param maxGpu Maximum total number of GPUs.
         * 
         * @return builder
         * 
         */
        public Builder maxGpu(@Nullable Output<Integer> maxGpu) {
            $.maxGpu = maxGpu;
            return this;
        }

        /**
         * @param maxGpu Maximum total number of GPUs.
         * 
         * @return builder
         * 
         */
        public Builder maxGpu(Integer maxGpu) {
            return maxGpu(Output.of(maxGpu));
        }

        /**
         * @param maxMemoryGib Maximum amount of Memory (GiB).
         * 
         * @return builder
         * 
         */
        public Builder maxMemoryGib(@Nullable Output<Double> maxMemoryGib) {
            $.maxMemoryGib = maxMemoryGib;
            return this;
        }

        /**
         * @param maxMemoryGib Maximum amount of Memory (GiB).
         * 
         * @return builder
         * 
         */
        public Builder maxMemoryGib(Double maxMemoryGib) {
            return maxMemoryGib(Output.of(maxMemoryGib));
        }

        /**
         * @param maxNetworkPerformance Maximum Bandwidth in Gib/s of network performance.
         * 
         * @return builder
         * 
         */
        public Builder maxNetworkPerformance(@Nullable Output<Integer> maxNetworkPerformance) {
            $.maxNetworkPerformance = maxNetworkPerformance;
            return this;
        }

        /**
         * @param maxNetworkPerformance Maximum Bandwidth in Gib/s of network performance.
         * 
         * @return builder
         * 
         */
        public Builder maxNetworkPerformance(Integer maxNetworkPerformance) {
            return maxNetworkPerformance(Output.of(maxNetworkPerformance));
        }

        /**
         * @param maxVcpu Maximum number of vcpus available.
         * 
         * @return builder
         * 
         */
        public Builder maxVcpu(@Nullable Output<Integer> maxVcpu) {
            $.maxVcpu = maxVcpu;
            return this;
        }

        /**
         * @param maxVcpu Maximum number of vcpus available.
         * 
         * @return builder
         * 
         */
        public Builder maxVcpu(Integer maxVcpu) {
            return maxVcpu(Output.of(maxVcpu));
        }

        /**
         * @param minEnis Minimum number of network interfaces (ENIs).
         * 
         * @return builder
         * 
         */
        public Builder minEnis(@Nullable Output<Integer> minEnis) {
            $.minEnis = minEnis;
            return this;
        }

        /**
         * @param minEnis Minimum number of network interfaces (ENIs).
         * 
         * @return builder
         * 
         */
        public Builder minEnis(Integer minEnis) {
            return minEnis(Output.of(minEnis));
        }

        /**
         * @param minGpu Minimum total number of GPUs.
         * 
         * @return builder
         * 
         */
        public Builder minGpu(@Nullable Output<Integer> minGpu) {
            $.minGpu = minGpu;
            return this;
        }

        /**
         * @param minGpu Minimum total number of GPUs.
         * 
         * @return builder
         * 
         */
        public Builder minGpu(Integer minGpu) {
            return minGpu(Output.of(minGpu));
        }

        /**
         * @param minMemoryGib Minimum amount of Memory (GiB).
         * 
         * @return builder
         * 
         */
        public Builder minMemoryGib(@Nullable Output<Double> minMemoryGib) {
            $.minMemoryGib = minMemoryGib;
            return this;
        }

        /**
         * @param minMemoryGib Minimum amount of Memory (GiB).
         * 
         * @return builder
         * 
         */
        public Builder minMemoryGib(Double minMemoryGib) {
            return minMemoryGib(Output.of(minMemoryGib));
        }

        /**
         * @param minNetworkPerformance Minimum Bandwidth in Gib/s of network performance.
         * 
         * @return builder
         * 
         */
        public Builder minNetworkPerformance(@Nullable Output<Integer> minNetworkPerformance) {
            $.minNetworkPerformance = minNetworkPerformance;
            return this;
        }

        /**
         * @param minNetworkPerformance Minimum Bandwidth in Gib/s of network performance.
         * 
         * @return builder
         * 
         */
        public Builder minNetworkPerformance(Integer minNetworkPerformance) {
            return minNetworkPerformance(Output.of(minNetworkPerformance));
        }

        /**
         * @param minVcpu Minimum number of vcpus available.
         * 
         * @return builder
         * 
         */
        public Builder minVcpu(@Nullable Output<Integer> minVcpu) {
            $.minVcpu = minVcpu;
            return this;
        }

        /**
         * @param minVcpu Minimum number of vcpus available.
         * 
         * @return builder
         * 
         */
        public Builder minVcpu(Integer minVcpu) {
            return minVcpu(Output.of(minVcpu));
        }

        /**
         * @param rootDeviceTypes The filtered instance types will have a root device types from this list.
         * 
         * @return builder
         * 
         */
        public Builder rootDeviceTypes(@Nullable Output<List<String>> rootDeviceTypes) {
            $.rootDeviceTypes = rootDeviceTypes;
            return this;
        }

        /**
         * @param rootDeviceTypes The filtered instance types will have a root device types from this list.
         * 
         * @return builder
         * 
         */
        public Builder rootDeviceTypes(List<String> rootDeviceTypes) {
            return rootDeviceTypes(Output.of(rootDeviceTypes));
        }

        /**
         * @param rootDeviceTypes The filtered instance types will have a root device types from this list.
         * 
         * @return builder
         * 
         */
        public Builder rootDeviceTypes(String... rootDeviceTypes) {
            return rootDeviceTypes(List.of(rootDeviceTypes));
        }

        /**
         * @param virtualizationTypes The filtered instance types will support at least one of the virtualization types from this list.
         * 
         * @return builder
         * 
         */
        public Builder virtualizationTypes(@Nullable Output<List<String>> virtualizationTypes) {
            $.virtualizationTypes = virtualizationTypes;
            return this;
        }

        /**
         * @param virtualizationTypes The filtered instance types will support at least one of the virtualization types from this list.
         * 
         * @return builder
         * 
         */
        public Builder virtualizationTypes(List<String> virtualizationTypes) {
            return virtualizationTypes(Output.of(virtualizationTypes));
        }

        /**
         * @param virtualizationTypes The filtered instance types will support at least one of the virtualization types from this list.
         * 
         * @return builder
         * 
         */
        public Builder virtualizationTypes(String... virtualizationTypes) {
            return virtualizationTypes(List.of(virtualizationTypes));
        }

        public OceanFiltersArgs build() {
            return $;
        }
    }

}
