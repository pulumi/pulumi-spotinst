// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.spotinst.aws;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.spotinst.aws.inputs.OceanAttachLoadBalancerArgs;
import com.pulumi.spotinst.aws.inputs.OceanAutoscalerArgs;
import com.pulumi.spotinst.aws.inputs.OceanBlockDeviceMappingArgs;
import com.pulumi.spotinst.aws.inputs.OceanClusterOrientationArgs;
import com.pulumi.spotinst.aws.inputs.OceanDetachLoadBalancerArgs;
import com.pulumi.spotinst.aws.inputs.OceanFiltersArgs;
import com.pulumi.spotinst.aws.inputs.OceanInstanceMetadataOptionsArgs;
import com.pulumi.spotinst.aws.inputs.OceanInstanceStorePolicyArgs;
import com.pulumi.spotinst.aws.inputs.OceanLoadBalancerArgs;
import com.pulumi.spotinst.aws.inputs.OceanLoggingArgs;
import com.pulumi.spotinst.aws.inputs.OceanResourceTagSpecificationArgs;
import com.pulumi.spotinst.aws.inputs.OceanScheduledTaskArgs;
import com.pulumi.spotinst.aws.inputs.OceanStartupTaintArgs;
import com.pulumi.spotinst.aws.inputs.OceanTagArgs;
import com.pulumi.spotinst.aws.inputs.OceanUpdatePolicyArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class OceanArgs extends com.pulumi.resources.ResourceArgs {

    public static final OceanArgs Empty = new OceanArgs();

    /**
     * Configure IPv6 address allocation.
     * 
     */
    @Import(name="associateIpv6Address")
    private @Nullable Output<Boolean> associateIpv6Address;

    /**
     * @return Configure IPv6 address allocation.
     * 
     */
    public Optional<Output<Boolean>> associateIpv6Address() {
        return Optional.ofNullable(this.associateIpv6Address);
    }

    /**
     * Configure public IP address allocation.
     * 
     */
    @Import(name="associatePublicIpAddress")
    private @Nullable Output<Boolean> associatePublicIpAddress;

    /**
     * @return Configure public IP address allocation.
     * 
     */
    public Optional<Output<Boolean>> associatePublicIpAddress() {
        return Optional.ofNullable(this.associatePublicIpAddress);
    }

    /**
     * Attach load balancers to the cluster.
     * 
     */
    @Import(name="attachLoadBalancers")
    private @Nullable Output<List<OceanAttachLoadBalancerArgs>> attachLoadBalancers;

    /**
     * @return Attach load balancers to the cluster.
     * 
     */
    public Optional<Output<List<OceanAttachLoadBalancerArgs>>> attachLoadBalancers() {
        return Optional.ofNullable(this.attachLoadBalancers);
    }

    /**
     * Describes the Ocean Kubernetes Auto Scaler.
     * 
     */
    @Import(name="autoscaler")
    private @Nullable Output<OceanAutoscalerArgs> autoscaler;

    /**
     * @return Describes the Ocean Kubernetes Auto Scaler.
     * 
     */
    public Optional<Output<OceanAutoscalerArgs>> autoscaler() {
        return Optional.ofNullable(this.autoscaler);
    }

    @Import(name="blacklists")
    private @Nullable Output<List<String>> blacklists;

    public Optional<Output<List<String>>> blacklists() {
        return Optional.ofNullable(this.blacklists);
    }

    /**
     * Object. Array list of block devices that are exposed to the instance, specify either virtual devices and EBS volumes.
     * 
     */
    @Import(name="blockDeviceMappings")
    private @Nullable Output<List<OceanBlockDeviceMappingArgs>> blockDeviceMappings;

    /**
     * @return Object. Array list of block devices that are exposed to the instance, specify either virtual devices and EBS volumes.
     * 
     */
    public Optional<Output<List<OceanBlockDeviceMappingArgs>>> blockDeviceMappings() {
        return Optional.ofNullable(this.blockDeviceMappings);
    }

    @Import(name="clusterOrientations")
    private @Nullable Output<List<OceanClusterOrientationArgs>> clusterOrientations;

    public Optional<Output<List<OceanClusterOrientationArgs>>> clusterOrientations() {
        return Optional.ofNullable(this.clusterOrientations);
    }

    /**
     * A unique identifier used for connecting the Ocean SaaS platform and the Kubernetes cluster. Typically, the cluster name is used as its identifier.
     * 
     */
    @Import(name="controllerId")
    private @Nullable Output<String> controllerId;

    /**
     * @return A unique identifier used for connecting the Ocean SaaS platform and the Kubernetes cluster. Typically, the cluster name is used as its identifier.
     * 
     */
    public Optional<Output<String>> controllerId() {
        return Optional.ofNullable(this.controllerId);
    }

    /**
     * The number of instances to launch and maintain in the cluster.
     * 
     */
    @Import(name="desiredCapacity")
    private @Nullable Output<Integer> desiredCapacity;

    /**
     * @return The number of instances to launch and maintain in the cluster.
     * 
     */
    public Optional<Output<Integer>> desiredCapacity() {
        return Optional.ofNullable(this.desiredCapacity);
    }

    /**
     * Detach load balancers from the cluster.
     * 
     */
    @Import(name="detachLoadBalancers")
    private @Nullable Output<List<OceanDetachLoadBalancerArgs>> detachLoadBalancers;

    /**
     * @return Detach load balancers from the cluster.
     * 
     */
    public Optional<Output<List<OceanDetachLoadBalancerArgs>>> detachLoadBalancers() {
        return Optional.ofNullable(this.detachLoadBalancers);
    }

    /**
     * The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
     * 
     */
    @Import(name="drainingTimeout")
    private @Nullable Output<Integer> drainingTimeout;

    /**
     * @return The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
     * 
     */
    public Optional<Output<Integer>> drainingTimeout() {
        return Optional.ofNullable(this.drainingTimeout);
    }

    /**
     * Enable EBS optimized for cluster. Flag will enable optimized capacity for high bandwidth connectivity to the EB service for non EBS optimized instance types. For instances that are EBS optimized this flag will be ignored.
     * 
     */
    @Import(name="ebsOptimized")
    private @Nullable Output<Boolean> ebsOptimized;

    /**
     * @return Enable EBS optimized for cluster. Flag will enable optimized capacity for high bandwidth connectivity to the EB service for non EBS optimized instance types. For instances that are EBS optimized this flag will be ignored.
     * 
     */
    public Optional<Output<Boolean>> ebsOptimized() {
        return Optional.ofNullable(this.ebsOptimized);
    }

    /**
     * If not Spot instance markets are available, enable Ocean to launch On-Demand instances instead.
     * 
     */
    @Import(name="fallbackToOndemand")
    private @Nullable Output<Boolean> fallbackToOndemand;

    /**
     * @return If not Spot instance markets are available, enable Ocean to launch On-Demand instances instead.
     * 
     */
    public Optional<Output<Boolean>> fallbackToOndemand() {
        return Optional.ofNullable(this.fallbackToOndemand);
    }

    @Import(name="filters")
    private @Nullable Output<OceanFiltersArgs> filters;

    public Optional<Output<OceanFiltersArgs>> filters() {
        return Optional.ofNullable(this.filters);
    }

    /**
     * The amount of time, in seconds, after the instance has launched to start checking its health.
     * 
     */
    @Import(name="gracePeriod")
    private @Nullable Output<Integer> gracePeriod;

    /**
     * @return The amount of time, in seconds, after the instance has launched to start checking its health.
     * 
     */
    public Optional<Output<Integer>> gracePeriod() {
        return Optional.ofNullable(this.gracePeriod);
    }

    /**
     * The amount of time, in seconds, an existing instance should remain active after becoming unhealthy. After the set time out the instance will be replaced. The minimum value allowed is 60, and it must be a multiple of 60.
     * 
     */
    @Import(name="healthCheckUnhealthyDurationBeforeReplacement")
    private @Nullable Output<Integer> healthCheckUnhealthyDurationBeforeReplacement;

    /**
     * @return The amount of time, in seconds, an existing instance should remain active after becoming unhealthy. After the set time out the instance will be replaced. The minimum value allowed is 60, and it must be a multiple of 60.
     * 
     */
    public Optional<Output<Integer>> healthCheckUnhealthyDurationBeforeReplacement() {
        return Optional.ofNullable(this.healthCheckUnhealthyDurationBeforeReplacement);
    }

    /**
     * The instance profile iam role.
     * 
     */
    @Import(name="iamInstanceProfile")
    private @Nullable Output<String> iamInstanceProfile;

    /**
     * @return The instance profile iam role.
     * 
     */
    public Optional<Output<String>> iamInstanceProfile() {
        return Optional.ofNullable(this.iamInstanceProfile);
    }

    /**
     * ID of the image used to launch the instances.
     * 
     */
    @Import(name="imageId", required=true)
    private Output<String> imageId;

    /**
     * @return ID of the image used to launch the instances.
     * 
     */
    public Output<String> imageId() {
        return this.imageId;
    }

    /**
     * Ocean instance metadata options object for IMDSv2.
     * 
     */
    @Import(name="instanceMetadataOptions")
    private @Nullable Output<OceanInstanceMetadataOptionsArgs> instanceMetadataOptions;

    /**
     * @return Ocean instance metadata options object for IMDSv2.
     * 
     */
    public Optional<Output<OceanInstanceMetadataOptionsArgs>> instanceMetadataOptions() {
        return Optional.ofNullable(this.instanceMetadataOptions);
    }

    /**
     * Determines the utilization of instance store volumes. If not defined, instance store volumes will not be used.
     * 
     */
    @Import(name="instanceStorePolicy")
    private @Nullable Output<OceanInstanceStorePolicyArgs> instanceStorePolicy;

    /**
     * @return Determines the utilization of instance store volumes. If not defined, instance store volumes will not be used.
     * 
     */
    public Optional<Output<OceanInstanceStorePolicyArgs>> instanceStorePolicy() {
        return Optional.ofNullable(this.instanceStorePolicy);
    }

    /**
     * The key pair to attach the instances.
     * 
     */
    @Import(name="keyName")
    private @Nullable Output<String> keyName;

    /**
     * @return The key pair to attach the instances.
     * 
     */
    public Optional<Output<String>> keyName() {
        return Optional.ofNullable(this.keyName);
    }

    /**
     * Array of load balancer objects to add to ocean cluster
     * 
     */
    @Import(name="loadBalancers")
    private @Nullable Output<List<OceanLoadBalancerArgs>> loadBalancers;

    /**
     * @return Array of load balancer objects to add to ocean cluster
     * 
     */
    public Optional<Output<List<OceanLoadBalancerArgs>>> loadBalancers() {
        return Optional.ofNullable(this.loadBalancers);
    }

    /**
     * Logging configuration.
     * 
     */
    @Import(name="logging")
    private @Nullable Output<OceanLoggingArgs> logging;

    /**
     * @return Logging configuration.
     * 
     */
    public Optional<Output<OceanLoggingArgs>> logging() {
        return Optional.ofNullable(this.logging);
    }

    /**
     * The upper limit of instances the cluster can scale up to.
     * 
     */
    @Import(name="maxSize")
    private @Nullable Output<Integer> maxSize;

    /**
     * @return The upper limit of instances the cluster can scale up to.
     * 
     */
    public Optional<Output<Integer>> maxSize() {
        return Optional.ofNullable(this.maxSize);
    }

    /**
     * The lower limit of instances the cluster can scale down to.
     * 
     */
    @Import(name="minSize")
    private @Nullable Output<Integer> minSize;

    /**
     * @return The lower limit of instances the cluster can scale down to.
     * 
     */
    public Optional<Output<Integer>> minSize() {
        return Optional.ofNullable(this.minSize);
    }

    /**
     * Enable detailed monitoring for cluster. Flag will enable Cloud Watch detailed monitoring (one minute increments). Note: there are additional hourly costs for this service based on the region used.
     * 
     */
    @Import(name="monitoring")
    private @Nullable Output<Boolean> monitoring;

    /**
     * @return Enable detailed monitoring for cluster. Flag will enable Cloud Watch detailed monitoring (one minute increments). Note: there are additional hourly costs for this service based on the region used.
     * 
     */
    public Optional<Output<Boolean>> monitoring() {
        return Optional.ofNullable(this.monitoring);
    }

    /**
     * The cluster name.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The cluster name.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Enables assignment of a primary IPv6 address to the cluster. This feature is only available when `associateIpv6Address` is explicitly set to true. Additionally, the cluster must have been initially created as an EKS cluster in IPv6 mode.
     * 
     */
    @Import(name="primaryIpv6")
    private @Nullable Output<Boolean> primaryIpv6;

    /**
     * @return Enables assignment of a primary IPv6 address to the cluster. This feature is only available when `associateIpv6Address` is explicitly set to true. Additionally, the cluster must have been initially created as an EKS cluster in IPv6 mode.
     * 
     */
    public Optional<Output<Boolean>> primaryIpv6() {
        return Optional.ofNullable(this.primaryIpv6);
    }

    /**
     * The region the cluster will run in.
     * 
     */
    @Import(name="region")
    private @Nullable Output<String> region;

    /**
     * @return The region the cluster will run in.
     * 
     */
    public Optional<Output<String>> region() {
        return Optional.ofNullable(this.region);
    }

    /**
     * Specifies the count of ENIs to reserve per instance type for scaling purposes.
     * 
     */
    @Import(name="reservedEnis")
    private @Nullable Output<Integer> reservedEnis;

    /**
     * @return Specifies the count of ENIs to reserve per instance type for scaling purposes.
     * 
     */
    public Optional<Output<Integer>> reservedEnis() {
        return Optional.ofNullable(this.reservedEnis);
    }

    /**
     * Specify which resources should be tagged with Virtual Node Group tags or Ocean tags. If tags are set on the VNG, the resources will be tagged with the VNG tags; otherwise, they will be tagged with the Ocean tags.
     * 
     */
    @Import(name="resourceTagSpecifications")
    private @Nullable Output<List<OceanResourceTagSpecificationArgs>> resourceTagSpecifications;

    /**
     * @return Specify which resources should be tagged with Virtual Node Group tags or Ocean tags. If tags are set on the VNG, the resources will be tagged with the VNG tags; otherwise, they will be tagged with the Ocean tags.
     * 
     */
    public Optional<Output<List<OceanResourceTagSpecificationArgs>>> resourceTagSpecifications() {
        return Optional.ofNullable(this.resourceTagSpecifications);
    }

    /**
     * The size (in Gb) to allocate for the root volume. Minimum `20`.
     * 
     */
    @Import(name="rootVolumeSize")
    private @Nullable Output<Integer> rootVolumeSize;

    /**
     * @return The size (in Gb) to allocate for the root volume. Minimum `20`.
     * 
     */
    public Optional<Output<Integer>> rootVolumeSize() {
        return Optional.ofNullable(this.rootVolumeSize);
    }

    /**
     * Set scheduling object.
     * 
     */
    @Import(name="scheduledTasks")
    private @Nullable Output<List<OceanScheduledTaskArgs>> scheduledTasks;

    /**
     * @return Set scheduling object.
     * 
     */
    public Optional<Output<List<OceanScheduledTaskArgs>>> scheduledTasks() {
        return Optional.ofNullable(this.scheduledTasks);
    }

    /**
     * One or more security group ids.
     * 
     */
    @Import(name="securityGroups", required=true)
    private Output<List<String>> securityGroups;

    /**
     * @return One or more security group ids.
     * 
     */
    public Output<List<String>> securityGroups() {
        return this.securityGroups;
    }

    /**
     * The desired percentage of Spot instances out of all running instances. Only available when the field is not set in any VNG directly (launchSpec.strategy.spotPercentage).
     * 
     */
    @Import(name="spotPercentage")
    private @Nullable Output<Integer> spotPercentage;

    /**
     * @return The desired percentage of Spot instances out of all running instances. Only available when the field is not set in any VNG directly (launchSpec.strategy.spotPercentage).
     * 
     */
    public Optional<Output<Integer>> spotPercentage() {
        return Optional.ofNullable(this.spotPercentage);
    }

    /**
     * Ocean will spread the nodes across markets by this value. Possible values: `vcpu` or `count`.
     * 
     */
    @Import(name="spreadNodesBy")
    private @Nullable Output<String> spreadNodesBy;

    /**
     * @return Ocean will spread the nodes across markets by this value. Possible values: `vcpu` or `count`.
     * 
     */
    public Optional<Output<String>> spreadNodesBy() {
        return Optional.ofNullable(this.spreadNodesBy);
    }

    /**
     * Temporary taints applied to a node during its initialization phase. For a startup taint to work, it must also be set as a regular taint in the userData for the cluster.
     * 
     */
    @Import(name="startupTaints")
    private @Nullable Output<List<OceanStartupTaintArgs>> startupTaints;

    /**
     * @return Temporary taints applied to a node during its initialization phase. For a startup taint to work, it must also be set as a regular taint in the userData for the cluster.
     * 
     */
    public Optional<Output<List<OceanStartupTaintArgs>>> startupTaints() {
        return Optional.ofNullable(this.startupTaints);
    }

    /**
     * A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public IP.
     * * `instanceTypes` - (Optional) The type of instances that may or may not be a part of the Ocean cluster.
     * 
     */
    @Import(name="subnetIds", required=true)
    private Output<List<String>> subnetIds;

    /**
     * @return A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public IP.
     * * `instanceTypes` - (Optional) The type of instances that may or may not be a part of the Ocean cluster.
     * 
     */
    public Output<List<String>> subnetIds() {
        return this.subnetIds;
    }

    /**
     * Optionally adds tags to instances launched in an Ocean cluster.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<List<OceanTagArgs>> tags;

    /**
     * @return Optionally adds tags to instances launched in an Ocean cluster.
     * 
     */
    public Optional<Output<List<OceanTagArgs>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    @Import(name="updatePolicy")
    private @Nullable Output<OceanUpdatePolicyArgs> updatePolicy;

    public Optional<Output<OceanUpdatePolicyArgs>> updatePolicy() {
        return Optional.ofNullable(this.updatePolicy);
    }

    /**
     * launch specification defined on the Ocean object will function only as a template for virtual node groups.
     * When set to true, on Ocean resource creation please make sure your custom VNG has an initialNodes parameter to create nodes for your VNG.
     * 
     */
    @Import(name="useAsTemplateOnly")
    private @Nullable Output<Boolean> useAsTemplateOnly;

    /**
     * @return launch specification defined on the Ocean object will function only as a template for virtual node groups.
     * When set to true, on Ocean resource creation please make sure your custom VNG has an initialNodes parameter to create nodes for your VNG.
     * 
     */
    public Optional<Output<Boolean>> useAsTemplateOnly() {
        return Optional.ofNullable(this.useAsTemplateOnly);
    }

    /**
     * Base64-encoded MIME user data to make available to the instances.
     * 
     */
    @Import(name="userData")
    private @Nullable Output<String> userData;

    /**
     * @return Base64-encoded MIME user data to make available to the instances.
     * 
     */
    public Optional<Output<String>> userData() {
        return Optional.ofNullable(this.userData);
    }

    /**
     * If savings plans exist, Ocean will utilize them before launching Spot instances.
     * 
     */
    @Import(name="utilizeCommitments")
    private @Nullable Output<Boolean> utilizeCommitments;

    /**
     * @return If savings plans exist, Ocean will utilize them before launching Spot instances.
     * 
     */
    public Optional<Output<Boolean>> utilizeCommitments() {
        return Optional.ofNullable(this.utilizeCommitments);
    }

    /**
     * If Reserved instances exist, Ocean will utilize them before launching Spot instances.
     * 
     */
    @Import(name="utilizeReservedInstances")
    private @Nullable Output<Boolean> utilizeReservedInstances;

    /**
     * @return If Reserved instances exist, Ocean will utilize them before launching Spot instances.
     * 
     */
    public Optional<Output<Boolean>> utilizeReservedInstances() {
        return Optional.ofNullable(this.utilizeReservedInstances);
    }

    @Import(name="whitelists")
    private @Nullable Output<List<String>> whitelists;

    public Optional<Output<List<String>>> whitelists() {
        return Optional.ofNullable(this.whitelists);
    }

    private OceanArgs() {}

    private OceanArgs(OceanArgs $) {
        this.associateIpv6Address = $.associateIpv6Address;
        this.associatePublicIpAddress = $.associatePublicIpAddress;
        this.attachLoadBalancers = $.attachLoadBalancers;
        this.autoscaler = $.autoscaler;
        this.blacklists = $.blacklists;
        this.blockDeviceMappings = $.blockDeviceMappings;
        this.clusterOrientations = $.clusterOrientations;
        this.controllerId = $.controllerId;
        this.desiredCapacity = $.desiredCapacity;
        this.detachLoadBalancers = $.detachLoadBalancers;
        this.drainingTimeout = $.drainingTimeout;
        this.ebsOptimized = $.ebsOptimized;
        this.fallbackToOndemand = $.fallbackToOndemand;
        this.filters = $.filters;
        this.gracePeriod = $.gracePeriod;
        this.healthCheckUnhealthyDurationBeforeReplacement = $.healthCheckUnhealthyDurationBeforeReplacement;
        this.iamInstanceProfile = $.iamInstanceProfile;
        this.imageId = $.imageId;
        this.instanceMetadataOptions = $.instanceMetadataOptions;
        this.instanceStorePolicy = $.instanceStorePolicy;
        this.keyName = $.keyName;
        this.loadBalancers = $.loadBalancers;
        this.logging = $.logging;
        this.maxSize = $.maxSize;
        this.minSize = $.minSize;
        this.monitoring = $.monitoring;
        this.name = $.name;
        this.primaryIpv6 = $.primaryIpv6;
        this.region = $.region;
        this.reservedEnis = $.reservedEnis;
        this.resourceTagSpecifications = $.resourceTagSpecifications;
        this.rootVolumeSize = $.rootVolumeSize;
        this.scheduledTasks = $.scheduledTasks;
        this.securityGroups = $.securityGroups;
        this.spotPercentage = $.spotPercentage;
        this.spreadNodesBy = $.spreadNodesBy;
        this.startupTaints = $.startupTaints;
        this.subnetIds = $.subnetIds;
        this.tags = $.tags;
        this.updatePolicy = $.updatePolicy;
        this.useAsTemplateOnly = $.useAsTemplateOnly;
        this.userData = $.userData;
        this.utilizeCommitments = $.utilizeCommitments;
        this.utilizeReservedInstances = $.utilizeReservedInstances;
        this.whitelists = $.whitelists;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(OceanArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private OceanArgs $;

        public Builder() {
            $ = new OceanArgs();
        }

        public Builder(OceanArgs defaults) {
            $ = new OceanArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param associateIpv6Address Configure IPv6 address allocation.
         * 
         * @return builder
         * 
         */
        public Builder associateIpv6Address(@Nullable Output<Boolean> associateIpv6Address) {
            $.associateIpv6Address = associateIpv6Address;
            return this;
        }

        /**
         * @param associateIpv6Address Configure IPv6 address allocation.
         * 
         * @return builder
         * 
         */
        public Builder associateIpv6Address(Boolean associateIpv6Address) {
            return associateIpv6Address(Output.of(associateIpv6Address));
        }

        /**
         * @param associatePublicIpAddress Configure public IP address allocation.
         * 
         * @return builder
         * 
         */
        public Builder associatePublicIpAddress(@Nullable Output<Boolean> associatePublicIpAddress) {
            $.associatePublicIpAddress = associatePublicIpAddress;
            return this;
        }

        /**
         * @param associatePublicIpAddress Configure public IP address allocation.
         * 
         * @return builder
         * 
         */
        public Builder associatePublicIpAddress(Boolean associatePublicIpAddress) {
            return associatePublicIpAddress(Output.of(associatePublicIpAddress));
        }

        /**
         * @param attachLoadBalancers Attach load balancers to the cluster.
         * 
         * @return builder
         * 
         */
        public Builder attachLoadBalancers(@Nullable Output<List<OceanAttachLoadBalancerArgs>> attachLoadBalancers) {
            $.attachLoadBalancers = attachLoadBalancers;
            return this;
        }

        /**
         * @param attachLoadBalancers Attach load balancers to the cluster.
         * 
         * @return builder
         * 
         */
        public Builder attachLoadBalancers(List<OceanAttachLoadBalancerArgs> attachLoadBalancers) {
            return attachLoadBalancers(Output.of(attachLoadBalancers));
        }

        /**
         * @param attachLoadBalancers Attach load balancers to the cluster.
         * 
         * @return builder
         * 
         */
        public Builder attachLoadBalancers(OceanAttachLoadBalancerArgs... attachLoadBalancers) {
            return attachLoadBalancers(List.of(attachLoadBalancers));
        }

        /**
         * @param autoscaler Describes the Ocean Kubernetes Auto Scaler.
         * 
         * @return builder
         * 
         */
        public Builder autoscaler(@Nullable Output<OceanAutoscalerArgs> autoscaler) {
            $.autoscaler = autoscaler;
            return this;
        }

        /**
         * @param autoscaler Describes the Ocean Kubernetes Auto Scaler.
         * 
         * @return builder
         * 
         */
        public Builder autoscaler(OceanAutoscalerArgs autoscaler) {
            return autoscaler(Output.of(autoscaler));
        }

        public Builder blacklists(@Nullable Output<List<String>> blacklists) {
            $.blacklists = blacklists;
            return this;
        }

        public Builder blacklists(List<String> blacklists) {
            return blacklists(Output.of(blacklists));
        }

        public Builder blacklists(String... blacklists) {
            return blacklists(List.of(blacklists));
        }

        /**
         * @param blockDeviceMappings Object. Array list of block devices that are exposed to the instance, specify either virtual devices and EBS volumes.
         * 
         * @return builder
         * 
         */
        public Builder blockDeviceMappings(@Nullable Output<List<OceanBlockDeviceMappingArgs>> blockDeviceMappings) {
            $.blockDeviceMappings = blockDeviceMappings;
            return this;
        }

        /**
         * @param blockDeviceMappings Object. Array list of block devices that are exposed to the instance, specify either virtual devices and EBS volumes.
         * 
         * @return builder
         * 
         */
        public Builder blockDeviceMappings(List<OceanBlockDeviceMappingArgs> blockDeviceMappings) {
            return blockDeviceMappings(Output.of(blockDeviceMappings));
        }

        /**
         * @param blockDeviceMappings Object. Array list of block devices that are exposed to the instance, specify either virtual devices and EBS volumes.
         * 
         * @return builder
         * 
         */
        public Builder blockDeviceMappings(OceanBlockDeviceMappingArgs... blockDeviceMappings) {
            return blockDeviceMappings(List.of(blockDeviceMappings));
        }

        public Builder clusterOrientations(@Nullable Output<List<OceanClusterOrientationArgs>> clusterOrientations) {
            $.clusterOrientations = clusterOrientations;
            return this;
        }

        public Builder clusterOrientations(List<OceanClusterOrientationArgs> clusterOrientations) {
            return clusterOrientations(Output.of(clusterOrientations));
        }

        public Builder clusterOrientations(OceanClusterOrientationArgs... clusterOrientations) {
            return clusterOrientations(List.of(clusterOrientations));
        }

        /**
         * @param controllerId A unique identifier used for connecting the Ocean SaaS platform and the Kubernetes cluster. Typically, the cluster name is used as its identifier.
         * 
         * @return builder
         * 
         */
        public Builder controllerId(@Nullable Output<String> controllerId) {
            $.controllerId = controllerId;
            return this;
        }

        /**
         * @param controllerId A unique identifier used for connecting the Ocean SaaS platform and the Kubernetes cluster. Typically, the cluster name is used as its identifier.
         * 
         * @return builder
         * 
         */
        public Builder controllerId(String controllerId) {
            return controllerId(Output.of(controllerId));
        }

        /**
         * @param desiredCapacity The number of instances to launch and maintain in the cluster.
         * 
         * @return builder
         * 
         */
        public Builder desiredCapacity(@Nullable Output<Integer> desiredCapacity) {
            $.desiredCapacity = desiredCapacity;
            return this;
        }

        /**
         * @param desiredCapacity The number of instances to launch and maintain in the cluster.
         * 
         * @return builder
         * 
         */
        public Builder desiredCapacity(Integer desiredCapacity) {
            return desiredCapacity(Output.of(desiredCapacity));
        }

        /**
         * @param detachLoadBalancers Detach load balancers from the cluster.
         * 
         * @return builder
         * 
         */
        public Builder detachLoadBalancers(@Nullable Output<List<OceanDetachLoadBalancerArgs>> detachLoadBalancers) {
            $.detachLoadBalancers = detachLoadBalancers;
            return this;
        }

        /**
         * @param detachLoadBalancers Detach load balancers from the cluster.
         * 
         * @return builder
         * 
         */
        public Builder detachLoadBalancers(List<OceanDetachLoadBalancerArgs> detachLoadBalancers) {
            return detachLoadBalancers(Output.of(detachLoadBalancers));
        }

        /**
         * @param detachLoadBalancers Detach load balancers from the cluster.
         * 
         * @return builder
         * 
         */
        public Builder detachLoadBalancers(OceanDetachLoadBalancerArgs... detachLoadBalancers) {
            return detachLoadBalancers(List.of(detachLoadBalancers));
        }

        /**
         * @param drainingTimeout The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
         * 
         * @return builder
         * 
         */
        public Builder drainingTimeout(@Nullable Output<Integer> drainingTimeout) {
            $.drainingTimeout = drainingTimeout;
            return this;
        }

        /**
         * @param drainingTimeout The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
         * 
         * @return builder
         * 
         */
        public Builder drainingTimeout(Integer drainingTimeout) {
            return drainingTimeout(Output.of(drainingTimeout));
        }

        /**
         * @param ebsOptimized Enable EBS optimized for cluster. Flag will enable optimized capacity for high bandwidth connectivity to the EB service for non EBS optimized instance types. For instances that are EBS optimized this flag will be ignored.
         * 
         * @return builder
         * 
         */
        public Builder ebsOptimized(@Nullable Output<Boolean> ebsOptimized) {
            $.ebsOptimized = ebsOptimized;
            return this;
        }

        /**
         * @param ebsOptimized Enable EBS optimized for cluster. Flag will enable optimized capacity for high bandwidth connectivity to the EB service for non EBS optimized instance types. For instances that are EBS optimized this flag will be ignored.
         * 
         * @return builder
         * 
         */
        public Builder ebsOptimized(Boolean ebsOptimized) {
            return ebsOptimized(Output.of(ebsOptimized));
        }

        /**
         * @param fallbackToOndemand If not Spot instance markets are available, enable Ocean to launch On-Demand instances instead.
         * 
         * @return builder
         * 
         */
        public Builder fallbackToOndemand(@Nullable Output<Boolean> fallbackToOndemand) {
            $.fallbackToOndemand = fallbackToOndemand;
            return this;
        }

        /**
         * @param fallbackToOndemand If not Spot instance markets are available, enable Ocean to launch On-Demand instances instead.
         * 
         * @return builder
         * 
         */
        public Builder fallbackToOndemand(Boolean fallbackToOndemand) {
            return fallbackToOndemand(Output.of(fallbackToOndemand));
        }

        public Builder filters(@Nullable Output<OceanFiltersArgs> filters) {
            $.filters = filters;
            return this;
        }

        public Builder filters(OceanFiltersArgs filters) {
            return filters(Output.of(filters));
        }

        /**
         * @param gracePeriod The amount of time, in seconds, after the instance has launched to start checking its health.
         * 
         * @return builder
         * 
         */
        public Builder gracePeriod(@Nullable Output<Integer> gracePeriod) {
            $.gracePeriod = gracePeriod;
            return this;
        }

        /**
         * @param gracePeriod The amount of time, in seconds, after the instance has launched to start checking its health.
         * 
         * @return builder
         * 
         */
        public Builder gracePeriod(Integer gracePeriod) {
            return gracePeriod(Output.of(gracePeriod));
        }

        /**
         * @param healthCheckUnhealthyDurationBeforeReplacement The amount of time, in seconds, an existing instance should remain active after becoming unhealthy. After the set time out the instance will be replaced. The minimum value allowed is 60, and it must be a multiple of 60.
         * 
         * @return builder
         * 
         */
        public Builder healthCheckUnhealthyDurationBeforeReplacement(@Nullable Output<Integer> healthCheckUnhealthyDurationBeforeReplacement) {
            $.healthCheckUnhealthyDurationBeforeReplacement = healthCheckUnhealthyDurationBeforeReplacement;
            return this;
        }

        /**
         * @param healthCheckUnhealthyDurationBeforeReplacement The amount of time, in seconds, an existing instance should remain active after becoming unhealthy. After the set time out the instance will be replaced. The minimum value allowed is 60, and it must be a multiple of 60.
         * 
         * @return builder
         * 
         */
        public Builder healthCheckUnhealthyDurationBeforeReplacement(Integer healthCheckUnhealthyDurationBeforeReplacement) {
            return healthCheckUnhealthyDurationBeforeReplacement(Output.of(healthCheckUnhealthyDurationBeforeReplacement));
        }

        /**
         * @param iamInstanceProfile The instance profile iam role.
         * 
         * @return builder
         * 
         */
        public Builder iamInstanceProfile(@Nullable Output<String> iamInstanceProfile) {
            $.iamInstanceProfile = iamInstanceProfile;
            return this;
        }

        /**
         * @param iamInstanceProfile The instance profile iam role.
         * 
         * @return builder
         * 
         */
        public Builder iamInstanceProfile(String iamInstanceProfile) {
            return iamInstanceProfile(Output.of(iamInstanceProfile));
        }

        /**
         * @param imageId ID of the image used to launch the instances.
         * 
         * @return builder
         * 
         */
        public Builder imageId(Output<String> imageId) {
            $.imageId = imageId;
            return this;
        }

        /**
         * @param imageId ID of the image used to launch the instances.
         * 
         * @return builder
         * 
         */
        public Builder imageId(String imageId) {
            return imageId(Output.of(imageId));
        }

        /**
         * @param instanceMetadataOptions Ocean instance metadata options object for IMDSv2.
         * 
         * @return builder
         * 
         */
        public Builder instanceMetadataOptions(@Nullable Output<OceanInstanceMetadataOptionsArgs> instanceMetadataOptions) {
            $.instanceMetadataOptions = instanceMetadataOptions;
            return this;
        }

        /**
         * @param instanceMetadataOptions Ocean instance metadata options object for IMDSv2.
         * 
         * @return builder
         * 
         */
        public Builder instanceMetadataOptions(OceanInstanceMetadataOptionsArgs instanceMetadataOptions) {
            return instanceMetadataOptions(Output.of(instanceMetadataOptions));
        }

        /**
         * @param instanceStorePolicy Determines the utilization of instance store volumes. If not defined, instance store volumes will not be used.
         * 
         * @return builder
         * 
         */
        public Builder instanceStorePolicy(@Nullable Output<OceanInstanceStorePolicyArgs> instanceStorePolicy) {
            $.instanceStorePolicy = instanceStorePolicy;
            return this;
        }

        /**
         * @param instanceStorePolicy Determines the utilization of instance store volumes. If not defined, instance store volumes will not be used.
         * 
         * @return builder
         * 
         */
        public Builder instanceStorePolicy(OceanInstanceStorePolicyArgs instanceStorePolicy) {
            return instanceStorePolicy(Output.of(instanceStorePolicy));
        }

        /**
         * @param keyName The key pair to attach the instances.
         * 
         * @return builder
         * 
         */
        public Builder keyName(@Nullable Output<String> keyName) {
            $.keyName = keyName;
            return this;
        }

        /**
         * @param keyName The key pair to attach the instances.
         * 
         * @return builder
         * 
         */
        public Builder keyName(String keyName) {
            return keyName(Output.of(keyName));
        }

        /**
         * @param loadBalancers Array of load balancer objects to add to ocean cluster
         * 
         * @return builder
         * 
         */
        public Builder loadBalancers(@Nullable Output<List<OceanLoadBalancerArgs>> loadBalancers) {
            $.loadBalancers = loadBalancers;
            return this;
        }

        /**
         * @param loadBalancers Array of load balancer objects to add to ocean cluster
         * 
         * @return builder
         * 
         */
        public Builder loadBalancers(List<OceanLoadBalancerArgs> loadBalancers) {
            return loadBalancers(Output.of(loadBalancers));
        }

        /**
         * @param loadBalancers Array of load balancer objects to add to ocean cluster
         * 
         * @return builder
         * 
         */
        public Builder loadBalancers(OceanLoadBalancerArgs... loadBalancers) {
            return loadBalancers(List.of(loadBalancers));
        }

        /**
         * @param logging Logging configuration.
         * 
         * @return builder
         * 
         */
        public Builder logging(@Nullable Output<OceanLoggingArgs> logging) {
            $.logging = logging;
            return this;
        }

        /**
         * @param logging Logging configuration.
         * 
         * @return builder
         * 
         */
        public Builder logging(OceanLoggingArgs logging) {
            return logging(Output.of(logging));
        }

        /**
         * @param maxSize The upper limit of instances the cluster can scale up to.
         * 
         * @return builder
         * 
         */
        public Builder maxSize(@Nullable Output<Integer> maxSize) {
            $.maxSize = maxSize;
            return this;
        }

        /**
         * @param maxSize The upper limit of instances the cluster can scale up to.
         * 
         * @return builder
         * 
         */
        public Builder maxSize(Integer maxSize) {
            return maxSize(Output.of(maxSize));
        }

        /**
         * @param minSize The lower limit of instances the cluster can scale down to.
         * 
         * @return builder
         * 
         */
        public Builder minSize(@Nullable Output<Integer> minSize) {
            $.minSize = minSize;
            return this;
        }

        /**
         * @param minSize The lower limit of instances the cluster can scale down to.
         * 
         * @return builder
         * 
         */
        public Builder minSize(Integer minSize) {
            return minSize(Output.of(minSize));
        }

        /**
         * @param monitoring Enable detailed monitoring for cluster. Flag will enable Cloud Watch detailed monitoring (one minute increments). Note: there are additional hourly costs for this service based on the region used.
         * 
         * @return builder
         * 
         */
        public Builder monitoring(@Nullable Output<Boolean> monitoring) {
            $.monitoring = monitoring;
            return this;
        }

        /**
         * @param monitoring Enable detailed monitoring for cluster. Flag will enable Cloud Watch detailed monitoring (one minute increments). Note: there are additional hourly costs for this service based on the region used.
         * 
         * @return builder
         * 
         */
        public Builder monitoring(Boolean monitoring) {
            return monitoring(Output.of(monitoring));
        }

        /**
         * @param name The cluster name.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The cluster name.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param primaryIpv6 Enables assignment of a primary IPv6 address to the cluster. This feature is only available when `associateIpv6Address` is explicitly set to true. Additionally, the cluster must have been initially created as an EKS cluster in IPv6 mode.
         * 
         * @return builder
         * 
         */
        public Builder primaryIpv6(@Nullable Output<Boolean> primaryIpv6) {
            $.primaryIpv6 = primaryIpv6;
            return this;
        }

        /**
         * @param primaryIpv6 Enables assignment of a primary IPv6 address to the cluster. This feature is only available when `associateIpv6Address` is explicitly set to true. Additionally, the cluster must have been initially created as an EKS cluster in IPv6 mode.
         * 
         * @return builder
         * 
         */
        public Builder primaryIpv6(Boolean primaryIpv6) {
            return primaryIpv6(Output.of(primaryIpv6));
        }

        /**
         * @param region The region the cluster will run in.
         * 
         * @return builder
         * 
         */
        public Builder region(@Nullable Output<String> region) {
            $.region = region;
            return this;
        }

        /**
         * @param region The region the cluster will run in.
         * 
         * @return builder
         * 
         */
        public Builder region(String region) {
            return region(Output.of(region));
        }

        /**
         * @param reservedEnis Specifies the count of ENIs to reserve per instance type for scaling purposes.
         * 
         * @return builder
         * 
         */
        public Builder reservedEnis(@Nullable Output<Integer> reservedEnis) {
            $.reservedEnis = reservedEnis;
            return this;
        }

        /**
         * @param reservedEnis Specifies the count of ENIs to reserve per instance type for scaling purposes.
         * 
         * @return builder
         * 
         */
        public Builder reservedEnis(Integer reservedEnis) {
            return reservedEnis(Output.of(reservedEnis));
        }

        /**
         * @param resourceTagSpecifications Specify which resources should be tagged with Virtual Node Group tags or Ocean tags. If tags are set on the VNG, the resources will be tagged with the VNG tags; otherwise, they will be tagged with the Ocean tags.
         * 
         * @return builder
         * 
         */
        public Builder resourceTagSpecifications(@Nullable Output<List<OceanResourceTagSpecificationArgs>> resourceTagSpecifications) {
            $.resourceTagSpecifications = resourceTagSpecifications;
            return this;
        }

        /**
         * @param resourceTagSpecifications Specify which resources should be tagged with Virtual Node Group tags or Ocean tags. If tags are set on the VNG, the resources will be tagged with the VNG tags; otherwise, they will be tagged with the Ocean tags.
         * 
         * @return builder
         * 
         */
        public Builder resourceTagSpecifications(List<OceanResourceTagSpecificationArgs> resourceTagSpecifications) {
            return resourceTagSpecifications(Output.of(resourceTagSpecifications));
        }

        /**
         * @param resourceTagSpecifications Specify which resources should be tagged with Virtual Node Group tags or Ocean tags. If tags are set on the VNG, the resources will be tagged with the VNG tags; otherwise, they will be tagged with the Ocean tags.
         * 
         * @return builder
         * 
         */
        public Builder resourceTagSpecifications(OceanResourceTagSpecificationArgs... resourceTagSpecifications) {
            return resourceTagSpecifications(List.of(resourceTagSpecifications));
        }

        /**
         * @param rootVolumeSize The size (in Gb) to allocate for the root volume. Minimum `20`.
         * 
         * @return builder
         * 
         */
        public Builder rootVolumeSize(@Nullable Output<Integer> rootVolumeSize) {
            $.rootVolumeSize = rootVolumeSize;
            return this;
        }

        /**
         * @param rootVolumeSize The size (in Gb) to allocate for the root volume. Minimum `20`.
         * 
         * @return builder
         * 
         */
        public Builder rootVolumeSize(Integer rootVolumeSize) {
            return rootVolumeSize(Output.of(rootVolumeSize));
        }

        /**
         * @param scheduledTasks Set scheduling object.
         * 
         * @return builder
         * 
         */
        public Builder scheduledTasks(@Nullable Output<List<OceanScheduledTaskArgs>> scheduledTasks) {
            $.scheduledTasks = scheduledTasks;
            return this;
        }

        /**
         * @param scheduledTasks Set scheduling object.
         * 
         * @return builder
         * 
         */
        public Builder scheduledTasks(List<OceanScheduledTaskArgs> scheduledTasks) {
            return scheduledTasks(Output.of(scheduledTasks));
        }

        /**
         * @param scheduledTasks Set scheduling object.
         * 
         * @return builder
         * 
         */
        public Builder scheduledTasks(OceanScheduledTaskArgs... scheduledTasks) {
            return scheduledTasks(List.of(scheduledTasks));
        }

        /**
         * @param securityGroups One or more security group ids.
         * 
         * @return builder
         * 
         */
        public Builder securityGroups(Output<List<String>> securityGroups) {
            $.securityGroups = securityGroups;
            return this;
        }

        /**
         * @param securityGroups One or more security group ids.
         * 
         * @return builder
         * 
         */
        public Builder securityGroups(List<String> securityGroups) {
            return securityGroups(Output.of(securityGroups));
        }

        /**
         * @param securityGroups One or more security group ids.
         * 
         * @return builder
         * 
         */
        public Builder securityGroups(String... securityGroups) {
            return securityGroups(List.of(securityGroups));
        }

        /**
         * @param spotPercentage The desired percentage of Spot instances out of all running instances. Only available when the field is not set in any VNG directly (launchSpec.strategy.spotPercentage).
         * 
         * @return builder
         * 
         */
        public Builder spotPercentage(@Nullable Output<Integer> spotPercentage) {
            $.spotPercentage = spotPercentage;
            return this;
        }

        /**
         * @param spotPercentage The desired percentage of Spot instances out of all running instances. Only available when the field is not set in any VNG directly (launchSpec.strategy.spotPercentage).
         * 
         * @return builder
         * 
         */
        public Builder spotPercentage(Integer spotPercentage) {
            return spotPercentage(Output.of(spotPercentage));
        }

        /**
         * @param spreadNodesBy Ocean will spread the nodes across markets by this value. Possible values: `vcpu` or `count`.
         * 
         * @return builder
         * 
         */
        public Builder spreadNodesBy(@Nullable Output<String> spreadNodesBy) {
            $.spreadNodesBy = spreadNodesBy;
            return this;
        }

        /**
         * @param spreadNodesBy Ocean will spread the nodes across markets by this value. Possible values: `vcpu` or `count`.
         * 
         * @return builder
         * 
         */
        public Builder spreadNodesBy(String spreadNodesBy) {
            return spreadNodesBy(Output.of(spreadNodesBy));
        }

        /**
         * @param startupTaints Temporary taints applied to a node during its initialization phase. For a startup taint to work, it must also be set as a regular taint in the userData for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder startupTaints(@Nullable Output<List<OceanStartupTaintArgs>> startupTaints) {
            $.startupTaints = startupTaints;
            return this;
        }

        /**
         * @param startupTaints Temporary taints applied to a node during its initialization phase. For a startup taint to work, it must also be set as a regular taint in the userData for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder startupTaints(List<OceanStartupTaintArgs> startupTaints) {
            return startupTaints(Output.of(startupTaints));
        }

        /**
         * @param startupTaints Temporary taints applied to a node during its initialization phase. For a startup taint to work, it must also be set as a regular taint in the userData for the cluster.
         * 
         * @return builder
         * 
         */
        public Builder startupTaints(OceanStartupTaintArgs... startupTaints) {
            return startupTaints(List.of(startupTaints));
        }

        /**
         * @param subnetIds A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public IP.
         * * `instanceTypes` - (Optional) The type of instances that may or may not be a part of the Ocean cluster.
         * 
         * @return builder
         * 
         */
        public Builder subnetIds(Output<List<String>> subnetIds) {
            $.subnetIds = subnetIds;
            return this;
        }

        /**
         * @param subnetIds A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public IP.
         * * `instanceTypes` - (Optional) The type of instances that may or may not be a part of the Ocean cluster.
         * 
         * @return builder
         * 
         */
        public Builder subnetIds(List<String> subnetIds) {
            return subnetIds(Output.of(subnetIds));
        }

        /**
         * @param subnetIds A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public IP.
         * * `instanceTypes` - (Optional) The type of instances that may or may not be a part of the Ocean cluster.
         * 
         * @return builder
         * 
         */
        public Builder subnetIds(String... subnetIds) {
            return subnetIds(List.of(subnetIds));
        }

        /**
         * @param tags Optionally adds tags to instances launched in an Ocean cluster.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<List<OceanTagArgs>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags Optionally adds tags to instances launched in an Ocean cluster.
         * 
         * @return builder
         * 
         */
        public Builder tags(List<OceanTagArgs> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param tags Optionally adds tags to instances launched in an Ocean cluster.
         * 
         * @return builder
         * 
         */
        public Builder tags(OceanTagArgs... tags) {
            return tags(List.of(tags));
        }

        public Builder updatePolicy(@Nullable Output<OceanUpdatePolicyArgs> updatePolicy) {
            $.updatePolicy = updatePolicy;
            return this;
        }

        public Builder updatePolicy(OceanUpdatePolicyArgs updatePolicy) {
            return updatePolicy(Output.of(updatePolicy));
        }

        /**
         * @param useAsTemplateOnly launch specification defined on the Ocean object will function only as a template for virtual node groups.
         * When set to true, on Ocean resource creation please make sure your custom VNG has an initialNodes parameter to create nodes for your VNG.
         * 
         * @return builder
         * 
         */
        public Builder useAsTemplateOnly(@Nullable Output<Boolean> useAsTemplateOnly) {
            $.useAsTemplateOnly = useAsTemplateOnly;
            return this;
        }

        /**
         * @param useAsTemplateOnly launch specification defined on the Ocean object will function only as a template for virtual node groups.
         * When set to true, on Ocean resource creation please make sure your custom VNG has an initialNodes parameter to create nodes for your VNG.
         * 
         * @return builder
         * 
         */
        public Builder useAsTemplateOnly(Boolean useAsTemplateOnly) {
            return useAsTemplateOnly(Output.of(useAsTemplateOnly));
        }

        /**
         * @param userData Base64-encoded MIME user data to make available to the instances.
         * 
         * @return builder
         * 
         */
        public Builder userData(@Nullable Output<String> userData) {
            $.userData = userData;
            return this;
        }

        /**
         * @param userData Base64-encoded MIME user data to make available to the instances.
         * 
         * @return builder
         * 
         */
        public Builder userData(String userData) {
            return userData(Output.of(userData));
        }

        /**
         * @param utilizeCommitments If savings plans exist, Ocean will utilize them before launching Spot instances.
         * 
         * @return builder
         * 
         */
        public Builder utilizeCommitments(@Nullable Output<Boolean> utilizeCommitments) {
            $.utilizeCommitments = utilizeCommitments;
            return this;
        }

        /**
         * @param utilizeCommitments If savings plans exist, Ocean will utilize them before launching Spot instances.
         * 
         * @return builder
         * 
         */
        public Builder utilizeCommitments(Boolean utilizeCommitments) {
            return utilizeCommitments(Output.of(utilizeCommitments));
        }

        /**
         * @param utilizeReservedInstances If Reserved instances exist, Ocean will utilize them before launching Spot instances.
         * 
         * @return builder
         * 
         */
        public Builder utilizeReservedInstances(@Nullable Output<Boolean> utilizeReservedInstances) {
            $.utilizeReservedInstances = utilizeReservedInstances;
            return this;
        }

        /**
         * @param utilizeReservedInstances If Reserved instances exist, Ocean will utilize them before launching Spot instances.
         * 
         * @return builder
         * 
         */
        public Builder utilizeReservedInstances(Boolean utilizeReservedInstances) {
            return utilizeReservedInstances(Output.of(utilizeReservedInstances));
        }

        public Builder whitelists(@Nullable Output<List<String>> whitelists) {
            $.whitelists = whitelists;
            return this;
        }

        public Builder whitelists(List<String> whitelists) {
            return whitelists(Output.of(whitelists));
        }

        public Builder whitelists(String... whitelists) {
            return whitelists(List.of(whitelists));
        }

        public OceanArgs build() {
            if ($.imageId == null) {
                throw new MissingRequiredPropertyException("OceanArgs", "imageId");
            }
            if ($.securityGroups == null) {
                throw new MissingRequiredPropertyException("OceanArgs", "securityGroups");
            }
            if ($.subnetIds == null) {
                throw new MissingRequiredPropertyException("OceanArgs", "subnetIds");
            }
            return $;
        }
    }

}
