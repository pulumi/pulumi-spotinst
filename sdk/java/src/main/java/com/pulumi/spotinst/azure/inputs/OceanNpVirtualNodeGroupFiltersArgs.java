// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.spotinst.azure.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class OceanNpVirtualNodeGroupFiltersArgs extends com.pulumi.resources.ResourceArgs {

    public static final OceanNpVirtualNodeGroupFiltersArgs Empty = new OceanNpVirtualNodeGroupFiltersArgs();

    /**
     * In case acceleratedNetworking is set to Enabled, accelerated networking applies only to the VM that enables it.
     * 
     */
    @Import(name="acceleratedNetworking")
    private @Nullable Output<String> acceleratedNetworking;

    /**
     * @return In case acceleratedNetworking is set to Enabled, accelerated networking applies only to the VM that enables it.
     * 
     */
    public Optional<Output<String>> acceleratedNetworking() {
        return Optional.ofNullable(this.acceleratedNetworking);
    }

    /**
     * The filtered vm sizes will support at least one of the architectures from this list. x8664 includes both intel64 and amd64.
     * 
     */
    @Import(name="architectures")
    private @Nullable Output<List<String>> architectures;

    /**
     * @return The filtered vm sizes will support at least one of the architectures from this list. x8664 includes both intel64 and amd64.
     * 
     */
    public Optional<Output<List<String>>> architectures() {
        return Optional.ofNullable(this.architectures);
    }

    /**
     * The filtered vm sizes will support at least one of the classes from this list.
     * 
     */
    @Import(name="diskPerformance")
    private @Nullable Output<String> diskPerformance;

    /**
     * @return The filtered vm sizes will support at least one of the classes from this list.
     * 
     */
    public Optional<Output<String>> diskPerformance() {
        return Optional.ofNullable(this.diskPerformance);
    }

    /**
     * Vm sizes belonging to a series from the list will not be available for scaling.
     * 
     */
    @Import(name="excludeSeries")
    private @Nullable Output<List<String>> excludeSeries;

    /**
     * @return Vm sizes belonging to a series from the list will not be available for scaling.
     * 
     */
    public Optional<Output<List<String>>> excludeSeries() {
        return Optional.ofNullable(this.excludeSeries);
    }

    /**
     * The filtered gpu types will belong to one of the gpu types from this list.
     * 
     */
    @Import(name="gpuTypes")
    private @Nullable Output<List<String>> gpuTypes;

    /**
     * @return The filtered gpu types will belong to one of the gpu types from this list.
     * 
     */
    public Optional<Output<List<String>>> gpuTypes() {
        return Optional.ofNullable(this.gpuTypes);
    }

    /**
     * Maximum number of GPUs available.
     * 
     */
    @Import(name="maxGpu")
    private @Nullable Output<Double> maxGpu;

    /**
     * @return Maximum number of GPUs available.
     * 
     */
    public Optional<Output<Double>> maxGpu() {
        return Optional.ofNullable(this.maxGpu);
    }

    /**
     * Maximum amount of Memory (GiB).
     * 
     */
    @Import(name="maxMemoryGib")
    private @Nullable Output<Double> maxMemoryGib;

    /**
     * @return Maximum amount of Memory (GiB).
     * 
     */
    public Optional<Output<Double>> maxMemoryGib() {
        return Optional.ofNullable(this.maxMemoryGib);
    }

    /**
     * Maximum number of vcpus available.
     * 
     */
    @Import(name="maxVcpu")
    private @Nullable Output<Integer> maxVcpu;

    /**
     * @return Maximum number of vcpus available.
     * 
     */
    public Optional<Output<Integer>> maxVcpu() {
        return Optional.ofNullable(this.maxVcpu);
    }

    /**
     * Minimum number of data disks available.
     * 
     */
    @Import(name="minDisk")
    private @Nullable Output<Integer> minDisk;

    /**
     * @return Minimum number of data disks available.
     * 
     */
    public Optional<Output<Integer>> minDisk() {
        return Optional.ofNullable(this.minDisk);
    }

    /**
     * Minimum number of GPUs available.
     * 
     */
    @Import(name="minGpu")
    private @Nullable Output<Double> minGpu;

    /**
     * @return Minimum number of GPUs available.
     * 
     */
    public Optional<Output<Double>> minGpu() {
        return Optional.ofNullable(this.minGpu);
    }

    /**
     * Minimum amount of Memory (GiB).
     * 
     */
    @Import(name="minMemoryGib")
    private @Nullable Output<Double> minMemoryGib;

    /**
     * @return Minimum amount of Memory (GiB).
     * 
     */
    public Optional<Output<Double>> minMemoryGib() {
        return Optional.ofNullable(this.minMemoryGib);
    }

    /**
     * Minimum number of network interfaces.
     * 
     */
    @Import(name="minNics")
    private @Nullable Output<Integer> minNics;

    /**
     * @return Minimum number of network interfaces.
     * 
     */
    public Optional<Output<Integer>> minNics() {
        return Optional.ofNullable(this.minNics);
    }

    /**
     * Minimum number of vcpus available.
     * 
     */
    @Import(name="minVcpu")
    private @Nullable Output<Integer> minVcpu;

    /**
     * @return Minimum number of vcpus available.
     * 
     */
    public Optional<Output<Integer>> minVcpu() {
        return Optional.ofNullable(this.minVcpu);
    }

    /**
     * Vm sizes belonging to a series from the list will be available for scaling.
     * 
     */
    @Import(name="series")
    private @Nullable Output<List<String>> series;

    /**
     * @return Vm sizes belonging to a series from the list will be available for scaling.
     * 
     */
    public Optional<Output<List<String>>> series() {
        return Optional.ofNullable(this.series);
    }

    /**
     * The filtered vm types will belong to one of the vm types from this list.
     * 
     */
    @Import(name="vmTypes")
    private @Nullable Output<List<String>> vmTypes;

    /**
     * @return The filtered vm types will belong to one of the vm types from this list.
     * 
     */
    public Optional<Output<List<String>>> vmTypes() {
        return Optional.ofNullable(this.vmTypes);
    }

    private OceanNpVirtualNodeGroupFiltersArgs() {}

    private OceanNpVirtualNodeGroupFiltersArgs(OceanNpVirtualNodeGroupFiltersArgs $) {
        this.acceleratedNetworking = $.acceleratedNetworking;
        this.architectures = $.architectures;
        this.diskPerformance = $.diskPerformance;
        this.excludeSeries = $.excludeSeries;
        this.gpuTypes = $.gpuTypes;
        this.maxGpu = $.maxGpu;
        this.maxMemoryGib = $.maxMemoryGib;
        this.maxVcpu = $.maxVcpu;
        this.minDisk = $.minDisk;
        this.minGpu = $.minGpu;
        this.minMemoryGib = $.minMemoryGib;
        this.minNics = $.minNics;
        this.minVcpu = $.minVcpu;
        this.series = $.series;
        this.vmTypes = $.vmTypes;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(OceanNpVirtualNodeGroupFiltersArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private OceanNpVirtualNodeGroupFiltersArgs $;

        public Builder() {
            $ = new OceanNpVirtualNodeGroupFiltersArgs();
        }

        public Builder(OceanNpVirtualNodeGroupFiltersArgs defaults) {
            $ = new OceanNpVirtualNodeGroupFiltersArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param acceleratedNetworking In case acceleratedNetworking is set to Enabled, accelerated networking applies only to the VM that enables it.
         * 
         * @return builder
         * 
         */
        public Builder acceleratedNetworking(@Nullable Output<String> acceleratedNetworking) {
            $.acceleratedNetworking = acceleratedNetworking;
            return this;
        }

        /**
         * @param acceleratedNetworking In case acceleratedNetworking is set to Enabled, accelerated networking applies only to the VM that enables it.
         * 
         * @return builder
         * 
         */
        public Builder acceleratedNetworking(String acceleratedNetworking) {
            return acceleratedNetworking(Output.of(acceleratedNetworking));
        }

        /**
         * @param architectures The filtered vm sizes will support at least one of the architectures from this list. x8664 includes both intel64 and amd64.
         * 
         * @return builder
         * 
         */
        public Builder architectures(@Nullable Output<List<String>> architectures) {
            $.architectures = architectures;
            return this;
        }

        /**
         * @param architectures The filtered vm sizes will support at least one of the architectures from this list. x8664 includes both intel64 and amd64.
         * 
         * @return builder
         * 
         */
        public Builder architectures(List<String> architectures) {
            return architectures(Output.of(architectures));
        }

        /**
         * @param architectures The filtered vm sizes will support at least one of the architectures from this list. x8664 includes both intel64 and amd64.
         * 
         * @return builder
         * 
         */
        public Builder architectures(String... architectures) {
            return architectures(List.of(architectures));
        }

        /**
         * @param diskPerformance The filtered vm sizes will support at least one of the classes from this list.
         * 
         * @return builder
         * 
         */
        public Builder diskPerformance(@Nullable Output<String> diskPerformance) {
            $.diskPerformance = diskPerformance;
            return this;
        }

        /**
         * @param diskPerformance The filtered vm sizes will support at least one of the classes from this list.
         * 
         * @return builder
         * 
         */
        public Builder diskPerformance(String diskPerformance) {
            return diskPerformance(Output.of(diskPerformance));
        }

        /**
         * @param excludeSeries Vm sizes belonging to a series from the list will not be available for scaling.
         * 
         * @return builder
         * 
         */
        public Builder excludeSeries(@Nullable Output<List<String>> excludeSeries) {
            $.excludeSeries = excludeSeries;
            return this;
        }

        /**
         * @param excludeSeries Vm sizes belonging to a series from the list will not be available for scaling.
         * 
         * @return builder
         * 
         */
        public Builder excludeSeries(List<String> excludeSeries) {
            return excludeSeries(Output.of(excludeSeries));
        }

        /**
         * @param excludeSeries Vm sizes belonging to a series from the list will not be available for scaling.
         * 
         * @return builder
         * 
         */
        public Builder excludeSeries(String... excludeSeries) {
            return excludeSeries(List.of(excludeSeries));
        }

        /**
         * @param gpuTypes The filtered gpu types will belong to one of the gpu types from this list.
         * 
         * @return builder
         * 
         */
        public Builder gpuTypes(@Nullable Output<List<String>> gpuTypes) {
            $.gpuTypes = gpuTypes;
            return this;
        }

        /**
         * @param gpuTypes The filtered gpu types will belong to one of the gpu types from this list.
         * 
         * @return builder
         * 
         */
        public Builder gpuTypes(List<String> gpuTypes) {
            return gpuTypes(Output.of(gpuTypes));
        }

        /**
         * @param gpuTypes The filtered gpu types will belong to one of the gpu types from this list.
         * 
         * @return builder
         * 
         */
        public Builder gpuTypes(String... gpuTypes) {
            return gpuTypes(List.of(gpuTypes));
        }

        /**
         * @param maxGpu Maximum number of GPUs available.
         * 
         * @return builder
         * 
         */
        public Builder maxGpu(@Nullable Output<Double> maxGpu) {
            $.maxGpu = maxGpu;
            return this;
        }

        /**
         * @param maxGpu Maximum number of GPUs available.
         * 
         * @return builder
         * 
         */
        public Builder maxGpu(Double maxGpu) {
            return maxGpu(Output.of(maxGpu));
        }

        /**
         * @param maxMemoryGib Maximum amount of Memory (GiB).
         * 
         * @return builder
         * 
         */
        public Builder maxMemoryGib(@Nullable Output<Double> maxMemoryGib) {
            $.maxMemoryGib = maxMemoryGib;
            return this;
        }

        /**
         * @param maxMemoryGib Maximum amount of Memory (GiB).
         * 
         * @return builder
         * 
         */
        public Builder maxMemoryGib(Double maxMemoryGib) {
            return maxMemoryGib(Output.of(maxMemoryGib));
        }

        /**
         * @param maxVcpu Maximum number of vcpus available.
         * 
         * @return builder
         * 
         */
        public Builder maxVcpu(@Nullable Output<Integer> maxVcpu) {
            $.maxVcpu = maxVcpu;
            return this;
        }

        /**
         * @param maxVcpu Maximum number of vcpus available.
         * 
         * @return builder
         * 
         */
        public Builder maxVcpu(Integer maxVcpu) {
            return maxVcpu(Output.of(maxVcpu));
        }

        /**
         * @param minDisk Minimum number of data disks available.
         * 
         * @return builder
         * 
         */
        public Builder minDisk(@Nullable Output<Integer> minDisk) {
            $.minDisk = minDisk;
            return this;
        }

        /**
         * @param minDisk Minimum number of data disks available.
         * 
         * @return builder
         * 
         */
        public Builder minDisk(Integer minDisk) {
            return minDisk(Output.of(minDisk));
        }

        /**
         * @param minGpu Minimum number of GPUs available.
         * 
         * @return builder
         * 
         */
        public Builder minGpu(@Nullable Output<Double> minGpu) {
            $.minGpu = minGpu;
            return this;
        }

        /**
         * @param minGpu Minimum number of GPUs available.
         * 
         * @return builder
         * 
         */
        public Builder minGpu(Double minGpu) {
            return minGpu(Output.of(minGpu));
        }

        /**
         * @param minMemoryGib Minimum amount of Memory (GiB).
         * 
         * @return builder
         * 
         */
        public Builder minMemoryGib(@Nullable Output<Double> minMemoryGib) {
            $.minMemoryGib = minMemoryGib;
            return this;
        }

        /**
         * @param minMemoryGib Minimum amount of Memory (GiB).
         * 
         * @return builder
         * 
         */
        public Builder minMemoryGib(Double minMemoryGib) {
            return minMemoryGib(Output.of(minMemoryGib));
        }

        /**
         * @param minNics Minimum number of network interfaces.
         * 
         * @return builder
         * 
         */
        public Builder minNics(@Nullable Output<Integer> minNics) {
            $.minNics = minNics;
            return this;
        }

        /**
         * @param minNics Minimum number of network interfaces.
         * 
         * @return builder
         * 
         */
        public Builder minNics(Integer minNics) {
            return minNics(Output.of(minNics));
        }

        /**
         * @param minVcpu Minimum number of vcpus available.
         * 
         * @return builder
         * 
         */
        public Builder minVcpu(@Nullable Output<Integer> minVcpu) {
            $.minVcpu = minVcpu;
            return this;
        }

        /**
         * @param minVcpu Minimum number of vcpus available.
         * 
         * @return builder
         * 
         */
        public Builder minVcpu(Integer minVcpu) {
            return minVcpu(Output.of(minVcpu));
        }

        /**
         * @param series Vm sizes belonging to a series from the list will be available for scaling.
         * 
         * @return builder
         * 
         */
        public Builder series(@Nullable Output<List<String>> series) {
            $.series = series;
            return this;
        }

        /**
         * @param series Vm sizes belonging to a series from the list will be available for scaling.
         * 
         * @return builder
         * 
         */
        public Builder series(List<String> series) {
            return series(Output.of(series));
        }

        /**
         * @param series Vm sizes belonging to a series from the list will be available for scaling.
         * 
         * @return builder
         * 
         */
        public Builder series(String... series) {
            return series(List.of(series));
        }

        /**
         * @param vmTypes The filtered vm types will belong to one of the vm types from this list.
         * 
         * @return builder
         * 
         */
        public Builder vmTypes(@Nullable Output<List<String>> vmTypes) {
            $.vmTypes = vmTypes;
            return this;
        }

        /**
         * @param vmTypes The filtered vm types will belong to one of the vm types from this list.
         * 
         * @return builder
         * 
         */
        public Builder vmTypes(List<String> vmTypes) {
            return vmTypes(Output.of(vmTypes));
        }

        /**
         * @param vmTypes The filtered vm types will belong to one of the vm types from this list.
         * 
         * @return builder
         * 
         */
        public Builder vmTypes(String... vmTypes) {
            return vmTypes(List.of(vmTypes));
        }

        public OceanNpVirtualNodeGroupFiltersArgs build() {
            return $;
        }
    }

}
