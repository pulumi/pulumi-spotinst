// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.spotinst.ecs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.spotinst.Utilities;
import com.pulumi.spotinst.ecs.OceanArgs;
import com.pulumi.spotinst.ecs.inputs.OceanState;
import com.pulumi.spotinst.ecs.outputs.OceanAutoscaler;
import com.pulumi.spotinst.ecs.outputs.OceanBlockDeviceMapping;
import com.pulumi.spotinst.ecs.outputs.OceanClusterOrientation;
import com.pulumi.spotinst.ecs.outputs.OceanFilters;
import com.pulumi.spotinst.ecs.outputs.OceanInstanceMetadataOptions;
import com.pulumi.spotinst.ecs.outputs.OceanLogging;
import com.pulumi.spotinst.ecs.outputs.OceanOptimizeImages;
import com.pulumi.spotinst.ecs.outputs.OceanScheduledTask;
import com.pulumi.spotinst.ecs.outputs.OceanTag;
import com.pulumi.spotinst.ecs.outputs.OceanUpdatePolicy;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages a Spotinst Ocean ECS resource.
 * 
 * ## Example Usage
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.spotinst.ecs.Ocean;
 * import com.pulumi.spotinst.ecs.OceanArgs;
 * import com.pulumi.spotinst.ecs.inputs.OceanClusterOrientationArgs;
 * import com.pulumi.spotinst.ecs.inputs.OceanInstanceMetadataOptionsArgs;
 * import com.pulumi.spotinst.ecs.inputs.OceanBlockDeviceMappingArgs;
 * import com.pulumi.spotinst.ecs.inputs.OceanBlockDeviceMappingEbsArgs;
 * import com.pulumi.spotinst.ecs.inputs.OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs;
 * import com.pulumi.spotinst.ecs.inputs.OceanOptimizeImagesArgs;
 * import com.pulumi.spotinst.ecs.inputs.OceanTagArgs;
 * import com.pulumi.spotinst.ecs.inputs.OceanLoggingArgs;
 * import com.pulumi.spotinst.ecs.inputs.OceanLoggingExportArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new Ocean("example", OceanArgs.builder()
 *             .region("us-west-2")
 *             .name("sample-ecs-cluster")
 *             .clusterName("sample-ecs-cluster")
 *             .minSize(0)
 *             .maxSize(1)
 *             .desiredCapacity(0)
 *             .subnetIds("subnet-12345")
 *             .instanceTypes(List.of(Map.of("filters", List.of(Map.ofEntries(
 *                 Map.entry("architectures", List.of(                
 *                     "x86_64",
 *                     "i386")),
 *                 Map.entry("categories", List.of(                
 *                     "Accelerated_computing",
 *                     "Compute_optimized")),
 *                 Map.entry("diskTypes", List.of(                
 *                     "EBS",
 *                     "SSD")),
 *                 Map.entry("excludeFamilies", List.of("m*")),
 *                 Map.entry("excludeMetal", false),
 *                 Map.entry("hypervisor", List.of("xen")),
 *                 Map.entry("includeFamilies", List.of(                
 *                     "c*",
 *                     "t*")),
 *                 Map.entry("isEnaSupported", false),
 *                 Map.entry("maxGpu", 4),
 *                 Map.entry("minGpu", 0),
 *                 Map.entry("maxMemoryGib", 16),
 *                 Map.entry("maxNetworkPerformance", 20),
 *                 Map.entry("maxVcpu", 16),
 *                 Map.entry("minEnis", 2),
 *                 Map.entry("minMemoryGib", 8),
 *                 Map.entry("minNetworkPerformance", 2),
 *                 Map.entry("minVcpu", 2),
 *                 Map.entry("rootDeviceTypes", List.of("ebs")),
 *                 Map.entry("virtualizationTypes", List.of("hvm"))
 *             )))))
 *             .securityGroupIds("sg-12345")
 *             .imageId("ami-12345")
 *             .iamInstanceProfile("iam-profile")
 *             .keyPair("KeyPair")
 *             .userData("echo hello world")
 *             .associatePublicIpAddress(false)
 *             .utilizeReservedInstances(false)
 *             .drainingTimeout(120)
 *             .monitoring(true)
 *             .ebsOptimized(true)
 *             .useAsTemplateOnly(true)
 *             .spotPercentage(100)
 *             .utilizeCommitments(false)
 *             .fallbackToOndemand(true)
 *             .clusterOrientations(OceanClusterOrientationArgs.builder()
 *                 .availabilityVsCost("balanced")
 *                 .build())
 *             .instanceMetadataOptions(OceanInstanceMetadataOptionsArgs.builder()
 *                 .httpTokens("required")
 *                 .httpPutResponseHopLimit(10)
 *                 .build())
 *             .blockDeviceMappings(OceanBlockDeviceMappingArgs.builder()
 *                 .deviceName("/dev/xvda1")
 *                 .ebs(OceanBlockDeviceMappingEbsArgs.builder()
 *                     .deleteOnTermination(true)
 *                     .encrypted(false)
 *                     .volumeType("gp2")
 *                     .volumeSize(50)
 *                     .throughput(500)
 *                     .dynamicVolumeSize(OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs.builder()
 *                         .baseSize(50)
 *                         .resource("CPU")
 *                         .sizePerResourceUnit(20)
 *                         .build())
 *                     .build())
 *                 .build())
 *             .optimizeImages(OceanOptimizeImagesArgs.builder()
 *                 .performAt("timeWindow")
 *                 .timeWindows(                
 *                     "Sun:02:00-Sun:12:00",
 *                     "Sun:05:00-Sun:16:00")
 *                 .shouldOptimizeEcsAmi(true)
 *                 .build())
 *             .tags(OceanTagArgs.builder()
 *                 .key("fakeKey")
 *                 .value("fakeValue")
 *                 .build())
 *             .logging(OceanLoggingArgs.builder()
 *                 .export(OceanLoggingExportArgs.builder()
 *                     .s3s(OceanLoggingExportS3Args.builder()
 *                         .id("di-abcd123")
 *                         .build())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 */
@ResourceType(type="spotinst:ecs/ocean:Ocean")
public class Ocean extends com.pulumi.resources.CustomResource {
    /**
     * Configure public IP address allocation.
     * 
     */
    @Export(name="associatePublicIpAddress", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> associatePublicIpAddress;

    /**
     * @return Configure public IP address allocation.
     * 
     */
    public Output<Optional<Boolean>> associatePublicIpAddress() {
        return Codegen.optional(this.associatePublicIpAddress);
    }
    /**
     * Describes the Ocean ECS autoscaler.
     * 
     */
    @Export(name="autoscaler", refs={OceanAutoscaler.class}, tree="[0]")
    private Output</* @Nullable */ OceanAutoscaler> autoscaler;

    /**
     * @return Describes the Ocean ECS autoscaler.
     * 
     */
    public Output<Optional<OceanAutoscaler>> autoscaler() {
        return Codegen.optional(this.autoscaler);
    }
    @Export(name="blacklists", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> blacklists;

    public Output<Optional<List<String>>> blacklists() {
        return Codegen.optional(this.blacklists);
    }
    /**
     * Object. List of block devices that are exposed to the instance, specify either virtual devices and EBS volumes.
     * 
     */
    @Export(name="blockDeviceMappings", refs={List.class,OceanBlockDeviceMapping.class}, tree="[0,1]")
    private Output</* @Nullable */ List<OceanBlockDeviceMapping>> blockDeviceMappings;

    /**
     * @return Object. List of block devices that are exposed to the instance, specify either virtual devices and EBS volumes.
     * 
     */
    public Output<Optional<List<OceanBlockDeviceMapping>>> blockDeviceMappings() {
        return Codegen.optional(this.blockDeviceMappings);
    }
    /**
     * The name of the ECS cluster.
     * 
     */
    @Export(name="clusterName", refs={String.class}, tree="[0]")
    private Output<String> clusterName;

    /**
     * @return The name of the ECS cluster.
     * 
     */
    public Output<String> clusterName() {
        return this.clusterName;
    }
    @Export(name="clusterOrientations", refs={List.class,OceanClusterOrientation.class}, tree="[0,1]")
    private Output</* @Nullable */ List<OceanClusterOrientation>> clusterOrientations;

    public Output<Optional<List<OceanClusterOrientation>>> clusterOrientations() {
        return Codegen.optional(this.clusterOrientations);
    }
    /**
     * The number of instances to launch and maintain in the cluster.
     * 
     */
    @Export(name="desiredCapacity", refs={Integer.class}, tree="[0]")
    private Output<Integer> desiredCapacity;

    /**
     * @return The number of instances to launch and maintain in the cluster.
     * 
     */
    public Output<Integer> desiredCapacity() {
        return this.desiredCapacity;
    }
    /**
     * The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
     * 
     */
    @Export(name="drainingTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> drainingTimeout;

    /**
     * @return The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
     * 
     */
    public Output<Optional<Integer>> drainingTimeout() {
        return Codegen.optional(this.drainingTimeout);
    }
    /**
     * Enable EBS optimized for cluster. Flag will enable optimized capacity for high bandwidth connectivity to the EB service for non EBS optimized instance types. For instances that are EBS optimized this flag will be ignored.
     * 
     */
    @Export(name="ebsOptimized", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> ebsOptimized;

    /**
     * @return Enable EBS optimized for cluster. Flag will enable optimized capacity for high bandwidth connectivity to the EB service for non EBS optimized instance types. For instances that are EBS optimized this flag will be ignored.
     * 
     */
    public Output<Optional<Boolean>> ebsOptimized() {
        return Codegen.optional(this.ebsOptimized);
    }
    /**
     * If no Spot instance markets are available, enable Ocean to launch On-Demand instances instead.
     * 
     */
    @Export(name="fallbackToOndemand", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> fallbackToOndemand;

    /**
     * @return If no Spot instance markets are available, enable Ocean to launch On-Demand instances instead.
     * 
     */
    public Output<Optional<Boolean>> fallbackToOndemand() {
        return Codegen.optional(this.fallbackToOndemand);
    }
    @Export(name="filters", refs={OceanFilters.class}, tree="[0]")
    private Output</* @Nullable */ OceanFilters> filters;

    public Output<Optional<OceanFilters>> filters() {
        return Codegen.optional(this.filters);
    }
    /**
     * The instance profile iam role.
     * 
     */
    @Export(name="iamInstanceProfile", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> iamInstanceProfile;

    /**
     * @return The instance profile iam role.
     * 
     */
    public Output<Optional<String>> iamInstanceProfile() {
        return Codegen.optional(this.iamInstanceProfile);
    }
    /**
     * ID of the image used to launch the instances.
     * 
     */
    @Export(name="imageId", refs={String.class}, tree="[0]")
    private Output<String> imageId;

    /**
     * @return ID of the image used to launch the instances.
     * 
     */
    public Output<String> imageId() {
        return this.imageId;
    }
    /**
     * Ocean instance metadata options object for IMDSv2.
     * 
     */
    @Export(name="instanceMetadataOptions", refs={OceanInstanceMetadataOptions.class}, tree="[0]")
    private Output</* @Nullable */ OceanInstanceMetadataOptions> instanceMetadataOptions;

    /**
     * @return Ocean instance metadata options object for IMDSv2.
     * 
     */
    public Output<Optional<OceanInstanceMetadataOptions>> instanceMetadataOptions() {
        return Codegen.optional(this.instanceMetadataOptions);
    }
    /**
     * The key pair to attach the instances.
     * 
     */
    @Export(name="keyPair", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> keyPair;

    /**
     * @return The key pair to attach the instances.
     * 
     */
    public Output<Optional<String>> keyPair() {
        return Codegen.optional(this.keyPair);
    }
    /**
     * Logging configuration.
     * 
     */
    @Export(name="logging", refs={OceanLogging.class}, tree="[0]")
    private Output</* @Nullable */ OceanLogging> logging;

    /**
     * @return Logging configuration.
     * 
     */
    public Output<Optional<OceanLogging>> logging() {
        return Codegen.optional(this.logging);
    }
    /**
     * The upper limit of instances the cluster can scale up to.
     * 
     */
    @Export(name="maxSize", refs={Integer.class}, tree="[0]")
    private Output<Integer> maxSize;

    /**
     * @return The upper limit of instances the cluster can scale up to.
     * 
     */
    public Output<Integer> maxSize() {
        return this.maxSize;
    }
    /**
     * The lower limit of instances the cluster can scale down to.
     * 
     */
    @Export(name="minSize", refs={Integer.class}, tree="[0]")
    private Output<Integer> minSize;

    /**
     * @return The lower limit of instances the cluster can scale down to.
     * 
     */
    public Output<Integer> minSize() {
        return this.minSize;
    }
    /**
     * Enable detailed monitoring for cluster. Flag will enable Cloud Watch detailed monitoring (one minute increments). Note: there are additional hourly costs for this service based on the region used.
     * 
     */
    @Export(name="monitoring", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> monitoring;

    /**
     * @return Enable detailed monitoring for cluster. Flag will enable Cloud Watch detailed monitoring (one minute increments). Note: there are additional hourly costs for this service based on the region used.
     * 
     */
    public Output<Optional<Boolean>> monitoring() {
        return Codegen.optional(this.monitoring);
    }
    /**
     * The Ocean cluster name.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The Ocean cluster name.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Object. Set auto image update settings.
     * 
     */
    @Export(name="optimizeImages", refs={OceanOptimizeImages.class}, tree="[0]")
    private Output</* @Nullable */ OceanOptimizeImages> optimizeImages;

    /**
     * @return Object. Set auto image update settings.
     * 
     */
    public Output<Optional<OceanOptimizeImages>> optimizeImages() {
        return Codegen.optional(this.optimizeImages);
    }
    /**
     * The region the cluster will run in.
     * 
     */
    @Export(name="region", refs={String.class}, tree="[0]")
    private Output<String> region;

    /**
     * @return The region the cluster will run in.
     * 
     */
    public Output<String> region() {
        return this.region;
    }
    /**
     * While used, you can control whether the group should perform a deployment after an update to the configuration.
     * 
     */
    @Export(name="scheduledTasks", refs={List.class,OceanScheduledTask.class}, tree="[0,1]")
    private Output</* @Nullable */ List<OceanScheduledTask>> scheduledTasks;

    /**
     * @return While used, you can control whether the group should perform a deployment after an update to the configuration.
     * 
     */
    public Output<Optional<List<OceanScheduledTask>>> scheduledTasks() {
        return Codegen.optional(this.scheduledTasks);
    }
    /**
     * One or more security group ids.
     * 
     */
    @Export(name="securityGroupIds", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> securityGroupIds;

    /**
     * @return One or more security group ids.
     * 
     */
    public Output<List<String>> securityGroupIds() {
        return this.securityGroupIds;
    }
    /**
     * The percentage of Spot instances that would spin up from the `desiredCapacity` number.
     * 
     */
    @Export(name="spotPercentage", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> spotPercentage;

    /**
     * @return The percentage of Spot instances that would spin up from the `desiredCapacity` number.
     * 
     */
    public Output<Optional<Integer>> spotPercentage() {
        return Codegen.optional(this.spotPercentage);
    }
    /**
     * A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public ip.
     * 
     */
    @Export(name="subnetIds", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> subnetIds;

    /**
     * @return A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public ip.
     * 
     */
    public Output<List<String>> subnetIds() {
        return this.subnetIds;
    }
    /**
     * Optionally adds tags to instances launched in an Ocean cluster.
     * 
     */
    @Export(name="tags", refs={List.class,OceanTag.class}, tree="[0,1]")
    private Output</* @Nullable */ List<OceanTag>> tags;

    /**
     * @return Optionally adds tags to instances launched in an Ocean cluster.
     * 
     */
    public Output<Optional<List<OceanTag>>> tags() {
        return Codegen.optional(this.tags);
    }
    /**
     * While used, you can control whether the group should perform a deployment after an update to the configuration.
     * 
     */
    @Export(name="updatePolicy", refs={OceanUpdatePolicy.class}, tree="[0]")
    private Output</* @Nullable */ OceanUpdatePolicy> updatePolicy;

    /**
     * @return While used, you can control whether the group should perform a deployment after an update to the configuration.
     * 
     */
    public Output<Optional<OceanUpdatePolicy>> updatePolicy() {
        return Codegen.optional(this.updatePolicy);
    }
    /**
     * launch specification defined on the Ocean object will function only as a template for virtual node groups.
     * 
     */
    @Export(name="useAsTemplateOnly", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> useAsTemplateOnly;

    /**
     * @return launch specification defined on the Ocean object will function only as a template for virtual node groups.
     * 
     */
    public Output<Optional<Boolean>> useAsTemplateOnly() {
        return Codegen.optional(this.useAsTemplateOnly);
    }
    /**
     * Base64-encoded MIME user data to make available to the instances.
     * 
     */
    @Export(name="userData", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> userData;

    /**
     * @return Base64-encoded MIME user data to make available to the instances.
     * 
     */
    public Output<Optional<String>> userData() {
        return Codegen.optional(this.userData);
    }
    /**
     * If savings plans exist, Ocean will utilize them before launching Spot instances.
     * 
     */
    @Export(name="utilizeCommitments", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> utilizeCommitments;

    /**
     * @return If savings plans exist, Ocean will utilize them before launching Spot instances.
     * 
     */
    public Output<Optional<Boolean>> utilizeCommitments() {
        return Codegen.optional(this.utilizeCommitments);
    }
    /**
     * If Reserved instances exist, Ocean will utilize them before launching Spot instances.
     * 
     */
    @Export(name="utilizeReservedInstances", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> utilizeReservedInstances;

    /**
     * @return If Reserved instances exist, Ocean will utilize them before launching Spot instances.
     * 
     */
    public Output<Optional<Boolean>> utilizeReservedInstances() {
        return Codegen.optional(this.utilizeReservedInstances);
    }
    @Export(name="whitelists", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> whitelists;

    public Output<Optional<List<String>>> whitelists() {
        return Codegen.optional(this.whitelists);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Ocean(java.lang.String name) {
        this(name, OceanArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Ocean(java.lang.String name, OceanArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Ocean(java.lang.String name, OceanArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("spotinst:ecs/ocean:Ocean", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Ocean(java.lang.String name, Output<java.lang.String> id, @Nullable OceanState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("spotinst:ecs/ocean:Ocean", name, state, makeResourceOptions(options, id), false);
    }

    private static OceanArgs makeArgs(OceanArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? OceanArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Ocean get(java.lang.String name, Output<java.lang.String> id, @Nullable OceanState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Ocean(name, id, state, options);
    }
}
