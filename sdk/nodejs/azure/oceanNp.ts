// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

export class OceanNp extends pulumi.CustomResource {
    /**
     * Get an existing OceanNp resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: OceanNpState, opts?: pulumi.CustomResourceOptions): OceanNp {
        return new OceanNp(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'spotinst:azure/oceanNp:OceanNp';

    /**
     * Returns true if the given object is an instance of OceanNp.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is OceanNp {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === OceanNp.__pulumiType;
    }

    declare public readonly aksClusterName: pulumi.Output<string>;
    declare public readonly aksInfrastructureResourceGroupName: pulumi.Output<string>;
    declare public readonly aksRegion: pulumi.Output<string>;
    declare public readonly aksResourceGroupName: pulumi.Output<string>;
    /**
     * The Ocean Kubernetes Autoscaler object.
     */
    declare public readonly autoscaler: pulumi.Output<outputs.azure.OceanNpAutoscaler | undefined>;
    /**
     * An Array holding Availability Zones, this configures the availability zones the Ocean may launch instances in per VNG.
     */
    declare public readonly availabilityZones: pulumi.Output<string[]>;
    /**
     * Enter a unique Ocean cluster identifier. Cannot be updated. This needs to match with string that was used to install the controller in the cluster, typically clusterName + 8 digit string.
     */
    declare public readonly controllerClusterId: pulumi.Output<string>;
    /**
     * Enable node public IP.
     */
    declare public readonly enableNodePublicIp: pulumi.Output<boolean | undefined>;
    /**
     * If no spot VM markets are available, enable Ocean to launch regular (pay-as-you-go) nodes instead.
     */
    declare public readonly fallbackToOndemand: pulumi.Output<boolean | undefined>;
    /**
     * Filters for the VM sizes that can be launched from the virtual node group.
     */
    declare public readonly filters: pulumi.Output<outputs.azure.OceanNpFilters | undefined>;
    /**
     * Specify the custom headroom per VNG. Provide a list of headroom objects.
     */
    declare public readonly headrooms: pulumi.Output<outputs.azure.OceanNpHeadroom[] | undefined>;
    /**
     * The Ocean AKS Health object.
     */
    declare public readonly health: pulumi.Output<outputs.azure.OceanNpHealth | undefined>;
    /**
     * The desired Kubernetes version of the launched nodes. In case the value is null, the Kubernetes version of the control plane is used.
     */
    declare public readonly kubernetesVersion: pulumi.Output<string | undefined>;
    /**
     * An array of labels to add to the virtual node group. Only custom user labels are allowed, and not [Kubernetes well-known labels](https://kubernetes.io/docs/reference/labels-annotations-taints/) or [ Azure AKS labels](https://learn.microsoft.com/en-us/azure/aks/use-labels) or [Spot labels](https://docs.spot.io/ocean/features/labels-and-taints?id=spot-labels).
     */
    declare public readonly labels: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * Custom Linux OS configuration.
     */
    declare public readonly linuxOsConfigs: pulumi.Output<outputs.azure.OceanNpLinuxOsConfig[] | undefined>;
    /**
     * The Ocean AKS Logging Object.
     */
    declare public readonly logging: pulumi.Output<outputs.azure.OceanNpLogging | undefined>;
    /**
     * Maximum node count limit.
     */
    declare public readonly maxCount: pulumi.Output<number | undefined>;
    /**
     * The maximum number of pods per node in the node pools.
     */
    declare public readonly maxPodsPerNode: pulumi.Output<number | undefined>;
    /**
     * Minimum node count limit.
     */
    declare public readonly minCount: pulumi.Output<number | undefined>;
    /**
     * Add a name for the Ocean cluster.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * The size of the OS disk in GB.
     */
    declare public readonly osDiskSizeGb: pulumi.Output<number | undefined>;
    /**
     * The type of the OS disk.
     */
    declare public readonly osDiskType: pulumi.Output<string | undefined>;
    /**
     * The OS SKU of the OS type. Must correlate with the os type.
     */
    declare public readonly osSku: pulumi.Output<string | undefined>;
    /**
     * The OS type of the OS disk. Can't be modified once set.
     */
    declare public readonly osType: pulumi.Output<string | undefined>;
    /**
     * The IDs of subnets in an existing VNet into which to assign pods in the cluster (requires azure network-plugin).
     */
    declare public readonly podSubnetIds: pulumi.Output<string[] | undefined>;
    declare public readonly scheduling: pulumi.Output<outputs.azure.OceanNpScheduling | undefined>;
    /**
     * Percentage of spot VMs to maintain.
     */
    declare public readonly spotPercentage: pulumi.Output<number | undefined>;
    declare public readonly tags: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * Add taints to a virtual node group. Only custom user taints are allowed, and not [Kubernetes well-known taints](https://kubernetes.io/docs/reference/labels-annotations-taints/) or Azure AKS [ScaleSetPrioirty (Spot VM) taint](https://learn.microsoft.com/en-us/azure/aks/spot-node-pool). For all Spot VMs, AKS injects a taint kubernetes.azure.com/scalesetpriority=spot:NoSchedule, to ensure that only workloads that can handle interruptions are scheduled on Spot nodes. To [schedule a pod to run on Spot node](https://learn.microsoft.com/en-us/azure/aks/spot-node-pool#schedule-a-pod-to-run-on-the-spot-node), add a toleration but dont include the nodeAffinity (not supported for Spot Ocean), this will prevent the pod from being scheduled using Spot Ocean.
     */
    declare public readonly taints: pulumi.Output<outputs.azure.OceanNpTaint[] | undefined>;
    declare public readonly updatePolicy: pulumi.Output<outputs.azure.OceanNpUpdatePolicy | undefined>;
    /**
     * The IDs of subnets in an existing VNet into which to assign nodes in the cluster (requires azure network-plugin).
     */
    declare public readonly vnetSubnetIds: pulumi.Output<string[] | undefined>;
    /**
     * An object used to specify times when the virtual node group will turn off all its node pools. Once the shutdown time will be over, the virtual node group will return to its previous state.
     */
    declare public readonly vngTemplateScheduling: pulumi.Output<outputs.azure.OceanNpVngTemplateScheduling | undefined>;

    /**
     * Create a OceanNp resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: OceanNpArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: OceanNpArgs | OceanNpState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as OceanNpState | undefined;
            resourceInputs["aksClusterName"] = state?.aksClusterName;
            resourceInputs["aksInfrastructureResourceGroupName"] = state?.aksInfrastructureResourceGroupName;
            resourceInputs["aksRegion"] = state?.aksRegion;
            resourceInputs["aksResourceGroupName"] = state?.aksResourceGroupName;
            resourceInputs["autoscaler"] = state?.autoscaler;
            resourceInputs["availabilityZones"] = state?.availabilityZones;
            resourceInputs["controllerClusterId"] = state?.controllerClusterId;
            resourceInputs["enableNodePublicIp"] = state?.enableNodePublicIp;
            resourceInputs["fallbackToOndemand"] = state?.fallbackToOndemand;
            resourceInputs["filters"] = state?.filters;
            resourceInputs["headrooms"] = state?.headrooms;
            resourceInputs["health"] = state?.health;
            resourceInputs["kubernetesVersion"] = state?.kubernetesVersion;
            resourceInputs["labels"] = state?.labels;
            resourceInputs["linuxOsConfigs"] = state?.linuxOsConfigs;
            resourceInputs["logging"] = state?.logging;
            resourceInputs["maxCount"] = state?.maxCount;
            resourceInputs["maxPodsPerNode"] = state?.maxPodsPerNode;
            resourceInputs["minCount"] = state?.minCount;
            resourceInputs["name"] = state?.name;
            resourceInputs["osDiskSizeGb"] = state?.osDiskSizeGb;
            resourceInputs["osDiskType"] = state?.osDiskType;
            resourceInputs["osSku"] = state?.osSku;
            resourceInputs["osType"] = state?.osType;
            resourceInputs["podSubnetIds"] = state?.podSubnetIds;
            resourceInputs["scheduling"] = state?.scheduling;
            resourceInputs["spotPercentage"] = state?.spotPercentage;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["taints"] = state?.taints;
            resourceInputs["updatePolicy"] = state?.updatePolicy;
            resourceInputs["vnetSubnetIds"] = state?.vnetSubnetIds;
            resourceInputs["vngTemplateScheduling"] = state?.vngTemplateScheduling;
        } else {
            const args = argsOrState as OceanNpArgs | undefined;
            if (args?.aksClusterName === undefined && !opts.urn) {
                throw new Error("Missing required property 'aksClusterName'");
            }
            if (args?.aksInfrastructureResourceGroupName === undefined && !opts.urn) {
                throw new Error("Missing required property 'aksInfrastructureResourceGroupName'");
            }
            if (args?.aksRegion === undefined && !opts.urn) {
                throw new Error("Missing required property 'aksRegion'");
            }
            if (args?.aksResourceGroupName === undefined && !opts.urn) {
                throw new Error("Missing required property 'aksResourceGroupName'");
            }
            if (args?.availabilityZones === undefined && !opts.urn) {
                throw new Error("Missing required property 'availabilityZones'");
            }
            if (args?.controllerClusterId === undefined && !opts.urn) {
                throw new Error("Missing required property 'controllerClusterId'");
            }
            resourceInputs["aksClusterName"] = args?.aksClusterName;
            resourceInputs["aksInfrastructureResourceGroupName"] = args?.aksInfrastructureResourceGroupName;
            resourceInputs["aksRegion"] = args?.aksRegion;
            resourceInputs["aksResourceGroupName"] = args?.aksResourceGroupName;
            resourceInputs["autoscaler"] = args?.autoscaler;
            resourceInputs["availabilityZones"] = args?.availabilityZones;
            resourceInputs["controllerClusterId"] = args?.controllerClusterId;
            resourceInputs["enableNodePublicIp"] = args?.enableNodePublicIp;
            resourceInputs["fallbackToOndemand"] = args?.fallbackToOndemand;
            resourceInputs["filters"] = args?.filters;
            resourceInputs["headrooms"] = args?.headrooms;
            resourceInputs["health"] = args?.health;
            resourceInputs["kubernetesVersion"] = args?.kubernetesVersion;
            resourceInputs["labels"] = args?.labels;
            resourceInputs["linuxOsConfigs"] = args?.linuxOsConfigs;
            resourceInputs["logging"] = args?.logging;
            resourceInputs["maxCount"] = args?.maxCount;
            resourceInputs["maxPodsPerNode"] = args?.maxPodsPerNode;
            resourceInputs["minCount"] = args?.minCount;
            resourceInputs["name"] = args?.name;
            resourceInputs["osDiskSizeGb"] = args?.osDiskSizeGb;
            resourceInputs["osDiskType"] = args?.osDiskType;
            resourceInputs["osSku"] = args?.osSku;
            resourceInputs["osType"] = args?.osType;
            resourceInputs["podSubnetIds"] = args?.podSubnetIds;
            resourceInputs["scheduling"] = args?.scheduling;
            resourceInputs["spotPercentage"] = args?.spotPercentage;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["taints"] = args?.taints;
            resourceInputs["updatePolicy"] = args?.updatePolicy;
            resourceInputs["vnetSubnetIds"] = args?.vnetSubnetIds;
            resourceInputs["vngTemplateScheduling"] = args?.vngTemplateScheduling;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(OceanNp.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering OceanNp resources.
 */
export interface OceanNpState {
    aksClusterName?: pulumi.Input<string>;
    aksInfrastructureResourceGroupName?: pulumi.Input<string>;
    aksRegion?: pulumi.Input<string>;
    aksResourceGroupName?: pulumi.Input<string>;
    /**
     * The Ocean Kubernetes Autoscaler object.
     */
    autoscaler?: pulumi.Input<inputs.azure.OceanNpAutoscaler>;
    /**
     * An Array holding Availability Zones, this configures the availability zones the Ocean may launch instances in per VNG.
     */
    availabilityZones?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Enter a unique Ocean cluster identifier. Cannot be updated. This needs to match with string that was used to install the controller in the cluster, typically clusterName + 8 digit string.
     */
    controllerClusterId?: pulumi.Input<string>;
    /**
     * Enable node public IP.
     */
    enableNodePublicIp?: pulumi.Input<boolean>;
    /**
     * If no spot VM markets are available, enable Ocean to launch regular (pay-as-you-go) nodes instead.
     */
    fallbackToOndemand?: pulumi.Input<boolean>;
    /**
     * Filters for the VM sizes that can be launched from the virtual node group.
     */
    filters?: pulumi.Input<inputs.azure.OceanNpFilters>;
    /**
     * Specify the custom headroom per VNG. Provide a list of headroom objects.
     */
    headrooms?: pulumi.Input<pulumi.Input<inputs.azure.OceanNpHeadroom>[]>;
    /**
     * The Ocean AKS Health object.
     */
    health?: pulumi.Input<inputs.azure.OceanNpHealth>;
    /**
     * The desired Kubernetes version of the launched nodes. In case the value is null, the Kubernetes version of the control plane is used.
     */
    kubernetesVersion?: pulumi.Input<string>;
    /**
     * An array of labels to add to the virtual node group. Only custom user labels are allowed, and not [Kubernetes well-known labels](https://kubernetes.io/docs/reference/labels-annotations-taints/) or [ Azure AKS labels](https://learn.microsoft.com/en-us/azure/aks/use-labels) or [Spot labels](https://docs.spot.io/ocean/features/labels-and-taints?id=spot-labels).
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Custom Linux OS configuration.
     */
    linuxOsConfigs?: pulumi.Input<pulumi.Input<inputs.azure.OceanNpLinuxOsConfig>[]>;
    /**
     * The Ocean AKS Logging Object.
     */
    logging?: pulumi.Input<inputs.azure.OceanNpLogging>;
    /**
     * Maximum node count limit.
     */
    maxCount?: pulumi.Input<number>;
    /**
     * The maximum number of pods per node in the node pools.
     */
    maxPodsPerNode?: pulumi.Input<number>;
    /**
     * Minimum node count limit.
     */
    minCount?: pulumi.Input<number>;
    /**
     * Add a name for the Ocean cluster.
     */
    name?: pulumi.Input<string>;
    /**
     * The size of the OS disk in GB.
     */
    osDiskSizeGb?: pulumi.Input<number>;
    /**
     * The type of the OS disk.
     */
    osDiskType?: pulumi.Input<string>;
    /**
     * The OS SKU of the OS type. Must correlate with the os type.
     */
    osSku?: pulumi.Input<string>;
    /**
     * The OS type of the OS disk. Can't be modified once set.
     */
    osType?: pulumi.Input<string>;
    /**
     * The IDs of subnets in an existing VNet into which to assign pods in the cluster (requires azure network-plugin).
     */
    podSubnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    scheduling?: pulumi.Input<inputs.azure.OceanNpScheduling>;
    /**
     * Percentage of spot VMs to maintain.
     */
    spotPercentage?: pulumi.Input<number>;
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Add taints to a virtual node group. Only custom user taints are allowed, and not [Kubernetes well-known taints](https://kubernetes.io/docs/reference/labels-annotations-taints/) or Azure AKS [ScaleSetPrioirty (Spot VM) taint](https://learn.microsoft.com/en-us/azure/aks/spot-node-pool). For all Spot VMs, AKS injects a taint kubernetes.azure.com/scalesetpriority=spot:NoSchedule, to ensure that only workloads that can handle interruptions are scheduled on Spot nodes. To [schedule a pod to run on Spot node](https://learn.microsoft.com/en-us/azure/aks/spot-node-pool#schedule-a-pod-to-run-on-the-spot-node), add a toleration but dont include the nodeAffinity (not supported for Spot Ocean), this will prevent the pod from being scheduled using Spot Ocean.
     */
    taints?: pulumi.Input<pulumi.Input<inputs.azure.OceanNpTaint>[]>;
    updatePolicy?: pulumi.Input<inputs.azure.OceanNpUpdatePolicy>;
    /**
     * The IDs of subnets in an existing VNet into which to assign nodes in the cluster (requires azure network-plugin).
     */
    vnetSubnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * An object used to specify times when the virtual node group will turn off all its node pools. Once the shutdown time will be over, the virtual node group will return to its previous state.
     */
    vngTemplateScheduling?: pulumi.Input<inputs.azure.OceanNpVngTemplateScheduling>;
}

/**
 * The set of arguments for constructing a OceanNp resource.
 */
export interface OceanNpArgs {
    aksClusterName: pulumi.Input<string>;
    aksInfrastructureResourceGroupName: pulumi.Input<string>;
    aksRegion: pulumi.Input<string>;
    aksResourceGroupName: pulumi.Input<string>;
    /**
     * The Ocean Kubernetes Autoscaler object.
     */
    autoscaler?: pulumi.Input<inputs.azure.OceanNpAutoscaler>;
    /**
     * An Array holding Availability Zones, this configures the availability zones the Ocean may launch instances in per VNG.
     */
    availabilityZones: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Enter a unique Ocean cluster identifier. Cannot be updated. This needs to match with string that was used to install the controller in the cluster, typically clusterName + 8 digit string.
     */
    controllerClusterId: pulumi.Input<string>;
    /**
     * Enable node public IP.
     */
    enableNodePublicIp?: pulumi.Input<boolean>;
    /**
     * If no spot VM markets are available, enable Ocean to launch regular (pay-as-you-go) nodes instead.
     */
    fallbackToOndemand?: pulumi.Input<boolean>;
    /**
     * Filters for the VM sizes that can be launched from the virtual node group.
     */
    filters?: pulumi.Input<inputs.azure.OceanNpFilters>;
    /**
     * Specify the custom headroom per VNG. Provide a list of headroom objects.
     */
    headrooms?: pulumi.Input<pulumi.Input<inputs.azure.OceanNpHeadroom>[]>;
    /**
     * The Ocean AKS Health object.
     */
    health?: pulumi.Input<inputs.azure.OceanNpHealth>;
    /**
     * The desired Kubernetes version of the launched nodes. In case the value is null, the Kubernetes version of the control plane is used.
     */
    kubernetesVersion?: pulumi.Input<string>;
    /**
     * An array of labels to add to the virtual node group. Only custom user labels are allowed, and not [Kubernetes well-known labels](https://kubernetes.io/docs/reference/labels-annotations-taints/) or [ Azure AKS labels](https://learn.microsoft.com/en-us/azure/aks/use-labels) or [Spot labels](https://docs.spot.io/ocean/features/labels-and-taints?id=spot-labels).
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Custom Linux OS configuration.
     */
    linuxOsConfigs?: pulumi.Input<pulumi.Input<inputs.azure.OceanNpLinuxOsConfig>[]>;
    /**
     * The Ocean AKS Logging Object.
     */
    logging?: pulumi.Input<inputs.azure.OceanNpLogging>;
    /**
     * Maximum node count limit.
     */
    maxCount?: pulumi.Input<number>;
    /**
     * The maximum number of pods per node in the node pools.
     */
    maxPodsPerNode?: pulumi.Input<number>;
    /**
     * Minimum node count limit.
     */
    minCount?: pulumi.Input<number>;
    /**
     * Add a name for the Ocean cluster.
     */
    name?: pulumi.Input<string>;
    /**
     * The size of the OS disk in GB.
     */
    osDiskSizeGb?: pulumi.Input<number>;
    /**
     * The type of the OS disk.
     */
    osDiskType?: pulumi.Input<string>;
    /**
     * The OS SKU of the OS type. Must correlate with the os type.
     */
    osSku?: pulumi.Input<string>;
    /**
     * The OS type of the OS disk. Can't be modified once set.
     */
    osType?: pulumi.Input<string>;
    /**
     * The IDs of subnets in an existing VNet into which to assign pods in the cluster (requires azure network-plugin).
     */
    podSubnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    scheduling?: pulumi.Input<inputs.azure.OceanNpScheduling>;
    /**
     * Percentage of spot VMs to maintain.
     */
    spotPercentage?: pulumi.Input<number>;
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Add taints to a virtual node group. Only custom user taints are allowed, and not [Kubernetes well-known taints](https://kubernetes.io/docs/reference/labels-annotations-taints/) or Azure AKS [ScaleSetPrioirty (Spot VM) taint](https://learn.microsoft.com/en-us/azure/aks/spot-node-pool). For all Spot VMs, AKS injects a taint kubernetes.azure.com/scalesetpriority=spot:NoSchedule, to ensure that only workloads that can handle interruptions are scheduled on Spot nodes. To [schedule a pod to run on Spot node](https://learn.microsoft.com/en-us/azure/aks/spot-node-pool#schedule-a-pod-to-run-on-the-spot-node), add a toleration but dont include the nodeAffinity (not supported for Spot Ocean), this will prevent the pod from being scheduled using Spot Ocean.
     */
    taints?: pulumi.Input<pulumi.Input<inputs.azure.OceanNpTaint>[]>;
    updatePolicy?: pulumi.Input<inputs.azure.OceanNpUpdatePolicy>;
    /**
     * The IDs of subnets in an existing VNet into which to assign nodes in the cluster (requires azure network-plugin).
     */
    vnetSubnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * An object used to specify times when the virtual node group will turn off all its node pools. Once the shutdown time will be over, the virtual node group will return to its previous state.
     */
    vngTemplateScheduling?: pulumi.Input<inputs.azure.OceanNpVngTemplateScheduling>;
}
