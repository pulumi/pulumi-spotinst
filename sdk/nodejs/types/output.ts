// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface HealthCheckCheck {
    endPoint?: string;
    /**
     * The destination for the request.
     */
    endpoint?: string;
    /**
     * The number of consecutive successful health checks that must occur before declaring an instance healthy.
     */
    healthy: number;
    /**
     * The amount of time (in seconds) between each health check (minimum: 10).
     */
    interval: number;
    /**
     * The port of the Spotinst HCS (default: 80).
     */
    port: number;
    /**
     * The protocol to use to connect with the instance. Valid values: http, https.
     */
    protocol: string;
    timeOut?: number;
    /**
     * the amount of time (in seconds) to wait when receiving a response from the health check.
     */
    timeout?: number;
    /**
     * The number of consecutive failed health checks that must occur before declaring an instance unhealthy.
     */
    unhealthy: number;
}
export namespace aws {
    export interface BeanstalkDeploymentPreferences {
        /**
         * Should roll perform automatically
         */
        automaticRoll?: boolean;
        /**
         * Percent size of each batch
         */
        batchSizePercentage?: number;
        /**
         * Amount of time to wait between batches
         */
        gracePeriod?: number;
        /**
         * Strategy parameters
         */
        strategies?: outputs.aws.BeanstalkDeploymentPreferencesStrategy[];
    }

    export interface BeanstalkDeploymentPreferencesStrategy {
        /**
         * Action to take
         */
        action?: string;
        /**
         * Bool value if to wait to drain instance
         */
        shouldDrainInstances?: boolean;
    }

    export interface BeanstalkManagedActions {
        /**
         * Platform Update parameters
         */
        platformUpdate?: outputs.aws.BeanstalkManagedActionsPlatformUpdate;
    }

    export interface BeanstalkManagedActionsPlatformUpdate {
        /**
         * Actions to perform (options: timeWindow, never)
         */
        performAt?: string;
        /**
         * Time Window for when action occurs ex. Mon:23:50-Tue:00:20
         */
        timeWindow?: string;
        /**
         * - Level to update
         */
        updateLevel?: string;
    }

    export interface BeanstalkScheduledTask {
        adjustment?: string;
        adjustmentPercentage?: string;
        /**
         * Percent size of each batch
         */
        batchSizePercentage?: string;
        cronExpression?: string;
        frequency?: string;
        /**
         * Amount of time to wait between batches
         */
        gracePeriod?: string;
        isEnabled?: boolean;
        maxCapacity?: string;
        minCapacity?: string;
        scaleMaxCapacity?: string;
        scaleMinCapacity?: string;
        scaleTargetCapacity?: string;
        startTime?: string;
        targetCapacity?: string;
        taskType: string;
    }

    export interface ElastigroupEbsBlockDevice {
        deleteOnTermination: boolean;
        deviceName: string;
        encrypted: boolean;
        iops?: number;
        kmsKeyId?: string;
        snapshotId?: string;
        volumeSize?: number;
        volumeType: string;
    }

    export interface ElastigroupEphemeralBlockDevice {
        deviceName: string;
        virtualName: string;
    }

    export interface ElastigroupInstanceTypesWeight {
        /**
         * Name of instance type (String).
         */
        instanceType: string;
        /**
         * Weight per instance type (Integer).
         */
        weight: number;
    }

    export interface ElastigroupIntegrationBeanstalk {
        deploymentPreferences?: outputs.aws.ElastigroupIntegrationBeanstalkDeploymentPreferences;
        environmentId?: string;
        managedActions?: outputs.aws.ElastigroupIntegrationBeanstalkManagedActions;
    }

    export interface ElastigroupIntegrationBeanstalkDeploymentPreferences {
        automaticRoll?: boolean;
        batchSizePercentage?: number;
        gracePeriod?: number;
        strategy?: outputs.aws.ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategy;
    }

    export interface ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategy {
        action?: string;
        shouldDrainInstances?: boolean;
    }

    export interface ElastigroupIntegrationBeanstalkManagedActions {
        platformUpdate?: outputs.aws.ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdate;
    }

    export interface ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdate {
        /**
         * In the event of a fallback to On-Demand instances, select the time period to revert back to Spot. Supported Arguments â€“ always (default), timeWindow, never. For timeWindow or never to be valid the group must have availabilityOriented OR persistence defined.
         */
        performAt?: string;
        timeWindow?: string;
        updateLevel?: string;
    }

    export interface ElastigroupIntegrationCodedeploy {
        cleanupOnFailure: boolean;
        deploymentGroups: outputs.aws.ElastigroupIntegrationCodedeployDeploymentGroup[];
        terminateInstanceOnFailure: boolean;
    }

    export interface ElastigroupIntegrationCodedeployDeploymentGroup {
        applicationName: string;
        deploymentGroupName: string;
    }

    export interface ElastigroupIntegrationDockerSwarm {
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.aws.ElastigroupIntegrationDockerSwarmAutoscaleDown;
        autoscaleHeadroom?: outputs.aws.ElastigroupIntegrationDockerSwarmAutoscaleHeadroom;
        autoscaleIsEnabled?: boolean;
        masterHost: string;
        masterPort: number;
    }

    export interface ElastigroupIntegrationDockerSwarmAutoscaleDown {
        evaluationPeriods?: number;
    }

    export interface ElastigroupIntegrationDockerSwarmAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationEcs {
        autoscaleAttributes?: outputs.aws.ElastigroupIntegrationEcsAutoscaleAttribute[];
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.aws.ElastigroupIntegrationEcsAutoscaleDown;
        autoscaleHeadroom?: outputs.aws.ElastigroupIntegrationEcsAutoscaleHeadroom;
        autoscaleIsAutoConfig?: boolean;
        autoscaleIsEnabled?: boolean;
        autoscaleScaleDownNonServiceTasks?: boolean;
        clusterName: string;
    }

    export interface ElastigroupIntegrationEcsAutoscaleAttribute {
        key: string;
        value: string;
    }

    export interface ElastigroupIntegrationEcsAutoscaleDown {
        evaluationPeriods?: number;
        maxScaleDownPercentage?: number;
    }

    export interface ElastigroupIntegrationEcsAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationGitlab {
        runner?: outputs.aws.ElastigroupIntegrationGitlabRunner;
    }

    export interface ElastigroupIntegrationGitlabRunner {
        isEnabled?: boolean;
    }

    export interface ElastigroupIntegrationKubernetes {
        apiServer?: string;
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.aws.ElastigroupIntegrationKubernetesAutoscaleDown;
        autoscaleHeadroom?: outputs.aws.ElastigroupIntegrationKubernetesAutoscaleHeadroom;
        autoscaleIsAutoConfig?: boolean;
        autoscaleIsEnabled?: boolean;
        autoscaleLabels?: outputs.aws.ElastigroupIntegrationKubernetesAutoscaleLabel[];
        clusterIdentifier?: string;
        integrationMode?: string;
        token?: string;
    }

    export interface ElastigroupIntegrationKubernetesAutoscaleDown {
        evaluationPeriods?: number;
    }

    export interface ElastigroupIntegrationKubernetesAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationKubernetesAutoscaleLabel {
        key: string;
        value: string;
    }

    export interface ElastigroupIntegrationMesosphere {
        apiServer: string;
    }

    export interface ElastigroupIntegrationMultaiRuntime {
        deploymentId: string;
    }

    export interface ElastigroupIntegrationNomad {
        aclToken?: string;
        autoscaleConstraints?: outputs.aws.ElastigroupIntegrationNomadAutoscaleConstraint[];
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.aws.ElastigroupIntegrationNomadAutoscaleDown;
        autoscaleHeadroom?: outputs.aws.ElastigroupIntegrationNomadAutoscaleHeadroom;
        autoscaleIsEnabled?: boolean;
        masterHost: string;
        masterPort: number;
    }

    export interface ElastigroupIntegrationNomadAutoscaleConstraint {
        key: string;
        value: string;
    }

    export interface ElastigroupIntegrationNomadAutoscaleDown {
        evaluationPeriods?: number;
    }

    export interface ElastigroupIntegrationNomadAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationRancher {
        accessKey: string;
        masterHost: string;
        secretKey: string;
        version?: string;
    }

    export interface ElastigroupIntegrationRoute53 {
        domains: outputs.aws.ElastigroupIntegrationRoute53Domain[];
    }

    export interface ElastigroupIntegrationRoute53Domain {
        hostedZoneId: string;
        recordSetType?: string;
        recordSets: outputs.aws.ElastigroupIntegrationRoute53DomainRecordSet[];
        spotinstAcctId?: string;
    }

    export interface ElastigroupIntegrationRoute53DomainRecordSet {
        /**
         * The group name.
         */
        name: string;
        usePublicDns?: boolean;
        usePublicIp?: boolean;
    }

    export interface ElastigroupMultaiTargetSet {
        balancerId: string;
        targetSetId: string;
    }

    export interface ElastigroupNetworkInterface {
        associateIpv6Address?: boolean;
        associatePublicIpAddress?: boolean;
        deleteOnTermination: boolean;
        /**
         * The group description.
         */
        description?: string;
        deviceIndex: string;
        networkInterfaceId?: string;
        privateIpAddress?: string;
        secondaryPrivateIpAddressCount?: string;
    }

    export interface ElastigroupRevertToSpot {
        /**
         * In the event of a fallback to On-Demand instances, select the time period to revert back to Spot. Supported Arguments â€“ always (default), timeWindow, never. For timeWindow or never to be valid the group must have availabilityOriented OR persistence defined.
         */
        performAt: string;
        /**
         * Specify a list of time windows for to execute revertToSpot strategy. Time window format: `ddd:hh:mm-ddd:hh:mm`. Example: `Mon:03:00-Wed:02:30`
         */
        timeWindows?: string[];
    }

    export interface ElastigroupScalingDownPolicy {
        actionType?: string;
        adjustment?: string;
        cooldown: number;
        dimensions?: outputs.aws.ElastigroupScalingDownPolicyDimension[];
        evaluationPeriods: number;
        isEnabled?: boolean;
        maxTargetCapacity?: string;
        maximum?: string;
        metricName: string;
        minTargetCapacity?: string;
        minimum?: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        source: string;
        statistic: string;
        target?: string;
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingDownPolicyDimension {
        /**
         * The group name.
         */
        name: string;
        value?: string;
    }

    export interface ElastigroupScalingStrategy {
        /**
         * Specify whether to terminate instances at the end of each billing hour.
         */
        terminateAtEndOfBillingHour?: boolean;
        /**
         * - Determines whether to terminate the newest instances when performing a scaling action. Valid values: `"default"`, `"newestInstance"`.
         */
        terminationPolicy?: string;
    }

    export interface ElastigroupScalingTargetPolicy {
        cooldown: number;
        dimensions?: outputs.aws.ElastigroupScalingTargetPolicyDimension[];
        maxCapacityPerScale?: string;
        metricName: string;
        namespace: string;
        policyName: string;
        predictiveMode?: string;
        source: string;
        statistic: string;
        target: number;
        unit: string;
    }

    export interface ElastigroupScalingTargetPolicyDimension {
        /**
         * The group name.
         */
        name: string;
        value?: string;
    }

    export interface ElastigroupScalingUpPolicy {
        actionType?: string;
        adjustment?: string;
        cooldown: number;
        dimensions?: outputs.aws.ElastigroupScalingUpPolicyDimension[];
        evaluationPeriods: number;
        isEnabled?: boolean;
        maxTargetCapacity?: string;
        maximum?: string;
        metricName: string;
        minTargetCapacity?: string;
        minimum?: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        source: string;
        statistic: string;
        target?: string;
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingUpPolicyDimension {
        /**
         * The group name.
         */
        name: string;
        value?: string;
    }

    export interface ElastigroupScheduledTask {
        adjustment?: string;
        adjustmentPercentage?: string;
        batchSizePercentage?: string;
        cronExpression?: string;
        frequency?: string;
        gracePeriod?: string;
        isEnabled?: boolean;
        maxCapacity?: string;
        minCapacity?: string;
        scaleMaxCapacity?: string;
        scaleMinCapacity?: string;
        scaleTargetCapacity?: string;
        startTime?: string;
        targetCapacity?: string;
        taskType: string;
    }

    export interface ElastigroupSignal {
        /**
         * The group name.
         */
        name: string;
        timeout?: number;
    }

    export interface ElastigroupStatefulDeallocation {
        shouldDeleteImages?: boolean;
        shouldDeleteNetworkInterfaces?: boolean;
        shouldDeleteSnapshots?: boolean;
        shouldDeleteVolumes?: boolean;
    }

    export interface ElastigroupTag {
        key?: string;
        value?: string;
    }

    export interface ElastigroupUpdatePolicy {
        autoApplyTags?: boolean;
        rollConfig?: outputs.aws.ElastigroupUpdatePolicyRollConfig;
        shouldResumeStateful: boolean;
        shouldRoll: boolean;
    }

    export interface ElastigroupUpdatePolicyRollConfig {
        batchSizePercentage: number;
        gracePeriod?: number;
        /**
         * The service that will perform health checks for the instance. Valid values: `"ELB"`, `"HCS"`, `"TARGET_GROUP"`, `"MLB"`, `"EC2"`, `"MULTAI_TARGET_SET"`, `"MLB_RUNTIME"`, `"K8S_NODE"`, `"NOMAD_NODE"`, `"ECS_CLUSTER_INSTANCE"`.
         */
        healthCheckType?: string;
        strategy?: outputs.aws.ElastigroupUpdatePolicyRollConfigStrategy;
        waitForRollPercentage?: number;
        waitForRollTimeout?: number;
    }

    export interface ElastigroupUpdatePolicyRollConfigStrategy {
        action: string;
        batchMinHealthyPercentage?: number;
        onFailure?: outputs.aws.ElastigroupUpdatePolicyRollConfigStrategyOnFailure;
        shouldDrainInstances?: boolean;
    }

    export interface ElastigroupUpdatePolicyRollConfigStrategyOnFailure {
        actionType: string;
        batchNum?: number;
        /**
         * The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
         */
        drainingTimeout?: number;
        shouldDecrementTargetCapacity?: boolean;
        shouldHandleAllBatches?: boolean;
    }

    export interface ManagedInstanceIntegrationRoute53 {
        domains: outputs.aws.ManagedInstanceIntegrationRoute53Domain[];
    }

    export interface ManagedInstanceIntegrationRoute53Domain {
        hostedZoneId: string;
        recordSetType?: string;
        recordSets: outputs.aws.ManagedInstanceIntegrationRoute53DomainRecordSet[];
        spotinstAcctId?: string;
    }

    export interface ManagedInstanceIntegrationRoute53DomainRecordSet {
        /**
         * The ManagedInstance name.
         */
        name: string;
        usePublicDns?: boolean;
        usePublicIp?: boolean;
    }

    export interface ManagedInstanceLoadBalancer {
        arn?: string;
        autoWeight?: boolean;
        azAwareness?: boolean;
        balancerId?: string;
        /**
         * The ManagedInstance name.
         */
        name?: string;
        targetSetId?: string;
        type: string;
    }

    export interface ManagedInstanceNetworkInterface {
        associateIpv6Address?: boolean;
        associatePublicIpAddress?: boolean;
        deviceIndex: string;
    }

    export interface ManagedInstanceRevertToSpot {
        /**
         * Valid values: `"always"`, `"never"`, `"timeWindow"`.
         * Default `"never"`.
         */
        performAt: string;
    }

    export interface ManagedInstanceScheduledTask {
        cronExpression?: string;
        frequency?: string;
        isEnabled?: boolean;
        startTime?: string;
        taskType: string;
    }

    export interface ManagedInstanceTag {
        /**
         * Tag's key.
         */
        key?: string;
        /**
         * Tag's name.
         */
        value?: string;
    }

    export interface MrScalarApplication {
        args?: string[];
        /**
         * The MrScaler name.
         */
        name: string;
        version?: string;
    }

    export interface MrScalarBootstrapActionsFile {
        bucket: string;
        key: string;
    }

    export interface MrScalarConfigurationsFile {
        bucket: string;
        key: string;
    }

    export interface MrScalarCoreEbsBlockDevice {
        iops?: number;
        sizeInGb: number;
        volumeType: string;
        volumesPerInstance?: number;
    }

    export interface MrScalarCoreScalingDownPolicy {
        actionType?: string;
        adjustment?: string;
        cooldown: number;
        dimensions?: {[key: string]: any};
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods: number;
        maxTargetCapacity?: string;
        maximum?: string;
        /**
         * The name of the metric in CloudWatch which the statement will be based on.
         */
        metricName: string;
        minTargetCapacity?: string;
        minimum?: string;
        /**
         * Must contain the value: `AWS/ElasticMapReduce`.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
         */
        operator: string;
        /**
         * The time window in seconds over which the statistic is applied.
         */
        period: number;
        policyName: string;
        /**
         * The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
         */
        statistic: string;
        target?: string;
        /**
         * The value that the specified statistic is compared to.
         */
        threshold: number;
        /**
         * The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
         */
        unit: string;
    }

    export interface MrScalarCoreScalingUpPolicy {
        actionType?: string;
        adjustment?: string;
        cooldown: number;
        dimensions?: {[key: string]: any};
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods: number;
        maxTargetCapacity?: string;
        maximum?: string;
        /**
         * The name of the metric in CloudWatch which the statement will be based on.
         */
        metricName: string;
        minTargetCapacity?: string;
        minimum?: string;
        /**
         * Must contain the value: `AWS/ElasticMapReduce`.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
         */
        operator: string;
        /**
         * The time window in seconds over which the statistic is applied.
         */
        period: number;
        policyName: string;
        /**
         * The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
         */
        statistic: string;
        target?: string;
        /**
         * The value that the specified statistic is compared to.
         */
        threshold: number;
        /**
         * The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
         */
        unit: string;
    }

    export interface MrScalarInstanceWeight {
        instanceType: string;
        weightedCapacity: number;
    }

    export interface MrScalarMasterEbsBlockDevice {
        iops?: number;
        sizeInGb: number;
        volumeType: string;
        volumesPerInstance?: number;
    }

    export interface MrScalarProvisioningTimeout {
        timeout: number;
        timeoutAction: string;
    }

    export interface MrScalarScheduledTask {
        cron: string;
        desiredCapacity?: string;
        instanceGroupType: string;
        isEnabled?: boolean;
        maxCapacity?: string;
        minCapacity?: string;
        taskType: string;
    }

    export interface MrScalarStepsFile {
        bucket: string;
        key: string;
    }

    export interface MrScalarTag {
        key: string;
        value: string;
    }

    export interface MrScalarTaskEbsBlockDevice {
        iops?: number;
        sizeInGb: number;
        volumeType: string;
        volumesPerInstance?: number;
    }

    export interface MrScalarTaskScalingDownPolicy {
        actionType?: string;
        adjustment?: string;
        cooldown: number;
        dimensions?: {[key: string]: any};
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods: number;
        maxTargetCapacity?: string;
        maximum?: string;
        /**
         * The name of the metric in CloudWatch which the statement will be based on.
         */
        metricName: string;
        minTargetCapacity?: string;
        minimum?: string;
        /**
         * Must contain the value: `AWS/ElasticMapReduce`.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
         */
        operator: string;
        /**
         * The time window in seconds over which the statistic is applied.
         */
        period: number;
        policyName: string;
        /**
         * The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
         */
        statistic: string;
        target?: string;
        /**
         * The value that the specified statistic is compared to.
         */
        threshold: number;
        /**
         * The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
         */
        unit: string;
    }

    export interface MrScalarTaskScalingUpPolicy {
        actionType?: string;
        adjustment?: string;
        cooldown: number;
        dimensions?: {[key: string]: any};
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods: number;
        maxTargetCapacity?: string;
        maximum?: string;
        /**
         * The name of the metric in CloudWatch which the statement will be based on.
         */
        metricName: string;
        minTargetCapacity?: string;
        minimum?: string;
        /**
         * Must contain the value: `AWS/ElasticMapReduce`.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
         */
        operator: string;
        /**
         * The time window in seconds over which the statistic is applied.
         */
        period: number;
        policyName: string;
        /**
         * The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
         */
        statistic: string;
        target?: string;
        /**
         * The value that the specified statistic is compared to.
         */
        threshold: number;
        /**
         * The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
         */
        unit: string;
    }

    export interface MrScalarTerminationPolicy {
        statements: outputs.aws.MrScalarTerminationPolicyStatement[];
    }

    export interface MrScalarTerminationPolicyStatement {
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods?: number;
        /**
         * The name of the metric in CloudWatch which the statement will be based on.
         */
        metricName: string;
        /**
         * Must contain the value: `AWS/ElasticMapReduce`.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
         */
        operator?: string;
        /**
         * The time window in seconds over which the statistic is applied.
         */
        period?: number;
        /**
         * The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
         */
        statistic?: string;
        /**
         * The value that the specified statistic is compared to.
         */
        threshold: number;
        /**
         * The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
         */
        unit?: string;
    }

    export interface OceanAutoscaler {
        autoHeadroomPercentage?: number;
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.aws.OceanAutoscalerAutoscaleDown;
        autoscaleHeadroom?: outputs.aws.OceanAutoscalerAutoscaleHeadroom;
        autoscaleIsAutoConfig?: boolean;
        autoscaleIsEnabled?: boolean;
        resourceLimits?: outputs.aws.OceanAutoscalerResourceLimits;
    }

    export interface OceanAutoscalerAutoscaleDown {
        evaluationPeriods?: number;
        maxScaleDownPercentage?: number;
    }

    export interface OceanAutoscalerAutoscaleHeadroom {
        cpuPerUnit?: number;
        gpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface OceanAutoscalerResourceLimits {
        maxMemoryGib?: number;
        maxVcpu?: number;
    }

    export interface OceanLaunchSpecAutoscaleHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the number of GPUS to allocate for each headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecBlockDeviceMapping {
        /**
         * String. Set device name. (Example: "/dev/xvda1").
         */
        deviceName: string;
        /**
         * Object. Set Elastic Block Store properties .
         */
        ebs?: outputs.aws.OceanLaunchSpecBlockDeviceMappingEbs;
        /**
         * String. suppresses the specified device included in the block device mapping of the AMI.
         */
        noDevice?: string;
        virtualName?: string;
    }

    export interface OceanLaunchSpecBlockDeviceMappingEbs {
        /**
         * Boolean. Flag to delete the EBS on instance termination.
         */
        deleteOnTermination: boolean;
        /**
         * Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
         */
        dynamicVolumeSize?: outputs.aws.OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize;
        /**
         * Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
         */
        encrypted: boolean;
        /**
         * Int. The number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
         */
        kmsKeyId?: string;
        /**
         * (Optional) String. The Snapshot ID to mount by.
         */
        snapshotId?: string;
        /**
         * Int. The size, in GB of the volume.
         */
        volumeSize?: number;
        /**
         * String. The type of the volume (example: "gp2").
         */
        volumeType: string;
    }

    export interface OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize {
        /**
         * Int. Initial size for volume. (Example: 50)
         */
        baseSize: number;
        /**
         * String. Resource type to increase volume size dynamically by. (valid values: "CPU")
         */
        resource: string;
        /**
         * Int. Additional size (in GB) per resource unit. (Example: baseSize= 50, sizePerResourceUnit=20, and instance with 2 CPU is launched - its total disk size will be: 90GB)
         */
        sizePerResourceUnit: number;
    }

    export interface OceanLaunchSpecElasticIpPool {
        /**
         * Key-value object, which defines an Elastic IP from the customer pool. Can be null.
         */
        tagSelector?: outputs.aws.OceanLaunchSpecElasticIpPoolTagSelector;
    }

    export interface OceanLaunchSpecElasticIpPoolTagSelector {
        /**
         * Elastic IP tag key. The launch spec will consider all elastic IPs tagged with this tag as a part of the elastic IP pool to use.
         */
        tagKey: string;
        /**
         * Elastic IP tag value. Can be null.
         */
        tagValue?: string;
    }

    export interface OceanLaunchSpecLabel {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface OceanLaunchSpecResourceLimit {
        /**
         * set a maximum number of instances per launch specification. Can be null. If set, value must be greater than or equal to 0.
         */
        maxInstanceCount?: number;
    }

    export interface OceanLaunchSpecTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface OceanLaunchSpecTaint {
        /**
         * The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
         */
        effect: string;
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface OceanLoadBalancer {
        /**
         * Required if type is set to TARGET_GROUP
         */
        arn?: string;
        /**
         * Required if type is set to CLASSIC
         */
        name?: string;
        /**
         * Can be set to CLASSIC or TARGET_GROUP
         */
        type?: string;
    }

    export interface OceanScheduledTask {
        shutdownHours?: outputs.aws.OceanScheduledTaskShutdownHours;
        tasks?: outputs.aws.OceanScheduledTaskTask[];
    }

    export interface OceanScheduledTaskShutdownHours {
        isEnabled?: boolean;
        timeWindows: string[];
    }

    export interface OceanScheduledTaskTask {
        cronExpression: string;
        isEnabled: boolean;
        taskType: string;
    }

    export interface OceanTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface OceanUpdatePolicy {
        rollConfig?: outputs.aws.OceanUpdatePolicyRollConfig;
        shouldRoll: boolean;
    }

    export interface OceanUpdatePolicyRollConfig {
        batchSizePercentage: number;
    }
}

export namespace azure {
    export interface ElastigroupHealthCheck {
        autoHealing?: boolean;
        gracePeriod?: number;
        healthCheckType: string;
    }

    export interface ElastigroupImage {
        customs?: outputs.azure.ElastigroupImageCustom[];
        marketplaces?: outputs.azure.ElastigroupImageMarketplace[];
    }

    export interface ElastigroupImageCustom {
        imageName: string;
        /**
         * The Resource Group that the user-assigned managed identity resides in.
         */
        resourceGroupName: string;
    }

    export interface ElastigroupImageMarketplace {
        offer: string;
        publisher: string;
        sku: string;
    }

    export interface ElastigroupIntegrationKubernetes {
        clusterIdentifier: string;
    }

    export interface ElastigroupIntegrationMultaiRuntime {
        deploymentId: string;
    }

    export interface ElastigroupLoadBalancer {
        autoWeight?: boolean;
        balancerId?: string;
        targetSetId?: string;
        type: string;
    }

    export interface ElastigroupLogin {
        password?: string;
        sshPublicKey?: string;
        userName: string;
    }

    export interface ElastigroupManagedServiceIdentity {
        /**
         * The name of the managed identity.
         */
        name: string;
        /**
         * The Resource Group that the user-assigned managed identity resides in.
         */
        resourceGroupName: string;
    }

    export interface ElastigroupNetwork {
        additionalIpConfigs?: outputs.azure.ElastigroupNetworkAdditionalIpConfig[];
        assignPublicIp?: boolean;
        /**
         * The Resource Group that the user-assigned managed identity resides in.
         */
        resourceGroupName: string;
        subnetName: string;
        virtualNetworkName: string;
    }

    export interface ElastigroupNetworkAdditionalIpConfig {
        /**
         * The name of the managed identity.
         */
        name: string;
        privateIpVersion?: string;
    }

    export interface ElastigroupScalingDownPolicy {
        actionType?: string;
        adjustment?: string;
        cooldown: number;
        dimensions?: outputs.azure.ElastigroupScalingDownPolicyDimension[];
        evaluationPeriods: number;
        maxTargetCapacity?: string;
        maximum?: string;
        metricName: string;
        minTargetCapacity?: string;
        minimum?: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        statistic: string;
        target?: string;
        threshold: number;
        unit?: string;
    }

    export interface ElastigroupScalingDownPolicyDimension {
        /**
         * The name of the managed identity.
         */
        name: string;
        value?: string;
    }

    export interface ElastigroupScalingUpPolicy {
        actionType?: string;
        adjustment?: string;
        cooldown: number;
        dimensions?: outputs.azure.ElastigroupScalingUpPolicyDimension[];
        evaluationPeriods: number;
        maxTargetCapacity?: string;
        maximum?: string;
        metricName: string;
        minTargetCapacity?: string;
        minimum?: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        statistic: string;
        target?: string;
        threshold: number;
        unit?: string;
    }

    export interface ElastigroupScalingUpPolicyDimension {
        /**
         * The name of the managed identity.
         */
        name: string;
        value?: string;
    }

    export interface ElastigroupScheduledTask {
        adjustment?: string;
        adjustmentPercentage?: string;
        batchSizePercentage?: string;
        cronExpression: string;
        gracePeriod?: string;
        isEnabled?: boolean;
        scaleMaxCapacity?: string;
        scaleMinCapacity?: string;
        scaleTargetCapacity?: string;
        taskType: string;
    }

    export interface ElastigroupStrategy {
        /**
         * Time (seconds) to allow the instance to be drained from incoming TCP connections and detached from MLB before terminating it during a scale-down operation.
         */
        drainingTimeout?: number;
        /**
         * Percentage of Low Priority instances to maintain. Required if `odCount` is not specified.
         */
        lowPriorityPercentage?: number;
        /**
         * Number of On-Demand instances to maintain. Required if lowPriorityPercentage is not specified.
         */
        odCount?: number;
    }

    export interface ElastigroupUpdatePolicy {
        rollConfig?: outputs.azure.ElastigroupUpdatePolicyRollConfig;
        shouldRoll: boolean;
    }

    export interface ElastigroupUpdatePolicyRollConfig {
        batchSizePercentage: number;
        gracePeriod?: number;
        healthCheckType?: string;
    }
}

export namespace ecs {
    export interface OceanAutoscaler {
        cooldown?: number;
        down?: outputs.ecs.OceanAutoscalerDown;
        headroom?: outputs.ecs.OceanAutoscalerHeadroom;
        isAutoConfig?: boolean;
        isEnabled?: boolean;
        resourceLimits?: outputs.ecs.OceanAutoscalerResourceLimits;
    }

    export interface OceanAutoscalerDown {
        maxScaleDownPercentage?: number;
    }

    export interface OceanAutoscalerHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface OceanAutoscalerResourceLimits {
        maxMemoryGib?: number;
        maxVcpu?: number;
    }

    export interface OceanLaunchSpecAttribute {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface OceanLaunchSpecAutoscaleHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in CPU units, where 1024 units = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecTag {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface OceanScheduledTask {
        shutdownHours?: outputs.ecs.OceanScheduledTaskShutdownHours;
        tasks?: outputs.ecs.OceanScheduledTaskTask[];
    }

    export interface OceanScheduledTaskShutdownHours {
        isEnabled?: boolean;
        timeWindows: string[];
    }

    export interface OceanScheduledTaskTask {
        cronExpression: string;
        isEnabled: boolean;
        taskType: string;
    }

    export interface OceanTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface OceanUpdatePolicy {
        rollConfig?: outputs.ecs.OceanUpdatePolicyRollConfig;
        shouldRoll: boolean;
    }

    export interface OceanUpdatePolicyRollConfig {
        batchSizePercentage: number;
    }
}

export namespace gcp {
    export interface ElastigroupBackendService {
        locationType?: string;
        namedPorts?: outputs.gcp.ElastigroupBackendServiceNamedPort[];
        scheme?: string;
        serviceName: string;
    }

    export interface ElastigroupBackendServiceNamedPort {
        /**
         * The group name.
         */
        name: string;
        ports: string[];
    }

    export interface ElastigroupDisk {
        autoDelete?: boolean;
        boot?: boolean;
        deviceName?: string;
        initializeParams?: outputs.gcp.ElastigroupDiskInitializeParam[];
        interface?: string;
        mode?: string;
        source?: string;
        type?: string;
    }

    export interface ElastigroupDiskInitializeParam {
        diskSizeGb?: string;
        diskType?: string;
        sourceImage: string;
    }

    export interface ElastigroupGpu {
        count: number;
        type: string;
    }

    export interface ElastigroupInstanceTypesCustom {
        /**
         * The memory (in GiB) in the custom instance types. GCP has a number of limitations on accepted memory values.For more information, see the GCP documentation (here.)[https://cloud.google.com/compute/docs/instances/creating-instance-with-custom-machine-type#specifications]
         */
        memoryGib: number;
        vcpu: number;
    }

    export interface ElastigroupIntegrationDockerSwarm {
        masterHost: string;
        masterPort: number;
    }

    export interface ElastigroupIntegrationGke {
        autoUpdate?: boolean;
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.gcp.ElastigroupIntegrationGkeAutoscaleDown;
        autoscaleHeadroom?: outputs.gcp.ElastigroupIntegrationGkeAutoscaleHeadroom;
        autoscaleIsAutoConfig?: boolean;
        autoscaleIsEnabled?: boolean;
        autoscaleLabels?: outputs.gcp.ElastigroupIntegrationGkeAutoscaleLabel[];
        clusterId?: string;
        location?: string;
    }

    export interface ElastigroupIntegrationGkeAutoscaleDown {
        evaluationPeriods?: number;
    }

    export interface ElastigroupIntegrationGkeAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationGkeAutoscaleLabel {
        /**
         * Labels key.
         */
        key: string;
        /**
         * Labels value.
         */
        value: string;
    }

    export interface ElastigroupLabel {
        /**
         * Labels key.
         */
        key: string;
        /**
         * Labels value.
         */
        value: string;
    }

    export interface ElastigroupMetadata {
        /**
         * Labels key.
         */
        key: string;
        /**
         * Labels value.
         */
        value: string;
    }

    export interface ElastigroupNetworkInterface {
        accessConfigs?: outputs.gcp.ElastigroupNetworkInterfaceAccessConfig[];
        aliasIpRanges?: outputs.gcp.ElastigroupNetworkInterfaceAliasIpRange[];
        network: string;
    }

    export interface ElastigroupNetworkInterfaceAccessConfig {
        /**
         * The group name.
         */
        name?: string;
        type?: string;
    }

    export interface ElastigroupNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName: string;
    }

    export interface ElastigroupScalingDownPolicy {
        actionType?: string;
        adjustment?: number;
        cooldown: number;
        dimensions?: outputs.gcp.ElastigroupScalingDownPolicyDimension[];
        evaluationPeriods: number;
        metricName: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        source: string;
        statistic: string;
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingDownPolicyDimension {
        /**
         * The group name.
         */
        name: string;
        /**
         * Labels value.
         */
        value?: string;
    }

    export interface ElastigroupScalingUpPolicy {
        actionType?: string;
        adjustment?: number;
        cooldown: number;
        dimensions?: outputs.gcp.ElastigroupScalingUpPolicyDimension[];
        evaluationPeriods: number;
        metricName: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        source: string;
        statistic: string;
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingUpPolicyDimension {
        /**
         * The group name.
         */
        name: string;
        /**
         * Labels value.
         */
        value?: string;
    }

    export interface ElastigroupScheduledTask {
        cronExpression?: string;
        isEnabled?: boolean;
        maxCapacity?: string;
        minCapacity?: string;
        targetCapacity?: string;
        taskType: string;
    }

    export interface ElastigroupSubnet {
        /**
         * The region for the group of subnets.
         */
        region: string;
        /**
         * The names of the subnets in the region.
         */
        subnetNames: string[];
    }
}

export namespace gke {
    export interface ElastigroupBackendService {
        locationType?: string;
        namedPorts?: outputs.gke.ElastigroupBackendServiceNamedPort[];
        scheme?: string;
        serviceName: string;
    }

    export interface ElastigroupBackendServiceNamedPort {
        name: string;
        ports: string[];
    }

    export interface ElastigroupDisk {
        autoDelete?: boolean;
        boot?: boolean;
        deviceName?: string;
        initializeParams?: outputs.gke.ElastigroupDiskInitializeParam[];
        interface?: string;
        mode?: string;
        source?: string;
        type?: string;
    }

    export interface ElastigroupDiskInitializeParam {
        diskSizeGb?: string;
        diskType?: string;
        sourceImage: string;
    }

    export interface ElastigroupGpu {
        count: number;
        type: string;
    }

    export interface ElastigroupInstanceTypesCustom {
        memoryGib: number;
        vcpu: number;
    }

    export interface ElastigroupIntegrationDockerSwarm {
        masterHost: string;
        masterPort: number;
    }

    export interface ElastigroupIntegrationGke {
        autoUpdate?: boolean;
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.gke.ElastigroupIntegrationGkeAutoscaleDown;
        autoscaleHeadroom?: outputs.gke.ElastigroupIntegrationGkeAutoscaleHeadroom;
        autoscaleIsAutoConfig?: boolean;
        autoscaleIsEnabled?: boolean;
        autoscaleLabels?: outputs.gke.ElastigroupIntegrationGkeAutoscaleLabel[];
        /**
         * The name of the GKE cluster you wish to import.
         */
        clusterId?: string;
        location?: string;
    }

    export interface ElastigroupIntegrationGkeAutoscaleDown {
        evaluationPeriods?: number;
    }

    export interface ElastigroupIntegrationGkeAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationGkeAutoscaleLabel {
        key: string;
        value: string;
    }

    export interface ElastigroupLabel {
        key: string;
        value: string;
    }

    export interface ElastigroupMetadata {
        key: string;
        value: string;
    }

    export interface ElastigroupNetworkInterface {
        accessConfigs?: outputs.gke.ElastigroupNetworkInterfaceAccessConfig[];
        aliasIpRanges?: outputs.gke.ElastigroupNetworkInterfaceAliasIpRange[];
        network: string;
    }

    export interface ElastigroupNetworkInterfaceAccessConfig {
        name?: string;
        type?: string;
    }

    export interface ElastigroupNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName: string;
    }

    export interface ElastigroupScalingDownPolicy {
        actionType?: string;
        adjustment?: number;
        cooldown: number;
        dimensions?: outputs.gke.ElastigroupScalingDownPolicyDimension[];
        evaluationPeriods: number;
        metricName: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        source: string;
        statistic: string;
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingDownPolicyDimension {
        name: string;
        value?: string;
    }

    export interface ElastigroupScalingUpPolicy {
        actionType?: string;
        adjustment?: number;
        cooldown: number;
        dimensions?: outputs.gke.ElastigroupScalingUpPolicyDimension[];
        evaluationPeriods: number;
        metricName: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        source: string;
        statistic: string;
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingUpPolicyDimension {
        name: string;
        value?: string;
    }

    export interface OceanImportAutoscaler {
        autoHeadroomPercentage?: number;
        cooldown?: number;
        down?: outputs.gke.OceanImportAutoscalerDown;
        headroom?: outputs.gke.OceanImportAutoscalerHeadroom;
        isAutoConfig?: boolean;
        isEnabled?: boolean;
        resourceLimits?: outputs.gke.OceanImportAutoscalerResourceLimits;
    }

    export interface OceanImportAutoscalerDown {
        evaluationPeriods?: number;
        maxScaleDownPercentage?: number;
    }

    export interface OceanImportAutoscalerHeadroom {
        cpuPerUnit?: number;
        gpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface OceanImportAutoscalerResourceLimits {
        maxMemoryGib?: number;
        maxVcpu?: number;
    }

    export interface OceanImportBackendService {
        /**
         * Sets which location the backend services will be active. Valid values: `regional`, `global`.
         */
        locationType?: string;
        namedPorts?: outputs.gke.OceanImportBackendServiceNamedPort[];
        /**
         * Use when `locationType` is `regional`. Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: `INTERNAL`, `EXTERNAL`.
         */
        scheme?: string;
        /**
         * The name of the backend service.
         */
        serviceName: string;
    }

    export interface OceanImportBackendServiceNamedPort {
        name: string;
        /**
         * A list of ports.
         */
        ports: string[];
    }

    export interface OceanImportScheduledTask {
        shutdownHours?: outputs.gke.OceanImportScheduledTaskShutdownHours;
        tasks?: outputs.gke.OceanImportScheduledTaskTask[];
    }

    export interface OceanImportScheduledTaskShutdownHours {
        isEnabled?: boolean;
        timeWindows: string[];
    }

    export interface OceanImportScheduledTaskTask {
        batchSizePercentage?: number;
        cronExpression: string;
        isEnabled: boolean;
        taskType: string;
    }

    export interface OceanLaunchSpecAutoscaleHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the number of GPUS to allocate for each headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecLabel {
        key: string;
        value: string;
    }

    export interface OceanLaunchSpecMetadata {
        key: string;
        value: string;
    }

    export interface OceanLaunchSpecTaint {
        effect: string;
        key: string;
        value: string;
    }
}

export namespace multai {
    export interface BalancerConnectionTimeouts {
        draining?: number;
        idle?: number;
    }

    export interface BalancerTag {
        key: string;
        value: string;
    }

    export interface ListenerTag {
        key: string;
        value: string;
    }

    export interface ListenerTlsConfig {
        certificateIds: string[];
        cipherSuites: string[];
        maxVersion: string;
        minVersion: string;
        preferServerCipherSuites: boolean;
        sessionTicketsDisabled: boolean;
    }

    export interface RoutingRuleTag {
        key: string;
        value: string;
    }

    export interface TargetSetHealthCheck {
        healthyThreshold: number;
        interval: number;
        path: string;
        port: number;
        protocol: string;
        timeout: number;
        unhealthyThreshold: number;
    }

    export interface TargetSetTag {
        key: string;
        value: string;
    }

    export interface TargetTag {
        key: string;
        value: string;
    }
}

