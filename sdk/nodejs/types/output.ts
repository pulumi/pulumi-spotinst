// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface DataIntegrationS3 {
    bucketName: string;
    /**
     * The subdirectory in which your files will be stored within the bucket. Adds the prefix subdir/ to new objects' keys. Can't be null or contain '/'.
     */
    subdir?: string;
}

export interface ElastigroupAzureV3Image {
    customs?: outputs.ElastigroupAzureV3ImageCustom[];
    marketplaces?: outputs.ElastigroupAzureV3ImageMarketplace[];
}

export interface ElastigroupAzureV3ImageCustom {
    imageName: string;
    resourceGroupName: string;
}

export interface ElastigroupAzureV3ImageMarketplace {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface ElastigroupAzureV3Login {
    password?: string;
    sshPublicKey?: string;
    userName: string;
}

export interface ElastigroupAzureV3ManagedServiceIdentity {
    name: string;
    resourceGroupName: string;
}

export interface ElastigroupAzureV3Network {
    networkInterfaces: outputs.ElastigroupAzureV3NetworkNetworkInterface[];
    resourceGroupName: string;
    virtualNetworkName: string;
}

export interface ElastigroupAzureV3NetworkNetworkInterface {
    additionalIpConfigs?: outputs.ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig[];
    applicationSecurityGroups?: outputs.ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup[];
    assignPublicIp: boolean;
    isPrimary: boolean;
    subnetName: string;
}

export interface ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig {
    name: string;
    privateIpVersion?: string;
}

export interface ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup {
    name: string;
    resourceGroupName: string;
}

export interface ElastigroupAzureV3Tag {
    key: string;
    value: string;
}

export interface HealthCheckCheck {
    endPoint?: string;
    /**
     * The destination for the request.
     */
    endpoint?: string;
    healthy: number;
    /**
     * The amount of time (in seconds) between each health check (minimum: 10).
     */
    interval: number;
    /**
     * The port to use to connect with the instance.
     */
    port: number;
    /**
     * The protocol to use to connect with the instance. Valid values: http, https.
     */
    protocol: string;
    timeOut?: number;
    /**
     * the amount of time (in seconds) to wait when receiving a response from the health check.
     */
    timeout?: number;
    unhealthy: number;
}

export interface StatefulNodeAzureAttachDataDisk {
    dataDiskName: string;
    dataDiskResourceGroupName: string;
    lun?: number;
    sizeGb: number;
    storageAccountType: string;
    zone?: string;
}

export interface StatefulNodeAzureBootDiagnostic {
    isEnabled: boolean;
    storageUrl: string;
    type: string;
}

export interface StatefulNodeAzureDataDisk {
    lun: number;
    sizeGb: number;
    type: string;
}

export interface StatefulNodeAzureDelete {
    diskShouldDeallocate: boolean;
    diskTtlInHours?: number;
    networkShouldDeallocate: boolean;
    networkTtlInHours?: number;
    publicIpShouldDeallocate: boolean;
    publicIpTtlInHours?: number;
    shouldTerminateVm: boolean;
    snapshotShouldDeallocate: boolean;
    snapshotTtlInHours?: number;
}

export interface StatefulNodeAzureDetachDataDisk {
    dataDiskName: string;
    dataDiskResourceGroupName: string;
    shouldDeallocate: boolean;
    ttlInHours?: number;
}

export interface StatefulNodeAzureExtension {
    apiVersion: string;
    minorVersionAutoUpgrade: boolean;
    name: string;
    protectedSettings: {[key: string]: any};
    publicSettings: {[key: string]: any};
    publisher: string;
    type: string;
}

export interface StatefulNodeAzureHealth {
    autoHealing: boolean;
    gracePeriod: number;
    healthCheckTypes: string[];
    unhealthyDuration: number;
}

export interface StatefulNodeAzureImage {
    customImages: outputs.StatefulNodeAzureImageCustomImage[];
    galleries: outputs.StatefulNodeAzureImageGallery[];
    marketplaceImages: outputs.StatefulNodeAzureImageMarketplaceImage[];
}

export interface StatefulNodeAzureImageCustomImage {
    customImageResourceGroupName: string;
    name: string;
}

export interface StatefulNodeAzureImageGallery {
    galleryName: string;
    galleryResourceGroupName: string;
    imageName: string;
    versionName: string;
}

export interface StatefulNodeAzureImageMarketplaceImage {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface StatefulNodeAzureImportVm {
    drainingTimeout?: number;
    originalVmName: string;
    resourceGroupName: string;
    resourcesRetentionTime?: number;
}

export interface StatefulNodeAzureLoadBalancer {
    backendPoolNames: string[];
    name: string;
    resourceGroupName: string;
    sku: string;
    type: string;
}

export interface StatefulNodeAzureLogin {
    password?: string;
    sshPublicKey?: string;
    userName: string;
}

export interface StatefulNodeAzureManagedServiceIdentity {
    name: string;
    resourceGroupName: string;
}

export interface StatefulNodeAzureNetwork {
    networkInterfaces: outputs.StatefulNodeAzureNetworkNetworkInterface[];
    networkResourceGroupName: string;
    virtualNetworkName: string;
}

export interface StatefulNodeAzureNetworkNetworkInterface {
    additionalIpConfigurations?: outputs.StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration[];
    applicationSecurityGroups?: outputs.StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup[];
    assignPublicIp?: boolean;
    enableIpForwarding?: boolean;
    isPrimary: boolean;
    networkSecurityGroups?: outputs.StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup[];
    privateIpAddresses?: string[];
    publicIpSku?: string;
    publicIps?: outputs.StatefulNodeAzureNetworkNetworkInterfacePublicIp[];
    subnetName: string;
}

export interface StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration {
    name: string;
    privateIpAddressVersion: string;
}

export interface StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup {
    name: string;
    networkResourceGroupName: string;
}

export interface StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup {
    name?: string;
    networkResourceGroupName?: string;
}

export interface StatefulNodeAzureNetworkNetworkInterfacePublicIp {
    name: string;
    networkResourceGroupName: string;
}

export interface StatefulNodeAzureOsDisk {
    caching?: string;
    sizeGb?: number;
    type: string;
}

export interface StatefulNodeAzureProximityPlacementGroup {
    name: string;
    resourceGroupName: string;
}

export interface StatefulNodeAzureSchedulingTask {
    cronExpression: string;
    isEnabled: boolean;
    type: string;
}

export interface StatefulNodeAzureSecret {
    sourceVaults: outputs.StatefulNodeAzureSecretSourceVault[];
    vaultCertificates: outputs.StatefulNodeAzureSecretVaultCertificate[];
}

export interface StatefulNodeAzureSecretSourceVault {
    name: string;
    resourceGroupName: string;
}

export interface StatefulNodeAzureSecretVaultCertificate {
    certificateStore?: string;
    certificateUrl?: string;
}

export interface StatefulNodeAzureSecurity {
    secureBootEnabled?: boolean;
    securityType?: string;
    vtpmEnabled?: boolean;
}

export interface StatefulNodeAzureSignal {
    timeout: number;
    type: string;
}

export interface StatefulNodeAzureStrategy {
    availabilityVsCost?: number;
    capacityReservations?: outputs.StatefulNodeAzureStrategyCapacityReservation[];
    drainingTimeout: number;
    fallbackToOnDemand: boolean;
    odWindows?: string[];
    optimizationWindows?: string[];
    preferredLifeCycle: string;
    revertToSpot: outputs.StatefulNodeAzureStrategyRevertToSpot;
}

export interface StatefulNodeAzureStrategyCapacityReservation {
    capacityReservationGroups?: outputs.StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup[];
    shouldUtilize: boolean;
    utilizationStrategy: string;
}

export interface StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup {
    crgName: string;
    crgResourceGroupName: string;
    crgShouldPrioritize?: boolean;
}

export interface StatefulNodeAzureStrategyRevertToSpot {
    performAt: string;
}

export interface StatefulNodeAzureTag {
    tagKey: string;
    tagValue?: string;
}

export interface StatefulNodeAzureUpdateState {
    state: string;
}

export namespace aws {
    export interface BeanstalkDeploymentPreferences {
        /**
         * Should roll perform automatically
         */
        automaticRoll?: boolean;
        /**
         * Percent size of each batch
         */
        batchSizePercentage?: number;
        /**
         * Amount of time to wait between batches
         */
        gracePeriod?: number;
        /**
         * Strategy parameters
         */
        strategies?: outputs.aws.BeanstalkDeploymentPreferencesStrategy[];
    }

    export interface BeanstalkDeploymentPreferencesStrategy {
        action?: string;
        shouldDrainInstances?: boolean;
    }

    export interface BeanstalkManagedActions {
        /**
         * Platform Update parameters
         */
        platformUpdate?: outputs.aws.BeanstalkManagedActionsPlatformUpdate;
    }

    export interface BeanstalkManagedActionsPlatformUpdate {
        performAt?: string;
        timeWindow?: string;
        updateLevel?: string;
    }

    export interface BeanstalkScheduledTask {
        /**
         * The number of instances to add or remove.
         */
        adjustment?: string;
        /**
         * The percentage of instances to add or remove.
         *
         * Usage:
         */
        adjustmentPercentage?: string;
        /**
         * The percentage size of each batch in the scheduled deployment roll.
         */
        batchSizePercentage?: string;
        /**
         * A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
         */
        cronExpression?: string;
        /**
         * The recurrence frequency to run this task. Supported values are `"hourly"`, `"daily"`, `"weekly"` and `"continuous"`.
         */
        frequency?: string;
        /**
         * The period of time (seconds) to wait before checking a batch's health after it's deployment.
         */
        gracePeriod?: string;
        /**
         * Setting the task to being enabled or disabled.
         */
        isEnabled?: boolean;
        /**
         * The maximum number of instances the group should have.
         */
        maxCapacity?: string;
        /**
         * The minimum number of instances the group should have.
         */
        minCapacity?: string;
        /**
         * The maximum number of instances the group should have.
         */
        scaleMaxCapacity?: string;
        /**
         * The minimum number of instances the group should have.
         */
        scaleMinCapacity?: string;
        /**
         * The desired number of instances the group should have.
         */
        scaleTargetCapacity?: string;
        /**
         * Set a start time for one time tasks.
         */
        startTime?: string;
        /**
         * The desired number of instances the group should have.
         */
        targetCapacity?: string;
        /**
         * The task type to run. Supported task types are: `"scale"`, `"backupAmi"`, `"roll"`, `"scaleUp"`, `"percentageScaleUp"`, `"scaleDown"`, `"percentageScaleDown"`, `"statefulUpdateCapacity"`.
         */
        taskType: string;
    }

    export interface ElastigroupCpuOptions {
        /**
         * The ability to define the number of threads per core in instances that allow this.
         */
        threadsPerCore: number;
    }

    export interface ElastigroupEbsBlockDevice {
        /**
         * Whether the volume should be destroyed on instance termination.
         */
        deleteOnTermination: boolean;
        /**
         * The name of the device to mount.
         */
        deviceName: string;
        /**
         * Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
         */
        encrypted: boolean;
        /**
         * The amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). This must be set with a `volumeType` of `"io1"`.
         */
        iops?: number;
        /**
         * ID for a user managed CMK under which the EBS Volume is encrypted
         */
        kmsKeyId?: string;
        /**
         * The Snapshot ID to mount.
         */
        snapshotId?: string;
        /**
         * The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volumeType` = gp3.
         *
         * Modifying any `ebsBlockDevice` currently requires resource replacement.
         *
         * Usage:
         */
        throughput?: number;
        /**
         * The size of the volume in gigabytes.
         */
        volumeSize?: number;
        /**
         * The type of volume. Can be `"standard"`, `"gp2"`, `"gp3"`, `"io1"`, `"st1"` or `"sc1"`.
         */
        volumeType: string;
    }

    export interface ElastigroupEphemeralBlockDevice {
        /**
         * The name of the block device to mount on the instance.
         */
        deviceName: string;
        /**
         * The [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
         * (e.g. `"ephemeral0"`).
         *
         * Usage:
         */
        virtualName: string;
    }

    export interface ElastigroupImage {
        images: outputs.aws.ElastigroupImageImage[];
    }

    export interface ElastigroupImageImage {
        /**
         * The group ID.
         */
        id: string;
    }

    export interface ElastigroupInstanceTypesWeight {
        /**
         * Name of instance type (String).
         */
        instanceType: string;
        /**
         * Weight per instance type (Integer).
         */
        weight: number;
    }

    export interface ElastigroupIntegrationBeanstalk {
        deploymentPreferences?: outputs.aws.ElastigroupIntegrationBeanstalkDeploymentPreferences;
        environmentId?: string;
        managedActions?: outputs.aws.ElastigroupIntegrationBeanstalkManagedActions;
    }

    export interface ElastigroupIntegrationBeanstalkDeploymentPreferences {
        automaticRoll?: boolean;
        batchSizePercentage?: number;
        gracePeriod?: number;
        strategy?: outputs.aws.ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategy;
    }

    export interface ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategy {
        action?: string;
        shouldDrainInstances?: boolean;
    }

    export interface ElastigroupIntegrationBeanstalkManagedActions {
        platformUpdate?: outputs.aws.ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdate;
    }

    export interface ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdate {
        performAt?: string;
        timeWindow?: string;
        updateLevel?: string;
    }

    export interface ElastigroupIntegrationCodedeploy {
        cleanupOnFailure: boolean;
        deploymentGroups: outputs.aws.ElastigroupIntegrationCodedeployDeploymentGroup[];
        terminateInstanceOnFailure: boolean;
    }

    export interface ElastigroupIntegrationCodedeployDeploymentGroup {
        applicationName: string;
        deploymentGroupName: string;
    }

    export interface ElastigroupIntegrationDockerSwarm {
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.aws.ElastigroupIntegrationDockerSwarmAutoscaleDown;
        autoscaleHeadroom?: outputs.aws.ElastigroupIntegrationDockerSwarmAutoscaleHeadroom;
        autoscaleIsEnabled?: boolean;
        masterHost: string;
        masterPort: number;
    }

    export interface ElastigroupIntegrationDockerSwarmAutoscaleDown {
        evaluationPeriods?: number;
        maxScaleDownPercentage?: number;
    }

    export interface ElastigroupIntegrationDockerSwarmAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationEcs {
        autoscaleAttributes?: outputs.aws.ElastigroupIntegrationEcsAutoscaleAttribute[];
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.aws.ElastigroupIntegrationEcsAutoscaleDown;
        autoscaleHeadroom?: outputs.aws.ElastigroupIntegrationEcsAutoscaleHeadroom;
        autoscaleIsAutoConfig?: boolean;
        autoscaleIsEnabled?: boolean;
        autoscaleScaleDownNonServiceTasks?: boolean;
        batch?: outputs.aws.ElastigroupIntegrationEcsBatch;
        clusterName: string;
    }

    export interface ElastigroupIntegrationEcsAutoscaleAttribute {
        key: string;
        value: string;
    }

    export interface ElastigroupIntegrationEcsAutoscaleDown {
        evaluationPeriods?: number;
        maxScaleDownPercentage?: number;
    }

    export interface ElastigroupIntegrationEcsAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationEcsBatch {
        jobQueueNames: string[];
    }

    export interface ElastigroupIntegrationGitlab {
        runner?: outputs.aws.ElastigroupIntegrationGitlabRunner;
    }

    export interface ElastigroupIntegrationGitlabRunner {
        isEnabled?: boolean;
    }

    export interface ElastigroupIntegrationKubernetes {
        apiServer?: string;
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.aws.ElastigroupIntegrationKubernetesAutoscaleDown;
        autoscaleHeadroom?: outputs.aws.ElastigroupIntegrationKubernetesAutoscaleHeadroom;
        autoscaleIsAutoConfig?: boolean;
        autoscaleIsEnabled?: boolean;
        autoscaleLabels?: outputs.aws.ElastigroupIntegrationKubernetesAutoscaleLabel[];
        clusterIdentifier?: string;
        integrationMode?: string;
        token?: string;
    }

    export interface ElastigroupIntegrationKubernetesAutoscaleDown {
        evaluationPeriods?: number;
        maxScaleDownPercentage?: number;
    }

    export interface ElastigroupIntegrationKubernetesAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationKubernetesAutoscaleLabel {
        key: string;
        value: string;
    }

    export interface ElastigroupIntegrationMesosphere {
        apiServer: string;
    }

    export interface ElastigroupIntegrationNomad {
        aclToken?: string;
        autoscaleConstraints?: outputs.aws.ElastigroupIntegrationNomadAutoscaleConstraint[];
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.aws.ElastigroupIntegrationNomadAutoscaleDown;
        autoscaleHeadroom?: outputs.aws.ElastigroupIntegrationNomadAutoscaleHeadroom;
        autoscaleIsEnabled?: boolean;
        masterHost: string;
        masterPort: number;
    }

    export interface ElastigroupIntegrationNomadAutoscaleConstraint {
        key: string;
        value: string;
    }

    export interface ElastigroupIntegrationNomadAutoscaleDown {
        evaluationPeriods?: number;
    }

    export interface ElastigroupIntegrationNomadAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationRancher {
        accessKey: string;
        masterHost: string;
        secretKey: string;
        version?: string;
    }

    export interface ElastigroupIntegrationRoute53 {
        domains: outputs.aws.ElastigroupIntegrationRoute53Domain[];
    }

    export interface ElastigroupIntegrationRoute53Domain {
        hostedZoneId: string;
        recordSetType?: string;
        recordSets: outputs.aws.ElastigroupIntegrationRoute53DomainRecordSet[];
        spotinstAcctId?: string;
    }

    export interface ElastigroupIntegrationRoute53DomainRecordSet {
        /**
         * The group name.
         */
        name: string;
        usePublicDns?: boolean;
        usePublicIp?: boolean;
    }

    export interface ElastigroupItf {
        defaultStaticTargetGroup?: outputs.aws.ElastigroupItfDefaultStaticTargetGroup;
        fixedTargetGroups: boolean;
        loadBalancers: outputs.aws.ElastigroupItfLoadBalancer[];
        migrationHealthinessThreshold?: number;
        targetGroupConfigs: outputs.aws.ElastigroupItfTargetGroupConfig[];
        weightStrategy: string;
    }

    export interface ElastigroupItfDefaultStaticTargetGroup {
        arn: string;
        percentage: number;
    }

    export interface ElastigroupItfLoadBalancer {
        listenerRules: outputs.aws.ElastigroupItfLoadBalancerListenerRule[];
        loadBalancerArn: string;
    }

    export interface ElastigroupItfLoadBalancerListenerRule {
        ruleArn: string;
        staticTargetGroup?: outputs.aws.ElastigroupItfLoadBalancerListenerRuleStaticTargetGroup;
    }

    export interface ElastigroupItfLoadBalancerListenerRuleStaticTargetGroup {
        arn: string;
        percentage: number;
    }

    export interface ElastigroupItfTargetGroupConfig {
        healthCheckIntervalSeconds?: number;
        healthCheckPath: string;
        healthCheckPort?: string;
        healthCheckProtocol?: string;
        healthCheckTimeoutSeconds?: number;
        healthyThresholdCount?: number;
        matchers?: outputs.aws.ElastigroupItfTargetGroupConfigMatcher[];
        port: number;
        protocol: string;
        protocolVersion?: string;
        /**
         * A key/value mapping of tags to assign to the resource.
         */
        tags?: outputs.aws.ElastigroupItfTargetGroupConfigTag[];
        unhealthyThresholdCount?: number;
        vpcId: string;
    }

    export interface ElastigroupItfTargetGroupConfigMatcher {
        grpcCode?: string;
        httpCode?: string;
    }

    export interface ElastigroupItfTargetGroupConfigTag {
        tagKey: string;
        tagValue?: string;
    }

    export interface ElastigroupLogging {
        /**
         * Logging Export configuration.
         */
        export?: outputs.aws.ElastigroupLoggingExport;
    }

    export interface ElastigroupLoggingExport {
        s3s?: outputs.aws.ElastigroupLoggingExportS3[];
    }

    export interface ElastigroupLoggingExportS3 {
        /**
         * The group ID.
         */
        id: string;
    }

    export interface ElastigroupMetadataOptions {
        /**
         * The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values: Integers from `1` to `64`.
         */
        httpPutResponseHopLimit?: number;
        /**
         * The state of token usage for your instance metadata requests. Valid values: `optional` or `required`.
         */
        httpTokens: string;
        /**
         * Indicates whether access to instance tags from the instance metadata is enabled or disabled. Can’t be null.
         */
        instanceMetadataTags?: string;
    }

    export interface ElastigroupMultipleMetrics {
        expressions?: outputs.aws.ElastigroupMultipleMetricsExpression[];
        metrics?: outputs.aws.ElastigroupMultipleMetricsMetric[];
    }

    export interface ElastigroupMultipleMetricsExpression {
        expression: string;
        /**
         * The group name.
         */
        name: string;
    }

    export interface ElastigroupMultipleMetricsMetric {
        dimensions?: outputs.aws.ElastigroupMultipleMetricsMetricDimension[];
        extendedStatistic?: string;
        metricName: string;
        /**
         * The group name.
         */
        name: string;
        namespace: string;
        statistic?: string;
        unit?: string;
    }

    export interface ElastigroupMultipleMetricsMetricDimension {
        /**
         * The group name.
         */
        name: string;
        value?: string;
    }

    export interface ElastigroupNetworkInterface {
        associateIpv6Address?: boolean;
        associatePublicIpAddress?: boolean;
        deleteOnTermination: boolean;
        /**
         * The group description.
         */
        description?: string;
        deviceIndex: string;
        networkInterfaceId?: string;
        privateIpAddress?: string;
        secondaryPrivateIpAddressCount?: string;
    }

    export interface ElastigroupResourceRequirement {
        /**
         * Instance families to exclude
         */
        excludedInstanceFamilies?: string[];
        /**
         * Instance generations to exclude
         */
        excludedInstanceGenerations?: string[];
        /**
         * Instance types to exclude
         */
        excludedInstanceTypes?: string[];
        /**
         * Required maximum instance GPU (<=16)
         */
        requiredGpuMaximum?: number;
        /**
         * Required minimum instance GPU (>=1)
         */
        requiredGpuMinimum?: number;
        /**
         * Required maximum instance memory (<=512)
         */
        requiredMemoryMaximum: number;
        /**
         * Required minimum instance memory (>=1)
         */
        requiredMemoryMinimum: number;
        /**
         * Required maximum instance vCPU (<=64)
         */
        requiredVcpuMaximum: number;
        /**
         * Required minimum instance vCPU (>=1)
         */
        requiredVcpuMinimum: number;
    }

    export interface ElastigroupResourceTagSpecification {
        /**
         * Tag specification for AMI resources.
         */
        shouldTagAmis?: boolean;
        /**
         * Tag specification for ENI resources.
         */
        shouldTagEnis?: boolean;
        /**
         * Tag specification for Snapshot resources.
         */
        shouldTagSnapshots?: boolean;
        /**
         * Tag specification for Volume resources.
         */
        shouldTagVolumes?: boolean;
    }

    export interface ElastigroupRevertToSpot {
        /**
         * In the event of a fallback to On-Demand instances, select the time period to revert back to Spot. Supported Arguments – always (default), timeWindow, never. For timeWindow or never to be valid the group must have availabilityOriented OR persistence defined.
         */
        performAt: string;
        /**
         * Specify a list of time windows for to execute revertToSpot strategy. Time window format: `ddd:hh:mm-ddd:hh:mm`. Example: `Mon:03:00-Wed:02:30`
         */
        timeWindows?: string[];
    }

    export interface ElastigroupScalingDownPolicy {
        /**
         * The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`. If a `stepAdjustment` object is defined, then it cannot be specified.
         */
        actionType?: string;
        /**
         * The number of instances to add/remove to/from the target capacity when scale is needed. Can be used as advanced expression for scaling of instances to add/remove to/from the target capacity when scale is needed. You can see more information here: Advanced expression. Example value: `"MAX(currCapacity / 5, value * 10)"`
         */
        adjustment?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
         */
        cooldown?: number;
        /**
         * A list of dimensions describing qualities of the metric.
         */
        dimensions?: outputs.aws.ElastigroupScalingDownPolicyDimension[];
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods: number;
        /**
         * Specifies whether the scaling policy described in this block is enabled.
         */
        isEnabled?: boolean;
        /**
         * . The number of the desired target (and maximum) capacity
         */
        maxTargetCapacity?: string;
        /**
         * The maximal number of instances to have in the group.
         */
        maximum?: string;
        /**
         * The name of the metric, with or without spaces.
         */
        metricName: string;
        minTargetCapacity?: string;
        /**
         * The minimal number of instances to have in the group.
         */
        minimum?: string;
        /**
         * The namespace for the alarm's associated metric.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
         */
        operator: string;
        /**
         * The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
         */
        period: number;
        /**
         * The name of the policy.
         */
        policyName: string;
        /**
         * The source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
         */
        source: string;
        /**
         * The metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
         */
        statistic?: string;
        stepAdjustments?: outputs.aws.ElastigroupScalingDownPolicyStepAdjustment[];
        /**
         * The target number of instances to have in the group.
         */
        target?: string;
        /**
         * The value against which the specified statistic is compared. If a `stepAdjustment` object is defined, then it cannot be specified.
         */
        threshold?: number;
        /**
         * The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
         */
        unit?: string;
    }

    export interface ElastigroupScalingDownPolicyDimension {
        /**
         * The dimension name.
         */
        name: string;
        /**
         * The dimension value.
         */
        value?: string;
    }

    export interface ElastigroupScalingDownPolicyStepAdjustment {
        action: outputs.aws.ElastigroupScalingDownPolicyStepAdjustmentAction;
        threshold: number;
    }

    export interface ElastigroupScalingDownPolicyStepAdjustmentAction {
        adjustment?: string;
        maxTargetCapacity?: string;
        maximum?: string;
        minTargetCapacity?: string;
        minimum?: string;
        target?: string;
        type: string;
    }

    export interface ElastigroupScalingStrategy {
        /**
         * Specify whether to terminate instances at the end of each billing hour.
         */
        terminateAtEndOfBillingHour?: boolean;
        /**
         * Determines whether to terminate the newest instances when performing a scaling action. Valid values: `"default"`, `"newestInstance"`.
         */
        terminationPolicy?: string;
    }

    export interface ElastigroupScalingTargetPolicy {
        /**
         * Integer the amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
         */
        cooldown?: number;
        /**
         * A list of dimensions describing qualities of the metric.
         */
        dimensions?: outputs.aws.ElastigroupScalingTargetPolicyDimension[];
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods?: number;
        /**
         * String, restrict the maximal number of instances which can be added in each scale-up action.
         *
         * `scalingTargetPolicies` support predictive scaling:
         */
        maxCapacityPerScale?: string;
        /**
         * String, the name of the metric, with or without spaces.
         */
        metricName: string;
        /**
         * String, the namespace for the alarm's associated metric.
         */
        namespace: string;
        /**
         * The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
         */
        period?: number;
        /**
         * String, the name of the policy.
         */
        policyName: string;
        /**
         * Start a metric prediction process to determine the expected target metric value within the next two days. See [Predictive Autoscaling](https://api.spotinst.com/elastigroup-for-aws/concepts/scaling-concepts/predictive-autoscaling/) documentation for more info. Valid values: `FORECAST_AND_SCALE`, `FORECAST_ONLY`.
         *
         * Usage:
         */
        predictiveMode?: string;
        /**
         * String, the source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
         */
        source: string;
        /**
         * String, the metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
         */
        statistic?: string;
        /**
         * The target number of instances to have in the group.
         */
        target: number;
        /**
         * String, tThe unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
         */
        unit?: string;
    }

    export interface ElastigroupScalingTargetPolicyDimension {
        /**
         * String, the dimension name.
         */
        name: string;
        /**
         * String, the dimension value.
         */
        value?: string;
    }

    export interface ElastigroupScalingUpPolicy {
        /**
         * The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`. If a `stepAdjustment` object is defined, then it cannot be specified.
         */
        actionType?: string;
        /**
         * The number of instances to add/remove to/from the target capacity when scale is needed. Can be used as advanced expression for scaling of instances to add/remove to/from the target capacity when scale is needed. You can see more information here: Advanced expression. Example value: `"MAX(currCapacity / 5, value * 10)"`
         */
        adjustment?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
         */
        cooldown?: number;
        /**
         * A list of dimensions describing qualities of the metric.
         */
        dimensions?: outputs.aws.ElastigroupScalingUpPolicyDimension[];
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods: number;
        /**
         * Specifies whether the scaling policy described in this block is enabled.
         */
        isEnabled?: boolean;
        maxTargetCapacity?: string;
        /**
         * The maximal number of instances to have in the group.
         */
        maximum?: string;
        /**
         * The name of the metric, with or without spaces.
         */
        metricName: string;
        /**
         * . The number of the desired target (and minimum) capacity
         */
        minTargetCapacity?: string;
        /**
         * The minimal number of instances to have in the group.
         */
        minimum?: string;
        /**
         * The namespace for the alarm's associated metric.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
         */
        operator: string;
        /**
         * The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
         */
        period: number;
        /**
         * The name of the policy.
         */
        policyName: string;
        /**
         * The source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
         */
        source: string;
        /**
         * The metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
         */
        statistic?: string;
        stepAdjustments?: outputs.aws.ElastigroupScalingUpPolicyStepAdjustment[];
        /**
         * The target number of instances to have in the group.
         */
        target?: string;
        /**
         * The value against which the specified statistic is compared. If a `stepAdjustment` object is defined, then it cannot be specified.
         */
        threshold?: number;
        /**
         * The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
         */
        unit?: string;
    }

    export interface ElastigroupScalingUpPolicyDimension {
        /**
         * The dimension name.
         */
        name: string;
        /**
         * The dimension value.
         */
        value?: string;
    }

    export interface ElastigroupScalingUpPolicyStepAdjustment {
        action: outputs.aws.ElastigroupScalingUpPolicyStepAdjustmentAction;
        threshold: number;
    }

    export interface ElastigroupScalingUpPolicyStepAdjustmentAction {
        adjustment?: string;
        maxTargetCapacity?: string;
        maximum?: string;
        minTargetCapacity?: string;
        minimum?: string;
        target?: string;
        type: string;
    }

    export interface ElastigroupScheduledTask {
        /**
         * The number of instances to add or remove.
         */
        adjustment?: string;
        /**
         * The percentage of instances to add or remove.
         *
         * Usage:
         */
        adjustmentPercentage?: string;
        /**
         * The percentage size of each batch in the scheduled deployment roll.
         */
        batchSizePercentage?: string;
        /**
         * A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
         */
        cronExpression?: string;
        /**
         * The recurrence frequency to run this task. Supported values are `"hourly"`, `"daily"`, `"weekly"` and `"continuous"`.
         */
        frequency?: string;
        /**
         * The period of time (seconds) to wait before checking a batch's health after it's deployment.
         */
        gracePeriod?: string;
        /**
         * Setting the task to being enabled or disabled.
         */
        isEnabled?: boolean;
        /**
         * The maximum number of instances the group should have.
         */
        maxCapacity?: string;
        /**
         * The minimum number of instances the group should have.
         */
        minCapacity?: string;
        /**
         * The maximum number of instances the group should have.
         */
        scaleMaxCapacity?: string;
        /**
         * The minimum number of instances the group should have.
         */
        scaleMinCapacity?: string;
        /**
         * The desired number of instances the group should have.
         */
        scaleTargetCapacity?: string;
        /**
         * Set a start time for one time tasks.
         */
        startTime?: string;
        /**
         * The desired number of instances the group should have.
         */
        targetCapacity?: string;
        /**
         * The task type to run. Supported task types are: `"scale"`, `"backupAmi"`, `"roll"`, `"scaleUp"`, `"percentageScaleUp"`, `"scaleDown"`, `"percentageScaleDown"`, `"statefulUpdateCapacity"`.
         */
        taskType: string;
    }

    export interface ElastigroupSignal {
        /**
         * The name of the signal defined for the group. Valid Values: `"INSTANCE_READY"`, `"INSTANCE_READY_TO_SHUTDOWN"`
         */
        name: string;
        /**
         * The signals defined timeout- default is 40 minutes (1800 seconds).
         *
         * Usage:
         */
        timeout?: number;
    }

    export interface ElastigroupStatefulDeallocation {
        shouldDeleteImages?: boolean;
        shouldDeleteNetworkInterfaces?: boolean;
        shouldDeleteSnapshots?: boolean;
        shouldDeleteVolumes?: boolean;
    }

    export interface ElastigroupStatefulInstanceAction {
        statefulInstanceId: string;
        type: string;
    }

    export interface ElastigroupTag {
        key?: string;
        value?: string;
    }

    export interface ElastigroupUpdatePolicy {
        autoApplyTags?: boolean;
        rollConfig?: outputs.aws.ElastigroupUpdatePolicyRollConfig;
        shouldResumeStateful: boolean;
        shouldRoll: boolean;
    }

    export interface ElastigroupUpdatePolicyRollConfig {
        batchSizePercentage: number;
        gracePeriod?: number;
        /**
         * The service that will perform health checks for the instance. Valid values: `"ELB"`, `"HCS"`, `"TARGET_GROUP"`, `"EC2"`, `"K8S_NODE"`, `"NOMAD_NODE"`, `"ECS_CLUSTER_INSTANCE"`.
         */
        healthCheckType?: string;
        strategy?: outputs.aws.ElastigroupUpdatePolicyRollConfigStrategy;
        waitForRollPercentage?: number;
        waitForRollTimeout?: number;
    }

    export interface ElastigroupUpdatePolicyRollConfigStrategy {
        action: string;
        batchMinHealthyPercentage?: number;
        onFailure?: outputs.aws.ElastigroupUpdatePolicyRollConfigStrategyOnFailure;
        shouldDrainInstances?: boolean;
    }

    export interface ElastigroupUpdatePolicyRollConfigStrategyOnFailure {
        actionType: string;
        batchNum?: number;
        /**
         * The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
         */
        drainingTimeout?: number;
        shouldDecrementTargetCapacity?: boolean;
        shouldHandleAllBatches?: boolean;
    }

    export interface ManagedInstanceBlockDeviceMapping {
        deviceName: string;
        ebs?: outputs.aws.ManagedInstanceBlockDeviceMappingEbs;
    }

    export interface ManagedInstanceBlockDeviceMappingEbs {
        deleteOnTermination: boolean;
        encrypted?: boolean;
        iops?: number;
        kmsKeyId?: string;
        snapshotId?: string;
        throughput?: number;
        volumeSize?: number;
        volumeType: string;
    }

    export interface ManagedInstanceDelete {
        amiBackupShouldDeleteImages?: boolean;
        deallocationConfigShouldDeleteImages?: boolean;
        shouldDeleteNetworkInterfaces?: boolean;
        shouldDeleteSnapshots?: boolean;
        shouldDeleteVolumes?: boolean;
        shouldTerminateInstance?: boolean;
    }

    export interface ManagedInstanceIntegrationRoute53 {
        domains: outputs.aws.ManagedInstanceIntegrationRoute53Domain[];
    }

    export interface ManagedInstanceIntegrationRoute53Domain {
        hostedZoneId: string;
        recordSetType?: string;
        recordSets: outputs.aws.ManagedInstanceIntegrationRoute53DomainRecordSet[];
        spotinstAcctId?: string;
    }

    export interface ManagedInstanceIntegrationRoute53DomainRecordSet {
        name: string;
        usePublicDns?: boolean;
        usePublicIp?: boolean;
    }

    export interface ManagedInstanceLoadBalancer {
        arn?: string;
        name?: string;
        type: string;
    }

    export interface ManagedInstanceManagedInstanceAction {
        type: string;
    }

    export interface ManagedInstanceNetworkInterface {
        associateIpv6Address?: boolean;
        associatePublicIpAddress?: boolean;
        deviceIndex: string;
    }

    export interface ManagedInstanceResourceTagSpecification {
        shouldTagAmis?: boolean;
        shouldTagEnis?: boolean;
        shouldTagSnapshots?: boolean;
        shouldTagVolumes?: boolean;
    }

    export interface ManagedInstanceRevertToSpot {
        performAt: string;
    }

    export interface ManagedInstanceScheduledTask {
        cronExpression?: string;
        frequency?: string;
        isEnabled?: boolean;
        startTime?: string;
        taskType: string;
    }

    export interface ManagedInstanceTag {
        key?: string;
        value?: string;
    }

    export interface MrScalarApplication {
        args?: string[];
        /**
         * The MrScaler name.
         */
        name: string;
        version?: string;
    }

    export interface MrScalarBootstrapActionsFile {
        bucket: string;
        key: string;
    }

    export interface MrScalarConfigurationsFile {
        bucket: string;
        key: string;
    }

    export interface MrScalarCoreEbsBlockDevice {
        iops?: number;
        sizeInGb: number;
        volumeType: string;
        volumesPerInstance?: number;
    }

    export interface MrScalarCoreScalingDownPolicy {
        actionType?: string;
        adjustment?: string;
        cooldown: number;
        dimensions?: {[key: string]: any};
        evaluationPeriods: number;
        maxTargetCapacity?: string;
        maximum?: string;
        metricName: string;
        minTargetCapacity?: string;
        minimum?: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        statistic: string;
        target?: string;
        threshold: number;
        unit: string;
    }

    export interface MrScalarCoreScalingUpPolicy {
        actionType?: string;
        adjustment?: string;
        cooldown: number;
        dimensions?: {[key: string]: any};
        evaluationPeriods: number;
        maxTargetCapacity?: string;
        maximum?: string;
        metricName: string;
        minTargetCapacity?: string;
        minimum?: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        statistic: string;
        target?: string;
        threshold: number;
        unit: string;
    }

    export interface MrScalarInstanceWeight {
        instanceType: string;
        weightedCapacity: number;
    }

    export interface MrScalarMasterEbsBlockDevice {
        iops?: number;
        sizeInGb: number;
        volumeType: string;
        volumesPerInstance?: number;
    }

    export interface MrScalarProvisioningTimeout {
        timeout: number;
        timeoutAction: string;
    }

    export interface MrScalarScheduledTask {
        cron: string;
        desiredCapacity?: string;
        instanceGroupType: string;
        isEnabled?: boolean;
        maxCapacity?: string;
        minCapacity?: string;
        taskType: string;
    }

    export interface MrScalarStepsFile {
        bucket: string;
        key: string;
    }

    export interface MrScalarTag {
        key: string;
        value: string;
    }

    export interface MrScalarTaskEbsBlockDevice {
        iops?: number;
        sizeInGb: number;
        volumeType: string;
        volumesPerInstance?: number;
    }

    export interface MrScalarTaskScalingDownPolicy {
        actionType?: string;
        adjustment?: string;
        cooldown: number;
        dimensions?: {[key: string]: any};
        evaluationPeriods: number;
        maxTargetCapacity?: string;
        maximum?: string;
        metricName: string;
        minTargetCapacity?: string;
        minimum?: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        statistic: string;
        target?: string;
        threshold: number;
        unit: string;
    }

    export interface MrScalarTaskScalingUpPolicy {
        actionType?: string;
        adjustment?: string;
        cooldown: number;
        dimensions?: {[key: string]: any};
        evaluationPeriods: number;
        maxTargetCapacity?: string;
        maximum?: string;
        metricName: string;
        minTargetCapacity?: string;
        minimum?: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        statistic: string;
        target?: string;
        threshold: number;
        unit: string;
    }

    export interface MrScalarTerminationPolicy {
        statements: outputs.aws.MrScalarTerminationPolicyStatement[];
    }

    export interface MrScalarTerminationPolicyStatement {
        evaluationPeriods?: number;
        metricName: string;
        namespace: string;
        operator?: string;
        period?: number;
        statistic?: string;
        threshold: number;
        unit?: string;
    }

    export interface OceanAutoscaler {
        autoHeadroomPercentage?: number;
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.aws.OceanAutoscalerAutoscaleDown;
        autoscaleHeadroom?: outputs.aws.OceanAutoscalerAutoscaleHeadroom;
        autoscaleIsAutoConfig?: boolean;
        autoscaleIsEnabled?: boolean;
        enableAutomaticAndManualHeadroom?: boolean;
        extendedResourceDefinitions?: string[];
        resourceLimits?: outputs.aws.OceanAutoscalerResourceLimits;
    }

    export interface OceanAutoscalerAutoscaleDown {
        evaluationPeriods?: number;
        isAggressiveScaleDownEnabled?: boolean;
        maxScaleDownPercentage?: number;
    }

    export interface OceanAutoscalerAutoscaleHeadroom {
        cpuPerUnit?: number;
        gpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface OceanAutoscalerResourceLimits {
        maxMemoryGib?: number;
        maxVcpu?: number;
    }

    export interface OceanBlockDeviceMapping {
        /**
         * String. Set device name. (Example: `/dev/xvda`).
         */
        deviceName?: string;
        /**
         * Object. Set Elastic Block Store properties .
         */
        ebs?: outputs.aws.OceanBlockDeviceMappingEbs;
    }

    export interface OceanBlockDeviceMappingEbs {
        deleteOnTermination: boolean;
        dynamicIops?: outputs.aws.OceanBlockDeviceMappingEbsDynamicIops;
        dynamicVolumeSize?: outputs.aws.OceanBlockDeviceMappingEbsDynamicVolumeSize;
        encrypted: boolean;
        iops?: number;
        kmsKeyId?: string;
        snapshotId?: string;
        throughput?: number;
        volumeSize?: number;
        volumeType: string;
    }

    export interface OceanBlockDeviceMappingEbsDynamicIops {
        baseSize: number;
        resource: string;
        sizePerResourceUnit: number;
    }

    export interface OceanBlockDeviceMappingEbsDynamicVolumeSize {
        baseSize: number;
        resource: string;
        sizePerResourceUnit: number;
    }

    export interface OceanClusterOrientation {
        /**
         * You can control the approach that Ocean takes while launching nodes by configuring this value. Possible values: `costOriented`,`balanced`,`cheapest`.
         */
        availabilityVsCost?: string;
    }

    export interface OceanFilters {
        architectures?: string[];
        categories?: string[];
        diskTypes?: string[];
        excludeFamilies?: string[];
        excludeMetal?: boolean;
        hypervisors?: string[];
        includeFamilies?: string[];
        isEnaSupported?: string;
        maxGpu?: number;
        maxMemoryGib?: number;
        maxNetworkPerformance?: number;
        maxVcpu?: number;
        minEnis?: number;
        minGpu?: number;
        minMemoryGib?: number;
        minNetworkPerformance?: number;
        minVcpu?: number;
        rootDeviceTypes?: string[];
        virtualizationTypes?: string[];
    }

    export interface OceanInstanceMetadataOptions {
        /**
         * An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
         */
        httpPutResponseHopLimit?: number;
        /**
         * Determines if a signed token is required or not. Valid values: `optional` or `required`.
         */
        httpTokens: string;
    }

    export interface OceanLaunchSpecAutoscaleDown {
        /**
         * The maximum percentage allowed to scale down in a single scaling action on the nodes running in a specific VNG. Allowed only if maxScaleDownPercentage is set to null at the cluster level. Number between [0.1-100].
         */
        maxScaleDownPercentage?: number;
    }

    export interface OceanLaunchSpecAutoscaleHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the number of GPUS to allocate for each headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecAutoscaleHeadroomsAutomatic {
        /**
         * Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.`isEnabled` = true is set on the Ocean cluster.
         */
        autoHeadroomPercentage?: number;
    }

    export interface OceanLaunchSpecBlockDeviceMapping {
        /**
         * String. Set device name. (Example: `/dev/xvda`).
         */
        deviceName?: string;
        /**
         * Object. Set Elastic Block Store properties .
         */
        ebs?: outputs.aws.OceanLaunchSpecBlockDeviceMappingEbs;
        /**
         * String. Suppresses the specified device included in the block device mapping of the AMI.
         */
        noDevice?: string;
        virtualName?: string;
    }

    export interface OceanLaunchSpecBlockDeviceMappingEbs {
        deleteOnTermination: boolean;
        dynamicVolumeSize?: outputs.aws.OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize;
        encrypted: boolean;
        iops?: number;
        kmsKeyId?: string;
        snapshotId?: string;
        throughput?: number;
        volumeSize?: number;
        volumeType: string;
    }

    export interface OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize {
        baseSize: number;
        resource: string;
        sizePerResourceUnit: number;
    }

    export interface OceanLaunchSpecCreateOptions {
        /**
         * When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group. The parameter is recommended in case the useAsTemplateOnly (in spotinst.aws.Ocean resource) is set to true during Ocean resource creation.
         */
        initialNodes?: number;
    }

    export interface OceanLaunchSpecDeleteOptions {
        /**
         * When set to "true", all instances belonging to the deleted launch specification will be drained, detached, and terminated.
         */
        deleteNodes?: boolean;
        /**
         * When set to `true`, delete even if it is the last Virtual Node Group (also, the default Virtual Node Group must be configured with `useAsTemlateOnly = true`). Should be set at creation or update, but will be used only at deletion.
         */
        forceDelete: boolean;
    }

    export interface OceanLaunchSpecElasticIpPool {
        /**
         * A key-value pair, which defines an Elastic IP from the customer pool. Can be null.
         */
        tagSelector?: outputs.aws.OceanLaunchSpecElasticIpPoolTagSelector;
    }

    export interface OceanLaunchSpecElasticIpPoolTagSelector {
        tagKey: string;
        tagValue?: string;
    }

    export interface OceanLaunchSpecEphemeralStorage {
        /**
         * Specify an alternative device name from which ephemeral storage calculations should be derived. This parameter is used when the ephemeral storage should not utilize the root device. Provide the device name configured in the VNG's BDM or AMI's BDM that differs from the default root device.
         *
         *
         * <a id="update-policy"></a>
         */
        ephemeralStorageDeviceName?: string;
    }

    export interface OceanLaunchSpecImage {
        /**
         * Identifier of the image in AWS. Valid values: any string which is not empty or null.
         */
        imageId?: string;
    }

    export interface OceanLaunchSpecInstanceMetadataOptions {
        /**
         * An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
         */
        httpPutResponseHopLimit?: number;
        /**
         * Determines if a signed token is required or not. Valid values: `optional` or `required`.
         */
        httpTokens: string;
    }

    export interface OceanLaunchSpecInstanceTypesFilters {
        /**
         * The filtered instance types will belong to one of the categories types from this list. Valid values: `Accelerated_computing`, `Compute_optimized`, `General_purpose`, `Memory_optimized`, `Storage_optimized`.
         */
        categories?: string[];
        /**
         * The filtered instance types will have one of the disk type from this list. Valid values: `NVMe`, `EBS`, `SSD`, `HDD`.
         */
        diskTypes?: string[];
        /**
         * Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
         */
        excludeFamilies?: string[];
        /**
         * In case excludeMetal is set to true, metal types will not be available for scaling.
         */
        excludeMetal?: boolean;
        /**
         * The filtered instance types will have a hypervisor type from this list. Valid values: `nitro`, `xen`.
         */
        hypervisors?: string[];
        /**
         * Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
         */
        includeFamilies?: string[];
        /**
         * Ena is supported or not.
         */
        isEnaSupported?: string;
        /**
         * Maximum total number of GPUs.
         */
        maxGpu?: number;
        /**
         * Maximum amount of Memory (GiB).
         */
        maxMemoryGib?: number;
        /**
         * Maximum Bandwidth in Gib/s of network performance.
         */
        maxNetworkPerformance?: number;
        /**
         * Maximum number of vcpus available.
         */
        maxVcpu?: number;
        /**
         * Minimum number of network interfaces (ENIs).
         */
        minEnis?: number;
        /**
         * Minimum total number of GPUs.
         */
        minGpu?: number;
        /**
         * Minimum amount of Memory (GiB).
         */
        minMemoryGib?: number;
        /**
         * Minimum Bandwidth in Gib/s of network performance.
         */
        minNetworkPerformance?: number;
        /**
         * Minimum number of vcpus available.
         */
        minVcpu?: number;
        /**
         * The filtered instance types will have a root device types from this list. Valid values: `ebs`, or `instance-store`.
         */
        rootDeviceTypes?: string[];
        /**
         * The filtered instance types will support at least one of the virtualization types from this list. Valid values: `hvm`, `paravirtual`.
         */
        virtualizationTypes?: string[];
    }

    export interface OceanLaunchSpecLabel {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface OceanLaunchSpecResourceLimit {
        /**
         * Set a maximum number of instances per Virtual Node Group. Can be null. If set, value must be greater than or equal to 0.
         */
        maxInstanceCount?: number;
        /**
         * Set a minimum number of instances per Virtual Node Group. Can be null. If set, value must be greater than or equal to 0.
         */
        minInstanceCount?: number;
    }

    export interface OceanLaunchSpecSchedulingShutdownHours {
        /**
         * Flag to enable or disable the shutdown hours mechanism. When False, the mechanism is deactivated, and the virtual node group remains in its current state.
         */
        isEnabled?: boolean;
        /**
         * The times that the shutdown hours will apply.
         */
        timeWindows: string[];
    }

    export interface OceanLaunchSpecSchedulingTask {
        /**
         * A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
         */
        cronExpression: string;
        /**
         * Describes whether the task is enabled. When True, the task runs. When False, it does not run.
         */
        isEnabled: boolean;
        /**
         * The config of this scheduled task. Depends on the value of taskType.
         */
        taskHeadrooms?: outputs.aws.OceanLaunchSpecSchedulingTaskTaskHeadroom[];
        /**
         * The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
         */
        taskType: string;
    }

    export interface OceanLaunchSpecSchedulingTaskTaskHeadroom {
        cpuPerUnit?: number;
        gpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits: number;
    }

    export interface OceanLaunchSpecStrategy {
        /**
         * The desired percentage of the Spot instances out of all running instances for this VNG. Only available when the field is not set in the cluster directly (cluster.strategy.spotPercentage).
         */
        spotPercentage?: number;
    }

    export interface OceanLaunchSpecTag {
        key: string;
        value: string;
    }

    export interface OceanLaunchSpecTaint {
        /**
         * The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
         */
        effect: string;
        /**
         * The taint key.
         */
        key: string;
        /**
         * The taint value.
         */
        value: string;
    }

    export interface OceanLaunchSpecUpdatePolicy {
        rollConfig?: outputs.aws.OceanLaunchSpecUpdatePolicyRollConfig;
        shouldRoll: boolean;
    }

    export interface OceanLaunchSpecUpdatePolicyRollConfig {
        batchSizePercentage: number;
    }

    export interface OceanLoadBalancer {
        /**
         * Required if type is set to `TARGET_GROUP`
         */
        arn?: string;
        /**
         * Required if type is set to `CLASSIC`
         */
        name?: string;
        /**
         * Can be set to `CLASSIC` or `TARGET_GROUP`
         */
        type?: string;
    }

    export interface OceanLogging {
        /**
         * Logging Export configuration.
         */
        export?: outputs.aws.OceanLoggingExport;
    }

    export interface OceanLoggingExport {
        s3s?: outputs.aws.OceanLoggingExportS3[];
    }

    export interface OceanLoggingExportS3 {
        /**
         * The Cluster ID.
         */
        id: string;
    }

    export interface OceanResourceTagSpecification {
        /**
         * Specify if Volume resources will be tagged with Virtual Node Group tags or Ocean tags.
         */
        shouldTagVolumes?: boolean;
    }

    export interface OceanScheduledTask {
        shutdownHours?: outputs.aws.OceanScheduledTaskShutdownHours;
        tasks?: outputs.aws.OceanScheduledTaskTask[];
    }

    export interface OceanScheduledTaskShutdownHours {
        isEnabled?: boolean;
        timeWindows: string[];
    }

    export interface OceanScheduledTaskTask {
        cronExpression: string;
        isEnabled: boolean;
        parameters?: outputs.aws.OceanScheduledTaskTaskParameters;
        taskType: string;
    }

    export interface OceanScheduledTaskTaskParameters {
        amiAutoUpdate?: outputs.aws.OceanScheduledTaskTaskParametersAmiAutoUpdate;
        parametersClusterRoll?: outputs.aws.OceanScheduledTaskTaskParametersParametersClusterRoll;
    }

    export interface OceanScheduledTaskTaskParametersAmiAutoUpdate {
        amiAutoUpdateClusterRoll?: outputs.aws.OceanScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRoll;
        applyRoll?: boolean;
        minorVersion?: boolean;
        patch?: boolean;
    }

    export interface OceanScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRoll {
        batchMinHealthyPercentage?: number;
        batchSizePercentage?: number;
        comment?: string;
        respectPdb?: boolean;
    }

    export interface OceanScheduledTaskTaskParametersParametersClusterRoll {
        batchMinHealthyPercentage?: number;
        batchSizePercentage?: number;
        comment?: string;
        respectPdb?: boolean;
    }

    export interface OceanTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface OceanUpdatePolicy {
        autoApplyTags?: boolean;
        conditionedRoll?: boolean;
        conditionedRollParams?: string[];
        rollConfig?: outputs.aws.OceanUpdatePolicyRollConfig;
        shouldRoll: boolean;
    }

    export interface OceanUpdatePolicyRollConfig {
        batchMinHealthyPercentage?: number;
        batchSizePercentage: number;
        launchSpecIds?: string[];
        respectPdb?: boolean;
    }

    export interface SuspensionSuspension {
        /**
         * The name of process to suspend. Valid values: `"AUTO_HEALING" , "OUT_OF_STRATEGY", "PREVENTIVE_REPLACEMENT", "REVERT_PREFERRED", or "SCHEDULING"`.
         */
        name: string;
    }

}

export namespace azure {
    export interface ElastigroupHealthCheck {
        autoHealing?: boolean;
        gracePeriod?: number;
        healthCheckType: string;
    }

    export interface ElastigroupImage {
        customs?: outputs.azure.ElastigroupImageCustom[];
        marketplaces?: outputs.azure.ElastigroupImageMarketplace[];
    }

    export interface ElastigroupImageCustom {
        imageName: string;
        /**
         * Name of the Resource Group for Elastigroup.
         */
        resourceGroupName: string;
    }

    export interface ElastigroupImageMarketplace {
        offer: string;
        publisher: string;
        sku: string;
    }

    export interface ElastigroupIntegrationKubernetes {
        clusterIdentifier: string;
    }

    export interface ElastigroupIntegrationMultaiRuntime {
        deploymentId: string;
    }

    export interface ElastigroupLoadBalancer {
        autoWeight?: boolean;
        balancerId?: string;
        targetSetId?: string;
        type: string;
    }

    export interface ElastigroupLogin {
        password?: string;
        sshPublicKey?: string;
        userName: string;
    }

    export interface ElastigroupManagedServiceIdentity {
        /**
         * The group name.
         */
        name: string;
        /**
         * Name of the Resource Group for Elastigroup.
         */
        resourceGroupName: string;
    }

    export interface ElastigroupNetwork {
        additionalIpConfigs?: outputs.azure.ElastigroupNetworkAdditionalIpConfig[];
        assignPublicIp?: boolean;
        /**
         * Name of the Resource Group for Elastigroup.
         */
        resourceGroupName: string;
        subnetName: string;
        virtualNetworkName: string;
    }

    export interface ElastigroupNetworkAdditionalIpConfig {
        /**
         * The group name.
         */
        name: string;
        privateIpVersion?: string;
    }

    export interface ElastigroupScalingDownPolicy {
        actionType?: string;
        adjustment?: string;
        cooldown: number;
        dimensions?: outputs.azure.ElastigroupScalingDownPolicyDimension[];
        evaluationPeriods: number;
        maxTargetCapacity?: string;
        maximum?: string;
        metricName: string;
        minTargetCapacity?: string;
        minimum?: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        statistic: string;
        target?: string;
        threshold: number;
        unit?: string;
    }

    export interface ElastigroupScalingDownPolicyDimension {
        /**
         * The group name.
         */
        name: string;
        value?: string;
    }

    export interface ElastigroupScalingUpPolicy {
        actionType?: string;
        adjustment?: string;
        cooldown: number;
        dimensions?: outputs.azure.ElastigroupScalingUpPolicyDimension[];
        evaluationPeriods: number;
        maxTargetCapacity?: string;
        maximum?: string;
        metricName: string;
        minTargetCapacity?: string;
        minimum?: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        statistic: string;
        target?: string;
        threshold: number;
        unit?: string;
    }

    export interface ElastigroupScalingUpPolicyDimension {
        /**
         * The group name.
         */
        name: string;
        value?: string;
    }

    export interface ElastigroupScheduledTask {
        adjustment?: string;
        adjustmentPercentage?: string;
        batchSizePercentage?: string;
        cronExpression: string;
        gracePeriod?: string;
        isEnabled?: boolean;
        scaleMaxCapacity?: string;
        scaleMinCapacity?: string;
        scaleTargetCapacity?: string;
        taskType: string;
    }

    export interface ElastigroupStrategy {
        drainingTimeout?: number;
        lowPriorityPercentage?: number;
        odCount?: number;
    }

    export interface ElastigroupUpdatePolicy {
        rollConfig?: outputs.azure.ElastigroupUpdatePolicyRollConfig;
        shouldRoll: boolean;
    }

    export interface ElastigroupUpdatePolicyRollConfig {
        batchSizePercentage: number;
        gracePeriod?: number;
        healthCheckType?: string;
    }

    export interface OceanAutoscaler {
        /**
         * Auto Scaling scale down operations.
         */
        autoscaleDown: outputs.azure.OceanAutoscalerAutoscaleDown;
        /**
         * Spare Resource Capacity Management feature enables fast assignment of Pods without having to wait for new resources to be launched.
         */
        autoscaleHeadroom: outputs.azure.OceanAutoscalerAutoscaleHeadroom;
        /**
         * Enable the Ocean Kubernetes Autoscaler.
         */
        autoscaleIsEnabled: boolean;
        /**
         * Optionally set upper and lower bounds on the resource usage of the cluster.
         */
        resourceLimits: outputs.azure.OceanAutoscalerResourceLimits;
    }

    export interface OceanAutoscalerAutoscaleDown {
        maxScaleDownPercentage: number;
    }

    export interface OceanAutoscalerAutoscaleHeadroom {
        automatic: outputs.azure.OceanAutoscalerAutoscaleHeadroomAutomatic;
    }

    export interface OceanAutoscalerAutoscaleHeadroomAutomatic {
        isEnabled: boolean;
        percentage: number;
    }

    export interface OceanAutoscalerResourceLimits {
        maxMemoryGib: number;
        maxVcpu?: number;
    }

    export interface OceanExtension {
        /**
         * API version of the extension.
         */
        apiVersion: string;
        /**
         * Toggles whether auto upgrades are allowed.
         */
        minorVersionAutoUpgrade: boolean;
        /**
         * Extension name.
         */
        name: string;
        publisher: string;
        /**
         * Extension type.
         */
        type: string;
    }

    export interface OceanHealth {
        /**
         * The amount of time to wait, in seconds, from the moment the instance has launched before monitoring its health checks.
         */
        gracePeriod?: number;
    }

    export interface OceanImage {
        /**
         * Select an image from Azure's Marketplace image catalogue.
         */
        marketplaces: outputs.azure.OceanImageMarketplace[];
    }

    export interface OceanImageMarketplace {
        offer: string;
        publisher: string;
        sku: string;
        version: string;
    }

    export interface OceanLoadBalancer {
        /**
         * Names of the Backend Pools to register the Cluster VMs to. Each Backend Pool is a separate load balancer.
         */
        backendPoolNames: string[];
        /**
         * Supported values: `Standard`, `Basic`.
         */
        loadBalancerSku: string;
        /**
         * Name of the Load Balancer.
         */
        name: string;
        /**
         * The Resource Group name of the Load Balancer.
         */
        resourceGroupName: string;
        /**
         * The type of load balancer. Supported value: `loadBalancer`
         */
        type: string;
    }

    export interface OceanManagedServiceIdentity {
        /**
         * Name of the Managed Service Identity.
         */
        name: string;
        /**
         * Name of the Azure Resource Group where the Managed Service Identity is located.
         */
        resourceGroupName: string;
    }

    export interface OceanNetwork {
        /**
         * A list of virtual network interfaces. The publicIpSku must be identical between all the network interfaces. One network interface must be set as the primary.
         */
        networkInterfaces: outputs.azure.OceanNetworkNetworkInterface[];
        /**
         * Vnet resource group name.
         */
        resourceGroupName: string;
        /**
         * Virtual network.
         */
        virtualNetworkName: string;
    }

    export interface OceanNetworkNetworkInterface {
        additionalIpConfigs: outputs.azure.OceanNetworkNetworkInterfaceAdditionalIpConfig[];
        assignPublicIp: boolean;
        isPrimary: boolean;
        securityGroup: outputs.azure.OceanNetworkNetworkInterfaceSecurityGroup;
        subnetName: string;
    }

    export interface OceanNetworkNetworkInterfaceAdditionalIpConfig {
        /**
         * The Ocean cluster name.
         */
        name: string;
        privateIpVersion: string;
    }

    export interface OceanNetworkNetworkInterfaceSecurityGroup {
        /**
         * The Ocean cluster name.
         */
        name: string;
        /**
         * Name of the Azure Resource Group into which VMs will be launched. Cannot be updated.
         */
        resourceGroupName: string;
    }

    export interface OceanNpAutoscaler {
        autoscaleDown?: outputs.azure.OceanNpAutoscalerAutoscaleDown;
        autoscaleHeadroom?: outputs.azure.OceanNpAutoscalerAutoscaleHeadroom;
        autoscaleIsEnabled?: boolean;
        resourceLimits?: outputs.azure.OceanNpAutoscalerResourceLimits;
    }

    export interface OceanNpAutoscalerAutoscaleDown {
        maxScaleDownPercentage?: number;
    }

    export interface OceanNpAutoscalerAutoscaleHeadroom {
        automatic?: outputs.azure.OceanNpAutoscalerAutoscaleHeadroomAutomatic;
    }

    export interface OceanNpAutoscalerAutoscaleHeadroomAutomatic {
        isEnabled?: boolean;
        percentage?: number;
    }

    export interface OceanNpAutoscalerResourceLimits {
        maxMemoryGib?: number;
        maxVcpu?: number;
    }

    export interface OceanNpFilters {
        acceleratedNetworking?: string;
        architectures?: string[];
        diskPerformance?: string;
        excludeSeries?: string[];
        gpuTypes?: string[];
        maxGpu?: number;
        maxMemoryGib?: number;
        maxVcpu?: number;
        minDisk?: number;
        minGpu?: number;
        minMemoryGib?: number;
        minNics?: number;
        minVcpu?: number;
        series?: string[];
        vmTypes?: string[];
    }

    export interface OceanNpHeadroom {
        cpuPerUnit?: number;
        gpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface OceanNpHealth {
        gracePeriod?: number;
    }

    export interface OceanNpScheduling {
        shutdownHours?: outputs.azure.OceanNpSchedulingShutdownHours;
    }

    export interface OceanNpSchedulingShutdownHours {
        isEnabled?: boolean;
        timeWindows: string[];
    }

    export interface OceanNpTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface OceanNpUpdatePolicy {
        conditionedRoll?: boolean;
        rollConfig?: outputs.azure.OceanNpUpdatePolicyRollConfig;
        shouldRoll: boolean;
    }

    export interface OceanNpUpdatePolicyRollConfig {
        batchMinHealthyPercentage?: number;
        batchSizePercentage?: number;
        comment?: string;
        nodeNames?: string[];
        nodePoolNames?: string[];
        respectPdb?: boolean;
        respectRestrictScaleDown?: boolean;
        vngIds?: string[];
    }

    export interface OceanNpVirtualNodeGroupFilters {
        acceleratedNetworking?: string;
        architectures?: string[];
        diskPerformance?: string;
        excludeSeries?: string[];
        gpuTypes?: string[];
        maxGpu?: number;
        maxMemoryGib?: number;
        maxVcpu?: number;
        minDisk?: number;
        minGpu?: number;
        minMemoryGib?: number;
        minNics?: number;
        minVcpu?: number;
        series?: string[];
        vmTypes?: string[];
    }

    export interface OceanNpVirtualNodeGroupHeadroom {
        cpuPerUnit?: number;
        gpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface OceanNpVirtualNodeGroupTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface OceanNpVirtualNodeGroupUpdatePolicy {
        conditionedRoll?: boolean;
        rollConfig?: outputs.azure.OceanNpVirtualNodeGroupUpdatePolicyRollConfig;
        shouldRoll: boolean;
    }

    export interface OceanNpVirtualNodeGroupUpdatePolicyRollConfig {
        batchMinHealthyPercentage?: number;
        batchSizePercentage?: number;
        comment?: string;
        nodeNames?: string[];
        nodePoolNames?: string[];
        respectPdb?: boolean;
        respectRestrictScaleDown?: boolean;
        vngIds?: string[];
    }

    export interface OceanOsDisk {
        /**
         * The size of the OS disk in GB.
         */
        sizeGb: number;
        /**
         * The type of the OS disk. Supported values: `Standard_LRS`, `Premium_LRS`, `StandardSSD_LRS`.
         */
        type?: string;
    }

    export interface OceanStrategy {
        /**
         * If no spot instance markets are available, enable Ocean to launch on-demand instances instead.
         */
        fallbackToOndemand?: boolean;
        /**
         * Percentage of Spot VMs to maintain.
         */
        spotPercentage?: number;
    }

    export interface OceanTag {
        /**
         * Tag key.
         */
        key?: string;
        /**
         * Tag value.
         */
        value?: string;
    }

    export interface OceanVirtualNodeGroupAutoscale {
        /**
         * Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when `cluster.autoScaler.headroom.automatic.is_enabled` = true is set on the Ocean cluster.
         */
        autoHeadroomPercentage?: number;
        autoscaleHeadrooms?: outputs.azure.OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom[];
    }

    export interface OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom {
        cpuPerUnit?: number;
        gpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits: number;
    }

    export interface OceanVirtualNodeGroupLabel {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value?: string;
    }

    export interface OceanVirtualNodeGroupLaunchSpecification {
        /**
         * The maximum number of pods per node in an AKS cluster.
         */
        maxPods?: number;
        /**
         * Specify OS disk specification other than default.
         */
        osDisk?: outputs.azure.OceanVirtualNodeGroupLaunchSpecificationOsDisk;
        /**
         * Additional key-value pairs to be used to tag the VMs in the virtual node group.
         */
        tags?: outputs.azure.OceanVirtualNodeGroupLaunchSpecificationTag[];
    }

    export interface OceanVirtualNodeGroupLaunchSpecificationOsDisk {
        sizeGb: number;
        type?: string;
        utilizeEphemeralStorage?: boolean;
    }

    export interface OceanVirtualNodeGroupLaunchSpecificationTag {
        key?: string;
        value?: string;
    }

    export interface OceanVirtualNodeGroupResourceLimit {
        /**
         * Option to set a maximum number of instances per virtual node group. If set, value must be greater than or equal to 0.
         */
        maxInstanceCount?: number;
    }

    export interface OceanVirtualNodeGroupTaint {
        /**
         * The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`, `"PreferNoExecute"`.
         */
        effect: string;
        /**
         * The taint key.
         */
        key: string;
        /**
         * The taint value.
         */
        value: string;
    }

    export interface OceanVmSize {
        /**
         * VM types allowed in the Ocean cluster.
         */
        whitelists?: string[];
    }

}

export namespace ecs {
    export interface OceanAutoscaler {
        autoHeadroomPercentage?: number;
        cooldown?: number;
        down?: outputs.ecs.OceanAutoscalerDown;
        enableAutomaticAndManualHeadroom?: boolean;
        headroom?: outputs.ecs.OceanAutoscalerHeadroom;
        isAutoConfig?: boolean;
        isEnabled?: boolean;
        resourceLimits?: outputs.ecs.OceanAutoscalerResourceLimits;
        shouldScaleDownNonServiceTasks?: boolean;
    }

    export interface OceanAutoscalerDown {
        maxScaleDownPercentage?: number;
    }

    export interface OceanAutoscalerHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface OceanAutoscalerResourceLimits {
        maxMemoryGib?: number;
        maxVcpu?: number;
    }

    export interface OceanBlockDeviceMapping {
        deviceName: string;
        ebs?: outputs.ecs.OceanBlockDeviceMappingEbs;
        noDevice?: string;
        virtualName?: string;
    }

    export interface OceanBlockDeviceMappingEbs {
        deleteOnTermination: boolean;
        dynamicVolumeSize?: outputs.ecs.OceanBlockDeviceMappingEbsDynamicVolumeSize;
        encrypted: boolean;
        iops?: number;
        kmsKeyId?: string;
        snapshotId?: string;
        throughput?: number;
        volumeSize?: number;
        volumeType: string;
    }

    export interface OceanBlockDeviceMappingEbsDynamicVolumeSize {
        baseSize: number;
        resource: string;
        sizePerResourceUnit: number;
    }

    export interface OceanClusterOrientation {
        /**
         * You can control the approach that Ocean takes while launching nodes by configuring this value. Possible values: `costOriented`,`balanced`,`cheapest`.
         */
        availabilityVsCost?: string;
    }

    export interface OceanFilters {
        architectures?: string[];
        categories?: string[];
        diskTypes?: string[];
        excludeFamilies?: string[];
        excludeMetal?: boolean;
        hypervisors?: string[];
        includeFamilies?: string[];
        isEnaSupported?: string;
        maxGpu?: number;
        maxMemoryGib?: number;
        maxNetworkPerformance?: number;
        maxVcpu?: number;
        minEnis?: number;
        minGpu?: number;
        minMemoryGib?: number;
        minNetworkPerformance?: number;
        minVcpu?: number;
        rootDeviceTypes?: string[];
        virtualizationTypes?: string[];
    }

    export interface OceanInstanceMetadataOptions {
        /**
         * An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
         */
        httpPutResponseHopLimit?: number;
        /**
         * Determines if a signed token is required or not. Valid values: `optional` or `required`.
         */
        httpTokens: string;
    }

    export interface OceanLaunchSpecAttribute {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface OceanLaunchSpecAutoscaleHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in CPU units, where 1024 units = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecBlockDeviceMapping {
        deviceName: string;
        ebs?: outputs.ecs.OceanLaunchSpecBlockDeviceMappingEbs;
        noDevice?: string;
        virtualName?: string;
    }

    export interface OceanLaunchSpecBlockDeviceMappingEbs {
        deleteOnTermination: boolean;
        dynamicVolumeSize?: outputs.ecs.OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize;
        encrypted: boolean;
        iops?: number;
        kmsKeyId?: string;
        snapshotId?: string;
        throughput?: number;
        volumeSize?: number;
        volumeType: string;
    }

    export interface OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize {
        baseSize: number;
        resource: string;
        sizePerResourceUnit: number;
    }

    export interface OceanLaunchSpecImage {
        /**
         * Identifier of the image in AWS. Valid values: any string which is not empty or null.
         */
        imageId?: string;
    }

    export interface OceanLaunchSpecInstanceMetadataOptions {
        /**
         * An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
         */
        httpPutResponseHopLimit?: number;
        /**
         * Determines if a signed token is required or not. Valid values: `optional` or `required`.
         */
        httpTokens: string;
    }

    export interface OceanLaunchSpecSchedulingTask {
        /**
         * A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
         */
        cronExpression: string;
        /**
         * Describes whether the task is enabled. When True, the task runs. When False, it does not run.
         */
        isEnabled: boolean;
        /**
         * The config of this scheduled task. Depends on the value of taskType.
         */
        taskHeadrooms?: outputs.ecs.OceanLaunchSpecSchedulingTaskTaskHeadroom[];
        /**
         * The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
         */
        taskType: string;
    }

    export interface OceanLaunchSpecSchedulingTaskTaskHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits: number;
    }

    export interface OceanLaunchSpecStrategy {
        /**
         * When set, Ocean will proactively try to maintain as close as possible to the percentage of Spot instances out of all the Virtual Node Group instances.
         *
         * <a id="block-devices"></a>
         */
        spotPercentage?: number;
    }

    export interface OceanLaunchSpecTag {
        key: string;
        value: string;
    }

    export interface OceanLogging {
        /**
         * Logging Export configuration.
         */
        export?: outputs.ecs.OceanLoggingExport;
    }

    export interface OceanLoggingExport {
        s3s?: outputs.ecs.OceanLoggingExportS3[];
    }

    export interface OceanLoggingExportS3 {
        /**
         * The Spotinst Ocean ID.
         */
        id: string;
    }

    export interface OceanOptimizeImages {
        performAt: string;
        shouldOptimizeEcsAmi: boolean;
        timeWindows?: string[];
    }

    export interface OceanScheduledTask {
        shutdownHours?: outputs.ecs.OceanScheduledTaskShutdownHours;
        tasks?: outputs.ecs.OceanScheduledTaskTask[];
    }

    export interface OceanScheduledTaskShutdownHours {
        isEnabled?: boolean;
        timeWindows: string[];
    }

    export interface OceanScheduledTaskTask {
        cronExpression: string;
        isEnabled: boolean;
        taskType: string;
    }

    export interface OceanTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface OceanUpdatePolicy {
        autoApplyTags?: boolean;
        conditionedRoll?: boolean;
        rollConfig?: outputs.ecs.OceanUpdatePolicyRollConfig;
        shouldRoll: boolean;
    }

    export interface OceanUpdatePolicyRollConfig {
        batchMinHealthyPercentage?: number;
        batchSizePercentage: number;
    }

}

export namespace gcp {
    export interface ElastigroupBackendService {
        locationType?: string;
        namedPorts?: outputs.gcp.ElastigroupBackendServiceNamedPort[];
        scheme?: string;
        serviceName: string;
    }

    export interface ElastigroupBackendServiceNamedPort {
        /**
         * The group name.
         */
        name: string;
        ports: string[];
    }

    export interface ElastigroupDisk {
        autoDelete?: boolean;
        boot?: boolean;
        deviceName?: string;
        initializeParams?: outputs.gcp.ElastigroupDiskInitializeParam[];
        interface?: string;
        mode?: string;
        source?: string;
        type?: string;
    }

    export interface ElastigroupDiskInitializeParam {
        diskSizeGb?: string;
        diskType?: string;
        sourceImage: string;
    }

    export interface ElastigroupGpu {
        count: number;
        type: string;
    }

    export interface ElastigroupInstanceTypesCustom {
        /**
         * The memory (in GiB) in the custom instance types. GCP has a number of limitations on accepted memory values.For more information, see the GCP documentation (here.)[https://cloud.google.com/compute/docs/instances/creating-instance-with-custom-machine-type#specifications]
         */
        memoryGib: number;
        vcpu: number;
    }

    export interface ElastigroupIntegrationDockerSwarm {
        masterHost: string;
        masterPort: number;
    }

    export interface ElastigroupIntegrationGke {
        autoUpdate?: boolean;
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.gcp.ElastigroupIntegrationGkeAutoscaleDown;
        autoscaleHeadroom?: outputs.gcp.ElastigroupIntegrationGkeAutoscaleHeadroom;
        autoscaleIsAutoConfig?: boolean;
        autoscaleIsEnabled?: boolean;
        autoscaleLabels?: outputs.gcp.ElastigroupIntegrationGkeAutoscaleLabel[];
        clusterId?: string;
        location?: string;
    }

    export interface ElastigroupIntegrationGkeAutoscaleDown {
        evaluationPeriods?: number;
    }

    export interface ElastigroupIntegrationGkeAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationGkeAutoscaleLabel {
        key: string;
        value: string;
    }

    export interface ElastigroupLabel {
        /**
         * Labels key.
         */
        key: string;
        /**
         * Labels value.
         */
        value: string;
    }

    export interface ElastigroupMetadata {
        /**
         * Metadata key.
         */
        key: string;
        /**
         * Metadata value.
         */
        value: string;
    }

    export interface ElastigroupNetworkInterface {
        accessConfigs?: outputs.gcp.ElastigroupNetworkInterfaceAccessConfig[];
        aliasIpRanges?: outputs.gcp.ElastigroupNetworkInterfaceAliasIpRange[];
        network: string;
    }

    export interface ElastigroupNetworkInterfaceAccessConfig {
        /**
         * The group name.
         */
        name?: string;
        type?: string;
    }

    export interface ElastigroupNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName: string;
    }

    export interface ElastigroupScalingDownPolicy {
        actionType?: string;
        adjustment?: number;
        cooldown: number;
        dimensions?: outputs.gcp.ElastigroupScalingDownPolicyDimension[];
        evaluationPeriods: number;
        metricName: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        source: string;
        statistic: string;
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingDownPolicyDimension {
        /**
         * The group name.
         */
        name: string;
        value?: string;
    }

    export interface ElastigroupScalingUpPolicy {
        actionType?: string;
        adjustment?: number;
        cooldown: number;
        dimensions?: outputs.gcp.ElastigroupScalingUpPolicyDimension[];
        evaluationPeriods: number;
        metricName: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        source: string;
        statistic: string;
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingUpPolicyDimension {
        /**
         * The group name.
         */
        name: string;
        value?: string;
    }

    export interface ElastigroupScheduledTask {
        /**
         * A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
         */
        cronExpression?: string;
        /**
         * Setting the task to being enabled or disabled.
         */
        isEnabled?: boolean;
        /**
         * The maximum number of instances the group should have.
         *
         * Usage:
         */
        maxCapacity?: string;
        /**
         * The minimum number of instances the group should have.
         */
        minCapacity?: string;
        /**
         * The desired number of instances the group should have.
         */
        targetCapacity?: string;
        /**
         * The task type to run. Valid values: `"setCapacity"`.
         */
        taskType: string;
    }

    export interface ElastigroupSubnet {
        /**
         * The region for the group of subnets.
         */
        region: string;
        /**
         * The names of the subnets in the region.
         */
        subnetNames: string[];
    }

}

export namespace gke {
    export interface ElastigroupBackendService {
        locationType?: string;
        namedPorts?: outputs.gke.ElastigroupBackendServiceNamedPort[];
        scheme?: string;
        serviceName: string;
    }

    export interface ElastigroupBackendServiceNamedPort {
        name: string;
        ports: string[];
    }

    export interface ElastigroupDisk {
        autoDelete?: boolean;
        boot?: boolean;
        deviceName?: string;
        initializeParams?: outputs.gke.ElastigroupDiskInitializeParam[];
        interface?: string;
        mode?: string;
        source?: string;
        type?: string;
    }

    export interface ElastigroupDiskInitializeParam {
        diskSizeGb?: string;
        diskType?: string;
        sourceImage: string;
    }

    export interface ElastigroupGpu {
        count: number;
        type: string;
    }

    export interface ElastigroupInstanceTypesCustom {
        memoryGib: number;
        vcpu: number;
    }

    export interface ElastigroupIntegrationDockerSwarm {
        masterHost: string;
        masterPort: number;
    }

    export interface ElastigroupIntegrationGke {
        autoUpdate?: boolean;
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.gke.ElastigroupIntegrationGkeAutoscaleDown;
        autoscaleHeadroom?: outputs.gke.ElastigroupIntegrationGkeAutoscaleHeadroom;
        autoscaleIsAutoConfig?: boolean;
        autoscaleIsEnabled?: boolean;
        autoscaleLabels?: outputs.gke.ElastigroupIntegrationGkeAutoscaleLabel[];
        clusterId?: string;
        location?: string;
    }

    export interface ElastigroupIntegrationGkeAutoscaleDown {
        evaluationPeriods?: number;
    }

    export interface ElastigroupIntegrationGkeAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationGkeAutoscaleLabel {
        key: string;
        value: string;
    }

    export interface ElastigroupLabel {
        key: string;
        value: string;
    }

    export interface ElastigroupMetadata {
        key: string;
        value: string;
    }

    export interface ElastigroupNetworkInterface {
        accessConfigs?: outputs.gke.ElastigroupNetworkInterfaceAccessConfig[];
        aliasIpRanges?: outputs.gke.ElastigroupNetworkInterfaceAliasIpRange[];
        network: string;
    }

    export interface ElastigroupNetworkInterfaceAccessConfig {
        name?: string;
        type?: string;
    }

    export interface ElastigroupNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName: string;
    }

    export interface ElastigroupScalingDownPolicy {
        actionType?: string;
        adjustment?: number;
        cooldown: number;
        dimensions?: outputs.gke.ElastigroupScalingDownPolicyDimension[];
        evaluationPeriods: number;
        metricName: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        source: string;
        statistic: string;
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingDownPolicyDimension {
        name: string;
        value?: string;
    }

    export interface ElastigroupScalingUpPolicy {
        actionType?: string;
        adjustment?: number;
        cooldown: number;
        dimensions?: outputs.gke.ElastigroupScalingUpPolicyDimension[];
        evaluationPeriods: number;
        metricName: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        source: string;
        statistic: string;
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingUpPolicyDimension {
        name: string;
        value?: string;
    }

    export interface OceanImportAutoscaler {
        autoHeadroomPercentage?: number;
        cooldown?: number;
        down?: outputs.gke.OceanImportAutoscalerDown;
        enableAutomaticAndManualHeadroom?: boolean;
        headroom?: outputs.gke.OceanImportAutoscalerHeadroom;
        isAutoConfig?: boolean;
        isEnabled?: boolean;
        resourceLimits?: outputs.gke.OceanImportAutoscalerResourceLimits;
    }

    export interface OceanImportAutoscalerDown {
        evaluationPeriods?: number;
        maxScaleDownPercentage?: number;
    }

    export interface OceanImportAutoscalerHeadroom {
        cpuPerUnit?: number;
        gpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface OceanImportAutoscalerResourceLimits {
        maxMemoryGib?: number;
        maxVcpu?: number;
    }

    export interface OceanImportBackendService {
        /**
         * Sets which location the backend services will be active. Valid values: `regional`, `global`.
         */
        locationType?: string;
        namedPorts?: outputs.gke.OceanImportBackendServiceNamedPort[];
        /**
         * Use when `locationType` is `regional`. Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: `INTERNAL`, `EXTERNAL`.
         */
        scheme?: string;
        /**
         * The name of the backend service.
         */
        serviceName: string;
    }

    export interface OceanImportBackendServiceNamedPort {
        name: string;
        ports: string[];
    }

    export interface OceanImportScheduledTask {
        shutdownHours?: outputs.gke.OceanImportScheduledTaskShutdownHours;
        tasks?: outputs.gke.OceanImportScheduledTaskTask[];
    }

    export interface OceanImportScheduledTaskShutdownHours {
        isEnabled?: boolean;
        timeWindows: string[];
    }

    export interface OceanImportScheduledTaskTask {
        cronExpression: string;
        isEnabled: boolean;
        taskParameters?: outputs.gke.OceanImportScheduledTaskTaskTaskParameters;
        taskType: string;
    }

    export interface OceanImportScheduledTaskTaskTaskParameters {
        clusterRoll?: outputs.gke.OceanImportScheduledTaskTaskTaskParametersClusterRoll;
    }

    export interface OceanImportScheduledTaskTaskTaskParametersClusterRoll {
        batchMinHealthyPercentage?: number;
        batchSizePercentage?: number;
        comment?: string;
        respectPdb?: boolean;
    }

    export interface OceanImportShieldedInstanceConfig {
        /**
         * Boolean. Enable the integrity monitoring parameter on the GCP instances.
         */
        enableIntegrityMonitoring: boolean;
        /**
         * Boolean. Enable the secure boot parameter on the GCP instances.
         */
        enableSecureBoot: boolean;
    }

    export interface OceanImportStrategy {
        /**
         * The draining timeout (in seconds) before terminating the instance.
         */
        drainingTimeout?: number;
        preemptiblePercentage?: number;
        provisioningModel?: string;
    }

    export interface OceanImportUpdatePolicy {
        conditionedRoll?: boolean;
        rollConfig?: outputs.gke.OceanImportUpdatePolicyRollConfig;
        shouldRoll: boolean;
    }

    export interface OceanImportUpdatePolicyRollConfig {
        batchMinHealthyPercentage?: number;
        batchSizePercentage: number;
        launchSpecIds?: string[];
        respectPdb?: boolean;
    }

    export interface OceanLaunchSpecAutoscaleHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the number of GPUS to allocate for each headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecAutoscaleHeadroomsAutomatic {
        /**
         * Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.`isEnabled` = true is set on the Ocean cluster.
         */
        autoHeadroomPercentage?: number;
    }

    export interface OceanLaunchSpecLabel {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface OceanLaunchSpecMetadata {
        /**
         * The metadata key.
         */
        key: string;
        /**
         * The metadata value.
         */
        value: string;
    }

    export interface OceanLaunchSpecNetworkInterface {
        /**
         * The network protocol of the VNG.
         */
        accessConfigs?: outputs.gke.OceanLaunchSpecNetworkInterfaceAccessConfig[];
        /**
         * use the imported node pool’s associated aliasIpRange to assign secondary IP addresses to the nodes. Cannot be changed after VNG creation.
         */
        aliasIpRanges?: outputs.gke.OceanLaunchSpecNetworkInterfaceAliasIpRange[];
        /**
         * The name of the network.
         */
        network: string;
        /**
         * Use a network resource from a different project. Set the project identifier to use its network resource. This parameter is relevant only if the network resource is in a different project.
         */
        projectId?: string;
    }

    export interface OceanLaunchSpecNetworkInterfaceAccessConfig {
        /**
         * The launch specification name.
         */
        name?: string;
        type?: string;
    }

    export interface OceanLaunchSpecNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName: string;
    }

    export interface OceanLaunchSpecResourceLimits {
        /**
         * Option to set a maximum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
         */
        maxInstanceCount?: number;
        /**
         * Option to set a minimum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
         */
        minInstanceCount?: number;
    }

    export interface OceanLaunchSpecSchedulingTask {
        /**
         * A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
         */
        cronExpression: string;
        /**
         * Describes whether the task is enabled. When True, the task runs. When False, it does not run.
         */
        isEnabled: boolean;
        /**
         * The config of this scheduled task. Depends on the value of taskType.
         */
        taskHeadrooms?: outputs.gke.OceanLaunchSpecSchedulingTaskTaskHeadroom[];
        /**
         * The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
         */
        taskType: string;
    }

    export interface OceanLaunchSpecSchedulingTaskTaskHeadroom {
        cpuPerUnit?: number;
        gpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits: number;
    }

    export interface OceanLaunchSpecShieldedInstanceConfig {
        /**
         * Boolean. Enable the integrity monitoring parameter on the GCP instances.
         */
        enableIntegrityMonitoring: boolean;
        /**
         * Boolean. Enable the secure boot parameter on the GCP instances.
         */
        enableSecureBoot: boolean;
    }

    export interface OceanLaunchSpecStorage {
        /**
         * Defines the number of local SSDs to be attached per node for this VNG.
         */
        localSsdCount: number;
    }

    export interface OceanLaunchSpecStrategy {
        /**
         * Defines the desired preemptible percentage for this launch specification.
         */
        preemptiblePercentage?: number;
    }

    export interface OceanLaunchSpecTaint {
        /**
         * The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
         */
        effect: string;
        /**
         * The taint key.
         */
        key: string;
        /**
         * The taint value.
         */
        value: string;
    }

    export interface OceanLaunchSpecUpdatePolicy {
        rollConfig?: outputs.gke.OceanLaunchSpecUpdatePolicyRollConfig;
        shouldRoll: boolean;
    }

    export interface OceanLaunchSpecUpdatePolicyRollConfig {
        batchSizePercentage: number;
    }

}

export namespace organization {
    export interface PolicyPolicyContent {
        /**
         * List of permissions statements.
         */
        statements: outputs.organization.PolicyPolicyContentStatement[];
    }

    export interface PolicyPolicyContentStatement {
        actions: string[];
        effect: string;
        resources: string[];
    }

    export interface ProgrammaticUserAccount {
        /**
         * Account ID the programmatic user will have access to.
         */
        accountId: string;
        /**
         * (Enum: `"viewer", "editor") Role to be associated with the
         * programmatic user for this account.
         */
        accountRole: string;
    }

    export interface ProgrammaticUserPolicy {
        /**
         * A list of the accounts that the policy should be
         * enforced for the user.
         */
        policyAccountIds: string[];
        /**
         * Policy ID the programmatic user will have access to.
         */
        policyId: string;
    }

    export interface UserGroupPolicy {
        /**
         * A list of accounts to register with the assigned under the
         * given group (should be existing accounts only).
         */
        accountIds: string[];
        /**
         * A policy to register under the given group
         * (should be existing policy only).
         */
        policyId: string;
    }

    export interface UserPolicy {
        policyAccountIds: string[];
        /**
         * A policy to register under the given group
         * (should be existing policy only).
         */
        policyId: string;
    }

}

export namespace spark {
    export interface OceanCompute {
        /**
         * - Enable/disable the creation of Ocean Spark VNGs during cluster creation.
         */
        createVngs: boolean;
        /**
         * - Enable/disable Ocean Spark taints on the Ocean Spark VNGs. By default, Ocean Spark uses taints to prevent non-Spark workloads from running on Ocean Spark VNGs.
         */
        useTaints: boolean;
    }

    export interface OceanIngress {
        controller?: outputs.spark.OceanIngressController;
        customEndpoint?: outputs.spark.OceanIngressCustomEndpoint;
        loadBalancer?: outputs.spark.OceanIngressLoadBalancer;
        privateLink?: outputs.spark.OceanIngressPrivateLink;
        /**
         * - **DEPRECATED**: Use `load_balancer.service_annotations` instead.
         */
        serviceAnnotations: {[key: string]: string};
    }

    export interface OceanIngressController {
        /**
         * - Should an ingress controller managed by Ocean for Apache Spark be installed on the cluster.
         */
        managed?: boolean;
    }

    export interface OceanIngressCustomEndpoint {
        /**
         * - The address the Ocean for Apache Spark control plane will use when addressing the cluster.
         */
        address?: string;
        /**
         * - Should the Ocean for Apache Spark control plane address the cluster using a custom endpoint. Use this to specify the DNS address of an externally provisioned (unmanaged) load balancer.
         */
        enabled?: boolean;
    }

    export interface OceanIngressLoadBalancer {
        /**
         * - Should a load balancer managed by Ocean for Apache Spark be provisioned for the cluster. Set this to false if you want to use an existing load balancer (only available on AWS).
         */
        managed?: boolean;
        /**
         * - Annotations to add to the ingress controller load balancer service. This is useful to configure properties of the managed load balancer, like the nature of the load balancer (e.g. ELB, NLB, ALB on AWS), the security groups, or various timeouts.
         */
        serviceAnnotations?: {[key: string]: string};
        /**
         * - The ARN of a target group that the Ocean for Apache Spark ingress controller will be bound to. Set this to use an existing load balancer with Ocean for Apache Spark. Has no effect if using a managed load balancer. Only available on AWS.
         */
        targetGroupArn?: string;
    }

    export interface OceanIngressPrivateLink {
        /**
         * - Should the Ocean for Apache Spark control plane address the cluster via an AWS Private Link. Only available on AWS.
         */
        enabled?: boolean;
        /**
         * - The name of the VPC Endpoint Service the Ocean for Apache Spark control plane should bind to.
         */
        vpcEndpointService?: string;
    }

    export interface OceanLogCollection {
        /**
         * - Enable/Disable collecting driver and executor logs. When enabled, logs are stored by NetApp and can be downloaded from the Spot console web interface. The logs are deleted after 30 days.
         */
        collectAppLogs: boolean;
    }

    export interface OceanSpark {
        /**
         * - List of Kubernetes namespaces that should be configured to run Spark applications, in addition to the default Spark application namespace `spark-apps`.
         */
        additionalAppNamespaces: string[];
    }

    export interface OceanWebhook {
        /**
         * - List of ports allowed to use on the host network - if empty default is `25554`.
         */
        hostNetworkPorts: number[];
        /**
         * - Enable/disable host networking for the Spark Operator. Host networking can be useful when using custom CNI plugins like Calico on EKS.
         */
        useHostNetwork: boolean;
    }

}
