// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface DataIntegrationS3 {
    bucketName: string;
    /**
     * The subdirectory in which your files will be stored within the bucket. Adds the prefix subdir/ to new objects' keys. Can't be null or contain '/'.
     */
    subdir?: string;
}

export interface ElastigroupAzureV3Image {
    customs?: outputs.ElastigroupAzureV3ImageCustom[];
    marketplaces?: outputs.ElastigroupAzureV3ImageMarketplace[];
}

export interface ElastigroupAzureV3ImageCustom {
    /**
     * Name of the custom image. Required if resourceGroupName is specified.
     */
    imageName: string;
    /**
     * Name of the Azure Resource Group where the Managed Service Identity is located.
     */
    resourceGroupName: string;
}

export interface ElastigroupAzureV3ImageMarketplace {
    /**
     * Name of the image to use. Required if publisher is specified.
     */
    offer: string;
    /**
     * Image publisher. Required if resourceGroupName is not specified.
     */
    publisher: string;
    /**
     * Image's Stock Keeping Unit, which is the specific version of the image. Required if publisher is specified.
     */
    sku: string;
    version: string;
}

export interface ElastigroupAzureV3Login {
    /**
     * Password for admin access to Windows VMs. Required for Windows OS types.
     */
    password?: string;
    /**
     * SSH for admin access to Linux VMs. Required for Linux OS types.
     */
    sshPublicKey?: string;
    /**
     * Set admin access for accessing your VMs.
     */
    userName: string;
}

export interface ElastigroupAzureV3ManagedServiceIdentity {
    /**
     * Name of the Managed Service Identity.
     */
    name: string;
    /**
     * Name of the Azure Resource Group where the Managed Service Identity is located.
     */
    resourceGroupName: string;
}

export interface ElastigroupAzureV3Network {
    networkInterfaces: outputs.ElastigroupAzureV3NetworkNetworkInterface[];
    /**
     * The resource group of the Application Security Group.
     * }
     */
    resourceGroupName: string;
    /**
     * Name of Vnet.
     */
    virtualNetworkName: string;
}

export interface ElastigroupAzureV3NetworkNetworkInterface {
    /**
     * Array of additional IP configuration objects.
     */
    additionalIpConfigs?: outputs.ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig[];
    /**
     * List of Application Security Groups that will be associated to the primary ip configuration of the network interface.
     */
    applicationSecurityGroups?: outputs.ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup[];
    assignPublicIp: boolean;
    isPrimary: boolean;
    /**
     * ID of subnet.
     */
    subnetName: string;
}

export interface ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig {
    /**
     * Name of the Managed Service Identity.
     */
    name: string;
    /**
     * Available from Azure Api-Version 2017-03-30 onwards, it represents whether the specific ip configuration is IPv4 or IPv6. Valid values: `IPv4`, `IPv6`.
     */
    privateIpVersion?: string;
}

export interface ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup {
    /**
     * Name of the Managed Service Identity.
     */
    name: string;
    /**
     * Name of the Azure Resource Group where the Managed Service Identity is located.
     */
    resourceGroupName: string;
}

export interface HealthCheckCheck {
    endPoint?: string;
    /**
     * The destination for the request.
     */
    endpoint?: string;
    /**
     * The number of consecutive successful health checks that must occur before declaring an instance healthy.
     */
    healthy: number;
    /**
     * The amount of time (in seconds) between each health check (minimum: 10).
     */
    interval: number;
    /**
     * The port of the Spotinst HCS (default: 80).
     */
    port: number;
    /**
     * The protocol to use to connect with the instance. Valid values: http, https.
     */
    protocol: string;
    timeOut?: number;
    /**
     * the amount of time (in seconds) to wait when receiving a response from the health check.
     */
    timeout?: number;
    /**
     * The number of consecutive failed health checks that must occur before declaring an instance unhealthy.
     */
    unhealthy: number;
}

export interface StatefulNodeAzureAttachDataDisk {
    dataDiskName: string;
    dataDiskResourceGroupName: string;
    lun?: number;
    sizeGb: number;
    storageAccountType: string;
    zone?: string;
}

export interface StatefulNodeAzureBootDiagnostic {
    isEnabled: boolean;
    storageUrl: string;
    type: string;
}

export interface StatefulNodeAzureDataDisk {
    lun: number;
    sizeGb: number;
    type: string;
}

export interface StatefulNodeAzureDelete {
    diskShouldDeallocate: boolean;
    diskTtlInHours?: number;
    networkShouldDeallocate: boolean;
    networkTtlInHours?: number;
    publicIpShouldDeallocate: boolean;
    publicIpTtlInHours?: number;
    shouldTerminateVm: boolean;
    snapshotShouldDeallocate: boolean;
    snapshotTtlInHours?: number;
}

export interface StatefulNodeAzureDetachDataDisk {
    dataDiskName: string;
    dataDiskResourceGroupName: string;
    shouldDeallocate: boolean;
    ttlInHours?: number;
}

export interface StatefulNodeAzureExtension {
    apiVersion: string;
    minorVersionAutoUpgrade: boolean;
    name: string;
    protectedSettings: {[key: string]: any};
    publicSettings: {[key: string]: any};
    publisher: string;
    type: string;
}

export interface StatefulNodeAzureHealth {
    autoHealing: boolean;
    gracePeriod: number;
    healthCheckTypes: string[];
    unhealthyDuration: number;
}

export interface StatefulNodeAzureImage {
    customImages: outputs.StatefulNodeAzureImageCustomImage[];
    galleries: outputs.StatefulNodeAzureImageGallery[];
    marketplaceImages: outputs.StatefulNodeAzureImageMarketplaceImage[];
}

export interface StatefulNodeAzureImageCustomImage {
    customImageResourceGroupName: string;
    name: string;
}

export interface StatefulNodeAzureImageGallery {
    galleryName: string;
    galleryResourceGroupName: string;
    imageName: string;
    versionName: string;
}

export interface StatefulNodeAzureImageMarketplaceImage {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface StatefulNodeAzureImportVm {
    drainingTimeout?: number;
    originalVmName: string;
    resourceGroupName: string;
    resourcesRetentionTime?: number;
}

export interface StatefulNodeAzureLoadBalancer {
    backendPoolNames: string[];
    name: string;
    resourceGroupName: string;
    sku: string;
    type: string;
}

export interface StatefulNodeAzureLogin {
    password: string;
    sshPublicKey: string;
    userName: string;
}

export interface StatefulNodeAzureManagedServiceIdentity {
    name: string;
    resourceGroupName: string;
}

export interface StatefulNodeAzureNetwork {
    networkInterfaces: outputs.StatefulNodeAzureNetworkNetworkInterface[];
    networkResourceGroupName: string;
    virtualNetworkName: string;
}

export interface StatefulNodeAzureNetworkNetworkInterface {
    additionalIpConfigurations: outputs.StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration[];
    applicationSecurityGroups: outputs.StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup[];
    assignPublicIp: boolean;
    enableIpForwarding: boolean;
    isPrimary: boolean;
    networkSecurityGroups: outputs.StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup[];
    privateIpAddresses: string[];
    publicIpSku: string;
    publicIps: outputs.StatefulNodeAzureNetworkNetworkInterfacePublicIp[];
    subnetName: string;
}

export interface StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration {
    name: string;
    privateIpAddressVersion: string;
}

export interface StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup {
    name: string;
    networkResourceGroupName: string;
}

export interface StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup {
    name: string;
    networkResourceGroupName: string;
}

export interface StatefulNodeAzureNetworkNetworkInterfacePublicIp {
    name: string;
    networkResourceGroupName: string;
}

export interface StatefulNodeAzureOsDisk {
    sizeGb: number;
    type: string;
}

export interface StatefulNodeAzureSchedulingTask {
    cronExpression: string;
    isEnabled: boolean;
    type: string;
}

export interface StatefulNodeAzureSecret {
    sourceVaults: outputs.StatefulNodeAzureSecretSourceVault[];
    vaultCertificates: outputs.StatefulNodeAzureSecretVaultCertificate[];
}

export interface StatefulNodeAzureSecretSourceVault {
    name: string;
    resourceGroupName: string;
}

export interface StatefulNodeAzureSecretVaultCertificate {
    certificateStore: string;
    certificateUrl: string;
}

export interface StatefulNodeAzureSignal {
    timeout: number;
    type: string;
}

export interface StatefulNodeAzureStrategy {
    drainingTimeout: number;
    fallbackToOnDemand: boolean;
    optimizationWindows?: string[];
    preferredLifeCycle: string;
    revertToSpot: outputs.StatefulNodeAzureStrategyRevertToSpot;
}

export interface StatefulNodeAzureStrategyRevertToSpot {
    performAt: string;
}

export interface StatefulNodeAzureTag {
    tagKey: string;
    tagValue?: string;
}

export interface StatefulNodeAzureUpdateState {
    state: string;
}

export namespace aws {
    export interface BeanstalkDeploymentPreferences {
        /**
         * Should roll perform automatically
         */
        automaticRoll?: boolean;
        /**
         * Percent size of each batch
         */
        batchSizePercentage?: number;
        /**
         * Amount of time to wait between batches
         */
        gracePeriod?: number;
        /**
         * Strategy parameters
         */
        strategies?: outputs.aws.BeanstalkDeploymentPreferencesStrategy[];
    }

    export interface BeanstalkDeploymentPreferencesStrategy {
        /**
         * Action to take
         */
        action?: string;
        /**
         * Bool value if to wait to drain instance
         */
        shouldDrainInstances?: boolean;
    }

    export interface BeanstalkManagedActions {
        /**
         * Platform Update parameters
         */
        platformUpdate?: outputs.aws.BeanstalkManagedActionsPlatformUpdate;
    }

    export interface BeanstalkManagedActionsPlatformUpdate {
        /**
         * Actions to perform (options: timeWindow, never)
         */
        performAt?: string;
        /**
         * Time Window for when action occurs ex. Mon:23:50-Tue:00:20
         */
        timeWindow?: string;
        /**
         * Level to update
         */
        updateLevel?: string;
    }

    export interface BeanstalkScheduledTask {
        /**
         * The number of instances to add or remove.
         */
        adjustment?: string;
        /**
         * The percentage of instances to add or remove.
         */
        adjustmentPercentage?: string;
        /**
         * The percentage size of each batch in the scheduled deployment roll.
         */
        batchSizePercentage?: string;
        /**
         * A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
         */
        cronExpression?: string;
        /**
         * The recurrence frequency to run this task. Supported values are `"hourly"`, `"daily"`, `"weekly"` and `"continuous"`.
         */
        frequency?: string;
        /**
         * The period of time (seconds) to wait before checking a batch's health after it's deployment.
         */
        gracePeriod?: string;
        /**
         * Setting the task to being enabled or disabled.
         */
        isEnabled?: boolean;
        /**
         * The maximum number of instances the group should have.
         */
        maxCapacity?: string;
        /**
         * The minimum number of instances the group should have.
         */
        minCapacity?: string;
        /**
         * The maximum number of instances the group should have.
         */
        scaleMaxCapacity?: string;
        /**
         * The minimum number of instances the group should have.
         */
        scaleMinCapacity?: string;
        /**
         * The desired number of instances the group should have.
         */
        scaleTargetCapacity?: string;
        /**
         * Set a start time for one time tasks.
         */
        startTime?: string;
        /**
         * The desired number of instances the group should have.
         */
        targetCapacity?: string;
        /**
         * The task type to run. Supported task types are: `"scale"`, `"backupAmi"`, `"roll"`, `"scaleUp"`, `"percentageScaleUp"`, `"scaleDown"`, `"percentageScaleDown"`, `"statefulUpdateCapacity"`.
         */
        taskType: string;
    }

    export interface ElastigroupCpuOptions {
        /**
         * The ability to define the number of threads per core in instances that allow this.
         */
        threadsPerCore: number;
    }

    export interface ElastigroupEbsBlockDevice {
        /**
         * Whether the volume should be destroyed on instance termination.
         */
        deleteOnTermination: boolean;
        /**
         * The name of the device to mount.
         */
        deviceName: string;
        /**
         * Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
         */
        encrypted: boolean;
        /**
         * The amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). This must be set with a `volumeType` of `"io1"`.
         */
        iops?: number;
        /**
         * ID for a user managed CMK under which the EBS Volume is encrypted
         */
        kmsKeyId?: string;
        /**
         * The Snapshot ID to mount.
         */
        snapshotId?: string;
        /**
         * The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volumeType` = gp3.
         */
        throughput?: number;
        /**
         * The size of the volume in gigabytes.
         */
        volumeSize?: number;
        /**
         * The type of volume. Can be `"standard"`, `"gp2"`, `"io1"`, `"st1"` or `"sc1"`.
         */
        volumeType: string;
    }

    export interface ElastigroupEphemeralBlockDevice {
        /**
         * The name of the block device to mount on the instance.
         */
        deviceName: string;
        /**
         * The [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
         * (e.g. `"ephemeral0"`).
         */
        virtualName: string;
    }

    export interface ElastigroupImage {
        images: outputs.aws.ElastigroupImageImage[];
    }

    export interface ElastigroupImageImage {
        /**
         * The group ID.
         */
        id: string;
    }

    export interface ElastigroupInstanceTypesWeight {
        /**
         * Name of instance type (String).
         */
        instanceType: string;
        /**
         * Weight per instance type (Integer).
         */
        weight: number;
    }

    export interface ElastigroupIntegrationBeanstalk {
        /**
         * Preferences when performing a roll
         */
        deploymentPreferences?: outputs.aws.ElastigroupIntegrationBeanstalkDeploymentPreferences;
        environmentId?: string;
        /**
         * Managed Actions parameters
         */
        managedActions?: outputs.aws.ElastigroupIntegrationBeanstalkManagedActions;
    }

    export interface ElastigroupIntegrationBeanstalkDeploymentPreferences {
        /**
         * Should roll perform automatically
         */
        automaticRoll?: boolean;
        /**
         * The percentage size of each batch in the scheduled deployment roll.
         */
        batchSizePercentage?: number;
        /**
         * The period of time (seconds) to wait before checking a batch's health after it's deployment.
         */
        gracePeriod?: number;
        /**
         * Strategy parameters
         */
        strategy?: outputs.aws.ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategy;
    }

    export interface ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategy {
        /**
         * The action to take when scale up according to step's threshold is needed.
         */
        action?: string;
        /**
         * Bool value if to wait to drain instance
         */
        shouldDrainInstances?: boolean;
    }

    export interface ElastigroupIntegrationBeanstalkManagedActions {
        /**
         * Platform Update parameters
         */
        platformUpdate?: outputs.aws.ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdate;
    }

    export interface ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdate {
        /**
         * In the event of a fallback to On-Demand instances, select the time period to revert back to Spot. Supported Arguments – always (default), timeWindow, never. For timeWindow or never to be valid the group must have availabilityOriented OR persistence defined.
         */
        performAt?: string;
        /**
         * Time Window for when action occurs ex. Mon:23:50-Tue:00:20
         */
        timeWindow?: string;
        /**
         * Level to update
         */
        updateLevel?: string;
    }

    export interface ElastigroupIntegrationCodedeploy {
        /**
         * Cleanup automatically after a failed deploy.
         */
        cleanupOnFailure: boolean;
        /**
         * Specify the deployment groups details.
         */
        deploymentGroups: outputs.aws.ElastigroupIntegrationCodedeployDeploymentGroup[];
        /**
         * Terminate the instance automatically after a failed deploy.
         */
        terminateInstanceOnFailure: boolean;
    }

    export interface ElastigroupIntegrationCodedeployDeploymentGroup {
        /**
         * The application name.
         */
        applicationName: string;
        /**
         * The deployment group name.
         */
        deploymentGroupName: string;
    }

    export interface ElastigroupIntegrationDockerSwarm {
        /**
         * The amount of time, in seconds, after a scaling activity completes before any further trigger-related scaling activities can start.
         */
        autoscaleCooldown?: number;
        /**
         * Enabling scale down.
         */
        autoscaleDown?: outputs.aws.ElastigroupIntegrationDockerSwarmAutoscaleDown;
        /**
         * Headroom for the cluster.
         */
        autoscaleHeadroom?: outputs.aws.ElastigroupIntegrationDockerSwarmAutoscaleHeadroom;
        /**
         * Specifies whether the auto scaling feature is enabled.
         */
        autoscaleIsEnabled?: boolean;
        /**
         * The URL of the Rancher Master host.
         */
        masterHost: string;
        /**
         * Network port used by your swarm.
         */
        masterPort: number;
    }

    export interface ElastigroupIntegrationDockerSwarmAutoscaleDown {
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods?: number;
        /**
         * Represents the maximum percent to scale-down. Number between 1-100.
         * Usage:
         */
        maxScaleDownPercentage?: number;
    }

    export interface ElastigroupIntegrationDockerSwarmAutoscaleHeadroom {
        /**
         * Cpu units for compute.
         */
        cpuPerUnit?: number;
        /**
         * RAM units for compute.
         */
        memoryPerUnit?: number;
        /**
         * Amount of units for compute.
         */
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationEcs {
        /**
         * A key/value mapping of tags to assign to the resource.
         */
        autoscaleAttributes?: outputs.aws.ElastigroupIntegrationEcsAutoscaleAttribute[];
        /**
         * The amount of time, in seconds, after a scaling activity completes before any further trigger-related scaling activities can start.
         */
        autoscaleCooldown?: number;
        /**
         * Enabling scale down.
         */
        autoscaleDown?: outputs.aws.ElastigroupIntegrationEcsAutoscaleDown;
        /**
         * Headroom for the cluster.
         */
        autoscaleHeadroom?: outputs.aws.ElastigroupIntegrationEcsAutoscaleHeadroom;
        /**
         * Enabling the automatic auto-scaler functionality. For more information please see: [ECS auto scaler](https://api.spotinst.com/container-management/amazon-ecs/elastigroup-for-ecs-concepts/autoscaling/).
         */
        autoscaleIsAutoConfig?: boolean;
        /**
         * Specifies whether the auto scaling feature is enabled.
         */
        autoscaleIsEnabled?: boolean;
        /**
         * Determines whether to scale down non-service tasks.
         */
        autoscaleScaleDownNonServiceTasks?: boolean;
        /**
         * Batch configuration object:
         */
        batch?: outputs.aws.ElastigroupIntegrationEcsBatch;
        /**
         * The name of the EC2 Container Service cluster.
         */
        clusterName: string;
    }

    export interface ElastigroupIntegrationEcsAutoscaleAttribute {
        key: string;
        /**
         * The dimension value.
         */
        value: string;
    }

    export interface ElastigroupIntegrationEcsAutoscaleDown {
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods?: number;
        /**
         * Represents the maximum percent to scale-down. Number between 1-100.
         * Usage:
         */
        maxScaleDownPercentage?: number;
    }

    export interface ElastigroupIntegrationEcsAutoscaleHeadroom {
        /**
         * Cpu units for compute.
         */
        cpuPerUnit?: number;
        /**
         * RAM units for compute.
         */
        memoryPerUnit?: number;
        /**
         * Amount of units for compute.
         */
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationEcsBatch {
        /**
         * Array of strings.
         */
        jobQueueNames: string[];
    }

    export interface ElastigroupIntegrationGitlab {
        /**
         * Settings for Gitlab runner.
         */
        runner?: outputs.aws.ElastigroupIntegrationGitlabRunner;
    }

    export interface ElastigroupIntegrationGitlabRunner {
        /**
         * Setting the task to being enabled or disabled.
         */
        isEnabled?: boolean;
    }

    export interface ElastigroupIntegrationKubernetes {
        apiServer?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes before any further trigger-related scaling activities can start.
         */
        autoscaleCooldown?: number;
        /**
         * Enabling scale down.
         */
        autoscaleDown?: outputs.aws.ElastigroupIntegrationKubernetesAutoscaleDown;
        /**
         * Headroom for the cluster.
         */
        autoscaleHeadroom?: outputs.aws.ElastigroupIntegrationKubernetesAutoscaleHeadroom;
        /**
         * Enabling the automatic auto-scaler functionality. For more information please see: [ECS auto scaler](https://api.spotinst.com/container-management/amazon-ecs/elastigroup-for-ecs-concepts/autoscaling/).
         */
        autoscaleIsAutoConfig?: boolean;
        /**
         * Specifies whether the auto scaling feature is enabled.
         */
        autoscaleIsEnabled?: boolean;
        /**
         * A key/value mapping of tags to assign to the resource.
         */
        autoscaleLabels?: outputs.aws.ElastigroupIntegrationKubernetesAutoscaleLabel[];
        clusterIdentifier?: string;
        /**
         * Valid values: `"saas"`, `"pod"`.
         */
        integrationMode?: string;
        /**
         * Kubernetes Token
         */
        token?: string;
    }

    export interface ElastigroupIntegrationKubernetesAutoscaleDown {
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods?: number;
    }

    export interface ElastigroupIntegrationKubernetesAutoscaleHeadroom {
        /**
         * Cpu units for compute.
         */
        cpuPerUnit?: number;
        /**
         * RAM units for compute.
         */
        memoryPerUnit?: number;
        /**
         * Amount of units for compute.
         */
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationKubernetesAutoscaleLabel {
        key: string;
        /**
         * The dimension value.
         */
        value: string;
    }

    export interface ElastigroupIntegrationMesosphere {
        apiServer: string;
    }

    export interface ElastigroupIntegrationMultaiRuntime {
        /**
         * The deployment id you want to get
         */
        deploymentId: string;
    }

    export interface ElastigroupIntegrationNomad {
        /**
         * Nomad ACL Token
         */
        aclToken?: string;
        /**
         * A key/value mapping of tags to assign to the resource.
         */
        autoscaleConstraints?: outputs.aws.ElastigroupIntegrationNomadAutoscaleConstraint[];
        /**
         * The amount of time, in seconds, after a scaling activity completes before any further trigger-related scaling activities can start.
         */
        autoscaleCooldown?: number;
        /**
         * Enabling scale down.
         */
        autoscaleDown?: outputs.aws.ElastigroupIntegrationNomadAutoscaleDown;
        /**
         * Headroom for the cluster.
         */
        autoscaleHeadroom?: outputs.aws.ElastigroupIntegrationNomadAutoscaleHeadroom;
        /**
         * Specifies whether the auto scaling feature is enabled.
         */
        autoscaleIsEnabled?: boolean;
        /**
         * The URL of the Rancher Master host.
         */
        masterHost: string;
        /**
         * Network port used by your swarm.
         */
        masterPort: number;
    }

    export interface ElastigroupIntegrationNomadAutoscaleConstraint {
        key: string;
        /**
         * The dimension value.
         */
        value: string;
    }

    export interface ElastigroupIntegrationNomadAutoscaleDown {
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods?: number;
    }

    export interface ElastigroupIntegrationNomadAutoscaleHeadroom {
        /**
         * Cpu units for compute.
         */
        cpuPerUnit?: number;
        /**
         * RAM units for compute.
         */
        memoryPerUnit?: number;
        /**
         * Amount of units for compute.
         */
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationRancher {
        /**
         * The access key of the Rancher API.
         */
        accessKey: string;
        /**
         * The URL of the Rancher Master host.
         */
        masterHost: string;
        /**
         * The secret key of the Rancher API.
         */
        secretKey: string;
        /**
         * The Rancher version. Must be `"1"` or `"2"`. If this field is omitted, it’s assumed that the Rancher cluster is version 1. Note that Kubernetes is required when using Rancher version 2^.
         * Usage:
         */
        version?: string;
    }

    export interface ElastigroupIntegrationRoute53 {
        /**
         * Collection of one or more domains to register.
         */
        domains: outputs.aws.ElastigroupIntegrationRoute53Domain[];
    }

    export interface ElastigroupIntegrationRoute53Domain {
        /**
         * The id associated with a hosted zone.
         */
        hostedZoneId: string;
        /**
         * The type of the record set. Valid values: `"a"`, `"cname"`.
         */
        recordSetType?: string;
        /**
         * Collection of records containing authoritative DNS information for the specified domain name.
         */
        recordSets: outputs.aws.ElastigroupIntegrationRoute53DomainRecordSet[];
        /**
         * The Spotinst account ID that is linked to the AWS account that holds the Route 53 Hosted Zone ID. The default is the user Spotinst account provided as a URL parameter.
         */
        spotinstAcctId?: string;
    }

    export interface ElastigroupIntegrationRoute53DomainRecordSet {
        /**
         * The group name.
         */
        name: string;
        /**
         * Designates whether the DNS address should be exposed to connections outside the VPC.
         */
        usePublicDns?: boolean;
        /**
         * Designates whether the IP address should be exposed to connections outside the VPC.
         */
        usePublicIp?: boolean;
    }

    export interface ElastigroupItf {
        defaultStaticTargetGroup?: outputs.aws.ElastigroupItfDefaultStaticTargetGroup;
        fixedTargetGroups: boolean;
        loadBalancers: outputs.aws.ElastigroupItfLoadBalancer[];
        migrationHealthinessThreshold?: number;
        targetGroupConfigs: outputs.aws.ElastigroupItfTargetGroupConfig[];
        weightStrategy: string;
    }

    export interface ElastigroupItfDefaultStaticTargetGroup {
        arn: string;
        percentage: number;
    }

    export interface ElastigroupItfLoadBalancer {
        listenerRules: outputs.aws.ElastigroupItfLoadBalancerListenerRule[];
        loadBalancerArn: string;
    }

    export interface ElastigroupItfLoadBalancerListenerRule {
        ruleArn: string;
        staticTargetGroup?: outputs.aws.ElastigroupItfLoadBalancerListenerRuleStaticTargetGroup;
    }

    export interface ElastigroupItfLoadBalancerListenerRuleStaticTargetGroup {
        arn: string;
        percentage: number;
    }

    export interface ElastigroupItfTargetGroupConfig {
        healthCheckIntervalSeconds?: number;
        healthCheckPath: string;
        healthCheckPort?: string;
        healthCheckProtocol?: string;
        healthCheckTimeoutSeconds?: number;
        healthyThresholdCount?: number;
        matchers?: outputs.aws.ElastigroupItfTargetGroupConfigMatcher[];
        port: number;
        protocol: string;
        protocolVersion?: string;
        /**
         * A key/value mapping of tags to assign to the resource.
         */
        tags?: outputs.aws.ElastigroupItfTargetGroupConfigTag[];
        unhealthyThresholdCount?: number;
        vpcId: string;
    }

    export interface ElastigroupItfTargetGroupConfigMatcher {
        grpcCode?: string;
        httpCode?: string;
    }

    export interface ElastigroupItfTargetGroupConfigTag {
        tagKey: string;
        tagValue?: string;
    }

    export interface ElastigroupMetadataOptions {
        /**
         * The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values: Integers from `1` to `64`.
         */
        httpPutResponseHopLimit?: number;
        /**
         * The state of token usage for your instance metadata requests. Valid values: `optional` or `required`.
         */
        httpTokens: string;
        /**
         * Indicates whether access to instance tags from the instance metadata is enabled or disabled. Can’t be null.
         */
        instanceMetadataTags?: string;
    }

    export interface ElastigroupMultaiTargetSet {
        /**
         * ID of Multai Load Balancer.
         */
        balancerId: string;
        /**
         * ID of Multai target set.
         */
        targetSetId: string;
    }

    export interface ElastigroupMultipleMetrics {
        /**
         * Array of objects (Expression config)
         */
        expressions?: outputs.aws.ElastigroupMultipleMetricsExpression[];
        /**
         * Array of objects (Metric config)
         */
        metrics?: outputs.aws.ElastigroupMultipleMetricsMetric[];
    }

    export interface ElastigroupMultipleMetricsExpression {
        /**
         * An expression consisting of the metric names listed in the 'metrics' array.
         */
        expression: string;
        /**
         * The group name.
         */
        name: string;
    }

    export interface ElastigroupMultipleMetricsMetric {
        /**
         * A list of dimensions describing qualities of the metric.
         */
        dimensions?: outputs.aws.ElastigroupMultipleMetricsMetricDimension[];
        /**
         * Percentile statistic. Valid values: `"p0.1"` - `"p100"`.
         */
        extendedStatistic?: string;
        /**
         * The name of the metric, with or without spaces.
         */
        metricName: string;
        /**
         * The group name.
         */
        name: string;
        /**
         * The namespace for the alarm's associated metric.
         */
        namespace: string;
        /**
         * The metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
         */
        statistic?: string;
        /**
         * The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
         */
        unit?: string;
    }

    export interface ElastigroupMultipleMetricsMetricDimension {
        /**
         * The group name.
         */
        name: string;
        /**
         * The dimension value.
         */
        value?: string;
    }

    export interface ElastigroupNetworkInterface {
        /**
         * Indicates whether to assign IPV6 addresses to your instance. Requires a subnet with IPV6 CIDR block ranges.
         */
        associateIpv6Address?: boolean;
        /**
         * Indicates whether to assign a public IP address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one.
         */
        associatePublicIpAddress?: boolean;
        /**
         * If set to true, the interface is deleted when the instance is terminated.
         */
        deleteOnTermination: boolean;
        /**
         * The group description.
         */
        description?: string;
        /**
         * The index of the device on the instance for the network interface attachment.
         */
        deviceIndex: string;
        /**
         * The ID of the network interface.
         */
        networkInterfaceId?: string;
        /**
         * The private IP address of the network interface.
         */
        privateIpAddress?: string;
        /**
         * The number of secondary private IP addresses.
         */
        secondaryPrivateIpAddressCount?: string;
    }

    export interface ElastigroupResourceTagSpecification {
        /**
         * Tag specification for AMI resources.
         */
        shouldTagAmis?: boolean;
        /**
         * Tag specification for ENI resources.
         */
        shouldTagEnis?: boolean;
        /**
         * Tag specification for Snapshot resources.
         */
        shouldTagSnapshots?: boolean;
        /**
         * Tag specification for Volume resources.
         */
        shouldTagVolumes?: boolean;
    }

    export interface ElastigroupRevertToSpot {
        /**
         * In the event of a fallback to On-Demand instances, select the time period to revert back to Spot. Supported Arguments – always (default), timeWindow, never. For timeWindow or never to be valid the group must have availabilityOriented OR persistence defined.
         */
        performAt: string;
        /**
         * Specify a list of time windows for to execute revertToSpot strategy. Time window format: `ddd:hh:mm-ddd:hh:mm`. Example: `Mon:03:00-Wed:02:30`
         */
        timeWindows?: string[];
    }

    export interface ElastigroupScalingDownPolicy {
        /**
         * The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`. If a `stepAdjustment` object is defined, then it cannot be specified.
         */
        actionType?: string;
        /**
         * The number of instances to add/remove to/from the target capacity when scale is needed. Can be used as advanced expression for scaling of instances to add/remove to/from the target capacity when scale is needed. You can see more information here: Advanced expression. Example value: `"MAX(currCapacity / 5, value * 10)"`
         */
        adjustment?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
         */
        cooldown?: number;
        /**
         * A list of dimensions describing qualities of the metric.
         */
        dimensions?: outputs.aws.ElastigroupScalingDownPolicyDimension[];
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods: number;
        /**
         * Specifies whether the scaling policy described in this block is enabled.
         */
        isEnabled?: boolean;
        /**
         * . The number of the desired target (and maximum) capacity
         */
        maxTargetCapacity?: string;
        /**
         * The maximal number of instances to have in the group.
         */
        maximum?: string;
        /**
         * The name of the metric, with or without spaces.
         */
        metricName: string;
        /**
         * The desired target capacity of a group. Required if using `"setMinTarget"` as action type
         */
        minTargetCapacity?: string;
        /**
         * The minimal number of instances to have in the group.
         */
        minimum?: string;
        /**
         * The namespace for the alarm's associated metric.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
         */
        operator: string;
        /**
         * The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
         */
        period: number;
        /**
         * The name of the policy.
         */
        policyName: string;
        /**
         * The source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
         */
        source: string;
        /**
         * The metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
         */
        statistic?: string;
        stepAdjustments?: outputs.aws.ElastigroupScalingDownPolicyStepAdjustment[];
        /**
         * The target number of instances to have in the group.
         */
        target?: string;
        /**
         * The value against which the specified statistic is compared in order to determine if a step should be applied.
         */
        threshold?: number;
        /**
         * The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
         */
        unit?: string;
    }

    export interface ElastigroupScalingDownPolicyDimension {
        /**
         * The group name.
         */
        name: string;
        /**
         * The dimension value.
         */
        value?: string;
    }

    export interface ElastigroupScalingDownPolicyStepAdjustment {
        /**
         * The action to take when scale up according to step's threshold is needed.
         */
        action: outputs.aws.ElastigroupScalingDownPolicyStepAdjustmentAction;
        /**
         * The value against which the specified statistic is compared. If a `stepAdjustment` object is defined, then it cannot be specified.
         */
        threshold: number;
    }

    export interface ElastigroupScalingDownPolicyStepAdjustmentAction {
        /**
         * The number of instances to add or remove.
         */
        adjustment?: string;
        /**
         * The desired target capacity of a group. Required if using `"setMaxTarget"` as action type
         */
        maxTargetCapacity?: string;
        /**
         * The upper limit number of instances that you can scale up to. Required if using `"updateCapacity"` as action type and neither `"target"` nor `"minimum"` are not defined.
         */
        maximum?: string;
        /**
         * The desired target capacity of a group. Required if using `"setMinTarget"` as action type
         */
        minTargetCapacity?: string;
        /**
         * The lower limit number of instances that you can scale down to. Required if using `"updateCapacity"` as action type and neither `"target"` nor `"maximum"` are not defined.
         */
        minimum?: string;
        /**
         * The desired number of instances. Required if using `"updateCapacity"` as action type and neither `"minimum"` nor `"maximum"` are not defined.
         */
        target?: string;
        /**
         * The type of the action to take when scale up is needed. Valid types: `"adjustment"`, `"updateCapacity"`, `"setMinTarget"`, `"percentageAdjustment"`.
         */
        type: string;
    }

    export interface ElastigroupScalingStrategy {
        /**
         * Specify whether to terminate instances at the end of each billing hour.
         */
        terminateAtEndOfBillingHour?: boolean;
        /**
         * Determines whether to terminate the newest instances when performing a scaling action. Valid values: `"default"`, `"newestInstance"`.
         */
        terminationPolicy?: string;
    }

    export interface ElastigroupScalingTargetPolicy {
        /**
         * Integer the amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
         */
        cooldown?: number;
        /**
         * A list of dimensions describing qualities of the metric.
         */
        dimensions?: outputs.aws.ElastigroupScalingTargetPolicyDimension[];
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods?: number;
        /**
         * String, restrict the maximal number of instances which can be added in each scale-up action.
         */
        maxCapacityPerScale?: string;
        /**
         * String, the name of the metric, with or without spaces.
         */
        metricName: string;
        /**
         * String, the namespace for the alarm's associated metric.
         */
        namespace: string;
        /**
         * The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
         */
        period?: number;
        /**
         * String, the name of the policy.
         */
        policyName: string;
        /**
         * Start a metric prediction process to determine the expected target metric value within the next two days. See [Predictive Autoscaling](https://api.spotinst.com/elastigroup-for-aws/concepts/scaling-concepts/predictive-autoscaling/) documentation for more info. Valid values: `FORECAST_AND_SCALE`, `FORECAST_ONLY`.
         */
        predictiveMode?: string;
        /**
         * String, the source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
         */
        source: string;
        /**
         * String, the metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
         */
        statistic?: string;
        /**
         * The target number of instances to have in the group.
         */
        target: number;
        /**
         * String, tThe unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
         */
        unit?: string;
    }

    export interface ElastigroupScalingTargetPolicyDimension {
        /**
         * The group name.
         */
        name: string;
        /**
         * The dimension value.
         */
        value?: string;
    }

    export interface ElastigroupScalingUpPolicy {
        /**
         * The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`. If a `stepAdjustment` object is defined, then it cannot be specified.
         */
        actionType?: string;
        /**
         * The number of instances to add/remove to/from the target capacity when scale is needed. Can be used as advanced expression for scaling of instances to add/remove to/from the target capacity when scale is needed. You can see more information here: Advanced expression. Example value: `"MAX(currCapacity / 5, value * 10)"`
         */
        adjustment?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
         */
        cooldown?: number;
        /**
         * A list of dimensions describing qualities of the metric.
         */
        dimensions?: outputs.aws.ElastigroupScalingUpPolicyDimension[];
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods: number;
        /**
         * Specifies whether the scaling policy described in this block is enabled.
         */
        isEnabled?: boolean;
        /**
         * The desired target capacity of a group. Required if using `"setMaxTarget"` as action type
         */
        maxTargetCapacity?: string;
        /**
         * The maximal number of instances to have in the group.
         */
        maximum?: string;
        /**
         * The name of the metric, with or without spaces.
         */
        metricName: string;
        /**
         * . The number of the desired target (and minimum) capacity
         */
        minTargetCapacity?: string;
        /**
         * The minimal number of instances to have in the group.
         */
        minimum?: string;
        /**
         * The namespace for the alarm's associated metric.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
         */
        operator: string;
        /**
         * The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
         */
        period: number;
        /**
         * The name of the policy.
         */
        policyName: string;
        /**
         * The source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
         */
        source: string;
        /**
         * The metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
         */
        statistic?: string;
        stepAdjustments?: outputs.aws.ElastigroupScalingUpPolicyStepAdjustment[];
        /**
         * The target number of instances to have in the group.
         */
        target?: string;
        /**
         * The value against which the specified statistic is compared in order to determine if a step should be applied.
         */
        threshold?: number;
        /**
         * The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
         */
        unit?: string;
    }

    export interface ElastigroupScalingUpPolicyDimension {
        /**
         * The group name.
         */
        name: string;
        /**
         * The dimension value.
         */
        value?: string;
    }

    export interface ElastigroupScalingUpPolicyStepAdjustment {
        /**
         * The action to take when scale up according to step's threshold is needed.
         */
        action: outputs.aws.ElastigroupScalingUpPolicyStepAdjustmentAction;
        /**
         * The value against which the specified statistic is compared. If a `stepAdjustment` object is defined, then it cannot be specified.
         */
        threshold: number;
    }

    export interface ElastigroupScalingUpPolicyStepAdjustmentAction {
        /**
         * The number of instances to add or remove.
         */
        adjustment?: string;
        /**
         * The desired target capacity of a group. Required if using `"setMaxTarget"` as action type
         */
        maxTargetCapacity?: string;
        /**
         * The upper limit number of instances that you can scale up to. Required if using `"updateCapacity"` as action type and neither `"target"` nor `"minimum"` are not defined.
         */
        maximum?: string;
        /**
         * The desired target capacity of a group. Required if using `"setMinTarget"` as action type
         */
        minTargetCapacity?: string;
        /**
         * The lower limit number of instances that you can scale down to. Required if using `"updateCapacity"` as action type and neither `"target"` nor `"maximum"` are not defined.
         */
        minimum?: string;
        /**
         * The desired number of instances. Required if using `"updateCapacity"` as action type and neither `"minimum"` nor `"maximum"` are not defined.
         */
        target?: string;
        /**
         * The type of the action to take when scale up is needed. Valid types: `"adjustment"`, `"updateCapacity"`, `"setMinTarget"`, `"percentageAdjustment"`.
         */
        type: string;
    }

    export interface ElastigroupScheduledTask {
        /**
         * The number of instances to add or remove.
         */
        adjustment?: string;
        /**
         * The percentage of instances to add or remove.
         */
        adjustmentPercentage?: string;
        /**
         * The percentage size of each batch in the scheduled deployment roll.
         */
        batchSizePercentage?: string;
        /**
         * A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
         */
        cronExpression?: string;
        /**
         * The recurrence frequency to run this task. Supported values are `"hourly"`, `"daily"`, `"weekly"` and `"continuous"`.
         */
        frequency?: string;
        /**
         * The period of time (seconds) to wait before checking a batch's health after it's deployment.
         */
        gracePeriod?: string;
        /**
         * Setting the task to being enabled or disabled.
         */
        isEnabled?: boolean;
        /**
         * The maximum number of instances the group should have.
         */
        maxCapacity?: string;
        /**
         * The minimum number of instances the group should have.
         */
        minCapacity?: string;
        /**
         * The maximum number of instances the group should have.
         */
        scaleMaxCapacity?: string;
        /**
         * The minimum number of instances the group should have.
         */
        scaleMinCapacity?: string;
        /**
         * The desired number of instances the group should have.
         */
        scaleTargetCapacity?: string;
        /**
         * Set a start time for one time tasks.
         */
        startTime?: string;
        /**
         * The desired number of instances the group should have.
         */
        targetCapacity?: string;
        /**
         * The task type to run. Supported task types are: `"scale"`, `"backupAmi"`, `"roll"`, `"scaleUp"`, `"percentageScaleUp"`, `"scaleDown"`, `"percentageScaleDown"`, `"statefulUpdateCapacity"`.
         */
        taskType: string;
    }

    export interface ElastigroupSignal {
        /**
         * The name of the signal defined for the group. Valid Values: `"INSTANCE_READY"`, `"INSTANCE_READY_TO_SHUTDOWN"`
         */
        name: string;
        /**
         * The signals defined timeout- default is 40 minutes (1800 seconds).
         */
        timeout?: number;
    }

    export interface ElastigroupStatefulDeallocation {
        /**
         * For stateful groups: remove persistent images.
         */
        shouldDeleteImages?: boolean;
        /**
         * For stateful groups: remove network interfaces.
         */
        shouldDeleteNetworkInterfaces?: boolean;
        /**
         * For stateful groups: remove snapshots.
         */
        shouldDeleteSnapshots?: boolean;
        /**
         * For stateful groups: remove persistent volumes.
         */
        shouldDeleteVolumes?: boolean;
    }

    export interface ElastigroupStatefulInstanceAction {
        /**
         * String, Stateful Instance ID on which the action should be performed.
         */
        statefulInstanceId: string;
        /**
         * String, Action type. Supported action types: `pause`, `resume`, `recycle`, `deallocate`.
         */
        type: string;
    }

    export interface ElastigroupTag {
        key?: string;
        /**
         * The dimension value.
         */
        value?: string;
    }

    export interface ElastigroupUpdatePolicy {
        /**
         * Enables updates to tags without rolling the group when set to `true`.
         */
        autoApplyTags?: boolean;
        /**
         * While used, you can control whether the group should perform a deployment after an update to the configuration.
         */
        rollConfig?: outputs.aws.ElastigroupUpdatePolicyRollConfig;
        /**
         * This will apply resuming action for Stateful instances in the Elastigroup upon scale up or capacity changes. Example usage will be for Elastigroups that will have scheduling rules to set a target capacity of 0 instances in the night and automatically restore the same state of the instances in the morning.
         */
        shouldResumeStateful: boolean;
        /**
         * Sets the enablement of the roll option.
         */
        shouldRoll: boolean;
    }

    export interface ElastigroupUpdatePolicyRollConfig {
        /**
         * The percentage size of each batch in the scheduled deployment roll.
         */
        batchSizePercentage: number;
        /**
         * The period of time (seconds) to wait before checking a batch's health after it's deployment.
         */
        gracePeriod?: number;
        /**
         * The service that will perform health checks for the instance. Valid values: `"ELB"`, `"HCS"`, `"TARGET_GROUP"`, `"MLB"`, `"EC2"`, `"MULTAI_TARGET_SET"`, `"MLB_RUNTIME"`, `"K8S_NODE"`, `"NOMAD_NODE"`, `"ECS_CLUSTER_INSTANCE"`.
         */
        healthCheckType?: string;
        /**
         * Strategy parameters
         */
        strategy?: outputs.aws.ElastigroupUpdatePolicyRollConfigStrategy;
        /**
         * For use with `shouldRoll`. Sets minimum % of roll required to complete before continuing the plan. Required if `waitForRollTimeout` is set.
         */
        waitForRollPercentage?: number;
        /**
         * For use with `shouldRoll`. Sets how long to wait for the deployed % of a roll to exceed `waitForRollPercentage` before continuing the plan. Required if `waitForRollPercentage` is set.
         */
        waitForRollTimeout?: number;
    }

    export interface ElastigroupUpdatePolicyRollConfigStrategy {
        /**
         * The action to take when scale up according to step's threshold is needed.
         */
        action: string;
        /**
         * Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the deployment will fail. Range `1` - `100`.
         */
        batchMinHealthyPercentage?: number;
        /**
         * Set detach options to the deployment.
         */
        onFailure?: outputs.aws.ElastigroupUpdatePolicyRollConfigStrategyOnFailure;
        /**
         * Bool value if to wait to drain instance
         */
        shouldDrainInstances?: boolean;
    }

    export interface ElastigroupUpdatePolicyRollConfigStrategyOnFailure {
        /**
         * The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`. If a `stepAdjustment` object is defined, then it cannot be specified.
         */
        actionType: string;
        batchNum?: number;
        /**
         * The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
         */
        drainingTimeout?: number;
        /**
         * Decrementing the group target capacity after detaching the instances.
         */
        shouldDecrementTargetCapacity?: boolean;
        /**
         * Indicator if the action should apply to all batches of the deployment or only the latest batch.
         */
        shouldHandleAllBatches?: boolean;
    }

    export interface ManagedInstanceBlockDeviceMapping {
        /**
         * The name of the device to mount.
         */
        deviceName: string;
        /**
         * Object
         */
        ebs?: outputs.aws.ManagedInstanceBlockDeviceMappingEbs;
    }

    export interface ManagedInstanceBlockDeviceMappingEbs {
        /**
         * Whether the volume should be destroyed on instance termination.
         */
        deleteOnTermination: boolean;
        /**
         * The amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). This must be set with a `volumeType` of `"io1"`.
         */
        iops?: number;
        /**
         * The throughput that the volume supports, in MiB/s. Minimum value of 125. Maximum value of 1000. Valid only if `volumeType` is set to `"gp3"`.
         */
        throughput?: number;
        /**
         * The size of the volume, in GiBs.
         */
        volumeSize?: number;
        /**
         * The type of volume. Can be `"standard"`, `"gp2"`, `"gp3"`, `"io1"`, `"st1"` or `"sc1"`.
         */
        volumeType: string;
    }

    export interface ManagedInstanceIntegrationRoute53 {
        /**
         * Route 53 Domain configurations.
         */
        domains: outputs.aws.ManagedInstanceIntegrationRoute53Domain[];
    }

    export interface ManagedInstanceIntegrationRoute53Domain {
        /**
         * The Route 53 Hosted Zone Id for the registered Domain.
         */
        hostedZoneId: string;
        /**
         * The type of the record set. Valid values: `"a"`, `"cname"`.
         */
        recordSetType?: string;
        /**
         * List of record sets
         */
        recordSets: outputs.aws.ManagedInstanceIntegrationRoute53DomainRecordSet[];
        /**
         * The Spotinst account ID that is linked to the AWS account that holds the Route 53 hosted Zone Id. The default is the user Spotinst account provided as a URL parameter.
         */
        spotinstAcctId?: string;
    }

    export interface ManagedInstanceIntegrationRoute53DomainRecordSet {
        /**
         * The ManagedInstance name.
         */
        name: string;
        /**
         * Designates whether the DNS address should be exposed to connections outside the VPC.
         */
        usePublicDns?: boolean;
        /**
         * Designates whether the IP address should be exposed to connections outside the VPC.
         */
        usePublicIp?: boolean;
    }

    export interface ManagedInstanceLoadBalancer {
        /**
         * The AWS resource ARN (Required only for ALB target groups).
         */
        arn?: string;
        /**
         * "Auto Weight" will automatically provide a higher weight for instances that are larger as appropriate. For example, if you have configured your Elastigroup with m4.large and m4.xlarge instances the m4.large will have half the weight of an m4.xlarge. This ensures that larger instances receive a higher number of MLB requests.
         */
        autoWeight?: boolean;
        /**
         * "AZ Awareness" will ensure that instances within the same AZ are using the corresponding MLB runtime instance in the same AZ. This feature reduces multi-zone data transfer fees.
         */
        azAwareness?: boolean;
        /**
         * The Multai load balancer ID. Example: lb-123456
         */
        balancerId?: string;
        /**
         * The AWS resource name. Required for Classic Load Balancer. Optional for Application Load Balancer.
         */
        name?: string;
        /**
         * The Multai load target set ID. Example: ts-123456
         */
        targetSetId?: string;
        /**
         * The resource type. Valid Values: `"CLASSIC"`, `"TARGET_GROUP"`, `"MULTAI_TARGET_SET"`.
         */
        type: string;
    }

    export interface ManagedInstanceManagedInstanceAction {
        /**
         * String, Action type. Supported action types: `pause`, `resume`, `recycle`.
         */
        type: string;
    }

    export interface ManagedInstanceNetworkInterface {
        /**
         * Indicates whether to assign an IPv6 address. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. Default: `false`
         */
        associateIpv6Address?: boolean;
        /**
         * Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is true.
         */
        associatePublicIpAddress?: boolean;
        /**
         * The position of the network interface in the attachment order. A primary network interface has a device index of 0. If you specify a network interface when launching an instance, you must specify the device index.
         */
        deviceIndex: string;
    }

    export interface ManagedInstanceResourceTagSpecification {
        /**
         * Tag specification for AMI resources.
         */
        shouldTagAmis?: boolean;
        /**
         * Tag specification for ENI resources.
         */
        shouldTagEnis?: boolean;
        /**
         * Tag specification for Snapshot resources.
         */
        shouldTagSnapshots?: boolean;
        /**
         * Tag specification for Volume resources.
         */
        shouldTagVolumes?: boolean;
    }

    export interface ManagedInstanceRevertToSpot {
        /**
         * Valid values: `"always"`, `"never"`, `"timeWindow"`. Default `"never"`.
         */
        performAt: string;
    }

    export interface ManagedInstanceScheduledTask {
        /**
         * A valid cron expression. The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of ‘frequency’ or ‘cronExpression’ should be used at a time.
         * Example: `"0 1 * * *"`.
         */
        cronExpression?: string;
        /**
         * Set frequency for the task. Valid values: "hourly", "daily", "weekly", "continuous".
         */
        frequency?: string;
        /**
         * Describes whether the task is enabled. When true the task should run when false it should not run.
         */
        isEnabled?: boolean;
        /**
         * DATETIME in ISO-8601 format. Sets a start time for scheduled actions. If "frequency" or "cronExpression" are not used - the task will run only once at the start time and will then be deleted from the instance configuration.
         * Example: `"2019-05-23T10:55:09Z"`
         */
        startTime?: string;
        /**
         * The task type to run. Valid values: `"pause"`, `"resume"`, `"recycle"`.
         */
        taskType: string;
    }

    export interface ManagedInstanceTag {
        /**
         * Tag's key.
         */
        key?: string;
        /**
         * Tag's name.
         */
        value?: string;
    }

    export interface MrScalarApplication {
        /**
         * Arguments for EMR to pass to the application.
         */
        args?: string[];
        /**
         * The MrScaler name.
         */
        name: string;
        /**
         * T he version of the application.
         */
        version?: string;
    }

    export interface MrScalarBootstrapActionsFile {
        /**
         * S3 Bucket name for configurations.
         */
        bucket: string;
        /**
         * Tag key.
         */
        key: string;
    }

    export interface MrScalarConfigurationsFile {
        /**
         * S3 Bucket name for configurations.
         */
        bucket: string;
        /**
         * Tag key.
         */
        key: string;
    }

    export interface MrScalarCoreEbsBlockDevice {
        /**
         * IOPS for the volume. Required in some volume types, such as io1.
         */
        iops?: number;
        /**
         * Size of the volume, in GBs.
         */
        sizeInGb: number;
        /**
         * volume type. Allowed values are 'gp2', 'io1' and others.
         */
        volumeType: string;
        /**
         * Amount of volumes per instance in the task group.
         */
        volumesPerInstance?: number;
    }

    export interface MrScalarCoreScalingDownPolicy {
        /**
         * The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
         */
        actionType?: string;
        /**
         * The number of instances to add/remove to/from the target capacity when scale is needed.
         */
        adjustment?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
         */
        cooldown: number;
        /**
         * A mapping of dimensions describing qualities of the metric.
         */
        dimensions?: {[key: string]: any};
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods: number;
        /**
         * Max target capacity for scale down.
         */
        maxTargetCapacity?: string;
        /**
         * The maximum to set when scale is needed.
         */
        maximum?: string;
        /**
         * The name of the metric in CloudWatch which the statement will be based on.
         */
        metricName: string;
        /**
         * Min target capacity for scale up.
         */
        minTargetCapacity?: string;
        /**
         * The minimum to set when scale is needed.
         */
        minimum?: string;
        /**
         * Must contain the value: `AWS/ElasticMapReduce`.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
         */
        operator: string;
        /**
         * The time window in seconds over which the statistic is applied.
         */
        period: number;
        /**
         * The name of the policy.
         */
        policyName: string;
        /**
         * The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
         */
        statistic: string;
        /**
         * The number of instances to set when scale is needed.
         */
        target?: string;
        /**
         * The value that the specified statistic is compared to.
         */
        threshold: number;
        /**
         * The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
         */
        unit: string;
    }

    export interface MrScalarCoreScalingUpPolicy {
        /**
         * The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
         */
        actionType?: string;
        /**
         * The number of instances to add/remove to/from the target capacity when scale is needed.
         */
        adjustment?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
         */
        cooldown: number;
        /**
         * A mapping of dimensions describing qualities of the metric.
         */
        dimensions?: {[key: string]: any};
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods: number;
        /**
         * Max target capacity for scale down.
         */
        maxTargetCapacity?: string;
        /**
         * The maximum to set when scale is needed.
         */
        maximum?: string;
        /**
         * The name of the metric in CloudWatch which the statement will be based on.
         */
        metricName: string;
        /**
         * Min target capacity for scale up.
         */
        minTargetCapacity?: string;
        /**
         * The minimum to set when scale is needed.
         */
        minimum?: string;
        /**
         * Must contain the value: `AWS/ElasticMapReduce`.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
         */
        operator: string;
        /**
         * The time window in seconds over which the statistic is applied.
         */
        period: number;
        /**
         * The name of the policy.
         */
        policyName: string;
        /**
         * The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
         */
        statistic: string;
        /**
         * The number of instances to set when scale is needed.
         */
        target?: string;
        /**
         * The value that the specified statistic is compared to.
         */
        threshold: number;
        /**
         * The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
         */
        unit: string;
    }

    export interface MrScalarInstanceWeight {
        /**
         * The type of the instance.
         */
        instanceType: string;
        /**
         * The weight given to the associated instance type.
         */
        weightedCapacity: number;
    }

    export interface MrScalarMasterEbsBlockDevice {
        /**
         * IOPS for the volume. Required in some volume types, such as io1.
         */
        iops?: number;
        /**
         * Size of the volume, in GBs.
         */
        sizeInGb: number;
        /**
         * volume type. Allowed values are 'gp2', 'io1' and others.
         */
        volumeType: string;
        /**
         * Amount of volumes per instance in the task group.
         */
        volumesPerInstance?: number;
    }

    export interface MrScalarProvisioningTimeout {
        /**
         * The amount of time (minutes) after which the cluster is automatically terminated if it's still in provisioning status. Minimum: '15'.
         */
        timeout: number;
        /**
         * The action to take if the timeout is exceeded. Valid values: `terminate`, `terminateAndRetry`.
         */
        timeoutAction: string;
    }

    export interface MrScalarScheduledTask {
        /**
         * A cron expression representing the schedule for the task.
         */
        cron: string;
        /**
         * New desired capacity for the elastigroup.
         */
        desiredCapacity?: string;
        /**
         * Select the EMR instance groups to execute the scheduled task on. Valid values: `task`.
         */
        instanceGroupType: string;
        /**
         * Enable/Disable the specified scheduling task.
         */
        isEnabled?: boolean;
        /**
         * New max capacity for the elastigroup.
         */
        maxCapacity?: string;
        /**
         * New min capacity for the elastigroup.
         */
        minCapacity?: string;
        /**
         * The type of task to be scheduled. Valid values: `setCapacity`.
         */
        taskType: string;
    }

    export interface MrScalarStepsFile {
        /**
         * S3 Bucket name for configurations.
         */
        bucket: string;
        /**
         * Tag key.
         */
        key: string;
    }

    export interface MrScalarTag {
        /**
         * Tag key.
         */
        key: string;
        /**
         * Tag value.
         */
        value: string;
    }

    export interface MrScalarTaskEbsBlockDevice {
        /**
         * IOPS for the volume. Required in some volume types, such as io1.
         */
        iops?: number;
        /**
         * Size of the volume, in GBs.
         */
        sizeInGb: number;
        /**
         * volume type. Allowed values are 'gp2', 'io1' and others.
         */
        volumeType: string;
        /**
         * Amount of volumes per instance in the task group.
         */
        volumesPerInstance?: number;
    }

    export interface MrScalarTaskScalingDownPolicy {
        /**
         * The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
         */
        actionType?: string;
        /**
         * The number of instances to add/remove to/from the target capacity when scale is needed.
         */
        adjustment?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
         */
        cooldown: number;
        /**
         * A mapping of dimensions describing qualities of the metric.
         */
        dimensions?: {[key: string]: any};
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods: number;
        /**
         * Max target capacity for scale down.
         */
        maxTargetCapacity?: string;
        /**
         * The maximum to set when scale is needed.
         */
        maximum?: string;
        /**
         * The name of the metric in CloudWatch which the statement will be based on.
         */
        metricName: string;
        /**
         * Min target capacity for scale up.
         */
        minTargetCapacity?: string;
        /**
         * The minimum to set when scale is needed.
         */
        minimum?: string;
        /**
         * Must contain the value: `AWS/ElasticMapReduce`.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
         */
        operator: string;
        /**
         * The time window in seconds over which the statistic is applied.
         */
        period: number;
        /**
         * The name of the policy.
         */
        policyName: string;
        /**
         * The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
         */
        statistic: string;
        /**
         * The number of instances to set when scale is needed.
         */
        target?: string;
        /**
         * The value that the specified statistic is compared to.
         */
        threshold: number;
        /**
         * The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
         */
        unit: string;
    }

    export interface MrScalarTaskScalingUpPolicy {
        /**
         * The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
         */
        actionType?: string;
        /**
         * The number of instances to add/remove to/from the target capacity when scale is needed.
         */
        adjustment?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
         */
        cooldown: number;
        /**
         * A mapping of dimensions describing qualities of the metric.
         */
        dimensions?: {[key: string]: any};
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods: number;
        /**
         * Max target capacity for scale down.
         */
        maxTargetCapacity?: string;
        /**
         * The maximum to set when scale is needed.
         */
        maximum?: string;
        /**
         * The name of the metric in CloudWatch which the statement will be based on.
         */
        metricName: string;
        /**
         * Min target capacity for scale up.
         */
        minTargetCapacity?: string;
        /**
         * The minimum to set when scale is needed.
         */
        minimum?: string;
        /**
         * Must contain the value: `AWS/ElasticMapReduce`.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
         */
        operator: string;
        /**
         * The time window in seconds over which the statistic is applied.
         */
        period: number;
        /**
         * The name of the policy.
         */
        policyName: string;
        /**
         * The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
         */
        statistic: string;
        /**
         * The number of instances to set when scale is needed.
         */
        target?: string;
        /**
         * The value that the specified statistic is compared to.
         */
        threshold: number;
        /**
         * The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
         */
        unit: string;
    }

    export interface MrScalarTerminationPolicy {
        statements: outputs.aws.MrScalarTerminationPolicyStatement[];
    }

    export interface MrScalarTerminationPolicyStatement {
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods?: number;
        /**
         * The name of the metric in CloudWatch which the statement will be based on.
         */
        metricName: string;
        /**
         * Must contain the value: `AWS/ElasticMapReduce`.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
         */
        operator?: string;
        /**
         * The time window in seconds over which the statistic is applied.
         */
        period?: number;
        /**
         * The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
         */
        statistic?: string;
        /**
         * The value that the specified statistic is compared to.
         */
        threshold: number;
        /**
         * The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
         */
        unit?: string;
    }

    export interface OceanAutoscaler {
        /**
         * Set the auto headroom percentage (a number in the range [0, 200]) which controls the percentage of headroom from the cluster. Relevant only when `autoscaleIsAutoConfig` toggled on.
         */
        autoHeadroomPercentage?: number;
        /**
         * Cooldown period between scaling actions.
         */
        autoscaleCooldown?: number;
        /**
         * Auto Scaling scale down operations.
         */
        autoscaleDown?: outputs.aws.OceanAutoscalerAutoscaleDown;
        /**
         * Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
         */
        autoscaleHeadroom?: outputs.aws.OceanAutoscalerAutoscaleHeadroom;
        /**
         * Automatically configure and optimize headroom resources.
         */
        autoscaleIsAutoConfig?: boolean;
        /**
         * Enable the Ocean Kubernetes Auto Scaler.
         */
        autoscaleIsEnabled?: boolean;
        /**
         * enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
         */
        enableAutomaticAndManualHeadroom?: boolean;
        /**
         * List of Ocean extended resource definitions to use in this cluster.
         */
        extendedResourceDefinitions?: string[];
        /**
         * Optionally set upper and lower bounds on the resource usage of the cluster.
         */
        resourceLimits?: outputs.aws.OceanAutoscalerResourceLimits;
    }

    export interface OceanAutoscalerAutoscaleDown {
        evaluationPeriods?: number;
        /**
         * Would represent the maximum % to scale-down. Number between 1-100.
         */
        maxScaleDownPercentage?: number;
    }

    export interface OceanAutoscalerAutoscaleHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the number of GPUs to allocate the headroom.
         */
        gpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MB) to allocate the headroom.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
         */
        numOfUnits?: number;
    }

    export interface OceanAutoscalerResourceLimits {
        /**
         * Maximum amount of Memory (GiB).
         */
        maxMemoryGib?: number;
        /**
         * Maximum number of vcpus available.
         */
        maxVcpu?: number;
    }

    export interface OceanBlockDeviceMapping {
        /**
         * String. Set device name. (Example: `/dev/xvda`).
         */
        deviceName?: string;
        /**
         * Object. Set Elastic Block Store properties .
         */
        ebs?: outputs.aws.OceanBlockDeviceMappingEbs;
    }

    export interface OceanBlockDeviceMappingEbs {
        /**
         * Boolean. Flag to delete the EBS on instance termination.
         */
        deleteOnTermination: boolean;
        /**
         * Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
         */
        dynamicVolumeSize?: outputs.aws.OceanBlockDeviceMappingEbsDynamicVolumeSize;
        /**
         * Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
         */
        encrypted: boolean;
        /**
         * Int. The number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
         */
        kmsKeyId?: string;
        /**
         * (Optional) String. The Snapshot ID to mount by.
         */
        snapshotId?: string;
        /**
         * The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volumeType` = `gp3`.
         */
        throughput?: number;
        /**
         * Int. The size, in GB of the volume.
         */
        volumeSize?: number;
        /**
         * String. The type of the volume. (Example: `gp2`).
         */
        volumeType: string;
    }

    export interface OceanBlockDeviceMappingEbsDynamicVolumeSize {
        /**
         * Int. Initial size for volume. (Example: 50)
         */
        baseSize: number;
        /**
         * String. Resource type to increase volume size dynamically by. (Valid values: `CPU`)
         */
        resource: string;
        /**
         * Int. Additional size (in GB) per resource unit. (Example: `baseSize=50`, `sizePerResourceUnit=20`, and instance with 2 CPU is launched; its total disk size will be: 90GB).
         */
        sizePerResourceUnit: number;
    }

    export interface OceanClusterOrientation {
        /**
         * You can control the approach that Ocean takes while launching nodes by configuring this value. Possible values: `costOriented`,`balanced`,`cheapest`.
         */
        availabilityVsCost?: string;
    }

    export interface OceanFilters {
        /**
         * The filtered instance types will support at least one of the architectures from this list.
         */
        architectures?: string[];
        /**
         * The filtered instance types will belong to one of the categories types from this list.
         */
        categories?: string[];
        /**
         * The filtered instance types will have one of the disk type from this list.
         */
        diskTypes?: string[];
        /**
         * Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
         */
        excludeFamilies?: string[];
        /**
         * In case excludeMetal is set to true, metal types will not be available for scaling.
         */
        excludeMetal?: boolean;
        /**
         * The filtered instance types will have a hypervisor type from this list.
         */
        hypervisors?: string[];
        /**
         * Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
         */
        includeFamilies?: string[];
        /**
         * Ena is supported or not.
         */
        isEnaSupported?: string;
        /**
         * Maximum total number of GPUs.
         */
        maxGpu?: number;
        /**
         * Maximum amount of Memory (GiB).
         */
        maxMemoryGib?: number;
        /**
         * Maximum Bandwidth in Gib/s of network performance.
         */
        maxNetworkPerformance?: number;
        /**
         * Maximum number of vcpus available.
         */
        maxVcpu?: number;
        /**
         * Minimum number of network interfaces (ENIs).
         */
        minEnis?: number;
        /**
         * Minimum total number of GPUs.
         */
        minGpu?: number;
        /**
         * Minimum amount of Memory (GiB).
         */
        minMemoryGib?: number;
        /**
         * Minimum Bandwidth in Gib/s of network performance.
         */
        minNetworkPerformance?: number;
        /**
         * Minimum number of vcpus available.
         */
        minVcpu?: number;
        /**
         * The filtered instance types will have a root device types from this list.
         */
        rootDeviceTypes?: string[];
        /**
         * The filtered instance types will support at least one of the virtualization types from this list.
         */
        virtualizationTypes?: string[];
    }

    export interface OceanInstanceMetadataOptions {
        /**
         * An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
         */
        httpPutResponseHopLimit?: number;
        /**
         * Determines if a signed token is required or not. Valid values: `optional` or `required`.
         */
        httpTokens: string;
    }

    export interface OceanLaunchSpecAutoscaleDown {
        /**
         * The maximum percentage allowed to scale down in a single scaling action on the nodes running in a specific VNG. Allowed only if maxScaleDownPercentage is set to null at the cluster level. Number between [0.1-100].
         */
        maxScaleDownPercentage?: number;
    }

    export interface OceanLaunchSpecAutoscaleHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the number of GPUS to allocate for each headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecAutoscaleHeadroomsAutomatic {
        /**
         * Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.`isEnabled` = true is set on the Ocean cluster.
         */
        autoHeadroomPercentage?: number;
    }

    export interface OceanLaunchSpecBlockDeviceMapping {
        /**
         * String. Set device name. (Example: `/dev/xvda`).
         */
        deviceName?: string;
        /**
         * Object. Set Elastic Block Store properties .
         */
        ebs?: outputs.aws.OceanLaunchSpecBlockDeviceMappingEbs;
        /**
         * String. Suppresses the specified device included in the block device mapping of the AMI.
         */
        noDevice?: string;
        virtualName?: string;
    }

    export interface OceanLaunchSpecBlockDeviceMappingEbs {
        /**
         * Boolean. Flag to delete the EBS on instance termination.
         */
        deleteOnTermination: boolean;
        /**
         * Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
         */
        dynamicVolumeSize?: outputs.aws.OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize;
        /**
         * Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
         */
        encrypted: boolean;
        /**
         * Int. The number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
         */
        kmsKeyId?: string;
        /**
         * (Optional) String. The Snapshot ID to mount by.
         */
        snapshotId?: string;
        /**
         * The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volumeType` = `gp3`.
         */
        throughput?: number;
        /**
         * Int. The size, in GB of the volume.
         */
        volumeSize?: number;
        /**
         * String. The type of the volume. (Example: `gp2`).
         */
        volumeType: string;
    }

    export interface OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize {
        /**
         * Int. Initial size for volume. (Example: 50)
         */
        baseSize: number;
        /**
         * String. Resource type to increase volume size dynamically by. (Valid values: `CPU`)
         */
        resource: string;
        /**
         * Int. Additional size (in GB) per resource unit. (Example: `baseSize=50`, `sizePerResourceUnit=20`, and instance with 2 CPU is launched; its total disk size will be: 90GB)
         */
        sizePerResourceUnit: number;
    }

    export interface OceanLaunchSpecCreateOptions {
        /**
         * When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group. The parameter is recommended in case the useAsTemplateOnly (in spotinst.aws.Ocean resource) is set to true during Ocean resource creation.
         */
        initialNodes?: number;
    }

    export interface OceanLaunchSpecDeleteOptions {
        /**
         * When set to "true", all instances belonging to the deleted launch specification will be drained, detached, and terminated.
         */
        deleteNodes?: boolean;
        /**
         * When set to `true`, delete even if it is the last Virtual Node Group (also, the default Virtual Node Group must be configured with `useAsTemlateOnly = true`). Should be set at creation or update, but will be used only at deletion.
         */
        forceDelete: boolean;
    }

    export interface OceanLaunchSpecElasticIpPool {
        /**
         * A key-value pair, which defines an Elastic IP from the customer pool. Can be null.
         */
        tagSelector?: outputs.aws.OceanLaunchSpecElasticIpPoolTagSelector;
    }

    export interface OceanLaunchSpecElasticIpPoolTagSelector {
        /**
         * Elastic IP tag key. The Virtual Node Group will consider all Elastic IPs tagged with this tag as a part of the Elastic IP pool to use.
         */
        tagKey: string;
        /**
         * Elastic IP tag value. Can be null.
         */
        tagValue?: string;
    }

    export interface OceanLaunchSpecImage {
        /**
         * ID of the image used to launch the instances.
         */
        imageId?: string;
    }

    export interface OceanLaunchSpecInstanceMetadataOptions {
        /**
         * An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
         */
        httpPutResponseHopLimit?: number;
        /**
         * Determines if a signed token is required or not. Valid values: `optional` or `required`.
         */
        httpTokens: string;
    }

    export interface OceanLaunchSpecLabel {
        /**
         * The taint key.
         */
        key: string;
        /**
         * The taint value.
         */
        value: string;
    }

    export interface OceanLaunchSpecResourceLimit {
        /**
         * Set a maximum number of instances per Virtual Node Group. Can be null. If set, value must be greater than or equal to 0.
         */
        maxInstanceCount?: number;
        /**
         * Set a minimum number of instances per Virtual Node Group. Can be null. If set, value must be greater than or equal to 0.
         */
        minInstanceCount?: number;
    }

    export interface OceanLaunchSpecSchedulingShutdownHours {
        /**
         * Flag to enable or disable the shutdown hours mechanism. When False, the mechanism is deactivated, and the virtual node group remains in its current state.
         */
        isEnabled?: boolean;
        /**
         * The times that the shutdown hours will apply.
         */
        timeWindows: string[];
    }

    export interface OceanLaunchSpecSchedulingTask {
        /**
         * A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
         */
        cronExpression: string;
        /**
         * Flag to enable or disable the shutdown hours mechanism. When False, the mechanism is deactivated, and the virtual node group remains in its current state.
         */
        isEnabled: boolean;
        /**
         * The config of this scheduled task. Depends on the value of taskType.
         */
        taskHeadrooms?: outputs.aws.OceanLaunchSpecSchedulingTaskTaskHeadroom[];
        /**
         * The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
         */
        taskType: string;
    }

    export interface OceanLaunchSpecSchedulingTaskTaskHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the number of GPUS to allocate for each headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecStrategy {
        /**
         * When set, Ocean will proactively try to maintain as close as possible to the percentage of Spot instances out of all the Virtual Node Group instances.
         */
        spotPercentage?: number;
    }

    export interface OceanLaunchSpecTag {
        /**
         * The taint key.
         */
        key: string;
        /**
         * The taint value.
         */
        value: string;
    }

    export interface OceanLaunchSpecTaint {
        /**
         * The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
         */
        effect: string;
        /**
         * The taint key.
         */
        key: string;
        /**
         * The taint value.
         */
        value: string;
    }

    export interface OceanLaunchSpecUpdatePolicy {
        rollConfig?: outputs.aws.OceanLaunchSpecUpdatePolicyRollConfig;
        shouldRoll: boolean;
    }

    export interface OceanLaunchSpecUpdatePolicyRollConfig {
        batchSizePercentage: number;
    }

    export interface OceanLoadBalancer {
        /**
         * Required if type is set to `TARGET_GROUP`
         */
        arn?: string;
        /**
         * Required if type is set to `CLASSIC`
         */
        name?: string;
        /**
         * Can be set to `CLASSIC` or `TARGET_GROUP`
         */
        type?: string;
    }

    export interface OceanLogging {
        /**
         * Logging Export configuration.
         */
        export?: outputs.aws.OceanLoggingExport;
    }

    export interface OceanLoggingExport {
        /**
         * Exports your cluster's logs to the S3 bucket and subdir configured on the S3 data integration given.
         */
        s3s?: outputs.aws.OceanLoggingExportS3[];
    }

    export interface OceanLoggingExportS3 {
        /**
         * The identifier of The S3 data integration to export the logs to.
         */
        id: string;
    }

    export interface OceanScheduledTask {
        shutdownHours?: outputs.aws.OceanScheduledTaskShutdownHours;
        tasks?: outputs.aws.OceanScheduledTaskTask[];
    }

    export interface OceanScheduledTaskShutdownHours {
        isEnabled?: boolean;
        timeWindows: string[];
    }

    export interface OceanScheduledTaskTask {
        cronExpression: string;
        isEnabled: boolean;
        taskType: string;
    }

    export interface OceanTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface OceanUpdatePolicy {
        /**
         * will update instance tags on the fly without rolling the cluster.
         */
        autoApplyTags?: boolean;
        /**
         * Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
         */
        conditionedRoll?: boolean;
        /**
         * While used, you can control whether the group should perform a deployment after an update to the configuration.
         */
        rollConfig?: outputs.aws.OceanUpdatePolicyRollConfig;
        /**
         * Enables the roll.
         */
        shouldRoll: boolean;
    }

    export interface OceanUpdatePolicyRollConfig {
        /**
         * Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
         */
        batchMinHealthyPercentage?: number;
        /**
         * Sets the percentage of the instances to deploy in each batch.
         */
        batchSizePercentage: number;
        /**
         * List of virtual node group identifiers to be rolled.
         */
        launchSpecIds?: string[];
        /**
         * During the roll, if the parameter is set to True we honor PDB during the instance replacement.
         */
        respectPdb?: boolean;
    }

    export interface SuspensionSuspension {
        /**
         * The name of process to suspend. Valid values: `"AUTO_HEALING" , "OUT_OF_STRATEGY", "PREVENTIVE_REPLACEMENT", "REVERT_PREFERRED", or "SCHEDULING"`.
         */
        name: string;
    }

}

export namespace azure {
    export interface ElastigroupHealthCheck {
        /**
         * Enable auto-healing of unhealthy VMs.
         */
        autoHealing?: boolean;
        /**
         * Period of time (seconds) to wait for VM to reach healthiness before monitoring for unhealthiness.
         */
        gracePeriod?: number;
        /**
         * Health check used to validate VM health. Valid values: “INSTANCE_STATE”.
         */
        healthCheckType: string;
    }

    export interface ElastigroupImage {
        customs?: outputs.azure.ElastigroupImageCustom[];
        marketplaces?: outputs.azure.ElastigroupImageMarketplace[];
    }

    export interface ElastigroupImageCustom {
        /**
         * Name of the custom image. Required if resourceGroupName is specified.
         */
        imageName: string;
        /**
         * The Resource Group that the user-assigned managed identity resides in.
         */
        resourceGroupName: string;
    }

    export interface ElastigroupImageMarketplace {
        /**
         * Name of the image to use. Required if publisher is specified.
         */
        offer: string;
        /**
         * Image publisher. Required if resourceGroupName is not specified.
         */
        publisher: string;
        /**
         * Image's Stock Keeping Unit, which is the specific version of the image. Required if publisher is specified.
         */
        sku: string;
    }

    export interface ElastigroupIntegrationKubernetes {
        /**
         * The cluster ID.
         */
        clusterIdentifier: string;
    }

    export interface ElastigroupIntegrationMultaiRuntime {
        /**
         * The deployment id you want to get
         */
        deploymentId: string;
    }

    export interface ElastigroupLoadBalancer {
        autoWeight?: boolean;
        /**
         * The balancer ID.
         */
        balancerId?: string;
        /**
         * The scale set ID associated with the load balancer.
         */
        targetSetId?: string;
        /**
         * The resource type. Valid values: CLASSIC, TARGET_GROUP, MULTAI_TARGET_SET.
         */
        type: string;
    }

    export interface ElastigroupLogin {
        /**
         * Password for admin access to Windows VMs. Required for Windows product types.
         */
        password?: string;
        /**
         * SSH for admin access to Linux VMs. Required for Linux product types.
         */
        sshPublicKey?: string;
        /**
         * Set admin access for accessing your VMs.
         */
        userName: string;
    }

    export interface ElastigroupManagedServiceIdentity {
        /**
         * The name of the managed identity.
         */
        name: string;
        /**
         * The Resource Group that the user-assigned managed identity resides in.
         */
        resourceGroupName: string;
    }

    export interface ElastigroupNetwork {
        /**
         * Array of additional IP configuration objects.
         */
        additionalIpConfigs?: outputs.azure.ElastigroupNetworkAdditionalIpConfig[];
        assignPublicIp?: boolean;
        /**
         * Vnet Resource Group Name.
         */
        resourceGroupName: string;
        /**
         * ID of subnet.
         */
        subnetName: string;
        /**
         * Name of Vnet.
         */
        virtualNetworkName: string;
    }

    export interface ElastigroupNetworkAdditionalIpConfig {
        /**
         * The name of the managed identity.
         */
        name: string;
        /**
         * Available from Azure Api-Version 2017-03-30 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Valid values: `IPv4`, `IPv6`.
         */
        privateIpVersion?: string;
    }

    export interface ElastigroupScalingDownPolicy {
        /**
         * The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`.
         */
        actionType?: string;
        /**
         * Value to which the action type will be adjusted. Required if using `numeric` or `percentageAdjustment` action types.
         */
        adjustment?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
         */
        cooldown: number;
        /**
         * A list of dimensions describing qualities of the metric. Required when `namespace` is defined AND not `"Microsoft.Compute"`.
         */
        dimensions?: outputs.azure.ElastigroupScalingDownPolicyDimension[];
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods: number;
        /**
         * . The number of the desired target (and maximum) capacity
         */
        maxTargetCapacity?: string;
        /**
         * The maximal number of instances to have in the group.
         */
        maximum?: string;
        /**
         * Metric to monitor by Azure metric display name.
         */
        metricName: string;
        /**
         * . The number of the desired target (and minimum) capacity
         */
        minTargetCapacity?: string;
        /**
         * The minimal number of instances to have in the group.
         */
        minimum?: string;
        /**
         * The namespace for the alarm's associated metric. Valid values:
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
         */
        operator: string;
        /**
         * The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
         */
        period: number;
        /**
         * The name of the policy.
         */
        policyName: string;
        /**
         * The metric statistics to return. Valid values: `average`.
         */
        statistic: string;
        /**
         * The target number of instances to have in the group.
         */
        target?: string;
        /**
         * The value against which the specified statistic is compared.
         */
        threshold: number;
        /**
         * The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
         */
        unit?: string;
    }

    export interface ElastigroupScalingDownPolicyDimension {
        /**
         * The name of the managed identity.
         */
        name: string;
        /**
         * The dimension value.
         */
        value?: string;
    }

    export interface ElastigroupScalingUpPolicy {
        /**
         * The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`.
         */
        actionType?: string;
        /**
         * Value to which the action type will be adjusted. Required if using `numeric` or `percentageAdjustment` action types.
         */
        adjustment?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
         */
        cooldown: number;
        /**
         * A list of dimensions describing qualities of the metric. Required when `namespace` is defined AND not `"Microsoft.Compute"`.
         */
        dimensions?: outputs.azure.ElastigroupScalingUpPolicyDimension[];
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods: number;
        /**
         * . The number of the desired target (and maximum) capacity
         */
        maxTargetCapacity?: string;
        /**
         * The maximal number of instances to have in the group.
         */
        maximum?: string;
        /**
         * Metric to monitor by Azure metric display name.
         */
        metricName: string;
        /**
         * . The number of the desired target (and minimum) capacity
         */
        minTargetCapacity?: string;
        /**
         * The minimal number of instances to have in the group.
         */
        minimum?: string;
        /**
         * The namespace for the alarm's associated metric. Valid values:
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
         */
        operator: string;
        /**
         * The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
         */
        period: number;
        /**
         * The name of the policy.
         */
        policyName: string;
        /**
         * The metric statistics to return. Valid values: `average`.
         */
        statistic: string;
        /**
         * The target number of instances to have in the group.
         */
        target?: string;
        /**
         * The value against which the specified statistic is compared.
         */
        threshold: number;
        /**
         * The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
         */
        unit?: string;
    }

    export interface ElastigroupScalingUpPolicyDimension {
        /**
         * The name of the managed identity.
         */
        name: string;
        /**
         * The dimension value.
         */
        value?: string;
    }

    export interface ElastigroupScheduledTask {
        /**
         * Value to which the action type will be adjusted. Required if using `numeric` or `percentageAdjustment` action types.
         */
        adjustment?: string;
        /**
         * The percent of instances to add/remove to/from the target capacity when scale is needed.
         */
        adjustmentPercentage?: string;
        /**
         * The percentage size of each batch in the scheduled deployment roll. Required when the 'task_type' is 'roll'.
         */
        batchSizePercentage?: string;
        /**
         * A valid cron expression (`* * * * *`). The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script.
         */
        cronExpression: string;
        /**
         * Period of time (seconds) to wait for VM to reach healthiness before monitoring for unhealthiness.
         */
        gracePeriod?: string;
        /**
         * Describes whether the task is enabled. When true the task should run when false it should not run.
         */
        isEnabled?: boolean;
        /**
         * The max capacity of the group. Required when ‘task_type' is ‘scale'.
         */
        scaleMaxCapacity?: string;
        /**
         * The min capacity of the group. Should be used when choosing ‘task_type' of ‘scale'.
         */
        scaleMinCapacity?: string;
        /**
         * The target capacity of the group. Should be used when choosing ‘task_type' of ‘scale'.
         */
        scaleTargetCapacity?: string;
        /**
         * The task type to run. Valid Values: `backupAmi`, `scale`, `scaleUp`, `roll`, `statefulUpdateCapacity`, `statefulRecycle`.
         */
        taskType: string;
    }

    export interface ElastigroupStrategy {
        /**
         * Time (seconds) to allow the instance to be drained from incoming TCP connections and detached from MLB before terminating it during a scale-down operation.
         */
        drainingTimeout?: number;
        /**
         * Percentage of Low Priority instances to maintain. Required if `odCount` is not specified.
         */
        lowPriorityPercentage?: number;
        /**
         * Number of On-Demand instances to maintain. Required if lowPriorityPercentage is not specified.
         */
        odCount?: number;
    }

    export interface ElastigroupUpdatePolicy {
        /**
         * While used, you can control whether the group should perform a deployment after an update to the configuration.
         */
        rollConfig?: outputs.azure.ElastigroupUpdatePolicyRollConfig;
        /**
         * Sets the enablement of the roll option.
         */
        shouldRoll: boolean;
    }

    export interface ElastigroupUpdatePolicyRollConfig {
        /**
         * The percentage size of each batch in the scheduled deployment roll. Required when the 'task_type' is 'roll'.
         */
        batchSizePercentage: number;
        /**
         * Period of time (seconds) to wait for VM to reach healthiness before monitoring for unhealthiness.
         */
        gracePeriod?: number;
        /**
         * Health check used to validate VM health. Valid values: “INSTANCE_STATE”.
         */
        healthCheckType?: string;
    }

    export interface OceanAutoscaler {
        /**
         * Auto Scaling scale down operations.
         */
        autoscaleDown: outputs.azure.OceanAutoscalerAutoscaleDown;
        /**
         * Spare Resource Capacity Management feature enables fast assignment of Pods without having to wait for new resources to be launched.
         */
        autoscaleHeadroom: outputs.azure.OceanAutoscalerAutoscaleHeadroom;
        /**
         * Enable the Ocean Kubernetes Autoscaler.
         */
        autoscaleIsEnabled: boolean;
        /**
         * Optionally set upper and lower bounds on the resource usage of the cluster.
         */
        resourceLimits: outputs.azure.OceanAutoscalerResourceLimits;
    }

    export interface OceanAutoscalerAutoscaleDown {
        /**
         * Would represent the maximum % to scale-down.
         */
        maxScaleDownPercentage: number;
    }

    export interface OceanAutoscalerAutoscaleHeadroom {
        /**
         * Automatic headroom configuration.
         */
        automatic: outputs.azure.OceanAutoscalerAutoscaleHeadroomAutomatic;
    }

    export interface OceanAutoscalerAutoscaleHeadroomAutomatic {
        /**
         * Enable automatic headroom. When set to `true`, Ocean configures and optimizes headroom automatically.
         */
        isEnabled: boolean;
        /**
         * Optionally set a number between 0-100 to control the percentage of total cluster resources dedicated to headroom. Relevant when `isEnabled` is toggled on.
         */
        percentage: number;
    }

    export interface OceanAutoscalerResourceLimits {
        /**
         * The maximum memory in GiB units that can be allocated to the cluster.
         */
        maxMemoryGib: number;
        /**
         * The maximum cpu in vCpu units that can be allocated to the cluster.
         */
        maxVcpu?: number;
    }

    export interface OceanExtension {
        /**
         * API version of the extension.
         */
        apiVersion: string;
        /**
         * Toggles whether auto upgrades are allowed.
         */
        minorVersionAutoUpgrade: boolean;
        /**
         * Name of the Load Balancer.
         */
        name: string;
        /**
         * Image publisher.
         */
        publisher: string;
        /**
         * The type of load balancer. Supported value: `loadBalancer`
         */
        type: string;
    }

    export interface OceanHealth {
        /**
         * The amount of time to wait, in seconds, from the moment the instance has launched before monitoring its health checks.
         */
        gracePeriod?: number;
    }

    export interface OceanImage {
        /**
         * Select an image from Azure's Marketplace image catalogue.
         */
        marketplaces: outputs.azure.OceanImageMarketplace[];
    }

    export interface OceanImageMarketplace {
        /**
         * Image name.
         */
        offer: string;
        /**
         * Image publisher.
         */
        publisher: string;
        /**
         * Image Stock Keeping Unit (which is the specific version of the image).
         */
        sku: string;
        /**
         * Image version.
         */
        version: string;
    }

    export interface OceanLoadBalancer {
        /**
         * Names of the Backend Pools to register the Cluster VMs to. Each Backend Pool is a separate load balancer.
         */
        backendPoolNames: string[];
        /**
         * Supported values: `Standard`, `Basic`.
         */
        loadBalancerSku: string;
        /**
         * Name of the Load Balancer.
         */
        name: string;
        /**
         * The Resource Group name of the Load Balancer.
         */
        resourceGroupName: string;
        /**
         * The type of load balancer. Supported value: `loadBalancer`
         */
        type: string;
    }

    export interface OceanManagedServiceIdentity {
        /**
         * Name of the Load Balancer.
         */
        name: string;
        /**
         * The Resource Group name of the Load Balancer.
         */
        resourceGroupName: string;
    }

    export interface OceanNetwork {
        /**
         * A list of virtual network interfaces. The publicIpSku must be identical between all the network interfaces. One network interface must be set as the primary.
         */
        networkInterfaces: outputs.azure.OceanNetworkNetworkInterface[];
        /**
         * The Resource Group name of the Load Balancer.
         */
        resourceGroupName: string;
        /**
         * Virtual network.
         */
        virtualNetworkName: string;
    }

    export interface OceanNetworkNetworkInterface {
        /**
         * Additional configuration of network interface. The name fields between all the `additionalIpConfig` must be unique.
         */
        additionalIpConfigs: outputs.azure.OceanNetworkNetworkInterfaceAdditionalIpConfig[];
        /**
         * Assign public IP.
         */
        assignPublicIp: boolean;
        /**
         * Defines whether the network interface is primary or not.
         */
        isPrimary: boolean;
        securityGroup: outputs.azure.OceanNetworkNetworkInterfaceSecurityGroup;
        /**
         * Subnet name.
         */
        subnetName: string;
    }

    export interface OceanNetworkNetworkInterfaceAdditionalIpConfig {
        /**
         * Name of the Load Balancer.
         */
        name: string;
        /**
         * Supported values: `IPv4`, `IPv6`.
         */
        privateIpVersion: string;
    }

    export interface OceanNetworkNetworkInterfaceSecurityGroup {
        /**
         * Name of the Load Balancer.
         */
        name: string;
        /**
         * The Resource Group name of the Load Balancer.
         */
        resourceGroupName: string;
    }

    export interface OceanNpAutoscaler {
        autoscaleDown: outputs.azure.OceanNpAutoscalerAutoscaleDown;
        autoscaleHeadroom: outputs.azure.OceanNpAutoscalerAutoscaleHeadroom;
        autoscaleIsEnabled?: boolean;
        resourceLimits: outputs.azure.OceanNpAutoscalerResourceLimits;
    }

    export interface OceanNpAutoscalerAutoscaleDown {
        maxScaleDownPercentage?: number;
    }

    export interface OceanNpAutoscalerAutoscaleHeadroom {
        automatic: outputs.azure.OceanNpAutoscalerAutoscaleHeadroomAutomatic;
    }

    export interface OceanNpAutoscalerAutoscaleHeadroomAutomatic {
        isEnabled?: boolean;
        percentage: number;
    }

    export interface OceanNpAutoscalerResourceLimits {
        maxMemoryGib?: number;
        maxVcpu?: number;
    }

    export interface OceanNpHealth {
        gracePeriod?: number;
    }

    export interface OceanNpTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface OceanNpVirtualNodeGroupHeadroom {
        cpuPerUnit?: number;
        gpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits: number;
    }

    export interface OceanNpVirtualNodeGroupTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface OceanOsDisk {
        /**
         * The size of the OS disk in GB.
         */
        sizeGb: number;
        /**
         * The type of load balancer. Supported value: `loadBalancer`
         */
        type?: string;
    }

    export interface OceanStrategy {
        /**
         * If no spot instance markets are available, enable Ocean to launch on-demand instances instead.
         */
        fallbackToOndemand?: boolean;
        /**
         * Percentage of Spot VMs to maintain.
         */
        spotPercentage?: number;
    }

    export interface OceanTag {
        /**
         * Tag key.
         */
        key?: string;
        /**
         * Tag value.
         */
        value?: string;
    }

    export interface OceanVirtualNodeGroupAutoscale {
        /**
         * Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when `cluster.autoScaler.headroom.automatic.is_enabled` = true is set on the Ocean cluster.
         */
        autoHeadroomPercentage?: number;
        autoscaleHeadrooms?: outputs.azure.OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom[];
    }

    export interface OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom {
        /**
         * Configure the number of CPUs to allocate for the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * How many GPU cores should be allocated for headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Configure the amount of memory (MiB) to allocate the headroom.
         */
        memoryPerUnit?: number;
        /**
         * The number of headroom units to maintain, where each unit has the defined CPU, memory and GPU.
         */
        numOfUnits: number;
    }

    export interface OceanVirtualNodeGroupLabel {
        /**
         * Tag Key for Vms in the cluster.
         */
        key: string;
        /**
         * Tag Value for VMs in the cluster.
         */
        value?: string;
    }

    export interface OceanVirtualNodeGroupLaunchSpecification {
        /**
         * The maximum number of pods per node in an AKS cluster.
         */
        maxPods?: number;
        /**
         * Specify OS disk specification other than default.
         */
        osDisk?: outputs.azure.OceanVirtualNodeGroupLaunchSpecificationOsDisk;
        /**
         * Additional key-value pairs to be used to tag the VMs in the virtual node group.
         */
        tags?: outputs.azure.OceanVirtualNodeGroupLaunchSpecificationTag[];
    }

    export interface OceanVirtualNodeGroupLaunchSpecificationOsDisk {
        /**
         * The size of the OS disk in GB, Required if dataDisks is specified.
         */
        sizeGb: number;
        /**
         * The type of the OS disk. Valid values: `"Standard_LRS"`, `"Premium_LRS"`, `"StandardSSD_LRS"`.
         */
        type?: string;
        /**
         * Flag to enable/disable the Ephemeral OS Disk utilization.
         */
        utilizeEphemeralStorage?: boolean;
    }

    export interface OceanVirtualNodeGroupLaunchSpecificationTag {
        /**
         * Tag Key for Vms in the cluster.
         */
        key?: string;
        /**
         * Tag Value for VMs in the cluster.
         */
        value?: string;
    }

    export interface OceanVirtualNodeGroupResourceLimit {
        /**
         * Option to set a maximum number of instances per virtual node group. If set, value must be greater than or equal to 0.
         */
        maxInstanceCount?: number;
    }

    export interface OceanVirtualNodeGroupTaint {
        /**
         * The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`, `"PreferNoExecute"`.
         */
        effect: string;
        /**
         * Tag Key for Vms in the cluster.
         */
        key: string;
        /**
         * Tag Value for VMs in the cluster.
         */
        value: string;
    }

    export interface OceanVmSize {
        /**
         * VM types allowed in the Ocean cluster.
         */
        whitelists?: string[];
    }

}

export namespace ecs {
    export interface OceanAutoscaler {
        /**
         * The auto-headroom percentage. Set a number between 0-200 to control the headroom % of the cluster. Relevant when `isAutoConfig`= true.
         */
        autoHeadroomPercentage?: number;
        /**
         * Cooldown period between scaling actions.
         */
        cooldown?: number;
        /**
         * Auto Scaling scale down operations.
         */
        down?: outputs.ecs.OceanAutoscalerDown;
        /**
         * When set to true, both automatic and per custom launch specification manual headroom to be saved concurrently and independently in the cluster. prerequisite: isAutoConfig must be true
         */
        enableAutomaticAndManualHeadroom?: boolean;
        /**
         * Spare resource capacity management enabling fast assignment of tasks without waiting for new resources to launch.
         */
        headroom?: outputs.ecs.OceanAutoscalerHeadroom;
        /**
         * Automatically configure and optimize headroom resources.
         */
        isAutoConfig?: boolean;
        /**
         * Enable the Ocean ECS autoscaler.
         */
        isEnabled?: boolean;
        /**
         * Optionally set upper and lower bounds on the resource usage of the cluster.
         */
        resourceLimits?: outputs.ecs.OceanAutoscalerResourceLimits;
        /**
         * Option to scale down non-service tasks. If not set, Ocean does not scale down standalone tasks.
         */
        shouldScaleDownNonServiceTasks?: boolean;
    }

    export interface OceanAutoscalerDown {
        /**
         * Would represent the maximum % to scale-down. Number between 1-100.
         */
        maxScaleDownPercentage?: number;
    }

    export interface OceanAutoscalerHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MB) to allocate the headroom.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
         */
        numOfUnits?: number;
    }

    export interface OceanAutoscalerResourceLimits {
        /**
         * Maximum amount of Memory (GiB).
         */
        maxMemoryGib?: number;
        /**
         * Maximum number of vcpus available.
         */
        maxVcpu?: number;
    }

    export interface OceanBlockDeviceMapping {
        /**
         * String. Set device name. Example: `/dev/xvda1`.
         */
        deviceName: string;
        /**
         * Object. Set Elastic Block Store properties.
         */
        ebs?: outputs.ecs.OceanBlockDeviceMappingEbs;
        /**
         * String. Suppresses the specified device included in the block device mapping of the AMI.
         */
        noDevice?: string;
        virtualName?: string;
    }

    export interface OceanBlockDeviceMappingEbs {
        /**
         * Boolean. Toggles EBS deletion upon instance termination.
         */
        deleteOnTermination: boolean;
        /**
         * Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
         */
        dynamicVolumeSize?: outputs.ecs.OceanBlockDeviceMappingEbsDynamicVolumeSize;
        /**
         * Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
         */
        encrypted: boolean;
        /**
         * Int. The number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
         */
        kmsKeyId?: string;
        /**
         * (Optional) String. The snapshot ID to mount by.
         */
        snapshotId?: string;
        /**
         * The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volumeType` = gp3.
         */
        throughput?: number;
        /**
         * Int. The size (in GB) of the volume.
         */
        volumeSize?: number;
        /**
         * String. The type of the volume. Example: `gp2`.
         */
        volumeType: string;
    }

    export interface OceanBlockDeviceMappingEbsDynamicVolumeSize {
        /**
         * Int. Initial size for volume. Example: `50`.
         */
        baseSize: number;
        /**
         * String. Resource type to increase volume size dynamically by. Valid values: `CPU`.
         */
        resource: string;
        /**
         * Int. Additional size (in GB) per resource unit. Example: When the `baseSize=50`, `sizePerResourceUnit=20`, and instance with two CPUs is launched, its total disk size will be: 90GB.
         */
        sizePerResourceUnit: number;
    }

    export interface OceanClusterOrientation {
        /**
         * You can control the approach that Ocean takes while launching nodes by configuring this value. Possible values: `costOriented`,`balanced`,`cheapest`.
         */
        availabilityVsCost?: string;
    }

    export interface OceanFilters {
        /**
         * The filtered instance types will support at least one of the architectures from this list.
         */
        architectures?: string[];
        /**
         * The filtered instance types will belong to one of the categories types from this list.
         */
        categories?: string[];
        /**
         * The filtered instance types will have one of the disk type from this list.
         */
        diskTypes?: string[];
        /**
         * Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
         */
        excludeFamilies?: string[];
        /**
         * In case excludeMetal is set to true, metal types will not be available for scaling.
         */
        excludeMetal?: boolean;
        /**
         * The filtered instance types will have a hypervisor type from this list.
         */
        hypervisors?: string[];
        /**
         * Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
         */
        includeFamilies?: string[];
        /**
         * Ena is supported or not.
         */
        isEnaSupported?: string;
        /**
         * Maximum total number of GPUs.
         */
        maxGpu?: number;
        /**
         * Maximum amount of Memory (GiB).
         */
        maxMemoryGib?: number;
        /**
         * Maximum Bandwidth in Gib/s of network performance.
         */
        maxNetworkPerformance?: number;
        /**
         * Maximum number of vcpus available.
         */
        maxVcpu?: number;
        /**
         * Minimum number of network interfaces (ENIs).
         */
        minEnis?: number;
        /**
         * Minimum total number of GPUs.
         */
        minGpu?: number;
        /**
         * Minimum amount of Memory (GiB).
         */
        minMemoryGib?: number;
        /**
         * Minimum Bandwidth in Gib/s of network performance.
         */
        minNetworkPerformance?: number;
        /**
         * Minimum number of vcpus available.
         */
        minVcpu?: number;
        /**
         * The filtered instance types will have a root device types from this list.
         */
        rootDeviceTypes?: string[];
        /**
         * The filtered instance types will support at least one of the virtualization types from this list.
         */
        virtualizationTypes?: string[];
    }

    export interface OceanInstanceMetadataOptions {
        /**
         * An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
         */
        httpPutResponseHopLimit?: number;
        /**
         * Determines if a signed token is required or not. Valid values: `optional` or `required`.
         */
        httpTokens: string;
    }

    export interface OceanLaunchSpecAttribute {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface OceanLaunchSpecAutoscaleHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecBlockDeviceMapping {
        deviceName: string;
        ebs?: outputs.ecs.OceanLaunchSpecBlockDeviceMappingEbs;
        noDevice?: string;
        virtualName?: string;
    }

    export interface OceanLaunchSpecBlockDeviceMappingEbs {
        deleteOnTermination: boolean;
        dynamicVolumeSize?: outputs.ecs.OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize;
        encrypted: boolean;
        iops?: number;
        kmsKeyId?: string;
        snapshotId?: string;
        throughput?: number;
        volumeSize?: number;
        volumeType: string;
    }

    export interface OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize {
        baseSize: number;
        resource: string;
        sizePerResourceUnit: number;
    }

    export interface OceanLaunchSpecInstanceMetadataOptions {
        /**
         * An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
         */
        httpPutResponseHopLimit?: number;
        /**
         * Determines if a signed token is required or not. Valid values: `optional` or `required`.
         */
        httpTokens: string;
    }

    export interface OceanLaunchSpecSchedulingTask {
        /**
         * A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
         */
        cronExpression: string;
        /**
         * Describes whether the task is enabled. When True, the task runs. When False, it does not run.
         */
        isEnabled: boolean;
        /**
         * The config of this scheduled task. Depends on the value of taskType.
         */
        taskHeadrooms?: outputs.ecs.OceanLaunchSpecSchedulingTaskTaskHeadroom[];
        /**
         * The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
         */
        taskType: string;
    }

    export interface OceanLaunchSpecSchedulingTaskTaskHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecStrategy {
        /**
         * When set, Ocean will proactively try to maintain as close as possible to the percentage of Spot instances out of all the Virtual Node Group instances.
         */
        spotPercentage?: number;
    }

    export interface OceanLaunchSpecTag {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface OceanLogging {
        /**
         * Logging Export configuration.
         */
        export?: outputs.ecs.OceanLoggingExport;
    }

    export interface OceanLoggingExport {
        /**
         * Exports your cluster's logs to the S3 bucket and subdir configured on the S3 data integration given.
         */
        s3s?: outputs.ecs.OceanLoggingExportS3[];
    }

    export interface OceanLoggingExportS3 {
        /**
         * The identifier of The S3 data integration to export the logs to.
         */
        id: string;
    }

    export interface OceanOptimizeImages {
        /**
         * String. Valid values: "always" "never" "timeWindow".
         */
        performAt: string;
        /**
         * Boolean. Enable auto image (AMI) update for the ECS container instances. The auto update applies for ECS-Optimized AMIs.
         */
        shouldOptimizeEcsAmi: boolean;
        /**
         * Array of strings. Set time windows for image update, at least one time window. Each string is in the format of ddd:hh:mm-ddd:hh:mm ddd. Time windows should not overlap.
         */
        timeWindows?: string[];
    }

    export interface OceanScheduledTask {
        /**
         * Set shutdown hours for cluster object.
         */
        shutdownHours?: outputs.ecs.OceanScheduledTaskShutdownHours;
        /**
         * The scheduling tasks for the cluster.
         */
        tasks?: outputs.ecs.OceanScheduledTaskTask[];
    }

    export interface OceanScheduledTaskShutdownHours {
        /**
         * Enable the Ocean ECS autoscaler.
         */
        isEnabled?: boolean;
        /**
         * Array of strings. Set time windows for image update, at least one time window. Each string is in the format of ddd:hh:mm-ddd:hh:mm ddd. Time windows should not overlap.
         */
        timeWindows: string[];
    }

    export interface OceanScheduledTaskTask {
        /**
         * A valid cron expression. The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of `frequency` or `cronExpression` should be used at a time. Required for `cluster.scheduling.tasks` object. Example: `0 1 * * *`.
         */
        cronExpression: string;
        /**
         * Enable the Ocean ECS autoscaler.
         */
        isEnabled: boolean;
        /**
         * Valid values: "clusterRoll". Required for `cluster.scheduling.tasks object`. Example: `clusterRoll`.
         */
        taskType: string;
    }

    export interface OceanTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface OceanUpdatePolicy {
        /**
         * will update instance tags on the fly without rolling the cluster.
         */
        autoApplyTags?: boolean;
        /**
         * Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
         */
        conditionedRoll?: boolean;
        rollConfig?: outputs.ecs.OceanUpdatePolicyRollConfig;
        /**
         * Enables the roll.
         */
        shouldRoll: boolean;
    }

    export interface OceanUpdatePolicyRollConfig {
        /**
         * Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
         */
        batchMinHealthyPercentage?: number;
        /**
         * Sets the percentage of the instances to deploy in each batch.
         */
        batchSizePercentage: number;
    }

}

export namespace gcp {
    export interface ElastigroupBackendService {
        /**
         * Sets which location the backend services will be active. Valid values: `regional`, `global`.
         */
        locationType?: string;
        /**
         * Describes a named port and a list of ports.
         */
        namedPorts?: outputs.gcp.ElastigroupBackendServiceNamedPort[];
        /**
         * Use when `locationType` is "regional". Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: `INTERNAL`, `EXTERNAL`.
         */
        scheme?: string;
        /**
         * The name of the backend service.
         */
        serviceName: string;
    }

    export interface ElastigroupBackendServiceNamedPort {
        /**
         * The group name.
         */
        name: string;
        /**
         * A list of ports.
         */
        ports: string[];
    }

    export interface ElastigroupDisk {
        /**
         * Specifies whether the disk will be auto-deleted when the instance is deleted.
         */
        autoDelete?: boolean;
        /**
         * Indicates that this is a boot disk. The virtual machine will use the first partition of the disk for its root filesystem.
         */
        boot?: boolean;
        /**
         * Specifies a unique device name of your choice.
         */
        deviceName?: string;
        /**
         * Specifies the parameters for a new disk that will be created alongside the new instance. Use initialization parameters to create boot disks or local SSDs attached to the new instance.
         */
        initializeParams?: outputs.gcp.ElastigroupDiskInitializeParam[];
        /**
         * Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME.
         */
        interface?: string;
        /**
         * The mode in which to attach this disk, either READ_WRITE or READ_ONLY.
         */
        mode?: string;
        /**
         * Specifies a valid partial or full URL to an existing Persistent Disk resource. This field is only applicable for persistent disks.
         */
        source?: string;
        /**
         * The type of GPU instance. Valid values: `nvidia-tesla-v100`, `nvidia-tesla-p100`, `nvidia-tesla-k80`.
         */
        type?: string;
    }

    export interface ElastigroupDiskInitializeParam {
        /**
         * Specifies disk size in gigabytes. Must be in increments of 2.
         */
        diskSizeGb?: string;
        /**
         * Specifies the disk type to use to create the instance. Valid values: pd-ssd, local-ssd.
         */
        diskType?: string;
        /**
         * A source image used to create the disk. You can provide a private (custom) image, and Compute Engine will use the corresponding image from your project.
         */
        sourceImage: string;
    }

    export interface ElastigroupGpu {
        /**
         * The number of GPUs. Must be 0, 2, 4, 6, 8.
         */
        count: number;
        /**
         * The type of GPU instance. Valid values: `nvidia-tesla-v100`, `nvidia-tesla-p100`, `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface ElastigroupInstanceTypesCustom {
        /**
         * The memory (in GiB) in the custom instance types. GCP has a number of limitations on accepted memory values.For more information, see the GCP documentation (here.)[https://cloud.google.com/compute/docs/instances/creating-instance-with-custom-machine-type#specifications]
         */
        memoryGib: number;
        vcpu: number;
    }

    export interface ElastigroupIntegrationDockerSwarm {
        /**
         * IP or FQDN of one of your swarm managers.
         */
        masterHost: string;
        /**
         * Network port used by your swarm.
         */
        masterPort: number;
    }

    export interface ElastigroupIntegrationGke {
        autoUpdate?: boolean;
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.gcp.ElastigroupIntegrationGkeAutoscaleDown;
        autoscaleHeadroom?: outputs.gcp.ElastigroupIntegrationGkeAutoscaleHeadroom;
        autoscaleIsAutoConfig?: boolean;
        autoscaleIsEnabled?: boolean;
        autoscaleLabels?: outputs.gcp.ElastigroupIntegrationGkeAutoscaleLabel[];
        clusterId?: string;
        location?: string;
    }

    export interface ElastigroupIntegrationGkeAutoscaleDown {
        /**
         * Number of consecutive periods in which the threshold must be met in order to trigger a scaling action.
         */
        evaluationPeriods?: number;
    }

    export interface ElastigroupIntegrationGkeAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationGkeAutoscaleLabel {
        /**
         * Labels key.
         */
        key: string;
        /**
         * Labels value.
         */
        value: string;
    }

    export interface ElastigroupLabel {
        /**
         * Labels key.
         */
        key: string;
        /**
         * Labels value.
         */
        value: string;
    }

    export interface ElastigroupMetadata {
        /**
         * Labels key.
         */
        key: string;
        /**
         * Labels value.
         */
        value: string;
    }

    export interface ElastigroupNetworkInterface {
        /**
         * Array of configurations.
         */
        accessConfigs?: outputs.gcp.ElastigroupNetworkInterfaceAccessConfig[];
        aliasIpRanges?: outputs.gcp.ElastigroupNetworkInterfaceAliasIpRange[];
        /**
         * Network resource for this group.
         */
        network: string;
    }

    export interface ElastigroupNetworkInterfaceAccessConfig {
        /**
         * The group name.
         */
        name?: string;
        /**
         * The type of GPU instance. Valid values: `nvidia-tesla-v100`, `nvidia-tesla-p100`, `nvidia-tesla-k80`.
         */
        type?: string;
    }

    export interface ElastigroupNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName: string;
    }

    export interface ElastigroupScalingDownPolicy {
        /**
         * Type of scaling action to take when the scaling policy is triggered. Valid values: "adjustment", "setMinTarget", "updateCapacity", "percentageAdjustment"
         */
        actionType?: string;
        /**
         * Value to which the action type will be adjusted. Required if using "numeric" or "percentageAdjustment" action types.
         */
        adjustment?: number;
        /**
         * Time (seconds) to wait after a scaling action before resuming monitoring.
         */
        cooldown: number;
        /**
         * A list of dimensions describing qualities of the metric.
         */
        dimensions?: outputs.gcp.ElastigroupScalingDownPolicyDimension[];
        /**
         * Number of consecutive periods in which the threshold must be met in order to trigger a scaling action.
         */
        evaluationPeriods: number;
        /**
         * Metric to monitor. Valid values: "Percentage CPU", "Network In", "Network Out", "Disk Read Bytes", "Disk Write Bytes", "Disk Write Operations/Sec", "Disk Read Operations/Sec".
         */
        metricName: string;
        namespace: string;
        /**
         * The operator used to evaluate the threshold against the current metric value. Valid values: "gt" (greater than), "get" (greater-than or equal), "lt" (less than), "lte" (less than or equal).
         */
        operator: string;
        /**
         * Amount of time (seconds) for which the threshold must be met in order to trigger the scaling action.
         */
        period: number;
        /**
         * Name of scaling policy.
         */
        policyName: string;
        /**
         * Specifies a valid partial or full URL to an existing Persistent Disk resource. This field is only applicable for persistent disks.
         */
        source: string;
        /**
         * Statistic by which to evaluate the selected metric. Valid values: "AVERAGE", "SAMPLE_COUNT", "SUM", "MINIMUM", "MAXIMUM", "PERCENTILE", "COUNT".
         */
        statistic: string;
        /**
         * The value at which the scaling action is triggered.
         */
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingDownPolicyDimension {
        /**
         * The group name.
         */
        name: string;
        /**
         * Labels value.
         */
        value?: string;
    }

    export interface ElastigroupScalingUpPolicy {
        /**
         * Type of scaling action to take when the scaling policy is triggered. Valid values: "adjustment", "setMinTarget", "updateCapacity", "percentageAdjustment"
         */
        actionType?: string;
        /**
         * Value to which the action type will be adjusted. Required if using "numeric" or "percentageAdjustment" action types.
         */
        adjustment?: number;
        /**
         * Time (seconds) to wait after a scaling action before resuming monitoring.
         */
        cooldown: number;
        /**
         * A list of dimensions describing qualities of the metric.
         */
        dimensions?: outputs.gcp.ElastigroupScalingUpPolicyDimension[];
        /**
         * Number of consecutive periods in which the threshold must be met in order to trigger a scaling action.
         */
        evaluationPeriods: number;
        /**
         * Metric to monitor. Valid values: "Percentage CPU", "Network In", "Network Out", "Disk Read Bytes", "Disk Write Bytes", "Disk Write Operations/Sec", "Disk Read Operations/Sec".
         */
        metricName: string;
        namespace: string;
        /**
         * The operator used to evaluate the threshold against the current metric value. Valid values: "gt" (greater than), "get" (greater-than or equal), "lt" (less than), "lte" (less than or equal).
         */
        operator: string;
        /**
         * Amount of time (seconds) for which the threshold must be met in order to trigger the scaling action.
         */
        period: number;
        /**
         * Name of scaling policy.
         */
        policyName: string;
        /**
         * Specifies a valid partial or full URL to an existing Persistent Disk resource. This field is only applicable for persistent disks.
         */
        source: string;
        /**
         * Statistic by which to evaluate the selected metric. Valid values: "AVERAGE", "SAMPLE_COUNT", "SUM", "MINIMUM", "MAXIMUM", "PERCENTILE", "COUNT".
         */
        statistic: string;
        /**
         * The value at which the scaling action is triggered.
         */
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingUpPolicyDimension {
        /**
         * The group name.
         */
        name: string;
        /**
         * Labels value.
         */
        value?: string;
    }

    export interface ElastigroupScheduledTask {
        /**
         * A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
         */
        cronExpression?: string;
        /**
         * Setting the task to being enabled or disabled.
         */
        isEnabled?: boolean;
        /**
         * The maximum number of instances the group should have.
         */
        maxCapacity?: string;
        /**
         * The minimum number of instances the group should have.
         */
        minCapacity?: string;
        /**
         * The desired number of instances the group should have.
         */
        targetCapacity?: string;
        /**
         * The task type to run. Valid values: `"setCapacity"`.
         */
        taskType: string;
    }

    export interface ElastigroupSubnet {
        /**
         * The region for the group of subnets.
         */
        region: string;
        /**
         * The names of the subnets in the region.
         */
        subnetNames: string[];
    }

}

export namespace gke {
    export interface ElastigroupBackendService {
        locationType?: string;
        namedPorts?: outputs.gke.ElastigroupBackendServiceNamedPort[];
        scheme?: string;
        serviceName: string;
    }

    export interface ElastigroupBackendServiceNamedPort {
        name: string;
        ports: string[];
    }

    export interface ElastigroupDisk {
        autoDelete?: boolean;
        boot?: boolean;
        deviceName?: string;
        initializeParams?: outputs.gke.ElastigroupDiskInitializeParam[];
        interface?: string;
        mode?: string;
        source?: string;
        type?: string;
    }

    export interface ElastigroupDiskInitializeParam {
        diskSizeGb?: string;
        diskType?: string;
        sourceImage: string;
    }

    export interface ElastigroupGpu {
        count: number;
        type: string;
    }

    export interface ElastigroupInstanceTypesCustom {
        memoryGib: number;
        vcpu: number;
    }

    export interface ElastigroupIntegrationDockerSwarm {
        masterHost: string;
        masterPort: number;
    }

    export interface ElastigroupIntegrationGke {
        autoUpdate?: boolean;
        /**
         * The amount of time, in seconds, after a scaling activity completes before any further trigger-related scaling activities can start.
         */
        autoscaleCooldown?: number;
        /**
         * Enabling scale down.
         */
        autoscaleDown?: outputs.gke.ElastigroupIntegrationGkeAutoscaleDown;
        /**
         * Headroom for the cluster.
         */
        autoscaleHeadroom?: outputs.gke.ElastigroupIntegrationGkeAutoscaleHeadroom;
        autoscaleIsAutoConfig?: boolean;
        /**
         * Specifies whether the auto scaling feature is enabled.
         */
        autoscaleIsEnabled?: boolean;
        /**
         * Labels to assign to the resource.
         */
        autoscaleLabels?: outputs.gke.ElastigroupIntegrationGkeAutoscaleLabel[];
        /**
         * The name of the GKE cluster you wish to import.
         */
        clusterId?: string;
        /**
         * The location of your GKE cluster.
         */
        location?: string;
    }

    export interface ElastigroupIntegrationGkeAutoscaleDown {
        /**
         * Amount of cooldown evaluation periods for scale down.
         */
        evaluationPeriods?: number;
    }

    export interface ElastigroupIntegrationGkeAutoscaleHeadroom {
        /**
         * Cpu units for compute.
         */
        cpuPerUnit?: number;
        /**
         * RAM units for compute.
         */
        memoryPerUnit?: number;
        /**
         * Amount of units for compute.
         */
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationGkeAutoscaleLabel {
        /**
         * The label name.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface ElastigroupLabel {
        /**
         * The label name.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface ElastigroupMetadata {
        /**
         * The label name.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface ElastigroupNetworkInterface {
        accessConfigs?: outputs.gke.ElastigroupNetworkInterfaceAccessConfig[];
        aliasIpRanges?: outputs.gke.ElastigroupNetworkInterfaceAliasIpRange[];
        network: string;
    }

    export interface ElastigroupNetworkInterfaceAccessConfig {
        name?: string;
        type?: string;
    }

    export interface ElastigroupNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName: string;
    }

    export interface ElastigroupScalingDownPolicy {
        actionType?: string;
        adjustment?: number;
        cooldown: number;
        dimensions?: outputs.gke.ElastigroupScalingDownPolicyDimension[];
        /**
         * Amount of cooldown evaluation periods for scale down.
         */
        evaluationPeriods: number;
        metricName: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        source: string;
        statistic: string;
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingDownPolicyDimension {
        name: string;
        /**
         * The label value.
         */
        value?: string;
    }

    export interface ElastigroupScalingUpPolicy {
        actionType?: string;
        adjustment?: number;
        cooldown: number;
        dimensions?: outputs.gke.ElastigroupScalingUpPolicyDimension[];
        /**
         * Amount of cooldown evaluation periods for scale down.
         */
        evaluationPeriods: number;
        metricName: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        source: string;
        statistic: string;
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingUpPolicyDimension {
        name: string;
        /**
         * The label value.
         */
        value?: string;
    }

    export interface OceanImportAutoscaler {
        /**
         * Optionally set the auto headroom percentage, set a number between 0-200 to control the headroom % from the cluster. Relevant when isAutoConfig=true.
         */
        autoHeadroomPercentage?: number;
        /**
         * Cooldown period between scaling actions.
         */
        cooldown?: number;
        /**
         * Auto Scaling scale down operations.
         */
        down?: outputs.gke.OceanImportAutoscalerDown;
        /**
         * enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
         */
        enableAutomaticAndManualHeadroom?: boolean;
        /**
         * Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
         */
        headroom?: outputs.gke.OceanImportAutoscalerHeadroom;
        /**
         * Automatically configure and optimize headroom resources.
         */
        isAutoConfig?: boolean;
        /**
         * Enable the Ocean Kubernetes Autoscaler.
         */
        isEnabled?: boolean;
        /**
         * Optionally set upper and lower bounds on the resource usage of the cluster.
         */
        resourceLimits?: outputs.gke.OceanImportAutoscalerResourceLimits;
    }

    export interface OceanImportAutoscalerDown {
        /**
         * The number of evaluation periods that should accumulate before a scale down action takes place.
         */
        evaluationPeriods?: number;
        /**
         * Would represent the maximum % to scale-down. Number between 1-100.
         */
        maxScaleDownPercentage?: number;
    }

    export interface OceanImportAutoscalerHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * How much GPU allocate for headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate the headroom.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
         */
        numOfUnits?: number;
    }

    export interface OceanImportAutoscalerResourceLimits {
        /**
         * The maximum memory in GiB units that can be allocated to the cluster.
         */
        maxMemoryGib?: number;
        /**
         * The maximum cpu in vCpu units that can be allocated to the cluster.
         */
        maxVcpu?: number;
    }

    export interface OceanImportBackendService {
        /**
         * Sets which location the backend services will be active. Valid values: `regional`, `global`.
         */
        locationType?: string;
        namedPorts?: outputs.gke.OceanImportBackendServiceNamedPort[];
        /**
         * Use when `locationType` is `regional`. Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: `INTERNAL`, `EXTERNAL`.
         */
        scheme?: string;
        /**
         * The name of the backend service.
         */
        serviceName: string;
    }

    export interface OceanImportBackendServiceNamedPort {
        name: string;
        /**
         * A list of ports.
         */
        ports: string[];
    }

    export interface OceanImportScheduledTask {
        /**
         * Set shutdown hours for cluster object.
         */
        shutdownHours?: outputs.gke.OceanImportScheduledTaskShutdownHours;
        /**
         * The scheduling tasks for the cluster.
         */
        tasks?: outputs.gke.OceanImportScheduledTaskTask[];
    }

    export interface OceanImportScheduledTaskShutdownHours {
        /**
         * Flag to enable / disable the shutdown hours.
         * Example: True
         */
        isEnabled?: boolean;
        /**
         * Set time windows for shutdown hours. specify a list of 'timeWindows' with at least one time window Each string is in the format of - ddd:hh:mm-ddd:hh:mm ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59. Time windows should not overlap. required on cluster.scheduling.isEnabled = True. API Times are in UTC
         * Example: Fri:15:30-Wed:14:30
         */
        timeWindows: string[];
    }

    export interface OceanImportScheduledTaskTask {
        /**
         * A valid cron expression. For example : " * * * * * ".The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of ‘frequency’ or ‘cronExpression’ should be used at a time. Required for cluster.scheduling.tasks object
         * Example: 0 1 * * *
         */
        cronExpression: string;
        /**
         * Flag to enable / disable the shutdown hours.
         * Example: True
         */
        isEnabled: boolean;
        taskParameters?: outputs.gke.OceanImportScheduledTaskTaskTaskParameters;
        /**
         * Valid values: "clusterRoll". Required for cluster.scheduling.tasks object.
         */
        taskType: string;
    }

    export interface OceanImportScheduledTaskTaskTaskParameters {
        clusterRoll?: outputs.gke.OceanImportScheduledTaskTaskTaskParametersClusterRoll;
    }

    export interface OceanImportScheduledTaskTaskTaskParametersClusterRoll {
        batchMinHealthyPercentage?: number;
        /**
         * Value in % to set size of batch in roll. Valid values are 0-100
         * Example: 20.
         */
        batchSizePercentage?: number;
        comment?: string;
        respectPdb?: boolean;
    }

    export interface OceanImportShieldedInstanceConfig {
        /**
         * Boolean. Enable the integrity monitoring parameter on the GCP instances.
         */
        enableIntegrityMonitoring: boolean;
        /**
         * Boolean. Enable the secure boot parameter on the GCP instances.
         */
        enableSecureBoot: boolean;
    }

    export interface OceanImportStrategy {
        /**
         * The draining timeout (in seconds) before terminating the instance.
         */
        drainingTimeout?: number;
        preemptiblePercentage?: number;
        provisioningModel?: string;
    }

    export interface OceanImportUpdatePolicy {
        conditionedRoll?: boolean;
        rollConfig?: outputs.gke.OceanImportUpdatePolicyRollConfig;
        shouldRoll: boolean;
    }

    export interface OceanImportUpdatePolicyRollConfig {
        batchMinHealthyPercentage?: number;
        /**
         * Value in % to set size of batch in roll. Valid values are 0-100
         * Example: 20.
         */
        batchSizePercentage: number;
        launchSpecIds?: string[];
        respectPdb?: boolean;
    }

    export interface OceanLaunchSpecAutoscaleHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the number of GPUS to allocate for each headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecAutoscaleHeadroomsAutomatic {
        /**
         * Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.`isEnabled` = true is set on the Ocean cluster.
         */
        autoHeadroomPercentage?: number;
    }

    export interface OceanLaunchSpecLabel {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface OceanLaunchSpecMetadata {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface OceanLaunchSpecResourceLimits {
        /**
         * Option to set a maximum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
         */
        maxInstanceCount?: number;
        /**
         * Option to set a minimum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
         */
        minInstanceCount?: number;
    }

    export interface OceanLaunchSpecSchedulingTask {
        /**
         * A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
         */
        cronExpression: string;
        /**
         * Describes whether the task is enabled. When True, the task runs. When False, it does not run.
         */
        isEnabled: boolean;
        /**
         * The config of this scheduled task. Depends on the value of taskType.
         */
        taskHeadrooms?: outputs.gke.OceanLaunchSpecSchedulingTaskTaskHeadroom[];
        /**
         * The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
         */
        taskType: string;
    }

    export interface OceanLaunchSpecSchedulingTaskTaskHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the number of GPUS to allocate for each headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecShieldedInstanceConfig {
        /**
         * Boolean. Enable the integrity monitoring parameter on the GCP instances.
         */
        enableIntegrityMonitoring: boolean;
        /**
         * Boolean. Enable the secure boot parameter on the GCP instances.
         */
        enableSecureBoot: boolean;
    }

    export interface OceanLaunchSpecStorage {
        /**
         * Defines the number of local SSDs to be attached per node for this VNG.
         */
        localSsdCount: number;
    }

    export interface OceanLaunchSpecStrategy {
        /**
         * Defines the desired preemptible percentage for this launch specification.
         */
        preemptiblePercentage?: number;
    }

    export interface OceanLaunchSpecTaint {
        /**
         * The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
         */
        effect: string;
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface OceanLaunchSpecUpdatePolicy {
        rollConfig?: outputs.gke.OceanLaunchSpecUpdatePolicyRollConfig;
        shouldRoll: boolean;
    }

    export interface OceanLaunchSpecUpdatePolicyRollConfig {
        batchSizePercentage: number;
    }

}

export namespace multai {
    export interface BalancerConnectionTimeouts {
        draining?: number;
        idle?: number;
    }

    export interface BalancerTag {
        key: string;
        value: string;
    }

    export interface ListenerTag {
        key: string;
        value: string;
    }

    export interface ListenerTlsConfig {
        certificateIds: string[];
        cipherSuites: string[];
        maxVersion: string;
        minVersion: string;
        preferServerCipherSuites: boolean;
        sessionTicketsDisabled: boolean;
    }

    export interface RoutingRuleTag {
        key: string;
        value: string;
    }

    export interface TargetSetHealthCheck {
        healthyThreshold: number;
        interval: number;
        path: string;
        port: number;
        protocol: string;
        timeout: number;
        unhealthyThreshold: number;
    }

    export interface TargetSetTag {
        key: string;
        value: string;
    }

    export interface TargetTag {
        key: string;
        value: string;
    }

}

export namespace spark {
    export interface OceanCompute {
        /**
         * - Enable/disable the creation of Ocean Spark VNGs during cluster creation.
         */
        createVngs: boolean;
        /**
         * - Enable/disable Ocean Spark taints on the Ocean Spark VNGs. By default, Ocean Spark uses taints to prevent non-Spark workloads from running on Ocean Spark VNGs.
         */
        useTaints: boolean;
    }

    export interface OceanIngress {
        controller?: outputs.spark.OceanIngressController;
        customEndpoint?: outputs.spark.OceanIngressCustomEndpoint;
        loadBalancer?: outputs.spark.OceanIngressLoadBalancer;
        privateLink?: outputs.spark.OceanIngressPrivateLink;
        /**
         * - **DEPRECATED**: Use `load_balancer.service_annotations` instead.
         */
        serviceAnnotations: {[key: string]: string};
    }

    export interface OceanIngressController {
        managed?: boolean;
    }

    export interface OceanIngressCustomEndpoint {
        address?: string;
        enabled?: boolean;
    }

    export interface OceanIngressLoadBalancer {
        managed?: boolean;
        serviceAnnotations?: {[key: string]: string};
        targetGroupArn?: string;
    }

    export interface OceanIngressPrivateLink {
        enabled?: boolean;
        vpcEndpointService?: string;
    }

    export interface OceanLogCollection {
        /**
         * - Enable/disable the collection of driver logs. When enabled, driver logs are stored by NetApp and can be downloaded from the Spot console web interface. The driver logs are deleted after 30 days.
         */
        collectDriverLogs: boolean;
    }

    export interface OceanSpark {
        /**
         * - List of Kubernetes namespaces that should be configured to run Spark applications, in addition to the default Spark application namespace `spark-apps`.
         */
        additionalAppNamespaces: string[];
    }

    export interface OceanWebhook {
        /**
         * - List of ports allowed to use on the host network - if empty default is `25554`.
         */
        hostNetworkPorts: number[];
        /**
         * - Enable/disable host networking for the Spark Operator. Host networking can be useful when using custom CNI plugins like Calico on EKS.
         */
        useHostNetwork: boolean;
    }

}
