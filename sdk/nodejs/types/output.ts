// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface DataIntegrationS3 {
    bucketName: string;
    /**
     * The subdirectory in which your files will be stored within the bucket. Adds the prefix subdir/ to new objects' keys. Can't be null or contain '/'.
     */
    subdir?: string;
}

export interface ElastigroupAzureV3BootDiagnostic {
    isEnabled: boolean;
    storageUrl: string;
    type: string;
}

export interface ElastigroupAzureV3CapacityReservation {
    capacityReservationGroups?: outputs.ElastigroupAzureV3CapacityReservationCapacityReservationGroups;
    shouldUtilize: boolean;
    utilizationStrategy: string;
}

export interface ElastigroupAzureV3CapacityReservationCapacityReservationGroups {
    crgName: string;
    crgResourceGroupName: string;
    crgShouldPrioritize?: boolean;
}

export interface ElastigroupAzureV3DataDisk {
    lun: number;
    sizeGb: number;
    type: string;
}

export interface ElastigroupAzureV3Extension {
    apiVersion: string;
    enableAutomaticUpgrade?: boolean;
    minorVersionAutoUpgrade: boolean;
    name: string;
    protectedSettings: {[key: string]: string};
    protectedSettingsFromKeyVault?: outputs.ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVault;
    publicSettings: {[key: string]: string};
    publisher: string;
    type: string;
}

export interface ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVault {
    secretUrl: string;
    sourceVault: string;
}

export interface ElastigroupAzureV3Health {
    autoHealing?: boolean;
    gracePeriod?: number;
    healthCheckTypes?: string[];
    unhealthyDuration?: number;
}

export interface ElastigroupAzureV3Image {
    customs?: outputs.ElastigroupAzureV3ImageCustom[];
    galleryImages?: outputs.ElastigroupAzureV3ImageGalleryImage[];
    marketplaces?: outputs.ElastigroupAzureV3ImageMarketplace[];
}

export interface ElastigroupAzureV3ImageCustom {
    imageName: string;
    resourceGroupName: string;
}

export interface ElastigroupAzureV3ImageGalleryImage {
    galleryName: string;
    imageName: string;
    resourceGroupName: string;
    spotAccountId?: string;
    version: string;
}

export interface ElastigroupAzureV3ImageMarketplace {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface ElastigroupAzureV3LoadBalancer {
    backendPoolNames?: string[];
    name: string;
    resourceGroupName: string;
    sku?: string;
    type: string;
}

export interface ElastigroupAzureV3Login {
    password?: string;
    sshPublicKey?: string;
    userName: string;
}

export interface ElastigroupAzureV3ManagedServiceIdentity {
    name: string;
    resourceGroupName: string;
}

export interface ElastigroupAzureV3Network {
    networkInterfaces: outputs.ElastigroupAzureV3NetworkNetworkInterface[];
    resourceGroupName: string;
    virtualNetworkName: string;
}

export interface ElastigroupAzureV3NetworkNetworkInterface {
    additionalIpConfigs?: outputs.ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig[];
    applicationSecurityGroups?: outputs.ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup[];
    assignPublicIp: boolean;
    enableIpForwarding?: boolean;
    isPrimary: boolean;
    privateIpAddresses?: string[];
    publicIpSku?: string;
    securityGroups?: outputs.ElastigroupAzureV3NetworkNetworkInterfaceSecurityGroup[];
    subnetName: string;
}

export interface ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig {
    name: string;
    privateIpVersion?: string;
}

export interface ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup {
    name: string;
    resourceGroupName: string;
}

export interface ElastigroupAzureV3NetworkNetworkInterfaceSecurityGroup {
    name?: string;
    resourceGroupName?: string;
}

export interface ElastigroupAzureV3OsDisk {
    sizeGb?: number;
    type: string;
}

export interface ElastigroupAzureV3ProximityPlacementGroup {
    name: string;
    resourceGroupName: string;
}

export interface ElastigroupAzureV3RevertToSpot {
    performAt: string;
}

export interface ElastigroupAzureV3ScalingDownPolicy {
    action: outputs.ElastigroupAzureV3ScalingDownPolicyAction;
    cooldown: number;
    dimensions?: outputs.ElastigroupAzureV3ScalingDownPolicyDimension[];
    evaluationPeriods: number;
    isEnabled?: boolean;
    metricName: string;
    namespace: string;
    operator: string;
    period: number;
    policyName: string;
    source: string;
    statistic: string;
    threshold: number;
    unit?: string;
}

export interface ElastigroupAzureV3ScalingDownPolicyAction {
    adjustment?: string;
    maximum?: string;
    minimum?: string;
    target?: string;
    type?: string;
}

export interface ElastigroupAzureV3ScalingDownPolicyDimension {
    name?: string;
    value?: string;
}

export interface ElastigroupAzureV3ScalingUpPolicy {
    action: outputs.ElastigroupAzureV3ScalingUpPolicyAction;
    cooldown: number;
    dimensions?: outputs.ElastigroupAzureV3ScalingUpPolicyDimension[];
    evaluationPeriods: number;
    isEnabled?: boolean;
    metricName: string;
    namespace: string;
    operator: string;
    period: number;
    policyName: string;
    source: string;
    statistic: string;
    threshold: number;
    unit?: string;
}

export interface ElastigroupAzureV3ScalingUpPolicyAction {
    adjustment?: string;
    maximum?: string;
    minimum?: string;
    target?: string;
    type?: string;
}

export interface ElastigroupAzureV3ScalingUpPolicyDimension {
    name?: string;
    value?: string;
}

export interface ElastigroupAzureV3SchedulingTask {
    adjustment?: string;
    adjustmentPercentage?: string;
    batchSizePercentage?: string;
    cronExpression: string;
    gracePeriod?: string;
    isEnabled: boolean;
    scaleMaxCapacity?: string;
    scaleMinCapacity?: string;
    scaleTargetCapacity?: string;
    type: string;
}

export interface ElastigroupAzureV3Secret {
    sourceVaults: outputs.ElastigroupAzureV3SecretSourceVault[];
    vaultCertificates: outputs.ElastigroupAzureV3SecretVaultCertificate[];
}

export interface ElastigroupAzureV3SecretSourceVault {
    name: string;
    resourceGroupName: string;
}

export interface ElastigroupAzureV3SecretVaultCertificate {
    certificateStore: string;
    certificateUrl: string;
}

export interface ElastigroupAzureV3Security {
    confidentialOsDiskEncryption?: boolean;
    encryptionAtHost?: boolean;
    secureBootEnabled?: boolean;
    securityType?: string;
    vtpmEnabled?: boolean;
}

export interface ElastigroupAzureV3Signal {
    timeout: number;
    type: string;
}

export interface ElastigroupAzureV3Tag {
    key: string;
    value: string;
}

export interface ElastigroupAzureV3VmSizes {
    excludedVmSizes?: string[];
    odSizes: string[];
    preferredSpotSizes?: string[];
    spotSizeAttributes?: outputs.ElastigroupAzureV3VmSizesSpotSizeAttributes;
    spotSizes?: string[];
}

export interface ElastigroupAzureV3VmSizesSpotSizeAttributes {
    maxCpu?: number;
    maxMemory?: number;
    maxStorage?: number;
    minCpu?: number;
    minMemory?: number;
    minStorage?: number;
}

export interface HealthCheckCheck {
    endPoint?: string;
    /**
     * The destination for the request.
     */
    endpoint?: string;
    /**
     * The number of consecutive successful health checks that must occur before declaring an instance healthy.
     */
    healthy: number;
    /**
     * The amount of time (in seconds) between each health check (minimum: 10).
     */
    interval: number;
    /**
     * The port to use to connect with the instance.
     */
    port: number;
    /**
     * The protocol to use to connect with the instance. Valid values: http, https.
     */
    protocol: string;
    timeOut?: number;
    /**
     * the amount of time (in seconds) to wait when receiving a response from the health check.
     */
    timeout?: number;
    /**
     * The number of consecutive failed health checks that must occur before declaring an instance unhealthy.
     */
    unhealthy: number;
}

export interface OceanRightSizingRuleAttachWorkload {
    namespaces: outputs.OceanRightSizingRuleAttachWorkloadNamespace[];
}

export interface OceanRightSizingRuleAttachWorkloadNamespace {
    labels?: outputs.OceanRightSizingRuleAttachWorkloadNamespaceLabel[];
    namespaceName: string;
    workloads?: outputs.OceanRightSizingRuleAttachWorkloadNamespaceWorkload[];
}

export interface OceanRightSizingRuleAttachWorkloadNamespaceLabel {
    key: string;
    value: string;
}

export interface OceanRightSizingRuleAttachWorkloadNamespaceWorkload {
    regexName?: string;
    workloadName?: string;
    workloadType: string;
}

export interface OceanRightSizingRuleDetachWorkload {
    namespaces: outputs.OceanRightSizingRuleDetachWorkloadNamespace[];
}

export interface OceanRightSizingRuleDetachWorkloadNamespace {
    labels?: outputs.OceanRightSizingRuleDetachWorkloadNamespaceLabel[];
    namespaceName: string;
    workloads?: outputs.OceanRightSizingRuleDetachWorkloadNamespaceWorkload[];
}

export interface OceanRightSizingRuleDetachWorkloadNamespaceLabel {
    key: string;
    value: string;
}

export interface OceanRightSizingRuleDetachWorkloadNamespaceWorkload {
    regexName?: string;
    workloadName?: string;
    workloadType: string;
}

export interface OceanRightSizingRuleRecommendationApplicationBoundary {
    cpuMax?: number;
    cpuMin?: number;
    memoryMax?: number;
    memoryMin?: number;
}

export interface OceanRightSizingRuleRecommendationApplicationHpa {
    allowHpaRecommendations?: boolean;
}

export interface OceanRightSizingRuleRecommendationApplicationInterval {
    monthlyRepetitionBases?: outputs.OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBase[];
    repetitionBasis: string;
    weeklyRepetitionBases?: outputs.OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBase[];
}

export interface OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBase {
    intervalMonths: number[];
    weekOfTheMonths: string[];
    weeklyRepetitionBases?: outputs.OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBase[];
}

export interface OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBase {
    intervalDays: string[];
    intervalHoursEndTime: string;
    intervalHoursStartTime: string;
}

export interface OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBase {
    intervalDays: string[];
    intervalHoursEndTime: string;
    intervalHoursStartTime: string;
}

export interface OceanRightSizingRuleRecommendationApplicationMinThreshold {
    cpuPercentage?: number;
    memoryPercentage?: number;
}

export interface OceanRightSizingRuleRecommendationApplicationOverheadValue {
    cpuPercentage?: number;
    memoryPercentage?: number;
}

export interface StatefulNodeAzureAttachDataDisk {
    dataDiskName: string;
    dataDiskResourceGroupName: string;
    lun?: number;
    sizeGb: number;
    storageAccountType: string;
    zone?: string;
}

export interface StatefulNodeAzureBootDiagnostic {
    isEnabled: boolean;
    storageUrl: string;
    type: string;
}

export interface StatefulNodeAzureDataDisk {
    lun: number;
    sizeGb: number;
    type: string;
}

export interface StatefulNodeAzureDelete {
    diskShouldDeallocate?: boolean;
    diskTtlInHours?: number;
    networkShouldDeallocate?: boolean;
    networkTtlInHours?: number;
    publicIpShouldDeallocate?: boolean;
    publicIpTtlInHours?: number;
    shouldDeregisterFromLb?: boolean;
    shouldRevertToOd?: boolean;
    shouldTerminateVm: boolean;
    snapshotShouldDeallocate?: boolean;
    snapshotTtlInHours?: number;
}

export interface StatefulNodeAzureDetachDataDisk {
    dataDiskName: string;
    dataDiskResourceGroupName: string;
    shouldDeallocate: boolean;
    ttlInHours?: number;
}

export interface StatefulNodeAzureExtension {
    apiVersion: string;
    minorVersionAutoUpgrade: boolean;
    name: string;
    protectedSettings: {[key: string]: string};
    publicSettings: {[key: string]: string};
    publisher: string;
    type: string;
}

export interface StatefulNodeAzureHealth {
    autoHealing: boolean;
    gracePeriod: number;
    healthCheckTypes: string[];
    unhealthyDuration: number;
}

export interface StatefulNodeAzureImage {
    customImages: outputs.StatefulNodeAzureImageCustomImage[];
    galleries: outputs.StatefulNodeAzureImageGallery[];
    marketplaceImages: outputs.StatefulNodeAzureImageMarketplaceImage[];
}

export interface StatefulNodeAzureImageCustomImage {
    customImageResourceGroupName: string;
    name: string;
}

export interface StatefulNodeAzureImageGallery {
    galleryName: string;
    galleryResourceGroupName: string;
    imageName: string;
    spotAccountId?: string;
    versionName: string;
}

export interface StatefulNodeAzureImageMarketplaceImage {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface StatefulNodeAzureImportVm {
    drainingTimeout?: number;
    originalVmName: string;
    resourceGroupName: string;
    resourcesRetentionTime?: number;
}

export interface StatefulNodeAzureLoadBalancer {
    backendPoolNames: string[];
    name: string;
    resourceGroupName: string;
    sku: string;
    type: string;
}

export interface StatefulNodeAzureLogin {
    password?: string;
    sshPublicKey?: string;
    userName: string;
}

export interface StatefulNodeAzureManagedServiceIdentity {
    name: string;
    resourceGroupName: string;
}

export interface StatefulNodeAzureNetwork {
    networkInterfaces: outputs.StatefulNodeAzureNetworkNetworkInterface[];
    networkResourceGroupName: string;
    virtualNetworkName: string;
}

export interface StatefulNodeAzureNetworkNetworkInterface {
    additionalIpConfigurations?: outputs.StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration[];
    applicationSecurityGroups?: outputs.StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup[];
    assignPublicIp?: boolean;
    enableIpForwarding?: boolean;
    isPrimary: boolean;
    networkSecurityGroups?: outputs.StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup[];
    privateIpAddresses?: string[];
    publicIpSku?: string;
    publicIps?: outputs.StatefulNodeAzureNetworkNetworkInterfacePublicIp[];
    subnetName: string;
}

export interface StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration {
    name: string;
    privateIpAddressVersion: string;
}

export interface StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup {
    name: string;
    networkResourceGroupName: string;
}

export interface StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup {
    name?: string;
    networkResourceGroupName?: string;
}

export interface StatefulNodeAzureNetworkNetworkInterfacePublicIp {
    name: string;
    networkResourceGroupName: string;
}

export interface StatefulNodeAzureOsDisk {
    caching?: string;
    sizeGb?: number;
    type: string;
}

export interface StatefulNodeAzureProximityPlacementGroup {
    name: string;
    resourceGroupName: string;
}

export interface StatefulNodeAzureSchedulingTask {
    cronExpression: string;
    isEnabled: boolean;
    type: string;
}

export interface StatefulNodeAzureSecret {
    sourceVaults: outputs.StatefulNodeAzureSecretSourceVault[];
    vaultCertificates: outputs.StatefulNodeAzureSecretVaultCertificate[];
}

export interface StatefulNodeAzureSecretSourceVault {
    name: string;
    resourceGroupName: string;
}

export interface StatefulNodeAzureSecretVaultCertificate {
    certificateStore?: string;
    certificateUrl?: string;
}

export interface StatefulNodeAzureSecurity {
    confidentialOsDiskEncryption?: boolean;
    encryptionAtHost?: boolean;
    secureBootEnabled?: boolean;
    securityType?: string;
    vtpmEnabled?: boolean;
}

export interface StatefulNodeAzureSignal {
    timeout: number;
    type: string;
}

export interface StatefulNodeAzureStrategy {
    availabilityVsCost?: number;
    capacityReservations?: outputs.StatefulNodeAzureStrategyCapacityReservation[];
    drainingTimeout: number;
    fallbackToOnDemand: boolean;
    odWindows?: string[];
    optimizationWindows?: string[];
    preferredLifeCycle: string;
    revertToSpot: outputs.StatefulNodeAzureStrategyRevertToSpot;
    vmAdmins?: string[];
}

export interface StatefulNodeAzureStrategyCapacityReservation {
    capacityReservationGroups?: outputs.StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup[];
    shouldUtilize: boolean;
    utilizationStrategy: string;
}

export interface StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup {
    crgName: string;
    crgResourceGroupName: string;
    crgShouldPrioritize?: boolean;
}

export interface StatefulNodeAzureStrategyRevertToSpot {
    performAt: string;
}

export interface StatefulNodeAzureTag {
    tagKey: string;
    tagValue?: string;
}

export interface StatefulNodeAzureUpdateState {
    state: string;
}

export interface StatefulNodeAzureVmSizes {
    excludedVmSizes?: string[];
    odSizes: string[];
    preferredSpotSizes?: string[];
    spotSizeAttributes?: outputs.StatefulNodeAzureVmSizesSpotSizeAttributes;
    spotSizes?: string[];
}

export interface StatefulNodeAzureVmSizesSpotSizeAttributes {
    maxCpu?: number;
    maxMemory?: number;
    maxStorage?: number;
    minCpu?: number;
    minMemory?: number;
    minStorage?: number;
}

export namespace aws {
    export interface BeanstalkDeploymentPreferences {
        /**
         * Should roll perform automatically
         */
        automaticRoll?: boolean;
        /**
         * Percent size of each batch
         */
        batchSizePercentage?: number;
        /**
         * Amount of time to wait between batches
         */
        gracePeriod?: number;
        /**
         * Strategy parameters
         */
        strategies?: outputs.aws.BeanstalkDeploymentPreferencesStrategy[];
    }

    export interface BeanstalkDeploymentPreferencesStrategy {
        /**
         * Action to take
         */
        action?: string;
        /**
         * Bool value if to wait to drain instance
         */
        shouldDrainInstances?: boolean;
    }

    export interface BeanstalkManagedActions {
        /**
         * Platform Update parameters
         */
        platformUpdate?: outputs.aws.BeanstalkManagedActionsPlatformUpdate;
    }

    export interface BeanstalkManagedActionsPlatformUpdate {
        /**
         * Actions to perform (options: timeWindow, never)
         */
        performAt?: string;
        /**
         * Time Window for when action occurs ex. Mon:23:50-Tue:00:20
         */
        timeWindow?: string;
        /**
         * Level to update
         */
        updateLevel?: string;
    }

    export interface BeanstalkScheduledTask {
        /**
         * The number of instances to add or remove.
         */
        adjustment?: string;
        /**
         * The percentage of instances to add or remove.
         *
         * Usage:
         */
        adjustmentPercentage?: string;
        /**
         * The percentage size of each batch in the scheduled deployment roll.
         */
        batchSizePercentage?: string;
        /**
         * A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
         */
        cronExpression?: string;
        /**
         * The recurrence frequency to run this task. Supported values are `"hourly"`, `"daily"`, `"weekly"` and `"continuous"`.
         */
        frequency?: string;
        /**
         * The period of time (seconds) to wait before checking a batch's health after it's deployment.
         */
        gracePeriod?: string;
        /**
         * Setting the task to being enabled or disabled.
         */
        isEnabled?: boolean;
        /**
         * The maximum number of instances the group should have.
         */
        maxCapacity?: string;
        /**
         * The minimum number of instances the group should have.
         */
        minCapacity?: string;
        /**
         * The maximum number of instances the group should have.
         */
        scaleMaxCapacity?: string;
        /**
         * The minimum number of instances the group should have.
         */
        scaleMinCapacity?: string;
        /**
         * The desired number of instances the group should have.
         */
        scaleTargetCapacity?: string;
        /**
         * Set a start time for one time tasks.
         */
        startTime?: string;
        /**
         * The desired number of instances the group should have.
         */
        targetCapacity?: string;
        /**
         * The task type to run. Supported task types are: `"scale"`, `"backupAmi"`, `"roll"`, `"scaleUp"`, `"percentageScaleUp"`, `"scaleDown"`, `"percentageScaleDown"`, `"statefulUpdateCapacity"`.
         */
        taskType: string;
    }

    export interface ElastigroupCpuOptions {
        /**
         * The ability to define the number of threads per core in instances that allow this.
         */
        threadsPerCore: number;
    }

    export interface ElastigroupEbsBlockDevice {
        /**
         * Whether the volume should be destroyed on instance termination.
         */
        deleteOnTermination: boolean;
        /**
         * The name of the device to mount.
         */
        deviceName: string;
        /**
         * Set dynamic IOPS properties. When using this object, you cannot use the `iops` object. You must use one or the other.
         */
        dynamicIops?: outputs.aws.ElastigroupEbsBlockDeviceDynamicIops;
        /**
         * Set dynamic volume size properties. When using this object, you cannot use `volumeSize`. You must use one or the other.
         */
        dynamicVolumeSize?: outputs.aws.ElastigroupEbsBlockDeviceDynamicVolumeSize;
        /**
         * Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
         */
        encrypted: boolean;
        /**
         * The amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). This must be set with a `volumeType` of `"io1"`.
         */
        iops?: number;
        /**
         * ID for a user managed CMK under which the EBS Volume is encrypted
         */
        kmsKeyId?: string;
        /**
         * The Snapshot ID to mount.
         */
        snapshotId?: string;
        /**
         * The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volumeType` = gp3.
         */
        throughput?: number;
        /**
         * The size of the volume in gigabytes.
         */
        volumeSize?: number;
        /**
         * The type of volume. Can be `"standard"`, `"gp2"`, `"gp3"`, `"io1"`, `"st1"` or `"sc1"`.
         */
        volumeType: string;
    }

    export interface ElastigroupEbsBlockDeviceDynamicIops {
        /**
         * Initial size for IOPS.
         */
        baseSize?: number;
        /**
         * Type of resource, valid values: `"CPU", "MEMORY"`.
         */
        resource?: string;
        /**
         * Additional size per resource unit (in IOPS).
         *
         * Modifying any `ebsBlockDevice` currently requires resource replacement.
         *
         * Usage:
         */
        sizePerResourceUnit?: number;
    }

    export interface ElastigroupEbsBlockDeviceDynamicVolumeSize {
        /**
         * Initial size for volume.
         */
        baseSize?: number;
        /**
         * Type of resource, valid values: `"CPU", "MEMORY"`.
         */
        resource?: string;
        /**
         * Additional size per resource unit (in GB).
         */
        sizePerResourceUnit?: number;
    }

    export interface ElastigroupEphemeralBlockDevice {
        /**
         * The name of the block device to mount on the instance.
         */
        deviceName: string;
        /**
         * The [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
         * (e.g. `"ephemeral0"`).
         *
         * Usage:
         */
        virtualName: string;
    }

    export interface ElastigroupImage {
        images: outputs.aws.ElastigroupImageImage[];
    }

    export interface ElastigroupImageImage {
        /**
         * The group ID.
         */
        id: string;
    }

    export interface ElastigroupInstanceTypesWeight {
        /**
         * Name of instance type (String).
         */
        instanceType: string;
        /**
         * Weight per instance type (Integer).
         */
        weight: number;
    }

    export interface ElastigroupIntegrationBeanstalk {
        /**
         * Preferences when performing a roll
         */
        deploymentPreferences?: outputs.aws.ElastigroupIntegrationBeanstalkDeploymentPreferences;
        environmentId?: string;
        /**
         * Managed Actions parameters
         */
        managedActions?: outputs.aws.ElastigroupIntegrationBeanstalkManagedActions;
    }

    export interface ElastigroupIntegrationBeanstalkDeploymentPreferences {
        /**
         * Should roll perform automatically
         */
        automaticRoll?: boolean;
        batchSizePercentage?: number;
        gracePeriod?: number;
        strategy?: outputs.aws.ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategy;
    }

    export interface ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategy {
        action?: string;
        shouldDrainInstances?: boolean;
    }

    export interface ElastigroupIntegrationBeanstalkManagedActions {
        /**
         * Platform Update parameters
         */
        platformUpdate?: outputs.aws.ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdate;
    }

    export interface ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdate {
        performAt?: string;
        /**
         * Time Window for when action occurs ex. Mon:23:50-Tue:00:20
         */
        timeWindow?: string;
        /**
         * Level to update
         *
         * Usage:
         */
        updateLevel?: string;
    }

    export interface ElastigroupIntegrationCodedeploy {
        /**
         * Cleanup automatically after a failed deploy.
         */
        cleanupOnFailure: boolean;
        /**
         * Specify the deployment groups details.
         */
        deploymentGroups: outputs.aws.ElastigroupIntegrationCodedeployDeploymentGroup[];
        /**
         * Terminate the instance automatically after a failed deploy.
         */
        terminateInstanceOnFailure: boolean;
    }

    export interface ElastigroupIntegrationCodedeployDeploymentGroup {
        /**
         * The application name.
         */
        applicationName: string;
        /**
         * The deployment group name.
         *
         * Usage:
         */
        deploymentGroupName: string;
    }

    export interface ElastigroupIntegrationDockerSwarm {
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.aws.ElastigroupIntegrationDockerSwarmAutoscaleDown;
        autoscaleHeadroom?: outputs.aws.ElastigroupIntegrationDockerSwarmAutoscaleHeadroom;
        autoscaleIsEnabled?: boolean;
        masterHost: string;
        masterPort: number;
    }

    export interface ElastigroupIntegrationDockerSwarmAutoscaleDown {
        evaluationPeriods?: number;
        maxScaleDownPercentage?: number;
    }

    export interface ElastigroupIntegrationDockerSwarmAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationEcs {
        /**
         * A key/value mapping of tags to assign to the resource.
         */
        autoscaleAttributes?: outputs.aws.ElastigroupIntegrationEcsAutoscaleAttribute[];
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.aws.ElastigroupIntegrationEcsAutoscaleDown;
        autoscaleHeadroom?: outputs.aws.ElastigroupIntegrationEcsAutoscaleHeadroom;
        autoscaleIsAutoConfig?: boolean;
        autoscaleIsEnabled?: boolean;
        /**
         * Determines whether to scale down non-service tasks.
         */
        autoscaleScaleDownNonServiceTasks?: boolean;
        /**
         * Batch configuration object:
         */
        batch?: outputs.aws.ElastigroupIntegrationEcsBatch;
        /**
         * The name of the EC2 Container Service cluster.
         */
        clusterName: string;
    }

    export interface ElastigroupIntegrationEcsAutoscaleAttribute {
        key: string;
        value: string;
    }

    export interface ElastigroupIntegrationEcsAutoscaleDown {
        evaluationPeriods?: number;
        maxScaleDownPercentage?: number;
    }

    export interface ElastigroupIntegrationEcsAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationEcsBatch {
        /**
         * Array of strings.
         *
         * Usage:
         */
        jobQueueNames: string[];
    }

    export interface ElastigroupIntegrationGitlab {
        /**
         * Settings for Gitlab runner.
         */
        runner?: outputs.aws.ElastigroupIntegrationGitlabRunner;
    }

    export interface ElastigroupIntegrationGitlabRunner {
        isEnabled?: boolean;
    }

    export interface ElastigroupIntegrationKubernetes {
        apiServer?: string;
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.aws.ElastigroupIntegrationKubernetesAutoscaleDown;
        autoscaleHeadroom?: outputs.aws.ElastigroupIntegrationKubernetesAutoscaleHeadroom;
        autoscaleIsAutoConfig?: boolean;
        autoscaleIsEnabled?: boolean;
        /**
         * A key/value mapping of tags to assign to the resource.
         *
         * Usage:
         */
        autoscaleLabels?: outputs.aws.ElastigroupIntegrationKubernetesAutoscaleLabel[];
        clusterIdentifier?: string;
        /**
         * Valid values: `"saas"`, `"pod"`.
         */
        integrationMode?: string;
        /**
         * Kubernetes Token
         */
        token?: string;
    }

    export interface ElastigroupIntegrationKubernetesAutoscaleDown {
        evaluationPeriods?: number;
        maxScaleDownPercentage?: number;
    }

    export interface ElastigroupIntegrationKubernetesAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationKubernetesAutoscaleLabel {
        key: string;
        value: string;
    }

    export interface ElastigroupIntegrationMesosphere {
        apiServer: string;
    }

    export interface ElastigroupIntegrationNomad {
        /**
         * Nomad ACL Token
         */
        aclToken?: string;
        /**
         * A key/value mapping of tags to assign to the resource.
         *
         * Usage:
         */
        autoscaleConstraints?: outputs.aws.ElastigroupIntegrationNomadAutoscaleConstraint[];
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.aws.ElastigroupIntegrationNomadAutoscaleDown;
        autoscaleHeadroom?: outputs.aws.ElastigroupIntegrationNomadAutoscaleHeadroom;
        autoscaleIsEnabled?: boolean;
        masterHost: string;
        masterPort: number;
    }

    export interface ElastigroupIntegrationNomadAutoscaleConstraint {
        key: string;
        value: string;
    }

    export interface ElastigroupIntegrationNomadAutoscaleDown {
        evaluationPeriods?: number;
    }

    export interface ElastigroupIntegrationNomadAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationRancher {
        /**
         * The access key of the Rancher API.
         */
        accessKey: string;
        masterHost: string;
        /**
         * The secret key of the Rancher API.
         */
        secretKey: string;
        /**
         * The Rancher version. Must be `"1"` or `"2"`. If this field is omitted, it’s assumed that the Rancher cluster is version 1. Note that Kubernetes is required when using Rancher version 2^.
         * Usage:
         */
        version?: string;
    }

    export interface ElastigroupIntegrationRoute53 {
        /**
         * Collection of one or more domains to register.
         */
        domains: outputs.aws.ElastigroupIntegrationRoute53Domain[];
    }

    export interface ElastigroupIntegrationRoute53Domain {
        /**
         * The id associated with a hosted zone.
         */
        hostedZoneId: string;
        /**
         * The type of the record set. Valid values: `"a"`, `"cname"`.
         */
        recordSetType?: string;
        /**
         * Collection of records containing authoritative DNS information for the specified domain name.
         */
        recordSets: outputs.aws.ElastigroupIntegrationRoute53DomainRecordSet[];
        /**
         * The Spotinst account ID that is linked to the AWS account that holds the Route 53 Hosted Zone ID. The default is the user Spotinst account provided as a URL parameter.
         */
        spotinstAcctId?: string;
    }

    export interface ElastigroupIntegrationRoute53DomainRecordSet {
        /**
         * The group name.
         */
        name: string;
        /**
         * Designates whether the DNS address should be exposed to connections outside the VPC.
         *
         * Usage:
         */
        usePublicDns?: boolean;
        /**
         * Designates whether the IP address should be exposed to connections outside the VPC.
         */
        usePublicIp?: boolean;
    }

    export interface ElastigroupItf {
        defaultStaticTargetGroup?: outputs.aws.ElastigroupItfDefaultStaticTargetGroup;
        fixedTargetGroups: boolean;
        loadBalancers: outputs.aws.ElastigroupItfLoadBalancer[];
        migrationHealthinessThreshold?: number;
        targetGroupConfigs: outputs.aws.ElastigroupItfTargetGroupConfig[];
        weightStrategy: string;
    }

    export interface ElastigroupItfDefaultStaticTargetGroup {
        arn: string;
        percentage: number;
    }

    export interface ElastigroupItfLoadBalancer {
        listenerRules: outputs.aws.ElastigroupItfLoadBalancerListenerRule[];
        loadBalancerArn: string;
    }

    export interface ElastigroupItfLoadBalancerListenerRule {
        ruleArn: string;
        staticTargetGroup?: outputs.aws.ElastigroupItfLoadBalancerListenerRuleStaticTargetGroup;
    }

    export interface ElastigroupItfLoadBalancerListenerRuleStaticTargetGroup {
        arn: string;
        percentage: number;
    }

    export interface ElastigroupItfTargetGroupConfig {
        healthCheckIntervalSeconds?: number;
        healthCheckPath: string;
        healthCheckPort?: string;
        healthCheckProtocol?: string;
        healthCheckTimeoutSeconds?: number;
        healthyThresholdCount?: number;
        matchers?: outputs.aws.ElastigroupItfTargetGroupConfigMatcher[];
        port: number;
        protocol: string;
        protocolVersion?: string;
        /**
         * A key/value mapping of tags to assign to the resource.
         */
        tags?: outputs.aws.ElastigroupItfTargetGroupConfigTag[];
        unhealthyThresholdCount?: number;
        vpcId: string;
    }

    export interface ElastigroupItfTargetGroupConfigMatcher {
        grpcCode?: string;
        httpCode?: string;
    }

    export interface ElastigroupItfTargetGroupConfigTag {
        tagKey: string;
        tagValue?: string;
    }

    export interface ElastigroupLogging {
        /**
         * Logging Export configuration.
         */
        export?: outputs.aws.ElastigroupLoggingExport;
    }

    export interface ElastigroupLoggingExport {
        /**
         * Exports your cluster's logs to the S3 bucket and subdir configured on the S3 data integration given.
         */
        s3s?: outputs.aws.ElastigroupLoggingExportS3[];
    }

    export interface ElastigroupLoggingExportS3 {
        /**
         * The identifier of The S3 data integration to export the logs to.
         */
        id: string;
    }

    export interface ElastigroupMetadataOptions {
        /**
         * The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values: Integers from `1` to `64`.
         */
        httpPutResponseHopLimit?: number;
        /**
         * The state of token usage for your instance metadata requests. Valid values: `optional` or `required`.
         */
        httpTokens: string;
        /**
         * Indicates whether access to instance tags from the instance metadata is enabled or disabled. Can’t be null.
         */
        instanceMetadataTags?: string;
    }

    export interface ElastigroupMultipleMetrics {
        /**
         * Array of objects (Expression config)
         */
        expressions?: outputs.aws.ElastigroupMultipleMetricsExpression[];
        /**
         * Array of objects (Metric config)
         */
        metrics?: outputs.aws.ElastigroupMultipleMetricsMetric[];
    }

    export interface ElastigroupMultipleMetricsExpression {
        /**
         * An expression consisting of the metric names listed in the 'metrics' array.
         */
        expression: string;
        /**
         * The group name.
         */
        name: string;
    }

    export interface ElastigroupMultipleMetricsMetric {
        dimensions?: outputs.aws.ElastigroupMultipleMetricsMetricDimension[];
        /**
         * Percentile statistic. Valid values: `"p0.1"` - `"p100"`.
         */
        extendedStatistic?: string;
        metricName: string;
        /**
         * The group name.
         */
        name: string;
        namespace: string;
        statistic?: string;
        unit?: string;
    }

    export interface ElastigroupMultipleMetricsMetricDimension {
        /**
         * The group name.
         */
        name: string;
        value?: string;
    }

    export interface ElastigroupNetworkInterface {
        /**
         * Indicates whether to assign IPV6 addresses to your instance. Requires a subnet with IPV6 CIDR block ranges.
         *
         * Usage:
         */
        associateIpv6Address?: boolean;
        /**
         * Indicates whether to assign a public IP address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one.
         */
        associatePublicIpAddress?: boolean;
        /**
         * If set to true, the interface is deleted when the instance is terminated.
         */
        deleteOnTermination: boolean;
        /**
         * The description of the network interface.
         */
        description?: string;
        /**
         * The index of the device on the instance for the network interface attachment.
         */
        deviceIndex: string;
        /**
         * The ID of the network interface.
         */
        networkInterfaceId?: string;
        /**
         * The private IP address of the network interface.
         */
        privateIpAddress?: string;
        /**
         * The number of secondary private IP addresses.
         */
        secondaryPrivateIpAddressCount?: string;
    }

    export interface ElastigroupResourceRequirement {
        /**
         * Instance families to exclude
         */
        excludedInstanceFamilies?: string[];
        /**
         * Instance generations to exclude
         */
        excludedInstanceGenerations?: string[];
        /**
         * Instance types to exclude
         */
        excludedInstanceTypes?: string[];
        /**
         * Required maximum instance GPU (<=16)
         */
        requiredGpuMaximum?: number;
        /**
         * Required minimum instance GPU (>=1)
         */
        requiredGpuMinimum?: number;
        /**
         * Required maximum instance memory (<=512)
         */
        requiredMemoryMaximum: number;
        /**
         * Required minimum instance memory (>=1)
         */
        requiredMemoryMinimum: number;
        /**
         * Required maximum instance vCPU (<=64)
         */
        requiredVcpuMaximum: number;
        /**
         * Required minimum instance vCPU (>=1)
         */
        requiredVcpuMinimum: number;
    }

    export interface ElastigroupResourceTagSpecification {
        /**
         * Tag specification for AMI resources.
         */
        shouldTagAmis?: boolean;
        /**
         * Tag specification for ENI resources.
         */
        shouldTagEnis?: boolean;
        /**
         * Tag specification for Snapshot resources.
         */
        shouldTagSnapshots?: boolean;
        /**
         * Tag specification for Volume resources.
         */
        shouldTagVolumes?: boolean;
    }

    export interface ElastigroupRevertToSpot {
        /**
         * In the event of a fallback to On-Demand instances, select the time period to revert back to Spot. Supported Arguments – always (default), timeWindow, never. For timeWindow or never to be valid the group must have availabilityOriented OR persistence defined.
         */
        performAt: string;
        /**
         * Specify a list of time windows for to execute revertToSpot strategy. Time window format: `ddd:hh:mm-ddd:hh:mm`. Example: `Mon:03:00-Wed:02:30`
         */
        timeWindows?: string[];
    }

    export interface ElastigroupScalingDownPolicy {
        /**
         * The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`. If a `stepAdjustment` object is defined, then it cannot be specified.
         */
        actionType?: string;
        /**
         * The number of instances to add/remove to/from the target capacity when scale is needed. Can be used as advanced expression for scaling of instances to add/remove to/from the target capacity when scale is needed. You can see more information here: Advanced expression. Example value: `"MAX(currCapacity / 5, value * 10)"`
         */
        adjustment?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
         */
        cooldown?: number;
        /**
         * A list of dimensions describing qualities of the metric.
         */
        dimensions?: outputs.aws.ElastigroupScalingDownPolicyDimension[];
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods: number;
        /**
         * Specifies whether the scaling policy described in this block is enabled.
         */
        isEnabled?: boolean;
        /**
         * . The number of the desired target (and maximum) capacity
         */
        maxTargetCapacity?: string;
        /**
         * The maximal number of instances to have in the group.
         */
        maximum?: string;
        /**
         * The name of the metric, with or without spaces.
         */
        metricName: string;
        minTargetCapacity?: string;
        /**
         * The minimal number of instances to have in the group.
         */
        minimum?: string;
        /**
         * The namespace for the alarm's associated metric.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
         */
        operator: string;
        /**
         * The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
         */
        period: number;
        /**
         * The name of the policy.
         */
        policyName: string;
        /**
         * The source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
         */
        source: string;
        /**
         * The metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
         */
        statistic?: string;
        stepAdjustments?: outputs.aws.ElastigroupScalingDownPolicyStepAdjustment[];
        /**
         * The target number of instances to have in the group.
         */
        target?: string;
        /**
         * The value against which the specified statistic is compared. If a `stepAdjustment` object is defined, then it cannot be specified.
         */
        threshold?: number;
        /**
         * The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
         */
        unit?: string;
    }

    export interface ElastigroupScalingDownPolicyDimension {
        /**
         * The dimension name.
         */
        name: string;
        /**
         * The dimension value.
         */
        value?: string;
    }

    export interface ElastigroupScalingDownPolicyStepAdjustment {
        action: outputs.aws.ElastigroupScalingDownPolicyStepAdjustmentAction;
        threshold: number;
    }

    export interface ElastigroupScalingDownPolicyStepAdjustmentAction {
        adjustment?: string;
        maxTargetCapacity?: string;
        maximum?: string;
        minTargetCapacity?: string;
        minimum?: string;
        target?: string;
        type: string;
    }

    export interface ElastigroupScalingStrategy {
        /**
         * Specify whether to terminate instances at the end of each billing hour.
         */
        terminateAtEndOfBillingHour?: boolean;
        /**
         * Determines whether to terminate the newest instances when performing a scaling action. Valid values: `"default"`, `"newestInstance"`.
         */
        terminationPolicy?: string;
    }

    export interface ElastigroupScalingTargetPolicy {
        /**
         * Integer the amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
         */
        cooldown?: number;
        /**
         * A list of dimensions describing qualities of the metric.
         */
        dimensions?: outputs.aws.ElastigroupScalingTargetPolicyDimension[];
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods?: number;
        /**
         * String, restrict the maximal number of instances which can be added in each scale-up action.
         *
         * `scalingTargetPolicies` support predictive scaling:
         */
        maxCapacityPerScale?: string;
        /**
         * String, the name of the metric, with or without spaces.
         */
        metricName: string;
        /**
         * String, the namespace for the alarm's associated metric.
         */
        namespace: string;
        /**
         * The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
         */
        period?: number;
        /**
         * String, the name of the policy.
         */
        policyName: string;
        /**
         * Start a metric prediction process to determine the expected target metric value within the next two days. See [Predictive Autoscaling](https://api.spotinst.com/elastigroup-for-aws/concepts/scaling-concepts/predictive-autoscaling/) documentation for more info. Valid values: `FORECAST_AND_SCALE`, `FORECAST_ONLY`.
         *
         * Usage:
         */
        predictiveMode?: string;
        /**
         * String, the source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
         */
        source: string;
        /**
         * String, the metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
         */
        statistic?: string;
        /**
         * The target number of instances to have in the group.
         */
        target: number;
        /**
         * String, tThe unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
         */
        unit?: string;
    }

    export interface ElastigroupScalingTargetPolicyDimension {
        /**
         * String, the dimension name.
         */
        name: string;
        /**
         * String, the dimension value.
         */
        value?: string;
    }

    export interface ElastigroupScalingUpPolicy {
        /**
         * The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`. If a `stepAdjustment` object is defined, then it cannot be specified.
         */
        actionType?: string;
        /**
         * The number of instances to add/remove to/from the target capacity when scale is needed. Can be used as advanced expression for scaling of instances to add/remove to/from the target capacity when scale is needed. You can see more information here: Advanced expression. Example value: `"MAX(currCapacity / 5, value * 10)"`
         */
        adjustment?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
         */
        cooldown?: number;
        /**
         * A list of dimensions describing qualities of the metric.
         */
        dimensions?: outputs.aws.ElastigroupScalingUpPolicyDimension[];
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods: number;
        /**
         * Specifies whether the scaling policy described in this block is enabled.
         */
        isEnabled?: boolean;
        maxTargetCapacity?: string;
        /**
         * The maximal number of instances to have in the group.
         */
        maximum?: string;
        /**
         * The name of the metric, with or without spaces.
         */
        metricName: string;
        /**
         * . The number of the desired target (and minimum) capacity
         */
        minTargetCapacity?: string;
        /**
         * The minimal number of instances to have in the group.
         */
        minimum?: string;
        /**
         * The namespace for the alarm's associated metric.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
         */
        operator: string;
        /**
         * The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
         */
        period: number;
        /**
         * The name of the policy.
         */
        policyName: string;
        /**
         * The source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
         */
        source: string;
        /**
         * The metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
         */
        statistic?: string;
        stepAdjustments?: outputs.aws.ElastigroupScalingUpPolicyStepAdjustment[];
        /**
         * The target number of instances to have in the group.
         */
        target?: string;
        /**
         * The value against which the specified statistic is compared. If a `stepAdjustment` object is defined, then it cannot be specified.
         */
        threshold?: number;
        /**
         * The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
         */
        unit?: string;
    }

    export interface ElastigroupScalingUpPolicyDimension {
        /**
         * The dimension name.
         */
        name: string;
        /**
         * The dimension value.
         */
        value?: string;
    }

    export interface ElastigroupScalingUpPolicyStepAdjustment {
        action: outputs.aws.ElastigroupScalingUpPolicyStepAdjustmentAction;
        threshold: number;
    }

    export interface ElastigroupScalingUpPolicyStepAdjustmentAction {
        adjustment?: string;
        maxTargetCapacity?: string;
        maximum?: string;
        minTargetCapacity?: string;
        minimum?: string;
        target?: string;
        type: string;
    }

    export interface ElastigroupScheduledTask {
        /**
         * The number of instances to add or remove.
         */
        adjustment?: string;
        /**
         * The percentage of instances to add or remove.
         *
         * Usage:
         */
        adjustmentPercentage?: string;
        /**
         * The percentage size of each batch in the scheduled deployment roll.
         */
        batchSizePercentage?: string;
        /**
         * A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
         */
        cronExpression?: string;
        /**
         * The recurrence frequency to run this task. Supported values are `"hourly"`, `"daily"`, `"weekly"` and `"continuous"`.
         */
        frequency?: string;
        /**
         * The period of time (seconds) to wait before checking a batch's health after it's deployment.
         */
        gracePeriod?: string;
        /**
         * Setting the task to being enabled or disabled.
         */
        isEnabled?: boolean;
        /**
         * The maximum number of instances the group should have.
         */
        maxCapacity?: string;
        /**
         * The minimum number of instances the group should have.
         */
        minCapacity?: string;
        /**
         * The maximum number of instances the group should have.
         */
        scaleMaxCapacity?: string;
        /**
         * The minimum number of instances the group should have.
         */
        scaleMinCapacity?: string;
        /**
         * The desired number of instances the group should have.
         */
        scaleTargetCapacity?: string;
        /**
         * Set a start time for one time tasks.
         */
        startTime?: string;
        /**
         * The desired number of instances the group should have.
         */
        targetCapacity?: string;
        /**
         * The task type to run. Supported task types are: `"scale"`, `"backupAmi"`, `"roll"`, `"scaleUp"`, `"percentageScaleUp"`, `"scaleDown"`, `"percentageScaleDown"`, `"statefulUpdateCapacity"`.
         */
        taskType: string;
    }

    export interface ElastigroupSignal {
        /**
         * The name of the signal defined for the group. Valid Values: `"INSTANCE_READY"`, `"INSTANCE_READY_TO_SHUTDOWN"`
         */
        name: string;
        /**
         * The signals defined timeout- default is 40 minutes (1800 seconds).
         *
         * Usage:
         */
        timeout?: number;
    }

    export interface ElastigroupStatefulDeallocation {
        /**
         * For stateful groups: remove persistent images.
         */
        shouldDeleteImages?: boolean;
        /**
         * For stateful groups: remove network interfaces.
         */
        shouldDeleteNetworkInterfaces?: boolean;
        /**
         * For stateful groups: remove snapshots.
         *
         * Usage:
         */
        shouldDeleteSnapshots?: boolean;
        /**
         * For stateful groups: remove persistent volumes.
         */
        shouldDeleteVolumes?: boolean;
    }

    export interface ElastigroupStatefulInstanceAction {
        /**
         * String, Stateful Instance ID on which the action should be performed.
         */
        statefulInstanceId: string;
        /**
         * String, Action type. Supported action types: `pause`, `resume`, `recycle`, `deallocate`.
         *
         * Usage:
         */
        type: string;
    }

    export interface ElastigroupTag {
        key?: string;
        value?: string;
    }

    export interface ElastigroupUpdatePolicy {
        /**
         * Enables updates to tags without rolling the group when set to `true`.
         */
        autoApplyTags?: boolean;
        /**
         * While used, you can control whether the group should perform a deployment after an update to the configuration.
         */
        rollConfig?: outputs.aws.ElastigroupUpdatePolicyRollConfig;
        /**
         * This will apply resuming action for Stateful instances in the Elastigroup upon scale up or capacity changes. Example usage will be for Elastigroups that will have scheduling rules to set a target capacity of 0 instances in the night and automatically restore the same state of the instances in the morning.
         */
        shouldResumeStateful: boolean;
        /**
         * Sets the enablement of the roll option.
         */
        shouldRoll: boolean;
    }

    export interface ElastigroupUpdatePolicyRollConfig {
        /**
         * Sets the percentage of the instances to deploy in each batch.
         */
        batchSizePercentage: number;
        /**
         * Sets the grace period for new instances to become healthy.
         */
        gracePeriod?: number;
        /**
         * Sets the health check type to use. Valid values: `"EC2"`, `"ECS_CLUSTER_INSTANCE"`, `"ELB"`, `"HCS"`, `"TARGET_GROUP"`, `"NONE"`.
         */
        healthCheckType?: string;
        /**
         * Strategy parameters
         */
        strategy?: outputs.aws.ElastigroupUpdatePolicyRollConfigStrategy;
        /**
         * For use with `shouldRoll`. Sets minimum % of roll required to complete before continuing the plan. Required if `waitForRollTimeout` is set.
         */
        waitForRollPercentage?: number;
        /**
         * For use with `shouldRoll`. Sets how long to wait for the deployed % of a roll to exceed `waitForRollPercentage` before continuing the plan. Required if `waitForRollPercentage` is set.
         */
        waitForRollTimeout?: number;
    }

    export interface ElastigroupUpdatePolicyRollConfigStrategy {
        /**
         * Action to take. Valid values: `REPLACE_SERVER`, `RESTART_SERVER`.
         */
        action: string;
        /**
         * Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the deployment will fail. Range `1` - `100`.
         */
        batchMinHealthyPercentage?: number;
        /**
         * Set detach options to the deployment.
         */
        onFailure?: outputs.aws.ElastigroupUpdatePolicyRollConfigStrategyOnFailure;
        /**
         * Specify whether to drain incoming TCP connections before terminating a server.
         */
        shouldDrainInstances?: boolean;
    }

    export interface ElastigroupUpdatePolicyRollConfigStrategyOnFailure {
        /**
         * Sets the action that will take place, Accepted values are: `DETACH_OLD`, `DETACH_NEW`.
         */
        actionType: string;
        batchNum?: number;
        /**
         * Indicates (in seconds) the timeout to wait until instance are detached.
         */
        drainingTimeout?: number;
        /**
         * Decrementing the group target capacity after detaching the instances.
         */
        shouldDecrementTargetCapacity?: boolean;
        /**
         * Indicator if the action should apply to all batches of the deployment or only the latest batch.
         */
        shouldHandleAllBatches?: boolean;
    }

    export interface ManagedInstanceBlockDeviceMapping {
        deviceName: string;
        ebs?: outputs.aws.ManagedInstanceBlockDeviceMappingEbs;
    }

    export interface ManagedInstanceBlockDeviceMappingEbs {
        deleteOnTermination: boolean;
        encrypted?: boolean;
        iops?: number;
        kmsKeyId?: string;
        snapshotId?: string;
        throughput?: number;
        volumeSize?: number;
        volumeType: string;
    }

    export interface ManagedInstanceDelete {
        amiBackupShouldDeleteImages?: boolean;
        deallocationConfigShouldDeleteImages?: boolean;
        shouldDeleteNetworkInterfaces?: boolean;
        shouldDeleteSnapshots?: boolean;
        shouldDeleteVolumes?: boolean;
        shouldTerminateInstance?: boolean;
    }

    export interface ManagedInstanceIntegrationRoute53 {
        domains: outputs.aws.ManagedInstanceIntegrationRoute53Domain[];
    }

    export interface ManagedInstanceIntegrationRoute53Domain {
        hostedZoneId: string;
        recordSetType?: string;
        recordSets: outputs.aws.ManagedInstanceIntegrationRoute53DomainRecordSet[];
        spotinstAcctId?: string;
    }

    export interface ManagedInstanceIntegrationRoute53DomainRecordSet {
        name: string;
        usePublicDns?: boolean;
        usePublicIp?: boolean;
    }

    export interface ManagedInstanceLoadBalancer {
        arn?: string;
        name?: string;
        type: string;
    }

    export interface ManagedInstanceManagedInstanceAction {
        type: string;
    }

    export interface ManagedInstanceMetadataOptions {
        httpPutResponseHopLimit?: number;
        httpTokens: string;
        instanceMetadataTags?: string;
    }

    export interface ManagedInstanceNetworkInterface {
        associateIpv6Address?: boolean;
        associatePublicIpAddress?: boolean;
        deviceIndex: string;
    }

    export interface ManagedInstanceResourceRequirement {
        excludedInstanceFamilies?: string[];
        excludedInstanceGenerations?: string[];
        excludedInstanceTypes?: string[];
        requiredGpuMaximum?: number;
        requiredGpuMinimum?: number;
        requiredMemoryMaximum: number;
        requiredMemoryMinimum: number;
        requiredVcpuMaximum: number;
        requiredVcpuMinimum: number;
    }

    export interface ManagedInstanceResourceTagSpecification {
        shouldTagAmis?: boolean;
        shouldTagEnis?: boolean;
        shouldTagSnapshots?: boolean;
        shouldTagVolumes?: boolean;
    }

    export interface ManagedInstanceRevertToSpot {
        performAt: string;
    }

    export interface ManagedInstanceScheduledTask {
        cronExpression?: string;
        frequency?: string;
        isEnabled?: boolean;
        startTime?: string;
        taskType: string;
    }

    export interface ManagedInstanceTag {
        key?: string;
        value?: string;
    }

    export interface MrScalarApplication {
        /**
         * Arguments for EMR to pass to the application.
         */
        args?: string[];
        /**
         * The MrScaler name.
         */
        name: string;
        /**
         * T he version of the application.
         */
        version?: string;
    }

    export interface MrScalarBootstrapActionsFile {
        bucket: string;
        key: string;
    }

    export interface MrScalarConfigurationsFile {
        bucket: string;
        key: string;
    }

    export interface MrScalarCoreEbsBlockDevice {
        iops?: number;
        sizeInGb: number;
        volumeType: string;
        volumesPerInstance?: number;
    }

    export interface MrScalarCoreScalingDownPolicy {
        /**
         * The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
         */
        actionType?: string;
        /**
         * The number of instances to add/remove to/from the target capacity when scale is needed.
         */
        adjustment?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
         */
        cooldown: number;
        /**
         * A mapping of dimensions describing qualities of the metric.
         */
        dimensions?: {[key: string]: string};
        evaluationPeriods: number;
        /**
         * Max target capacity for scale down.
         */
        maxTargetCapacity?: string;
        /**
         * The maximum to set when scale is needed.
         */
        maximum?: string;
        metricName: string;
        /**
         * Min target capacity for scale up.
         */
        minTargetCapacity?: string;
        /**
         * The minimum to set when scale is needed.
         */
        minimum?: string;
        namespace: string;
        operator: string;
        period: number;
        /**
         * The name of the policy.
         */
        policyName: string;
        statistic: string;
        /**
         * The number of instances to set when scale is needed.
         */
        target?: string;
        threshold: number;
        unit: string;
    }

    export interface MrScalarCoreScalingUpPolicy {
        /**
         * The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
         */
        actionType?: string;
        /**
         * The number of instances to add/remove to/from the target capacity when scale is needed.
         */
        adjustment?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
         */
        cooldown: number;
        /**
         * A mapping of dimensions describing qualities of the metric.
         */
        dimensions?: {[key: string]: string};
        evaluationPeriods: number;
        /**
         * Max target capacity for scale down.
         */
        maxTargetCapacity?: string;
        /**
         * The maximum to set when scale is needed.
         */
        maximum?: string;
        metricName: string;
        /**
         * Min target capacity for scale up.
         */
        minTargetCapacity?: string;
        /**
         * The minimum to set when scale is needed.
         */
        minimum?: string;
        namespace: string;
        operator: string;
        period: number;
        /**
         * The name of the policy.
         */
        policyName: string;
        statistic: string;
        /**
         * The number of instances to set when scale is needed.
         */
        target?: string;
        threshold: number;
        unit: string;
    }

    export interface MrScalarInstanceWeight {
        /**
         * The type of the instance.
         */
        instanceType: string;
        /**
         * The weight given to the associated instance type.
         */
        weightedCapacity: number;
    }

    export interface MrScalarMasterEbsBlockDevice {
        iops?: number;
        sizeInGb: number;
        volumeType: string;
        volumesPerInstance?: number;
    }

    export interface MrScalarProvisioningTimeout {
        /**
         * The amount of time (minutes) after which the cluster is automatically terminated if it's still in provisioning status. Minimum: '15'.
         */
        timeout: number;
        /**
         * The action to take if the timeout is exceeded. Valid values: `terminate`, `terminateAndRetry`.
         */
        timeoutAction: string;
    }

    export interface MrScalarScheduledTask {
        /**
         * A cron expression representing the schedule for the task.
         */
        cron: string;
        /**
         * New desired capacity for the elastigroup.
         */
        desiredCapacity?: string;
        /**
         * Select the EMR instance groups to execute the scheduled task on. Valid values: `task`.
         */
        instanceGroupType: string;
        /**
         * Enable/Disable the specified scheduling task.
         */
        isEnabled?: boolean;
        /**
         * New max capacity for the elastigroup.
         */
        maxCapacity?: string;
        /**
         * New min capacity for the elastigroup.
         */
        minCapacity?: string;
        /**
         * The type of task to be scheduled. Valid values: `setCapacity`.
         */
        taskType: string;
    }

    export interface MrScalarStepsFile {
        bucket: string;
        key: string;
    }

    export interface MrScalarTag {
        key: string;
        /**
         * Tag value.
         *
         * <a id="Optional Compute Parameters"></a>
         */
        value: string;
    }

    export interface MrScalarTaskEbsBlockDevice {
        iops?: number;
        sizeInGb: number;
        volumeType: string;
        volumesPerInstance?: number;
    }

    export interface MrScalarTaskScalingDownPolicy {
        /**
         * The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
         */
        actionType?: string;
        /**
         * The number of instances to add/remove to/from the target capacity when scale is needed.
         */
        adjustment?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
         */
        cooldown: number;
        /**
         * A mapping of dimensions describing qualities of the metric.
         */
        dimensions?: {[key: string]: string};
        evaluationPeriods: number;
        /**
         * Max target capacity for scale down.
         */
        maxTargetCapacity?: string;
        /**
         * The maximum to set when scale is needed.
         */
        maximum?: string;
        metricName: string;
        /**
         * Min target capacity for scale up.
         */
        minTargetCapacity?: string;
        /**
         * The minimum to set when scale is needed.
         */
        minimum?: string;
        namespace: string;
        operator: string;
        period: number;
        /**
         * The name of the policy.
         */
        policyName: string;
        statistic: string;
        /**
         * The number of instances to set when scale is needed.
         */
        target?: string;
        threshold: number;
        unit: string;
    }

    export interface MrScalarTaskScalingUpPolicy {
        /**
         * The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
         */
        actionType?: string;
        /**
         * The number of instances to add/remove to/from the target capacity when scale is needed.
         */
        adjustment?: string;
        /**
         * The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
         */
        cooldown: number;
        /**
         * A mapping of dimensions describing qualities of the metric.
         */
        dimensions?: {[key: string]: string};
        evaluationPeriods: number;
        /**
         * Max target capacity for scale down.
         */
        maxTargetCapacity?: string;
        /**
         * The maximum to set when scale is needed.
         */
        maximum?: string;
        metricName: string;
        /**
         * Min target capacity for scale up.
         */
        minTargetCapacity?: string;
        /**
         * The minimum to set when scale is needed.
         */
        minimum?: string;
        namespace: string;
        operator: string;
        period: number;
        /**
         * The name of the policy.
         */
        policyName: string;
        statistic: string;
        /**
         * The number of instances to set when scale is needed.
         */
        target?: string;
        threshold: number;
        unit: string;
    }

    export interface MrScalarTerminationPolicy {
        statements: outputs.aws.MrScalarTerminationPolicyStatement[];
    }

    export interface MrScalarTerminationPolicyStatement {
        /**
         * The number of periods over which data is compared to the specified threshold.
         */
        evaluationPeriods?: number;
        /**
         * The name of the metric in CloudWatch which the statement will be based on.
         */
        metricName: string;
        /**
         * Must contain the value: `AWS/ElasticMapReduce`.
         */
        namespace: string;
        /**
         * The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
         */
        operator?: string;
        /**
         * The time window in seconds over which the statistic is applied.
         */
        period?: number;
        /**
         * The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
         */
        statistic?: string;
        /**
         * The value that the specified statistic is compared to.
         */
        threshold: number;
        /**
         * The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
         */
        unit?: string;
    }

    export interface OceanAttachLoadBalancer {
        /**
         * If type is "TARGET_GROUP" then an ARN is required. Otherwise is not allowed.
         */
        arn?: string;
        /**
         * If type is "CLASSIC" then a name is required. Otherwise is not allowed.
         */
        name?: string;
        /**
         * Type of load balancer to use.
         */
        type: string;
    }

    export interface OceanAutoscaler {
        /**
         * Set the auto headroom percentage (a number in the range [0, 200]) which controls the percentage of headroom from the cluster. Relevant only when `autoscaleIsAutoConfig` toggled on.
         */
        autoHeadroomPercentage?: number;
        /**
         * Cooldown period between scaling actions.
         */
        autoscaleCooldown?: number;
        /**
         * Auto Scaling scale down operations.
         */
        autoscaleDown?: outputs.aws.OceanAutoscalerAutoscaleDown;
        /**
         * Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
         */
        autoscaleHeadroom?: outputs.aws.OceanAutoscalerAutoscaleHeadroom;
        /**
         * Automatically configure and optimize headroom resources.
         */
        autoscaleIsAutoConfig?: boolean;
        /**
         * Enable the Ocean Kubernetes Auto Scaler.
         */
        autoscaleIsEnabled?: boolean;
        /**
         * enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
         */
        enableAutomaticAndManualHeadroom?: boolean;
        /**
         * List of Ocean extended resource definitions to use in this cluster.
         */
        extendedResourceDefinitions?: string[];
        /**
         * Optionally set upper and lower bounds on the resource usage of the cluster.
         */
        resourceLimits?: outputs.aws.OceanAutoscalerResourceLimits;
    }

    export interface OceanAutoscalerAutoscaleDown {
        evaluationPeriods?: number;
        /**
         * When set to 'true', the Aggressive Scale Down feature is enabled.
         */
        isAggressiveScaleDownEnabled?: boolean;
        /**
         * Would represent the maximum % to scale-down. Number between 1-100.
         */
        maxScaleDownPercentage?: number;
    }

    export interface OceanAutoscalerAutoscaleHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the number of GPUs to allocate the headroom.
         */
        gpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MB) to allocate the headroom.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
         */
        numOfUnits?: number;
    }

    export interface OceanAutoscalerResourceLimits {
        /**
         * The maximum memory in GiB units that can be allocated to the cluster.
         */
        maxMemoryGib?: number;
        /**
         * The maximum cpu in vCPU units that can be allocated to the cluster.
         */
        maxVcpu?: number;
    }

    export interface OceanBlockDeviceMapping {
        /**
         * String. Set device name. (Example: `/dev/xvda`).
         */
        deviceName?: string;
        /**
         * Object. Set Elastic Block Store properties .
         */
        ebs?: outputs.aws.OceanBlockDeviceMappingEbs;
    }

    export interface OceanBlockDeviceMappingEbs {
        /**
         * Boolean. Flag to delete the EBS on instance termination.
         */
        deleteOnTermination: boolean;
        /**
         * Set dynamic IOPS properties. When using this object, you cannot use the `iops` attribute. You must use one or the other.
         */
        dynamicIops?: outputs.aws.OceanBlockDeviceMappingEbsDynamicIops;
        /**
         * Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
         */
        dynamicVolumeSize?: outputs.aws.OceanBlockDeviceMappingEbsDynamicVolumeSize;
        /**
         * Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
         */
        encrypted: boolean;
        /**
         * Must be greater than or equal to 0.
         */
        iops?: number;
        /**
         * String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
         */
        kmsKeyId?: string;
        /**
         * (Optional) String. The Snapshot ID to mount by.
         */
        snapshotId?: string;
        /**
         * The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volumeType` = `gp3`.
         */
        throughput?: number;
        /**
         * Int. The size, in GB of the volume.
         */
        volumeSize?: number;
        /**
         * String. The type of the volume. (Example: `gp2`).
         */
        volumeType: string;
    }

    export interface OceanBlockDeviceMappingEbsDynamicIops {
        /**
         * Initial size for IOPS.
         */
        baseSize: number;
        resource: string;
        /**
         * Additional size per resource unit (in IOPS). (Example: `baseSize=50`, `sizePerResourceUnit=20`, and an instance with 2 CPU is launched; its IOPS size will be: 90).
         */
        sizePerResourceUnit: number;
    }

    export interface OceanBlockDeviceMappingEbsDynamicVolumeSize {
        /**
         * Int. Initial size for volume. (Example: 50)
         */
        baseSize: number;
        /**
         * String. Resource type to increase volume size dynamically by. (Valid values: `CPU`)
         */
        resource: string;
        /**
         * Int. Additional size (in GB) per resource unit. (Example: `baseSize=50`, `sizePerResourceUnit=20`, and instance with 2 CPU is launched; its total disk size will be: 90GB).
         */
        sizePerResourceUnit: number;
    }

    export interface OceanClusterOrientation {
        /**
         * You can control the approach that Ocean takes while launching nodes by configuring this value. Possible values: `costOriented`,`balanced`,`cheapest`.
         */
        availabilityVsCost?: string;
    }

    export interface OceanDetachLoadBalancer {
        /**
         * If type is "TARGET_GROUP" then an ARN is required. Otherwise is not allowed.
         */
        arn?: string;
        /**
         * If type is "CLASSIC" then a name is required. Otherwise is not allowed.
         */
        name?: string;
        /**
         * Type of load balancer to use.
         */
        type: string;
    }

    export interface OceanFilters {
        /**
         * The filtered instance types will support at least one of the architectures from this list.
         */
        architectures?: string[];
        /**
         * The filtered instance types will belong to one of the categories types from this list.
         */
        categories?: string[];
        /**
         * The filtered instance types will have one of the disk type from this list.
         */
        diskTypes?: string[];
        /**
         * Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
         */
        excludeFamilies?: string[];
        /**
         * In case excludeMetal is set to true, metal types will not be available for scaling.
         */
        excludeMetal?: boolean;
        /**
         * The filtered instance types will have a hypervisor type from this list.
         */
        hypervisors?: string[];
        /**
         * Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
         */
        includeFamilies?: string[];
        /**
         * Ena is supported or not.
         */
        isEnaSupported?: string;
        /**
         * Maximum total number of GPUs.
         */
        maxGpu?: number;
        maxMemoryGib?: number;
        /**
         * Maximum Bandwidth in Gib/s of network performance.
         */
        maxNetworkPerformance?: number;
        maxVcpu?: number;
        /**
         * Minimum number of network interfaces (ENIs).
         */
        minEnis?: number;
        /**
         * Minimum total number of GPUs.
         */
        minGpu?: number;
        /**
         * Minimum amount of Memory (GiB).
         */
        minMemoryGib?: number;
        /**
         * Minimum Bandwidth in Gib/s of network performance.
         */
        minNetworkPerformance?: number;
        /**
         * Minimum number of vcpus available.
         */
        minVcpu?: number;
        /**
         * The filtered instance types will have a root device types from this list.
         */
        rootDeviceTypes?: string[];
        /**
         * The filtered instance types will support at least one of the virtualization types from this list.
         */
        virtualizationTypes?: string[];
    }

    export interface OceanInstanceMetadataOptions {
        /**
         * An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
         */
        httpPutResponseHopLimit?: number;
        /**
         * Determines if a signed token is required or not. Valid values: `optional` or `required`.
         */
        httpTokens: string;
    }

    export interface OceanInstanceStorePolicy {
        /**
         * Value: `"RAID0"` The method for using the instance store volumes (must also be defined in the userData).
         */
        instanceStorePolicyType?: string;
    }

    export interface OceanLaunchSpecAutoscaleDown {
        /**
         * The maximum percentage allowed to scale down in a single scaling action on the nodes running in a specific VNG. Allowed only if maxScaleDownPercentage is set to null at the cluster level. Number between [0.1-100].
         */
        maxScaleDownPercentage?: number;
    }

    export interface OceanLaunchSpecAutoscaleHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the number of GPUS to allocate for each headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecAutoscaleHeadroomsAutomatic {
        /**
         * Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.`isEnabled` = true is set on the Ocean cluster.
         */
        autoHeadroomPercentage?: number;
    }

    export interface OceanLaunchSpecBlockDeviceMapping {
        /**
         * String. Set device name. (Example: `/dev/xvda`).
         */
        deviceName?: string;
        /**
         * Object. Set Elastic Block Store properties .
         */
        ebs?: outputs.aws.OceanLaunchSpecBlockDeviceMappingEbs;
        noDevice?: string;
        virtualName?: string;
    }

    export interface OceanLaunchSpecBlockDeviceMappingEbs {
        /**
         * Boolean. Flag to delete the EBS on instance termination.
         */
        deleteOnTermination?: boolean;
        /**
         * Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
         */
        dynamicVolumeSize?: outputs.aws.OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize;
        /**
         * Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
         */
        encrypted?: boolean;
        /**
         * Int. The number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
         */
        kmsKeyId?: string;
        /**
         * (Optional) String. The Snapshot ID to mount by.
         */
        snapshotId?: string;
        /**
         * The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volumeType` = `gp3`.
         */
        throughput?: number;
        /**
         * Int. The size, in GB of the volume.
         */
        volumeSize?: number;
        /**
         * String. The type of the volume. (Example: `gp2`).
         */
        volumeType?: string;
    }

    export interface OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize {
        /**
         * Int. Initial size for volume. (Example: 50)
         */
        baseSize: number;
        /**
         * String. Resource type to increase volume size dynamically by. (Valid values: `CPU`)
         */
        resource: string;
        /**
         * Int. Additional size (in GB) per resource unit. (Example: `baseSize=50`, `sizePerResourceUnit=20`, and instance with 2 CPU is launched; its total disk size will be: 90GB)
         */
        sizePerResourceUnit: number;
    }

    export interface OceanLaunchSpecCreateOptions {
        /**
         * When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group. The parameter is recommended in case the useAsTemplateOnly (in spotinst.aws.Ocean resource) is set to true during Ocean resource creation.
         */
        initialNodes?: number;
    }

    export interface OceanLaunchSpecDeleteOptions {
        /**
         * When set to "true", all instances belonging to the deleted launch specification will be drained, detached, and terminated.
         */
        deleteNodes?: boolean;
        /**
         * When set to `true`, delete even if it is the last Virtual Node Group (also, the default Virtual Node Group must be configured with `useAsTemlateOnly = true`). Should be set at creation or update, but will be used only at deletion.
         */
        forceDelete: boolean;
    }

    export interface OceanLaunchSpecElasticIpPool {
        /**
         * A key-value pair, which defines an Elastic IP from the customer pool. Can be null.
         */
        tagSelector?: outputs.aws.OceanLaunchSpecElasticIpPoolTagSelector;
    }

    export interface OceanLaunchSpecElasticIpPoolTagSelector {
        /**
         * Elastic IP tag key. The Virtual Node Group will consider all Elastic IPs tagged with this tag as a part of the Elastic IP pool to use.
         */
        tagKey: string;
        /**
         * Elastic IP tag value. Can be null.
         */
        tagValue?: string;
    }

    export interface OceanLaunchSpecEphemeralStorage {
        /**
         * Specify an alternative device name from which ephemeral storage calculations should be derived. This parameter is used when the ephemeral storage should not utilize the root device. Provide the device name configured in the VNG's BDM or AMI's BDM that differs from the default root device.
         */
        ephemeralStorageDeviceName?: string;
    }

    export interface OceanLaunchSpecImage {
        /**
         * Identifier of the image in AWS. Valid values: any string which is not empty or null.
         */
        imageId?: string;
    }

    export interface OceanLaunchSpecInstanceMetadataOptions {
        /**
         * An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
         */
        httpPutResponseHopLimit?: number;
        /**
         * Determines if a signed token is required or not. Valid values: `optional` or `required`.
         */
        httpTokens: string;
    }

    export interface OceanLaunchSpecInstanceStorePolicy {
        /**
         * Value: `"RAID0"` The method for using the instance store volumes (must also be defined in the userData).
         */
        instanceStorePolicyType?: string;
    }

    export interface OceanLaunchSpecInstanceTypesFilters {
        /**
         * The filtered instance types will belong to one of the categories types from this list. Valid values: `Accelerated_computing`, `Compute_optimized`, `General_purpose`, `Memory_optimized`, `Storage_optimized`.
         */
        categories?: string[];
        /**
         * The filtered instance types will have one of the disk type from this list. Valid values: `NVMe`, `EBS`, `SSD`, `HDD`.
         */
        diskTypes?: string[];
        /**
         * Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
         */
        excludeFamilies?: string[];
        /**
         * In case excludeMetal is set to true, metal types will not be available for scaling.
         */
        excludeMetal?: boolean;
        /**
         * The filtered instance types will have a hypervisor type from this list. Valid values: `nitro`, `xen`.
         */
        hypervisors?: string[];
        /**
         * Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
         */
        includeFamilies?: string[];
        /**
         * Ena is supported or not.
         */
        isEnaSupported?: string;
        /**
         * Maximum total number of GPUs.
         */
        maxGpu?: number;
        /**
         * Maximum amount of Memory (GiB).
         */
        maxMemoryGib?: number;
        /**
         * Maximum Bandwidth in Gib/s of network performance.
         */
        maxNetworkPerformance?: number;
        /**
         * Maximum number of vcpus available.
         */
        maxVcpu?: number;
        /**
         * Minimum number of network interfaces (ENIs).
         */
        minEnis?: number;
        /**
         * Minimum total number of GPUs.
         */
        minGpu?: number;
        /**
         * Minimum amount of Memory (GiB).
         */
        minMemoryGib?: number;
        /**
         * Minimum Bandwidth in Gib/s of network performance.
         */
        minNetworkPerformance?: number;
        /**
         * Minimum number of vcpus available.
         */
        minVcpu?: number;
        /**
         * The filtered instance types will have a root device types from this list. Valid values: `ebs`, or `instance-store`.
         */
        rootDeviceTypes?: string[];
        /**
         * The filtered instance types will support at least one of the virtualization types from this list. Valid values: `hvm`, `paravirtual`.
         */
        virtualizationTypes?: string[];
    }

    export interface OceanLaunchSpecLabel {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface OceanLaunchSpecResourceLimit {
        /**
         * Set a maximum number of instances per Virtual Node Group. Can be null. If set, value must be greater than or equal to 0.
         */
        maxInstanceCount?: number;
        /**
         * Set a minimum number of instances per Virtual Node Group. Can be null. If set, value must be greater than or equal to 0.
         */
        minInstanceCount?: number;
    }

    export interface OceanLaunchSpecSchedulingShutdownHours {
        /**
         * Flag to enable or disable the shutdown hours mechanism. When `false`, the mechanism is deactivated, and the virtual node group remains in its current state.
         */
        isEnabled?: boolean;
        /**
         * The times that the shutdown hours will apply.
         */
        timeWindows: string[];
    }

    export interface OceanLaunchSpecSchedulingTask {
        /**
         * A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
         */
        cronExpression: string;
        /**
         * Describes whether the task is enabled. When `true`, the task runs. When `false`, it does not run.
         */
        isEnabled: boolean;
        /**
         * The config of this scheduled task. Depends on the value of taskType.
         */
        taskHeadrooms?: outputs.aws.OceanLaunchSpecSchedulingTaskTaskHeadroom[];
        /**
         * The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
         */
        taskType: string;
    }

    export interface OceanLaunchSpecSchedulingTaskTaskHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the number of GPUS to allocate for each headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecStartupTaint {
        /**
         * Set startup taint effect.
         */
        effect?: string;
        /**
         * Set startup taint key.
         */
        key?: string;
        /**
         * Set startup taint value.
         */
        value?: string;
    }

    export interface OceanLaunchSpecStrategy {
        /**
         * The configurable amount of time that Ocean will wait for the draining process to complete before terminating an instance. If you have not defined a draining timeout, the default of 300 seconds will be used.
         */
        drainingTimeout?: number;
        /**
         * The desired percentage of the Spot instances out of all running instances for this VNG. Only available when the field is not set in the cluster directly (cluster.strategy.spotPercentage).
         */
        spotPercentage?: number;
        /**
         * When set as ‘true’, if savings plans commitments have available capacity, Ocean will utilize them alongside RIs (if exist) to maximize cost efficiency. If the value is set as 'null', it will automatically be inherited from the cluster level.
         */
        utilizeCommitments?: boolean;
        /**
         * When set as ‘true’, if reserved instances exist, Ocean will utilize them before launching spot instances. If the value is set as 'null', it will automatically be inherited from the cluster level.
         */
        utilizeReservedInstances?: boolean;
    }

    export interface OceanLaunchSpecTag {
        key: string;
        value: string;
    }

    export interface OceanLaunchSpecTaint {
        /**
         * The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
         */
        effect: string;
        /**
         * The taint key.
         */
        key: string;
        /**
         * The taint value.
         */
        value: string;
    }

    export interface OceanLaunchSpecUpdatePolicy {
        /**
         * Holds the roll configuration.
         */
        rollConfig?: outputs.aws.OceanLaunchSpecUpdatePolicyRollConfig;
        /**
         * Enables the roll.
         */
        shouldRoll: boolean;
    }

    export interface OceanLaunchSpecUpdatePolicyRollConfig {
        /**
         * Sets the percentage of the instances to deploy in each batch.
         */
        batchSizePercentage: number;
        /**
         * During the roll, if the parameter is set to `true` we honor PDB during the instance replacement.
         */
        respectPdb?: boolean;
    }

    export interface OceanLoadBalancer {
        /**
         * Required if type is set to `TARGET_GROUP`
         */
        arn?: string;
        /**
         * Required if type is set to `CLASSIC`
         */
        name?: string;
        /**
         * Can be set to `CLASSIC` or `TARGET_GROUP`
         */
        type?: string;
    }

    export interface OceanLogging {
        /**
         * Logging Export configuration.
         */
        export?: outputs.aws.OceanLoggingExport;
    }

    export interface OceanLoggingExport {
        /**
         * Exports your cluster's logs to the S3 bucket and subdir configured on the S3 data integration given.
         */
        s3s?: outputs.aws.OceanLoggingExportS3[];
    }

    export interface OceanLoggingExportS3 {
        /**
         * The identifier of The S3 data integration to export the logs to.
         */
        id: string;
    }

    export interface OceanResourceTagSpecification {
        /**
         * Specify if Volume resources will be tagged with Virtual Node Group tags or Ocean tags.
         */
        shouldTagVolumes?: boolean;
    }

    export interface OceanScheduledTask {
        /**
         * Set shutdown hours for cluster object.
         */
        shutdownHours?: outputs.aws.OceanScheduledTaskShutdownHours;
        /**
         * The scheduling tasks for the cluster.
         */
        tasks?: outputs.aws.OceanScheduledTaskTask[];
    }

    export interface OceanScheduledTaskShutdownHours {
        /**
         * Toggle the shutdown hours task. (Example: `true`).
         */
        isEnabled?: boolean;
        /**
         * Set time windows for shutdown hours. Specify a list of `timeWindows` with at least one time window Each string is in the format of: `ddd:hh:mm-ddd:hh:mm` where `ddd` = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat, `hh` = hour 24 = 0 -23, `mm` = minute = 0 - 59. Time windows should not overlap. Required if `cluster.scheduling.isEnabled` is `true`. (Example: `Fri:15:30-Wed:14:30`).
         */
        timeWindows: string[];
    }

    export interface OceanScheduledTaskTask {
        /**
         * A valid cron expression. The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of `frequency` or `cronExpression` should be used at a time. Required for `cluster.scheduling.tasks` object. (Example: `0 1 * * *`).
         */
        cronExpression: string;
        /**
         * Describes whether the task is enabled. When true the task should run when false it should not run. Required for `cluster.scheduling.tasks` object.
         */
        isEnabled: boolean;
        /**
         * This filed will be compatible to the `taskType` field. If `taskType` is defined as `clusterRoll`, user cluster roll object in parameters.
         */
        parameters?: outputs.aws.OceanScheduledTaskTaskParameters;
        /**
         * Valid values: `clusterRoll` `amiAutoUpdate`. Required for `cluster.scheduling.tasks`
         */
        taskType: string;
    }

    export interface OceanScheduledTaskTaskParameters {
        /**
         * Set amiAutoUpdate object
         */
        amiAutoUpdate?: outputs.aws.OceanScheduledTaskTaskParametersAmiAutoUpdate;
        /**
         * Set clusterRoll object
         */
        parametersClusterRoll?: outputs.aws.OceanScheduledTaskTaskParametersParametersClusterRoll;
    }

    export interface OceanScheduledTaskTaskParametersAmiAutoUpdate {
        /**
         * Set clusterRoll object
         */
        amiAutoUpdateClusterRoll?: outputs.aws.OceanScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRoll;
        /**
         * When the AMI is updated according to the configuration set, a cluster roll can be triggered
         */
        applyRoll?: boolean;
        /**
         * When set to 'true', the auto-update process will update the VNGs’ AMI with the AMI to match the Kubernetes control plane version. either "patch" or "minorVersion" must be true.
         */
        minorVersion?: boolean;
        /**
         * When set to 'true', the auto-update process will update the VNGs’ images with the latest security patches. either "patch" or "minorVersion" must be true.
         */
        patch?: boolean;
    }

    export interface OceanScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRoll {
        /**
         * Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
         */
        batchMinHealthyPercentage?: number;
        /**
         * Value as a percent to set the size of a batch in a roll. Valid values are 0-100.
         */
        batchSizePercentage?: number;
        /**
         * Add a `comment` description for the roll. The `comment` is limited to 256 chars
         */
        comment?: string;
        /**
         * During the roll, if the parameter is set to true we honor PDB during the instance replacement.
         */
        respectPdb?: boolean;
    }

    export interface OceanScheduledTaskTaskParametersParametersClusterRoll {
        /**
         * Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
         */
        batchMinHealthyPercentage?: number;
        /**
         * Value as a percent to set the size of a batch in a roll. Valid values are 0-100.
         */
        batchSizePercentage?: number;
        /**
         * Add a `comment` description for the roll. The `comment` is limited to 256 chars
         */
        comment?: string;
        /**
         * During the roll, if the parameter is set to true we honor PDB during the instance replacement.
         */
        respectPdb?: boolean;
    }

    export interface OceanStartupTaint {
        /**
         * Set startup taint effect.
         */
        effect?: string;
        /**
         * Set startup taint key.
         */
        key?: string;
        /**
         * Set startup taint value.
         */
        value?: string;
    }

    export interface OceanTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface OceanUpdatePolicy {
        /**
         * will update instance tags on the fly without rolling the cluster.
         */
        autoApplyTags?: boolean;
        /**
         * Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
         */
        conditionedRoll?: boolean;
        /**
         * A custom list of attributes will trigger the cluster roll operation (overrides the predefined list of parameters). Valid only when the `conditionedRoll` parameter is set to true. (Valid values: `"subnetIds"`,`"whitelist"`,`"blacklist"`,`"userData"`,`"imageId"`,`"securityGroups"`,`"keyName"`,`"iamInstanceProfile"`,`"associatePublicIpAddress"`,`"loadBalancers"`,`"instanceMetadataOptions"`,`"ebsOptimized"`,`"rootVolumeSize"`)
         */
        conditionedRollParams?: string[];
        /**
         * While used, you can control whether the group should perform a deployment after an update to the configuration.
         */
        rollConfig?: outputs.aws.OceanUpdatePolicyRollConfig;
        /**
         * Enables the roll.
         */
        shouldRoll: boolean;
    }

    export interface OceanUpdatePolicyRollConfig {
        /**
         * Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
         */
        batchMinHealthyPercentage?: number;
        /**
         * Sets the percentage of the instances to deploy in each batch.
         */
        batchSizePercentage: number;
        /**
         * List of virtual node group identifiers to be rolled.
         */
        launchSpecIds?: string[];
        /**
         * During the roll, if the parameter is set to `true` we honor PDB during the instance replacement.
         */
        respectPdb?: boolean;
    }

    export interface SuspensionSuspension {
        /**
         * The name of process to suspend. Valid values: `"AUTO_HEALING" , "OUT_OF_STRATEGY", "PREVENTIVE_REPLACEMENT", "REVERT_PREFERRED", or "SCHEDULING"`.
         */
        name: string;
    }

}

export namespace azure {
    export interface OceanNpAutoscaler {
        /**
         * Auto Scaling scale down operations.
         */
        autoscaleDown?: outputs.azure.OceanNpAutoscalerAutoscaleDown;
        /**
         * Spare resource capacity management enabling fast assignment of pods without waiting for new resources to launch.
         */
        autoscaleHeadroom?: outputs.azure.OceanNpAutoscalerAutoscaleHeadroom;
        /**
         * Enable the Ocean Kubernetes Autoscaler.
         */
        autoscaleIsEnabled?: boolean;
        /**
         * Optionally set upper and lower bounds on the resource usage of the cluster.
         */
        resourceLimits?: outputs.azure.OceanNpAutoscalerResourceLimits;
    }

    export interface OceanNpAutoscalerAutoscaleDown {
        /**
         * The maximum percentage allowed to scale down in a single scaling action.
         */
        maxScaleDownPercentage?: number;
    }

    export interface OceanNpAutoscalerAutoscaleHeadroom {
        /**
         * [Automatic headroom](https://docs.spot.io/ocean/features/headroom?id=automatic-headroom) configuration.
         */
        automatic?: outputs.azure.OceanNpAutoscalerAutoscaleHeadroomAutomatic;
    }

    export interface OceanNpAutoscalerAutoscaleHeadroomAutomatic {
        /**
         * Enable automatic headroom. When set to `true`, Ocean configures and optimizes headroom automatically.
         */
        isEnabled?: boolean;
        /**
         * Optionally set a number between 0-100 to control the percentage of total cluster resources dedicated to headroom.
         */
        percentage?: number;
    }

    export interface OceanNpAutoscalerResourceLimits {
        /**
         * The maximum memory in GiB units that can be allocated to the cluster.
         */
        maxMemoryGib?: number;
        /**
         * The maximum cpu in vCpu units that can be allocated to the cluster.
         */
        maxVcpu?: number;
    }

    export interface OceanNpFilters {
        /**
         * In case acceleratedNetworking is set to Enabled, accelerated networking applies only to the VM that enables it.
         */
        acceleratedNetworking?: string;
        /**
         * The filtered vm sizes will support at least one of the architectures from this list. x8664 includes both intel64 and amd64.
         */
        architectures?: string[];
        /**
         * The filtered vm sizes will support at least one of the classes from this list.
         */
        diskPerformance?: string;
        /**
         * Vm sizes belonging to a series from the list will not be available for scaling
         */
        excludeSeries?: string[];
        /**
         * The filtered gpu types will belong to one of the gpu types from this list.
         */
        gpuTypes?: string[];
        /**
         * Maximum number of GPUs available.
         */
        maxGpu?: number;
        /**
         * Maximum amount of Memory (GiB).
         */
        maxMemoryGib?: number;
        /**
         * Maximum number of vcpus available.
         */
        maxVcpu?: number;
        /**
         * Minimum number of data disks available.
         */
        minDisk?: number;
        /**
         * Minimum number of GPUs available.
         */
        minGpu?: number;
        /**
         * Minimum amount of Memory (GiB).
         */
        minMemoryGib?: number;
        /**
         * Minimum number of network interfaces.
         */
        minNics?: number;
        /**
         * Minimum number of vcpus available.
         */
        minVcpu?: number;
        /**
         * Vm sizes belonging to a series from the list will be available for scaling. We can specify include list and series can be specified with capital or small letters, with space, without space or with underscore '_' .  For example all of these "DSv2", "Ds v2", "dsV2" refer to same DS_v2 series.
         */
        series?: string[];
        /**
         * The filtered vm types will belong to one of the vm types from this list.
         */
        vmTypes?: string[];
    }

    export interface OceanNpHeadroom {
        /**
         * Configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Amount of GPU to allocate for headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Configure the amount of memory (MiB) to allocate the headroom.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
         */
        numOfUnits?: number;
    }

    export interface OceanNpHealth {
        /**
         * The amount of time to wait, in seconds, from the moment the instance has launched until monitoring of its health checks begins.
         */
        gracePeriod?: number;
    }

    export interface OceanNpLinuxOsConfig {
        /**
         * System Controls
         */
        sysctls?: outputs.azure.OceanNpLinuxOsConfigSysctl[];
    }

    export interface OceanNpLinuxOsConfigSysctl {
        /**
         * Maximum number of memory map areas a process may have. Can be configured only if OS type is Linux.
         */
        vmMaxMapCount?: number;
    }

    export interface OceanNpLogging {
        /**
         * The Ocean AKS Logging Export object.
         */
        export?: outputs.azure.OceanNpLoggingExport;
    }

    export interface OceanNpLoggingExport {
        /**
         * Exports your cluster's logs to the storage account and container configured on the storage account [data integration](https://docs.spot.io/ocean/features/log-integration-with-azure-blob?id=log-integration-with-azure-blob) given. Each file contains logs of 3 minutes where each log is separated by a new line and saved as a JSON. The file formats are `container`/`accountId``oceanId``oceanName`_`startTime`.log
         */
        azureBlobs?: outputs.azure.OceanNpLoggingExportAzureBlob[];
    }

    export interface OceanNpLoggingExportAzureBlob {
        /**
         * The identifier of The Azure Blob data integration to export the logs to.
         */
        id?: string;
    }

    export interface OceanNpScheduling {
        /**
         * An object used to specify times that the nodes in the virtual node group will be stopped.
         */
        shutdownHours?: outputs.azure.OceanNpSchedulingShutdownHours;
        suspensionHours?: outputs.azure.OceanNpSchedulingSuspensionHours;
        tasks?: outputs.azure.OceanNpSchedulingTask[];
    }

    export interface OceanNpSchedulingShutdownHours {
        isEnabled?: boolean;
        /**
         * The times that the shutdown hours will apply. Required if `isEnabled` is true.
         */
        timeWindows?: string[];
    }

    export interface OceanNpSchedulingSuspensionHours {
        isEnabled?: boolean;
        /**
         * The times that the shutdown hours will apply. Required if `isEnabled` is true.
         */
        timeWindows?: string[];
    }

    export interface OceanNpSchedulingTask {
        cronExpression: string;
        isEnabled: boolean;
        parameters?: outputs.azure.OceanNpSchedulingTaskParameters;
        taskType: string;
    }

    export interface OceanNpSchedulingTaskParameters {
        parametersClusterRoll?: outputs.azure.OceanNpSchedulingTaskParametersParametersClusterRoll;
        parametersUpgradeConfig?: outputs.azure.OceanNpSchedulingTaskParametersParametersUpgradeConfig;
    }

    export interface OceanNpSchedulingTaskParametersParametersClusterRoll {
        /**
         * Indicates the threshold of minimum healthy nodes in single batch. If the amount of healthy nodes in single batch is under the threshold, the roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
         */
        batchMinHealthyPercentage?: number;
        /**
         * Value as a percent to set the size of a batch in a roll. Valid values are 0-100. In case of null as value, the default value in the backend will be 20%.
         */
        batchSizePercentage?: number;
        /**
         * Add a comment description for the roll. The comment is limited to 256 chars and optional.
         */
        comment?: string;
        /**
         * During the roll, if the parameter is set to true we honor PDB during the nodes replacement.
         */
        respectPdb?: boolean;
        /**
         * During the roll, if the parameter is set to true we honor Restrict Scale Down label during the nodes replacement.
         */
        respectRestrictScaleDown?: boolean;
        /**
         * List of virtual node group identifiers to be rolled. Each identifier is a string. vngIds can be null, and cannot be used together with nodeNames and nodePoolNames.
         */
        vngIds?: string[];
    }

    export interface OceanNpSchedulingTaskParametersParametersUpgradeConfig {
        applyRoll?: boolean;
        rollParameters?: outputs.azure.OceanNpSchedulingTaskParametersParametersUpgradeConfigRollParameters;
        scopeVersion?: string;
    }

    export interface OceanNpSchedulingTaskParametersParametersUpgradeConfigRollParameters {
        /**
         * Indicates the threshold of minimum healthy nodes in single batch. If the amount of healthy nodes in single batch is under the threshold, the roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
         */
        batchMinHealthyPercentage?: number;
        /**
         * Value as a percent to set the size of a batch in a roll. Valid values are 0-100. In case of null as value, the default value in the backend will be 20%.
         */
        batchSizePercentage?: number;
        /**
         * Add a comment description for the roll. The comment is limited to 256 chars and optional.
         */
        comment?: string;
        /**
         * During the roll, if the parameter is set to true we honor PDB during the nodes replacement.
         */
        respectPdb?: boolean;
        /**
         * During the roll, if the parameter is set to true we honor Restrict Scale Down label during the nodes replacement.
         */
        respectRestrictScaleDown?: boolean;
    }

    export interface OceanNpTaint {
        /**
         * Set taint effect.
         */
        effect: string;
        /**
         * Set taint key. The following taint keys are not allowed: ["node.kubernetes.io/not-ready",  "node.kubernetes.io/unreachable", "node.kubernetes.io/unschedulable",  "node.kubernetes.io/memory-pressure",  "node.kubernetes.io/disk-pressure",  "node.kubernetes.io/network-unavailable",  "node.kubernetes.io/pid-pressure",  "node.kubernetes.io/out-of-service",  "node.cloudprovider.kubernetes.io/uninitialized",  "node.cloudprovider.kubernetes.io/shutdown", "kubernetes.azure.com/scalesetpriority"]
         */
        key: string;
        /**
         * Set taint value.
         */
        value: string;
    }

    export interface OceanNpUpdatePolicy {
        /**
         * Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as availability_zones, max_pods_per_node, enable_node_public_ip, os_disk_size_gb, os_disk_type, os_sku, kubernetes_version, vnet_subnet_ids, pod_subnet_ids, labels, taints and tags).
         */
        conditionedRoll?: boolean;
        /**
         * While used, you can control whether the group should perform a deployment after an update to the configuration.
         */
        rollConfig?: outputs.azure.OceanNpUpdatePolicyRollConfig;
        /**
         * If set to true along with the cluster update, roll will be triggered.
         */
        shouldRoll: boolean;
    }

    export interface OceanNpUpdatePolicyRollConfig {
        /**
         * Indicates the threshold of minimum healthy nodes in single batch. If the amount of healthy nodes in single batch is under the threshold, the roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
         */
        batchMinHealthyPercentage?: number;
        /**
         * Value as a percent to set the size of a batch in a roll. Valid values are 0-100. In case of null as value, the default value in the backend will be 20%.
         */
        batchSizePercentage?: number;
        /**
         * Add a comment description for the roll. The comment is limited to 256 chars and optional.
         */
        comment?: string;
        /**
         * List of node names to be rolled. Each identifier is a string. nodeNames can be null, and cannot be used together with nodePoolNames and vngIds.
         */
        nodeNames?: string[];
        /**
         * List of node pools to be rolled. Each node pool name is a string. nodePoolNames can be null, and cannot be used together with nodeNames and vngIds.
         */
        nodePoolNames?: string[];
        /**
         * During the roll, if the parameter is set to true we honor PDB during the nodes replacement.
         */
        respectPdb?: boolean;
        /**
         * During the roll, if the parameter is set to true we honor Restrict Scale Down label during the nodes replacement.
         */
        respectRestrictScaleDown?: boolean;
        /**
         * List of virtual node group identifiers to be rolled. Each identifier is a string. vngIds can be null, and cannot be used together with nodeNames and nodePoolNames.
         */
        vngIds?: string[];
    }

    export interface OceanNpVirtualNodeGroupFilters {
        /**
         * In case acceleratedNetworking is set to Enabled, accelerated networking applies only to the VM that enables it.
         */
        acceleratedNetworking?: string;
        /**
         * The filtered vm sizes will support at least one of the architectures from this list. x8664 includes both intel64 and amd64.
         */
        architectures?: string[];
        /**
         * The filtered vm sizes will support at least one of the classes from this list.
         */
        diskPerformance?: string;
        /**
         * Vm sizes belonging to a series from the list will not be available for scaling.
         */
        excludeSeries?: string[];
        /**
         * The filtered gpu types will belong to one of the gpu types from this list.
         */
        gpuTypes?: string[];
        /**
         * Maximum number of GPUs available.
         */
        maxGpu?: number;
        /**
         * Maximum amount of Memory (GiB).
         */
        maxMemoryGib?: number;
        /**
         * Maximum number of vcpus available.
         */
        maxVcpu?: number;
        /**
         * Minimum number of data disks available.
         */
        minDisk?: number;
        /**
         * Minimum number of GPUs available.
         */
        minGpu?: number;
        /**
         * Minimum amount of Memory (GiB).
         */
        minMemoryGib?: number;
        /**
         * Minimum number of network interfaces.
         */
        minNics?: number;
        /**
         * Minimum number of vcpus available.
         */
        minVcpu?: number;
        /**
         * Vm sizes belonging to a series from the list will be available for scaling.
         */
        series?: string[];
        /**
         * The filtered vm types will belong to one of the vm types from this list.
         */
        vmTypes?: string[];
    }

    export interface OceanNpVirtualNodeGroupHeadroom {
        /**
         * Configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Amount of GPU to allocate for headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Configure the amount of memory (MiB) to allocate the headroom.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
         */
        numOfUnits?: number;
    }

    export interface OceanNpVirtualNodeGroupLinuxOsConfig {
        /**
         * System Controls
         */
        sysctls?: outputs.azure.OceanNpVirtualNodeGroupLinuxOsConfigSysctl[];
    }

    export interface OceanNpVirtualNodeGroupLinuxOsConfigSysctl {
        /**
         * Maximum number of memory map areas a process may have. Can be configured only if OS type is Linux.
         */
        vmMaxMapCount?: number;
    }

    export interface OceanNpVirtualNodeGroupScheduling {
        /**
         * An object used to specify times that the nodes in the virtual node group will be stopped.
         */
        shutdownHours?: outputs.azure.OceanNpVirtualNodeGroupSchedulingShutdownHours;
    }

    export interface OceanNpVirtualNodeGroupSchedulingShutdownHours {
        /**
         * Flag to enable or disable the shutdown hours mechanism. When `false`, the mechanism is deactivated, and the virtual node gorup remains in its current state.
         */
        isEnabled?: boolean;
        /**
         * The times that the shutdown hours will apply. Required if isEnabled is true.
         */
        timeWindows?: string[];
    }

    export interface OceanNpVirtualNodeGroupTaint {
        /**
         * Set taint effect.
         */
        effect: string;
        /**
         * Set taint key. The following are not allowed: "kubernetes.azure.com/scalesetpriority".
         */
        key: string;
        /**
         * Set taint value.
         */
        value: string;
    }

    export interface OceanNpVirtualNodeGroupUpdatePolicy {
        /**
         * Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as availability_zones, max_pods_per_node, enable_node_public_ip, os_disk_size_gb, os_disk_type, os_sku, kubernetes_version, vnet_subnet_ids, pod_subnet_ids, labels, taints and tags).
         */
        conditionedRoll?: boolean;
        /**
         * While used, you can control whether the group should perform a deployment after an update to the configuration.
         */
        rollConfig?: outputs.azure.OceanNpVirtualNodeGroupUpdatePolicyRollConfig;
        /**
         * If set to true along with the vng update, roll will be triggered.
         */
        shouldRoll: boolean;
    }

    export interface OceanNpVirtualNodeGroupUpdatePolicyRollConfig {
        /**
         * Indicates the threshold of minimum healthy nodes in single batch. If the amount of healthy nodes in single batch is under the threshold, the roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
         */
        batchMinHealthyPercentage?: number;
        /**
         * Value as a percent to set the size of a batch in a roll. Valid values are 0-100. In case of null as value, the default value in the backend will be 20%.
         */
        batchSizePercentage?: number;
        /**
         * Add a comment description for the roll. The comment is limited to 256 chars and optional.
         */
        comment?: string;
        /**
         * List of node names to be rolled. Each identifier is a string. nodeNames can be null, and cannot be used together with nodePoolNames and vngIds.
         */
        nodeNames?: string[];
        /**
         * List of node pools to be rolled. Each node pool name is a string. nodePoolNames can be null, and cannot be used together with nodeNames and vngIds.
         */
        nodePoolNames?: string[];
        /**
         * During the roll, if the parameter is set to true we honor PDB during the nodes replacement.
         */
        respectPdb?: boolean;
        /**
         * During the roll, if the parameter is set to true we honor Restrict Scale Down label during the nodes replacement.
         */
        respectRestrictScaleDown?: boolean;
        /**
         * List of virtual node group identifiers to be rolled. Each identifier is a string. vngIds can be null, and cannot be used together with nodeNames and nodePoolNames.
         */
        vngIds?: string[];
    }

    export interface OceanNpVngTemplateScheduling {
        vngTemplateShutdownHours?: outputs.azure.OceanNpVngTemplateSchedulingVngTemplateShutdownHours;
    }

    export interface OceanNpVngTemplateSchedulingVngTemplateShutdownHours {
        isEnabled?: boolean;
        /**
         * The times that the shutdown hours will apply. Required if `isEnabled` is true.
         */
        timeWindows?: string[];
    }

}

export namespace ecs {
    export interface OceanAutoscaler {
        /**
         * The auto-headroom percentage. Set a number between 0-200 to control the headroom % of the cluster. Relevant when `isAutoConfig`= true.
         */
        autoHeadroomPercentage?: number;
        /**
         * Cooldown period between scaling actions.
         */
        cooldown?: number;
        /**
         * Auto Scaling scale down operations.
         */
        down?: outputs.ecs.OceanAutoscalerDown;
        /**
         * When set to true, both automatic and per custom launch specification manual headroom to be saved concurrently and independently in the cluster. prerequisite: isAutoConfig must be true
         */
        enableAutomaticAndManualHeadroom?: boolean;
        /**
         * Spare resource capacity management enabling fast assignment of tasks without waiting for new resources to launch.
         */
        headroom?: outputs.ecs.OceanAutoscalerHeadroom;
        /**
         * Automatically configure and optimize headroom resources.
         */
        isAutoConfig?: boolean;
        /**
         * Enable the Ocean ECS autoscaler.
         */
        isEnabled?: boolean;
        /**
         * Optionally set upper and lower bounds on the resource usage of the cluster.
         */
        resourceLimits?: outputs.ecs.OceanAutoscalerResourceLimits;
        /**
         * Option to scale down non-service tasks. If not set, Ocean does not scale down standalone tasks.
         */
        shouldScaleDownNonServiceTasks?: boolean;
    }

    export interface OceanAutoscalerDown {
        /**
         * Would represent the maximum % to scale-down. Number between 1-100.
         */
        maxScaleDownPercentage?: number;
    }

    export interface OceanAutoscalerHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MB) to allocate the headroom.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
         */
        numOfUnits?: number;
    }

    export interface OceanAutoscalerResourceLimits {
        /**
         * The maximum memory in GiB units that can be allocated to the cluster.
         */
        maxMemoryGib?: number;
        /**
         * The maximum cpu in vCPU units that can be allocated to the cluster.
         */
        maxVcpu?: number;
    }

    export interface OceanBlockDeviceMapping {
        /**
         * String. Set device name. Example: `/dev/xvda1`.
         */
        deviceName: string;
        /**
         * Object. Set Elastic Block Store properties.
         */
        ebs?: outputs.ecs.OceanBlockDeviceMappingEbs;
        /**
         * String. Suppresses the specified device included in the block device mapping of the AMI.
         */
        noDevice?: string;
        virtualName?: string;
    }

    export interface OceanBlockDeviceMappingEbs {
        /**
         * Boolean. Toggles EBS deletion upon instance termination.
         */
        deleteOnTermination: boolean;
        /**
         * Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
         */
        dynamicVolumeSize?: outputs.ecs.OceanBlockDeviceMappingEbsDynamicVolumeSize;
        /**
         * Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
         */
        encrypted: boolean;
        /**
         * Int. The number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
         */
        kmsKeyId?: string;
        /**
         * (Optional) String. The snapshot ID to mount by.
         */
        snapshotId?: string;
        /**
         * The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volumeType` = gp3.
         */
        throughput?: number;
        /**
         * Int. The size (in GB) of the volume.
         */
        volumeSize?: number;
        /**
         * String. The type of the volume. Example: `gp2`.
         */
        volumeType: string;
    }

    export interface OceanBlockDeviceMappingEbsDynamicVolumeSize {
        /**
         * Int. Initial size for volume. Example: `50`.
         */
        baseSize: number;
        /**
         * String. Resource type to increase volume size dynamically by. Valid values: `CPU`.
         */
        resource: string;
        /**
         * Int. Additional size (in GB) per resource unit. Example: When the `baseSize=50`, `sizePerResourceUnit=20`, and instance with two CPUs is launched, its total disk size will be: 90GB.
         */
        sizePerResourceUnit: number;
    }

    export interface OceanClusterOrientation {
        /**
         * You can control the approach that Ocean takes while launching nodes by configuring this value. Possible values: `costOriented`,`balanced`,`cheapest`.
         */
        availabilityVsCost?: string;
    }

    export interface OceanFilters {
        /**
         * The filtered instance types will support at least one of the architectures from this list.
         */
        architectures?: string[];
        /**
         * The filtered instance types will belong to one of the categories types from this list.
         */
        categories?: string[];
        /**
         * The filtered instance types will have one of the disk type from this list.
         */
        diskTypes?: string[];
        /**
         * Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
         */
        excludeFamilies?: string[];
        /**
         * In case excludeMetal is set to true, metal types will not be available for scaling.
         */
        excludeMetal?: boolean;
        /**
         * The filtered instance types will have a hypervisor type from this list.
         */
        hypervisors?: string[];
        /**
         * Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
         */
        includeFamilies?: string[];
        /**
         * Ena is supported or not.
         */
        isEnaSupported?: string;
        /**
         * Maximum total number of GPUs.
         */
        maxGpu?: number;
        maxMemoryGib?: number;
        /**
         * Maximum Bandwidth in Gib/s of network performance.
         */
        maxNetworkPerformance?: number;
        maxVcpu?: number;
        /**
         * Minimum number of network interfaces (ENIs).
         */
        minEnis?: number;
        /**
         * Minimum total number of GPUs.
         */
        minGpu?: number;
        /**
         * Minimum amount of Memory (GiB).
         */
        minMemoryGib?: number;
        /**
         * Minimum Bandwidth in Gib/s of network performance.
         */
        minNetworkPerformance?: number;
        /**
         * Minimum number of vcpus available.
         */
        minVcpu?: number;
        /**
         * The filtered instance types will have a root device types from this list.
         */
        rootDeviceTypes?: string[];
        /**
         * The filtered instance types will support at least one of the virtualization types from this list.
         */
        virtualizationTypes?: string[];
    }

    export interface OceanInstanceMetadataOptions {
        /**
         * An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
         */
        httpPutResponseHopLimit?: number;
        /**
         * Determines if a signed token is required or not. Valid values: `optional` or `required`.
         */
        httpTokens: string;
    }

    export interface OceanLaunchSpecAttribute {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface OceanLaunchSpecAutoscaleHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in CPU units, where 1024 units = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecBlockDeviceMapping {
        /**
         * String. Set device name. (Example: "/dev/xvda1").
         */
        deviceName: string;
        /**
         * Object. Set Elastic Block Store properties .
         */
        ebs?: outputs.ecs.OceanLaunchSpecBlockDeviceMappingEbs;
        /**
         * String. suppresses the specified device included in the block device mapping of the AMI.
         */
        noDevice?: string;
        virtualName?: string;
    }

    export interface OceanLaunchSpecBlockDeviceMappingEbs {
        /**
         * Boolean. Flag to delete the EBS on instance termination.
         */
        deleteOnTermination: boolean;
        /**
         * Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
         */
        dynamicVolumeSize?: outputs.ecs.OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize;
        /**
         * Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
         */
        encrypted: boolean;
        /**
         * Int. The number of I/O operations per second (IOPS) that the volume supports.
         */
        iops?: number;
        /**
         * String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
         */
        kmsKeyId?: string;
        /**
         * (Optional) String. The Snapshot ID to mount by.
         */
        snapshotId?: string;
        /**
         * The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volumeType` = gp3.
         */
        throughput?: number;
        /**
         * Int. The size, in GB of the volume.
         */
        volumeSize?: number;
        /**
         * String. The type of the volume (example: "gp2").
         */
        volumeType: string;
    }

    export interface OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize {
        /**
         * Int. Initial size for volume. (Example: 50)
         */
        baseSize: number;
        /**
         * String. Resource type to increase volume size dynamically by. (valid values: "CPU")
         */
        resource: string;
        /**
         * Int. Additional size (in GB) per resource unit. (Example: baseSize= 50, sizePerResourceUnit=20, and instance with 2 CPU is launched - its total disk size will be: 90GB)
         */
        sizePerResourceUnit: number;
    }

    export interface OceanLaunchSpecImage {
        /**
         * Identifier of the image in AWS. Valid values: any string which is not empty or null.
         */
        imageId?: string;
    }

    export interface OceanLaunchSpecInstanceMetadataOptions {
        /**
         * An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
         */
        httpPutResponseHopLimit?: number;
        /**
         * Determines if a signed token is required or not. Valid values: `optional` or `required`.
         */
        httpTokens: string;
    }

    export interface OceanLaunchSpecSchedulingTask {
        /**
         * A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
         */
        cronExpression: string;
        /**
         * Describes whether the task is enabled. When `true`, the task runs. When `false`, it does not run.
         */
        isEnabled: boolean;
        /**
         * The config of this scheduled task. Depends on the value of taskType.
         */
        taskHeadrooms?: outputs.ecs.OceanLaunchSpecSchedulingTaskTaskHeadroom[];
        /**
         * The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
         */
        taskType: string;
    }

    export interface OceanLaunchSpecSchedulingTaskTaskHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecStrategy {
        /**
         * When set, Ocean will proactively try to maintain as close as possible to the percentage of Spot instances out of all the Virtual Node Group instances.
         */
        spotPercentage?: number;
    }

    export interface OceanLaunchSpecTag {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface OceanLogging {
        /**
         * Logging Export configuration.
         */
        export?: outputs.ecs.OceanLoggingExport;
    }

    export interface OceanLoggingExport {
        /**
         * Exports your cluster's logs to the S3 bucket and subdir configured on the S3 data integration given.
         */
        s3s?: outputs.ecs.OceanLoggingExportS3[];
    }

    export interface OceanLoggingExportS3 {
        /**
         * The identifier of The S3 data integration to export the logs to.
         */
        id: string;
    }

    export interface OceanOptimizeImages {
        /**
         * String. Valid values: "always" "never" "timeWindow".
         */
        performAt: string;
        /**
         * Boolean. Enable auto image (AMI) update for the ECS container instances. The auto update applies for ECS-Optimized AMIs.
         */
        shouldOptimizeEcsAmi: boolean;
        /**
         * Array of strings. Set time windows for image update, at least one time window. Each string is in the format of ddd:hh:mm-ddd:hh:mm ddd. Time windows should not overlap.
         */
        timeWindows?: string[];
    }

    export interface OceanScheduledTask {
        /**
         * Set shutdown hours for cluster object.
         */
        shutdownHours?: outputs.ecs.OceanScheduledTaskShutdownHours;
        /**
         * The scheduling tasks for the cluster.
         */
        tasks?: outputs.ecs.OceanScheduledTaskTask[];
    }

    export interface OceanScheduledTaskShutdownHours {
        /**
         * Flag to enable / disable the shutdown hours.
         */
        isEnabled?: boolean;
        /**
         * Set time windows for shutdown hours. Specify a list of `timeWindows` with at least one time window Each string is in the format of `ddd:hh:mm-ddd:hh:mm` (ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59). Time windows should not overlap. Required when `cluster.scheduling.isEnabled` is true. API Times are in UTC. Example: `Fri:15:30-Wed:14:30`.
         */
        timeWindows: string[];
    }

    export interface OceanScheduledTaskTask {
        /**
         * A valid cron expression. The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of `frequency` or `cronExpression` should be used at a time. Required for `cluster.scheduling.tasks` object. Example: `0 1 * * *`.
         */
        cronExpression: string;
        /**
         * Describes whether the task is enabled. When true the task should run when false it should not run. Required for `cluster.scheduling.tasks` object.
         */
        isEnabled: boolean;
        /**
         * Valid values: "clusterRoll". Required for `cluster.scheduling.tasks object`. Example: `clusterRoll`.
         */
        taskType: string;
    }

    export interface OceanTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         * * `instanceTypes` - (Optional) The type of instances that may or may not be a part of the Ocean cluster.
         */
        value: string;
    }

    export interface OceanUpdatePolicy {
        /**
         * will update instance tags on the fly without rolling the cluster.
         */
        autoApplyTags?: boolean;
        /**
         * Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
         */
        conditionedRoll?: boolean;
        rollConfig?: outputs.ecs.OceanUpdatePolicyRollConfig;
        /**
         * Enables the roll.
         */
        shouldRoll: boolean;
    }

    export interface OceanUpdatePolicyRollConfig {
        /**
         * Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
         */
        batchMinHealthyPercentage?: number;
        /**
         * Sets the percentage of the instances to deploy in each batch.
         */
        batchSizePercentage: number;
    }

}

export namespace gcp {
    export interface ElastigroupBackendService {
        /**
         * Sets which location the backend services will be active. Valid values: `regional`, `global`.
         */
        locationType?: string;
        /**
         * Describes a named port and a list of ports.
         */
        namedPorts?: outputs.gcp.ElastigroupBackendServiceNamedPort[];
        /**
         * Use when `locationType` is "regional". Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: `INTERNAL`, `EXTERNAL`.
         */
        scheme?: string;
        /**
         * The name of the backend service.
         */
        serviceName: string;
    }

    export interface ElastigroupBackendServiceNamedPort {
        /**
         * The name of the port.
         */
        name: string;
        /**
         * A list of ports.
         *
         * Usage:
         */
        ports: string[];
    }

    export interface ElastigroupDisk {
        /**
         * Specifies whether the disk will be auto-deleted when the instance is deleted.
         */
        autoDelete?: boolean;
        /**
         * Indicates that this is a boot disk. The virtual machine will use the first partition of the disk for its root filesystem.
         */
        boot?: boolean;
        /**
         * Specifies a unique device name of your choice.
         */
        deviceName?: string;
        /**
         * Specifies the parameters for a new disk that will be created alongside the new instance. Use initialization parameters to create boot disks or local SSDs attached to the new instance.
         */
        initializeParams?: outputs.gcp.ElastigroupDiskInitializeParam[];
        /**
         * Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME.
         */
        interface?: string;
        /**
         * The mode in which to attach this disk, either READ_WRITE or READ_ONLY.
         */
        mode?: string;
        /**
         * Specifies a valid partial or full URL to an existing Persistent Disk resource. This field is only applicable for persistent disks.
         */
        source?: string;
        /**
         * Specifies the type of disk, either SCRATCH or PERSISTENT.
         */
        type?: string;
    }

    export interface ElastigroupDiskInitializeParam {
        /**
         * Specifies disk size in gigabytes. Must be in increments of 2.
         */
        diskSizeGb?: string;
        /**
         * Specifies the disk type to use to create the instance. Valid values: pd-ssd, local-ssd.
         */
        diskType?: string;
        /**
         * A source image used to create the disk. You can provide a private (custom) image, and Compute Engine will use the corresponding image from your project.
         *
         * Usage:
         */
        sourceImage: string;
    }

    export interface ElastigroupGpu {
        /**
         * The number of GPUs. Must be 0, 2, 4, 6, 8.
         *
         * Usage:
         */
        count: number;
        /**
         * The type of GPU instance. Valid values: `nvidia-tesla-v100`, `nvidia-tesla-p100`, `nvidia-tesla-k80`.
         */
        type: string;
    }

    export interface ElastigroupInstanceTypesCustom {
        /**
         * The memory (in GiB) in the custom instance types. GCP has a number of limitations on accepted memory values.For more information, see the GCP documentation (here.)[https://cloud.google.com/compute/docs/instances/creating-instance-with-custom-machine-type#specifications]
         */
        memoryGib: number;
        vcpu: number;
    }

    export interface ElastigroupIntegrationDockerSwarm {
        /**
         * IP or FQDN of one of your swarm managers.
         */
        masterHost: string;
        /**
         * Network port used by your swarm.
         *
         * Usage:
         */
        masterPort: number;
    }

    export interface ElastigroupIntegrationGke {
        autoUpdate?: boolean;
        autoscaleCooldown?: number;
        autoscaleDown?: outputs.gcp.ElastigroupIntegrationGkeAutoscaleDown;
        autoscaleHeadroom?: outputs.gcp.ElastigroupIntegrationGkeAutoscaleHeadroom;
        autoscaleIsAutoConfig?: boolean;
        autoscaleIsEnabled?: boolean;
        autoscaleLabels?: outputs.gcp.ElastigroupIntegrationGkeAutoscaleLabel[];
        clusterId?: string;
        location?: string;
    }

    export interface ElastigroupIntegrationGkeAutoscaleDown {
        /**
         * Number of consecutive periods in which the threshold must be met in order to trigger a scaling action.
         */
        evaluationPeriods?: number;
    }

    export interface ElastigroupIntegrationGkeAutoscaleHeadroom {
        cpuPerUnit?: number;
        memoryPerUnit?: number;
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationGkeAutoscaleLabel {
        key: string;
        value: string;
    }

    export interface ElastigroupLabel {
        /**
         * Labels key.
         */
        key: string;
        /**
         * Labels value.
         */
        value: string;
    }

    export interface ElastigroupMetadata {
        /**
         * Metadata key.
         */
        key: string;
        /**
         * Metadata value.
         */
        value: string;
    }

    export interface ElastigroupNetworkInterface {
        /**
         * Array of configurations.
         */
        accessConfigs?: outputs.gcp.ElastigroupNetworkInterfaceAccessConfig[];
        aliasIpRanges?: outputs.gcp.ElastigroupNetworkInterfaceAliasIpRange[];
        /**
         * Network resource for this group.
         */
        network: string;
    }

    export interface ElastigroupNetworkInterfaceAccessConfig {
        /**
         * The group name.
         */
        name?: string;
        type?: string;
    }

    export interface ElastigroupNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName: string;
    }

    export interface ElastigroupRevertToPreemptible {
        /**
         * Valid values: "always", "never", "timeWindow". Required on strategy.revertToPreemptible object.
         */
        performAt: string;
    }

    export interface ElastigroupScalingDownPolicy {
        /**
         * Type of scaling action to take when the scaling policy is triggered. Valid values: "adjustment", "setMinTarget", "updateCapacity", "percentageAdjustment"
         */
        actionType?: string;
        /**
         * Value to which the action type will be adjusted. Required if using "numeric" or "percentageAdjustment" action types.
         */
        adjustment?: number;
        /**
         * Time (seconds) to wait after a scaling action before resuming monitoring.
         */
        cooldown: number;
        /**
         * A list of dimensions describing qualities of the metric.
         */
        dimensions?: outputs.gcp.ElastigroupScalingDownPolicyDimension[];
        /**
         * Number of consecutive periods in which the threshold must be met in order to trigger a scaling action.
         */
        evaluationPeriods: number;
        /**
         * Metric to monitor. Valid values: "Percentage CPU", "Network In", "Network Out", "Disk Read Bytes", "Disk Write Bytes", "Disk Write Operations/Sec", "Disk Read Operations/Sec".
         */
        metricName: string;
        namespace: string;
        /**
         * The operator used to evaluate the threshold against the current metric value. Valid values: "gt" (greater than), "get" (greater-than or equal), "lt" (less than), "lte" (less than or equal).
         */
        operator: string;
        /**
         * Amount of time (seconds) for which the threshold must be met in order to trigger the scaling action.
         */
        period: number;
        /**
         * Name of scaling policy.
         */
        policyName: string;
        /**
         * Specifies a valid partial or full URL to an existing Persistent Disk resource. This field is only applicable for persistent disks.
         */
        source: string;
        /**
         * Statistic by which to evaluate the selected metric. Valid values: "AVERAGE", "SAMPLE_COUNT", "SUM", "MINIMUM", "MAXIMUM", "PERCENTILE", "COUNT".
         */
        statistic: string;
        /**
         * The value at which the scaling action is triggered.
         */
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingDownPolicyDimension {
        /**
         * The group name.
         */
        name: string;
        value?: string;
    }

    export interface ElastigroupScalingUpPolicy {
        /**
         * Type of scaling action to take when the scaling policy is triggered. Valid values: "adjustment", "setMinTarget", "updateCapacity", "percentageAdjustment"
         */
        actionType?: string;
        /**
         * Value to which the action type will be adjusted. Required if using "numeric" or "percentageAdjustment" action types.
         */
        adjustment?: number;
        /**
         * Time (seconds) to wait after a scaling action before resuming monitoring.
         */
        cooldown: number;
        /**
         * A list of dimensions describing qualities of the metric.
         */
        dimensions?: outputs.gcp.ElastigroupScalingUpPolicyDimension[];
        /**
         * Number of consecutive periods in which the threshold must be met in order to trigger a scaling action.
         */
        evaluationPeriods: number;
        /**
         * Metric to monitor. Valid values: "Percentage CPU", "Network In", "Network Out", "Disk Read Bytes", "Disk Write Bytes", "Disk Write Operations/Sec", "Disk Read Operations/Sec".
         */
        metricName: string;
        namespace: string;
        /**
         * The operator used to evaluate the threshold against the current metric value. Valid values: "gt" (greater than), "get" (greater-than or equal), "lt" (less than), "lte" (less than or equal).
         */
        operator: string;
        /**
         * Amount of time (seconds) for which the threshold must be met in order to trigger the scaling action.
         */
        period: number;
        /**
         * Name of scaling policy.
         */
        policyName: string;
        /**
         * Specifies a valid partial or full URL to an existing Persistent Disk resource. This field is only applicable for persistent disks.
         */
        source: string;
        /**
         * Statistic by which to evaluate the selected metric. Valid values: "AVERAGE", "SAMPLE_COUNT", "SUM", "MINIMUM", "MAXIMUM", "PERCENTILE", "COUNT".
         */
        statistic: string;
        /**
         * The value at which the scaling action is triggered.
         */
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingUpPolicyDimension {
        /**
         * The dimension name.
         */
        name: string;
        /**
         * The dimension value.
         *
         * Usage:
         */
        value?: string;
    }

    export interface ElastigroupScheduledTask {
        /**
         * A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
         */
        cronExpression?: string;
        /**
         * Setting the task to being enabled or disabled.
         */
        isEnabled?: boolean;
        /**
         * The maximum number of instances the group should have.
         *
         * Usage:
         */
        maxCapacity?: string;
        /**
         * The minimum number of instances the group should have.
         */
        minCapacity?: string;
        /**
         * The desired number of instances the group should have.
         */
        targetCapacity?: string;
        /**
         * The task type to run. Valid values: `"setCapacity"`.
         */
        taskType: string;
    }

    export interface ElastigroupShieldedInstanceConfig {
        /**
         * Default: false
         */
        enableIntegrityMonitoring?: boolean;
        /**
         * Default: false
         */
        enableSecureBoot?: boolean;
    }

    export interface ElastigroupSubnet {
        /**
         * The region for the group of subnets.
         */
        region: string;
        /**
         * The names of the subnets in the region.
         */
        subnetNames: string[];
    }

}

export namespace gke {
    export interface ElastigroupBackendService {
        locationType?: string;
        namedPorts?: outputs.gke.ElastigroupBackendServiceNamedPort[];
        scheme?: string;
        serviceName: string;
    }

    export interface ElastigroupBackendServiceNamedPort {
        name: string;
        ports: string[];
    }

    export interface ElastigroupDisk {
        autoDelete?: boolean;
        boot?: boolean;
        deviceName?: string;
        initializeParams?: outputs.gke.ElastigroupDiskInitializeParam[];
        interface?: string;
        mode?: string;
        source?: string;
        type?: string;
    }

    export interface ElastigroupDiskInitializeParam {
        diskSizeGb?: string;
        diskType?: string;
        sourceImage: string;
    }

    export interface ElastigroupGpu {
        count: number;
        type: string;
    }

    export interface ElastigroupInstanceTypesCustom {
        memoryGib: number;
        vcpu: number;
    }

    export interface ElastigroupIntegrationDockerSwarm {
        masterHost: string;
        masterPort: number;
    }

    export interface ElastigroupIntegrationGke {
        autoUpdate?: boolean;
        /**
         * The amount of time, in seconds, after a scaling activity completes before any further trigger-related scaling activities can start.
         */
        autoscaleCooldown?: number;
        /**
         * Enabling scale down.
         */
        autoscaleDown?: outputs.gke.ElastigroupIntegrationGkeAutoscaleDown;
        /**
         * Headroom for the cluster.
         */
        autoscaleHeadroom?: outputs.gke.ElastigroupIntegrationGkeAutoscaleHeadroom;
        autoscaleIsAutoConfig?: boolean;
        /**
         * Specifies whether the auto scaling feature is enabled.
         */
        autoscaleIsEnabled?: boolean;
        /**
         * Labels to assign to the resource.
         */
        autoscaleLabels?: outputs.gke.ElastigroupIntegrationGkeAutoscaleLabel[];
        clusterId?: string;
        /**
         * The location of your GKE cluster.
         */
        location?: string;
    }

    export interface ElastigroupIntegrationGkeAutoscaleDown {
        /**
         * Amount of cooldown evaluation periods for scale down.
         */
        evaluationPeriods?: number;
    }

    export interface ElastigroupIntegrationGkeAutoscaleHeadroom {
        /**
         * Cpu units for compute.
         */
        cpuPerUnit?: number;
        /**
         * RAM units for compute.
         */
        memoryPerUnit?: number;
        /**
         * Amount of units for compute.
         */
        numOfUnits?: number;
    }

    export interface ElastigroupIntegrationGkeAutoscaleLabel {
        key: string;
        value: string;
    }

    export interface ElastigroupLabel {
        key: string;
        value: string;
    }

    export interface ElastigroupMetadata {
        key: string;
        value: string;
    }

    export interface ElastigroupNetworkInterface {
        accessConfigs?: outputs.gke.ElastigroupNetworkInterfaceAccessConfig[];
        aliasIpRanges?: outputs.gke.ElastigroupNetworkInterfaceAliasIpRange[];
        network: string;
    }

    export interface ElastigroupNetworkInterfaceAccessConfig {
        name?: string;
        type?: string;
    }

    export interface ElastigroupNetworkInterfaceAliasIpRange {
        ipCidrRange: string;
        subnetworkRangeName: string;
    }

    export interface ElastigroupRevertToPreemptible {
        performAt: string;
    }

    export interface ElastigroupScalingDownPolicy {
        actionType?: string;
        adjustment?: number;
        cooldown: number;
        dimensions?: outputs.gke.ElastigroupScalingDownPolicyDimension[];
        /**
         * Amount of cooldown evaluation periods for scale down.
         */
        evaluationPeriods: number;
        metricName: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        source: string;
        statistic: string;
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingDownPolicyDimension {
        name: string;
        value?: string;
    }

    export interface ElastigroupScalingUpPolicy {
        actionType?: string;
        adjustment?: number;
        cooldown: number;
        dimensions?: outputs.gke.ElastigroupScalingUpPolicyDimension[];
        /**
         * Amount of cooldown evaluation periods for scale down.
         */
        evaluationPeriods: number;
        metricName: string;
        namespace: string;
        operator: string;
        period: number;
        policyName: string;
        source: string;
        statistic: string;
        threshold: number;
        unit: string;
    }

    export interface ElastigroupScalingUpPolicyDimension {
        name: string;
        value?: string;
    }

    export interface ElastigroupShieldedInstanceConfig {
        enableIntegrityMonitoring?: boolean;
        enableSecureBoot?: boolean;
    }

    export interface OceanImportAutoUpdate {
        /**
         * Enable the Ocean Kubernetes AutoUpdate.
         */
        isEnabled?: boolean;
    }

    export interface OceanImportAutoscaler {
        /**
         * Optionally set the auto headroom percentage, set a number between 0-200 to control the headroom % from the cluster. Relevant when isAutoConfig=true.
         */
        autoHeadroomPercentage?: number;
        /**
         * Cooldown period between scaling actions.
         */
        cooldown?: number;
        /**
         * Auto Scaling scale down operations.
         */
        down?: outputs.gke.OceanImportAutoscalerDown;
        /**
         * enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
         */
        enableAutomaticAndManualHeadroom?: boolean;
        /**
         * Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
         */
        headroom?: outputs.gke.OceanImportAutoscalerHeadroom;
        /**
         * Automatically configure and optimize headroom resources.
         */
        isAutoConfig?: boolean;
        /**
         * Enable the Ocean Kubernetes Autoscaler.
         */
        isEnabled?: boolean;
        /**
         * Optionally set upper and lower bounds on the resource usage of the cluster.
         */
        resourceLimits?: outputs.gke.OceanImportAutoscalerResourceLimits;
    }

    export interface OceanImportAutoscalerDown {
        /**
         * The number of evaluation periods that should accumulate before a scale down action takes place.
         */
        evaluationPeriods?: number;
        /**
         * When set to 'true', the Aggressive Scale Down feature is enabled.
         */
        isAggressiveScaleDownEnabled?: boolean;
        /**
         * Would represent the maximum % to scale-down. Number between 1-100.
         */
        maxScaleDownPercentage?: number;
    }

    export interface OceanImportAutoscalerHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * How much GPU allocate for headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate the headroom.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
         */
        numOfUnits?: number;
    }

    export interface OceanImportAutoscalerResourceLimits {
        /**
         * The maximum memory in GiB units that can be allocated to the cluster.
         */
        maxMemoryGib?: number;
        /**
         * The maximum cpu in vCpu units that can be allocated to the cluster.
         */
        maxVcpu?: number;
    }

    export interface OceanImportBackendService {
        /**
         * Sets which location the backend services will be active. Valid values: `regional`, `global`.
         */
        locationType?: string;
        namedPorts?: outputs.gke.OceanImportBackendServiceNamedPort[];
        /**
         * Use when `locationType` is `regional`. Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: `INTERNAL`, `EXTERNAL`.
         */
        scheme?: string;
        /**
         * The name of the backend service.
         */
        serviceName: string;
    }

    export interface OceanImportBackendServiceNamedPort {
        name: string;
        /**
         * A list of ports.
         */
        ports: string[];
    }

    export interface OceanImportFilters {
        /**
         * Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
         */
        excludeFamilies?: string[];
        /**
         * Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
         */
        includeFamilies?: string[];
        /**
         * Maximum amount of Memory (GiB).
         */
        maxMemoryGib?: number;
        /**
         * Maximum number of vcpus available.
         */
        maxVcpu?: number;
        /**
         * Minimum amount of Memory (GiB).
         */
        minMemoryGib?: number;
        /**
         * Minimum number of vcpus available.
         */
        minVcpu?: number;
    }

    export interface OceanImportScheduledTask {
        /**
         * Set shutdown hours for cluster object.
         */
        shutdownHours?: outputs.gke.OceanImportScheduledTaskShutdownHours;
        /**
         * The scheduling tasks for the cluster.
         */
        tasks?: outputs.gke.OceanImportScheduledTaskTask[];
    }

    export interface OceanImportScheduledTaskShutdownHours {
        /**
         * Flag to enable / disable the shutdown hours.
         * Example: `true`
         */
        isEnabled?: boolean;
        /**
         * Set time windows for shutdown hours. specify a list of 'timeWindows' with at least one time window Each string is in the format of - ddd:hh:mm-ddd:hh:mm ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59. Time windows should not overlap. required on cluster.scheduling.isEnabled = `true`. API Times are in UTC
         * Example: Fri:15:30-Wed:14:30
         */
        timeWindows: string[];
    }

    export interface OceanImportScheduledTaskTask {
        /**
         * A valid cron expression. For example : " * * * * * ".The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of ‘frequency’ or ‘cronExpression’ should be used at a time. Required for cluster.scheduling.tasks object
         * Example: 0 1 * * *
         */
        cronExpression: string;
        /**
         * Describes whether the task is enabled. When true the task should run when false it should not run. Required for cluster.scheduling.tasks object.
         */
        isEnabled: boolean;
        /**
         * The scheduling parameters for the cluster.
         */
        taskParameters?: outputs.gke.OceanImportScheduledTaskTaskTaskParameters;
        /**
         * Valid values: "clusterRoll". Required for cluster.scheduling.tasks object.
         */
        taskType: string;
    }

    export interface OceanImportScheduledTaskTaskTaskParameters {
        /**
         * The cluster roll parameters for the cluster.
         */
        clusterRoll?: outputs.gke.OceanImportScheduledTaskTaskTaskParametersClusterRoll;
    }

    export interface OceanImportScheduledTaskTaskTaskParametersClusterRoll {
        /**
         * Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
         */
        batchMinHealthyPercentage?: number;
        /**
         * Value as a percent to set the size of a batch in a roll. Valid values are 0-100.
         */
        batchSizePercentage?: number;
        /**
         * Add a comment description for the roll. The comment is limited to 256 chars.
         */
        comment?: string;
        /**
         * During the roll, if the parameter is set to true we honor PDB during the instance replacement.
         */
        respectPdb?: boolean;
    }

    export interface OceanImportShieldedInstanceConfig {
        /**
         * Boolean. Enable the integrity monitoring parameter on the GCP instances.
         */
        enableIntegrityMonitoring: boolean;
        /**
         * Boolean. Enable the secure boot parameter on the GCP instances.
         */
        enableSecureBoot: boolean;
    }

    export interface OceanImportStrategy {
        /**
         * The draining timeout (in seconds) before terminating the instance. If no draining timeout is defined, the default draining timeout will be used.
         */
        drainingTimeout?: number;
        /**
         * Defines the desired preemptible percentage for the cluster.
         */
        preemptiblePercentage?: number;
        /**
         * Define the provisioning model of the launched instances. Valid values: `SPOT`, `PREEMPTIBLE`.
         */
        provisioningModel?: string;
        /**
         * Valid Values: `"cost", "availability", "balanced"`. Set this value to control the approach that Ocean takes when launching nodes.
         */
        scalingOrientation?: string;
        /**
         * Enable committed use discounts utilization.
         */
        shouldUtilizeCommitments?: boolean;
    }

    export interface OceanImportUpdatePolicy {
        /**
         * Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
         */
        conditionedRoll?: boolean;
        /**
         * Holds the roll configuration.
         */
        rollConfig?: outputs.gke.OceanImportUpdatePolicyRollConfig;
        /**
         * Enables the roll.
         */
        shouldRoll: boolean;
    }

    export interface OceanImportUpdatePolicyRollConfig {
        /**
         * Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
         */
        batchMinHealthyPercentage?: number;
        /**
         * Sets the percentage of the instances to deploy in each batch.
         */
        batchSizePercentage: number;
        /**
         * List of Virtual Node Group identifiers to be rolled.
         */
        launchSpecIds?: string[];
        /**
         * Default: `false`. During the roll, if the parameter is set to `true` we honor PDB during the instance replacement.
         */
        respectPdb?: boolean;
    }

    export interface OceanLaunchSpecAutoscaleHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the number of GPUS to allocate for each headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecAutoscaleHeadroomsAutomatic {
        /**
         * Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.`isEnabled` = true is set on the Ocean cluster.
         */
        autoHeadroomPercentage?: number;
    }

    export interface OceanLaunchSpecCreateOptions {
        /**
         * When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group.
         */
        initialNodes?: number;
    }

    export interface OceanLaunchSpecLabel {
        /**
         * The label key.
         */
        key: string;
        /**
         * The label value.
         */
        value: string;
    }

    export interface OceanLaunchSpecMetadata {
        /**
         * The metadata key.
         */
        key: string;
        /**
         * The metadata value.
         */
        value: string;
    }

    export interface OceanLaunchSpecNetworkInterface {
        /**
         * The network protocol of the VNG.
         */
        accessConfigs?: outputs.gke.OceanLaunchSpecNetworkInterfaceAccessConfig[];
        /**
         * use the imported node pool’s associated aliasIpRange to assign secondary IP addresses to the nodes. Cannot be changed after VNG creation.
         */
        aliasIpRanges?: outputs.gke.OceanLaunchSpecNetworkInterfaceAliasIpRange[];
        /**
         * The name of the network.
         */
        network: string;
        /**
         * Use a network resource from a different project. Set the project identifier to use its network resource. This parameter is relevant only if the network resource is in a different project.
         */
        projectId?: string;
    }

    export interface OceanLaunchSpecNetworkInterfaceAccessConfig {
        /**
         * The name of the access configuration.
         */
        name?: string;
        /**
         * The type of the access configuration.
         */
        type?: string;
    }

    export interface OceanLaunchSpecNetworkInterfaceAliasIpRange {
        /**
         * specify the IP address range in CIDR notation that can be used for the alias IP addresses associated with the imported node pool.
         */
        ipCidrRange: string;
        /**
         * specify the IP address range for the subnet secondary IP range.
         */
        subnetworkRangeName: string;
    }

    export interface OceanLaunchSpecResourceLimits {
        /**
         * Option to set a maximum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
         */
        maxInstanceCount?: number;
        /**
         * Option to set a minimum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
         */
        minInstanceCount?: number;
    }

    export interface OceanLaunchSpecSchedulingTask {
        /**
         * A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
         */
        cronExpression: string;
        /**
         * Describes whether the task is enabled. When `true`, the task runs. When `false`, it does not run.
         */
        isEnabled: boolean;
        /**
         * The config of this scheduled task. Depends on the value of taskType.
         */
        taskHeadrooms?: outputs.gke.OceanLaunchSpecSchedulingTaskTaskHeadroom[];
        /**
         * The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
         */
        taskType: string;
    }

    export interface OceanLaunchSpecSchedulingTaskTaskHeadroom {
        /**
         * Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
         */
        cpuPerUnit?: number;
        /**
         * Optionally configure the number of GPUS to allocate for each headroom unit.
         */
        gpuPerUnit?: number;
        /**
         * Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
         */
        memoryPerUnit?: number;
        /**
         * The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
         */
        numOfUnits: number;
    }

    export interface OceanLaunchSpecShieldedInstanceConfig {
        /**
         * Boolean. Enable the integrity monitoring parameter on the GCP instances.
         */
        enableIntegrityMonitoring: boolean;
        /**
         * Boolean. Enable the secure boot parameter on the GCP instances.
         */
        enableSecureBoot: boolean;
    }

    export interface OceanLaunchSpecStorage {
        /**
         * Defines the number of local SSDs to be attached per node for this VNG.
         */
        localSsdCount: number;
    }

    export interface OceanLaunchSpecStrategy {
        /**
         * Defines the desired preemptible percentage for this launch specification.
         */
        preemptiblePercentage?: number;
        /**
         * Valid Values: `"cost", "availability", "balanced"`. Set this value to control the approach that Ocean takes when launching nodes.
         */
        scalingOrientation?: string;
    }

    export interface OceanLaunchSpecTaint {
        /**
         * The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
         */
        effect: string;
        /**
         * The taint key.
         */
        key: string;
        /**
         * The taint value.
         */
        value: string;
    }

    export interface OceanLaunchSpecUpdatePolicy {
        /**
         * Holds the roll configuration.
         */
        rollConfig?: outputs.gke.OceanLaunchSpecUpdatePolicyRollConfig;
        /**
         * Enables the roll.
         */
        shouldRoll: boolean;
    }

    export interface OceanLaunchSpecUpdatePolicyRollConfig {
        /**
         * Sets the percentage of the instances to deploy in each batch.
         */
        batchSizePercentage: number;
    }

}

export namespace oceancd {
    export interface RolloutSpecFailurePolicy {
        /**
         * Choose an action to perform on failure. Default is `abort`.  Enum: "abort" "pause" "promote".
         */
        action: string;
    }

    export interface RolloutSpecSpotDeployment {
        /**
         * Ocean CD cluster identifier for the references `SpotDeployment`.
         */
        spotDeploymentsClusterId?: string;
        /**
         * The name of the `SpotDeployment` resource
         */
        spotDeploymentsName?: string;
        /**
         * The namespace which the `SpotDeployment` resource exists within.
         */
        spotDeploymentsNamespace?: string;
    }

    export interface RolloutSpecStrategy {
        /**
         * Arguments defined in Verification Templates.
         */
        args?: outputs.oceancd.RolloutSpecStrategyArg[];
        /**
         * Ocean CD strategy name identifier.
         */
        strategyName: string;
    }

    export interface RolloutSpecStrategyArg {
        /**
         * Name of an argument.
         */
        argName: string;
        /**
         * Value of an argument.
         */
        argValue?: string;
        /**
         * Defines from where to get the value of an argument.
         */
        valueFrom?: outputs.oceancd.RolloutSpecStrategyArgValueFrom;
    }

    export interface RolloutSpecStrategyArgValueFrom {
        /**
         * Defines the field path from where to get the value of an argument.
         */
        fieldRef: outputs.oceancd.RolloutSpecStrategyArgValueFromFieldRef;
    }

    export interface RolloutSpecStrategyArgValueFromFieldRef {
        /**
         * Path to SpotDeployment's field from where to get the value of an argument.
         */
        fieldPath: string;
    }

    export interface RolloutSpecTraffic {
        /**
         * Holds ALB Ingress specific configuration to route traffic.
         */
        alb?: outputs.oceancd.RolloutSpecTrafficAlb;
        /**
         * Holds specific configuration to use Ambassador to route traffic.
         */
        ambassador?: outputs.oceancd.RolloutSpecTrafficAmbassador;
        /**
         * The canary service name.
         */
        canaryService?: string;
        /**
         * Holds Istio specific configuration to route traffic.
         */
        istio?: outputs.oceancd.RolloutSpecTrafficIstio;
        /**
         * Holds Nginx Ingress specific configuration to route traffic.
         */
        nginx?: outputs.oceancd.RolloutSpecTrafficNginx;
        /**
         * Holds the ping and pong services. You can use `pingPong` field only when using ALB as a traffic manager with the IP Mode approach.
         */
        pingPong?: outputs.oceancd.RolloutSpecTrafficPingPong;
        /**
         * Holds TrafficSplit specific configuration to route traffic.
         */
        smi?: outputs.oceancd.RolloutSpecTrafficSmi;
        /**
         * The stable service name.
         */
        stableService?: string;
    }

    export interface RolloutSpecTrafficAlb {
        /**
         * Has to match the configured annotation prefix on the alb ingress controller.
         */
        albAnnotationPrefix?: string;
        /**
         * Refers to the name of an `Ingress` resource in the same namespace as the `SpotDeployment`.
         */
        albIngress: string;
        /**
         * References the service in the ingress to the controller should add the action to.
         */
        albRootService: string;
        /**
         * Refers to the port that the Ingress action should route traffic to.
         */
        servicePort: number;
        /**
         * Allows to specify further settings on the ForwardConfig.
         */
        stickinessConfig?: outputs.oceancd.RolloutSpecTrafficAlbStickinessConfig;
    }

    export interface RolloutSpecTrafficAlbStickinessConfig {
        /**
         * Defines how long the load balancer should consistently route the user's request to the same target.
         */
        durationSeconds?: number;
        /**
         * Enables the load balancer to bind a user's session to a specific target.
         */
        enabled?: boolean;
    }

    export interface RolloutSpecTrafficAmbassador {
        /**
         * A list of names of the Ambassador Mappings used to route traffic to the service.
         */
        mappings: string[];
    }

    export interface RolloutSpecTrafficIstio {
        /**
         * It references to an Istio DestinationRule to modify and shape traffic. `DestinationRule` field belongs only to the Subset Level approach.
         */
        destinationRule?: outputs.oceancd.RolloutSpecTrafficIstioDestinationRule;
        /**
         * Defines a set of traffic routing rules to apply when a host is addressed.
         */
        virtualServices: outputs.oceancd.RolloutSpecTrafficIstioVirtualService[];
    }

    export interface RolloutSpecTrafficIstioDestinationRule {
        /**
         * The subset name to modify labels with the canary version.
         */
        canarySubsetName: string;
        /**
         * Holds the name of the DestinationRule.
         */
        destinationRuleName: string;
        /**
         * The subset name to modify labels with the stable version.
         */
        stableSubsetName: string;
    }

    export interface RolloutSpecTrafficIstioVirtualService {
        /**
         * A list of HTTPS routes within VirtualService.
         */
        tlsRoutes?: outputs.oceancd.RolloutSpecTrafficIstioVirtualServiceTlsRoute[];
        /**
         * Holds the name of the VirtualService.
         */
        virtualServiceName: string;
        /**
         * A list of HTTP routes within VirtualService.
         */
        virtualServiceRoutes?: string[];
    }

    export interface RolloutSpecTrafficIstioVirtualServiceTlsRoute {
        /**
         * The port of the TLS Route desired to be matched in the given Istio VirtualService.
         */
        port?: number;
        /**
         * A list of all the SNI Hosts of the TLS Route desired to be matched in the given Istio VirtualService.
         */
        sniHosts?: string[];
    }

    export interface RolloutSpecTrafficNginx {
        /**
         * Provides additional features to add to the canary ingress (such as routing by header, cookie, etc). You can add these Kubernetes annotations to specific Ingress objects to customize their behavior. Above are found examples of accepted k8s keys.For the full list of supported keys, you may reach the following documentation - https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#canary.
         */
        additionalIngressAnnotation?: outputs.oceancd.RolloutSpecTrafficNginxAdditionalIngressAnnotation;
        /**
         * Has to match the configured annotation prefix on the Nginx ingress controller.
         */
        nginxAnnotationPrefix?: string;
        /**
         * Refers to the name of an `Ingress` resource in the same namespace as the `SpotDeployment`.
         */
        stableIngress: string;
    }

    export interface RolloutSpecTrafficNginxAdditionalIngressAnnotation {
        /**
         * Allows customizing the header value instead of using hardcoded values.
         */
        canaryByHeader?: string;
        /**
         * Any of supported annotations.
         */
        key1?: string;
    }

    export interface RolloutSpecTrafficPingPong {
        /**
         * Holds the name of the ping service.
         */
        pingService: string;
        /**
         * Holds the name of the pong service.
         */
        pongService: string;
    }

    export interface RolloutSpecTrafficSmi {
        /**
         * Holds the name of service that clients use to communicate.
         */
        smiRootService?: string;
        /**
         * Holds the name of the TrafficSplit.
         */
        trafficSplitName?: string;
    }

    export interface StrategyCanary {
        /**
         * A list of background verifications.
         */
        backgroundVerification?: outputs.oceancd.StrategyCanaryBackgroundVerification;
        /**
         * A set of separate conditions of rollout processing.
         */
        steps: outputs.oceancd.StrategyCanaryStep[];
    }

    export interface StrategyCanaryBackgroundVerification {
        /**
         * List of Verification Template names.
         */
        templateNames: string[];
    }

    export interface StrategyCanaryStep {
        /**
         * Defines the duration of time to freeze the rollout.
         */
        pause?: outputs.oceancd.StrategyCanaryStepPause;
        /**
         * Defines how to scale the version without traffic weight changing.
         */
        setCanaryScale?: outputs.oceancd.StrategyCanaryStepSetCanaryScale;
        /**
         * Defines the list of HeaderRoutes to add to the Rollout.
         */
        setHeaderRoute?: outputs.oceancd.StrategyCanaryStepSetHeaderRoute;
        /**
         * Defines the percentage that the new version should receive.
         */
        setWeight?: number;
        stepName?: string;
        /**
         * Represents the list of verifications to run in a step.
         */
        verification?: outputs.oceancd.StrategyCanaryStepVerification;
    }

    export interface StrategyCanaryStepPause {
        /**
         * The amount of time to wait before moving to the next step.
         */
        duration?: string;
    }

    export interface StrategyCanaryStepSetCanaryScale {
        /**
         * Defines whether a rollout should match the current canary's setWeight step.
         */
        matchTrafficWeight?: boolean;
        /**
         * Sets the number of replicas the new version should have.
         */
        replicas?: number;
        /**
         * Sets the percentage of replicas the new version should have.
         */
        weight?: number;
    }

    export interface StrategyCanaryStepSetHeaderRoute {
        /**
         * The name of the HeaderRoute group.
         */
        headerRouteName: string;
        /**
         * The matching rules for the header route.
         */
        matches: outputs.oceancd.StrategyCanaryStepSetHeaderRouteMatch[];
    }

    export interface StrategyCanaryStepSetHeaderRouteMatch {
        /**
         * The name of the header.
         */
        headerName: string;
        /**
         * Defines a single header to add to the Rollout. Must be only one initialized from the following (exact, prefix, regex).
         */
        headerValue: outputs.oceancd.StrategyCanaryStepSetHeaderRouteMatchHeaderValue;
    }

    export interface StrategyCanaryStepSetHeaderRouteMatchHeaderValue {
        /**
         * The exact header value.
         */
        exact?: string;
        /**
         * The prefix of the value.
         */
        prefix?: string;
        /**
         * The value in a regex format.
         */
        regex?: string;
    }

    export interface StrategyCanaryStepVerification {
        /**
         * List of Verification Template names.
         */
        templateNames: string[];
    }

    export interface StrategyRolling {
        /**
         * A set of separate conditions of rollout processing.
         */
        steps: outputs.oceancd.StrategyRollingStep[];
    }

    export interface StrategyRollingStep {
        /**
         * Defines the duration of time to freeze the rollout.
         */
        pause?: outputs.oceancd.StrategyRollingStepPause;
        stepsName?: string;
        /**
         * Represents the list of verifications to run in a step.
         */
        verification?: outputs.oceancd.StrategyRollingStepVerification;
    }

    export interface StrategyRollingStepPause {
        /**
         * The amount of time to wait before moving to the next step.
         */
        duration?: string;
    }

    export interface StrategyRollingStepVerification {
        /**
         * List of Verification Template names.
         */
        templateNames: string[];
    }

    export interface VerificationProviderCloudWatch {
        /**
         * Set label key.
         */
        iamArn: string;
    }

    export interface VerificationProviderDatadog {
        /**
         * DataDog API URL.
         */
        address: string;
        /**
         * API key required by the Datadog Agent to submit metrics and events to Datadog.
         */
        apiKey: string;
        /**
         * API key that gives users access to Datadog’s programmatic API.
         */
        appKey: string;
    }

    export interface VerificationProviderJenkins {
        /**
         * The Jenkins server’s access apiToken.
         */
        apiToken: string;
        /**
         * The address of the Jenkins server within the cluster.
         */
        baseUrl: string;
        /**
         * The Jenkins server’s access username.
         */
        username: string;
    }

    export interface VerificationProviderNewRelic {
        accountId: string;
        /**
         * The base URL for NerdGraph for a proxy.
         */
        baseUrlNerdGraph?: string;
        /**
         * The base URL of the New Relic REST API for a proxy.
         */
        baseUrlRest?: string;
        /**
         * The NewRelic user key
         */
        personalApiKey: string;
        /**
         * A region which the account is attached to. Default is "us".
         */
        region?: string;
    }

    export interface VerificationProviderPrometheus {
        /**
         * The address which the Prometheus server available on.
         */
        address: string;
    }

    export interface VerificationTemplateArg {
        /**
         * Name of an argument.
         */
        argName: string;
        /**
         * String representation of data.
         */
        value?: string;
        /**
         * ValueFrom object.
         */
        valueFrom?: outputs.oceancd.VerificationTemplateArgValueFrom;
    }

    export interface VerificationTemplateArgValueFrom {
        /**
         * Secret key to use.
         */
        secretKeyRef?: outputs.oceancd.VerificationTemplateArgValueFromSecretKeyRef;
    }

    export interface VerificationTemplateArgValueFromSecretKeyRef {
        /**
         * The name of the field inside the secret.
         */
        key: string;
        /**
         * The name of the secret.
         */
        name: string;
    }

    export interface VerificationTemplateMetric {
        /**
         * Baseline Object.
         */
        baseline?: outputs.oceancd.VerificationTemplateMetricBaseline;
        /**
         * The maximum number of times the measurement is allowed to error in succession, before the metric is considered error.Default is 4.When choosing `Jenkins` as the provider, there is no need to send this variable.
         */
        consecutiveErrorLimit?: number;
        /**
         * The number of times to run the measurement. If both interval and count are omitted, the effective count is 1. If only interval is specified, metric runs indefinitely. If count > 1, interval must be specified. When choosing `Jenkins` as the provider, there is no need to send this variable.
         */
        count?: number;
        /**
         * Defines whether the metric should have an impact on the result of the rollout.
         */
        dryRun?: boolean;
        /**
         * An expression which determines if a measurement is considered failed.If failureCondition is set, then successCondition is not allowed. When choosing Jenkins as the provider, there is no need to send this variable.
         */
        failureCondition?: string;
        /**
         * The maximum number of times the measurement is allowed to fail, before the entire metric is considered failed.Default is 0. When choosing `Jenkins` as the provider, there is no need to send this variable.
         */
        failureLimit?: number;
        /**
         * How long to wait before starting this metric measurements. When choosing Jenkins as the provider, there is no need to send this variable.
         */
        initialDelay?: string;
        /**
         * Defines an interval string (30s, 5m, 1h) between each verification measurements. If omitted, will perform a single measurement.When choosing Jenkins as the provider, there is no need to send this variable.
         */
        interval?: string;
        /**
         * The name of the verification metric.
         */
        metricsName: string;
        /**
         * The name of the monitoring tool chosen for the metric.
         */
        providers: outputs.oceancd.VerificationTemplateMetricProvider[];
        /**
         * An expression which determines if a measurement is considered successful. The keyword `result` is a variable reference to the value of measurement. Results can be both structured data or primitive. If successCondition is set, then failureCondition is not allowed. When choosing `Jenkins` as the provider, there is no need to send this variable.
         */
        successCondition?: string;
    }

    export interface VerificationTemplateMetricBaseline {
        /**
         * The name of the monitoring tool chosen for the metric.
         */
        baselineProviders: outputs.oceancd.VerificationTemplateMetricBaselineBaselineProvider[];
        /**
         * Number in percent we allow the new version’s data result to be under baseline data result.
         */
        maxRange?: number;
        /**
         * Number in percent we allow the new version’s data result to be under baseline data result.*
         */
        minRange?: number;
        /**
         * A mathematical expression needed for the comparison. Enum: "<" ">" "<=" ">=" "=" "range"
         */
        threshold: string;
    }

    export interface VerificationTemplateMetricBaselineBaselineProvider {
        /**
         * The datadog provider.
         */
        datadog?: outputs.oceancd.VerificationTemplateMetricBaselineBaselineProviderDatadog;
        /**
         * The New Relic provider.
         */
        newRelic?: outputs.oceancd.VerificationTemplateMetricBaselineBaselineProviderNewRelic;
        /**
         * The Prometheus provider.
         */
        prometheus?: outputs.oceancd.VerificationTemplateMetricBaselineBaselineProviderPrometheus;
    }

    export interface VerificationTemplateMetricBaselineBaselineProviderDatadog {
        /**
         * A request for information retrieved from Datadog.
         */
        datadogQuery: string;
        /**
         * The window of time we are looking at in DataDog.
         */
        duration?: string;
    }

    export interface VerificationTemplateMetricBaselineBaselineProviderNewRelic {
        /**
         * A raw newrelic NRQL query to perform.
         */
        newRelicQuery: string;
        /**
         * The name of the secret holding NR account configuration.
         */
        profile?: string;
    }

    export interface VerificationTemplateMetricBaselineBaselineProviderPrometheus {
        /**
         * A request for information retrieved from Prometheus.
         */
        prometheusQuery: string;
    }

    export interface VerificationTemplateMetricProvider {
        /**
         * The CloudWatch provider.
         */
        cloudWatch?: outputs.oceancd.VerificationTemplateMetricProviderCloudWatch;
        /**
         * The datadog provider.
         */
        datadog?: outputs.oceancd.VerificationTemplateMetricProviderDatadog;
        /**
         * The Jenkins provider. Default is "{$}"
         */
        jenkins?: outputs.oceancd.VerificationTemplateMetricProviderJenkins;
        /**
         * The Job provider.
         */
        job?: outputs.oceancd.VerificationTemplateMetricProviderJob;
        /**
         * The New Relic provider.
         */
        newRelic?: outputs.oceancd.VerificationTemplateMetricProviderNewRelic;
        /**
         * The Prometheus provider.
         */
        prometheus?: outputs.oceancd.VerificationTemplateMetricProviderPrometheus;
        /**
         * The Web provider.
         */
        web?: outputs.oceancd.VerificationTemplateMetricProviderWeb;
    }

    export interface VerificationTemplateMetricProviderCloudWatch {
        /**
         * The window of time we are looking at in CloudWatch.
         */
        duration?: string;
        /**
         * The metric queries to be returned. A single MetricData call can include as many as 500 MetricDataQuery structures. Each of these structures can specify either a metric to retrieve, a Metrics Insights query, or a math expression to perform on retrieved data.
         */
        metricDataQueries: outputs.oceancd.VerificationTemplateMetricProviderCloudWatchMetricDataQuery[];
    }

    export interface VerificationTemplateMetricProviderCloudWatchMetricDataQuery {
        /**
         * This field can contain either a Metrics Insights query, or a metric math expression to be performed on the returned data. Within one metricdataquery object, you must specify either expression or metricstat but not both.
         */
        expression?: string;
        /**
         * The response ID. Must be unique and not null. This object can contain characters, letters, numbers and underscore. The first letter must be a lowercase letter.
         */
        id: string;
        /**
         * A human-readable label for this metric or expression. If the metric or expression is shown in a CloudWatch dashboard widget, the label is shown
         */
        label?: string;
        /**
         * The metric to be returned, along with statistics, period, and units. Use this parameter only if this object is retrieving a metric and not performing a math expression on returned data.Within one metricdataquery object, you must specify either expression or metricstat but not both.
         */
        metricStat?: outputs.oceancd.VerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStat;
        /**
         * The granularity, in seconds, of the returned data points.
         */
        period?: number;
        /**
         * This option indicates whether to return the timestamps and raw data values of this metric. If you are performing this call just to do math expressions and do not also need the raw data returned, you can specify `false`. If you omit this, the default of `true` is used.
         */
        returnData?: boolean;
    }

    export interface VerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStat {
        /**
         * The metric to return, including the metric name, namespace, and dimensions.
         */
        metric?: outputs.oceancd.VerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStatMetric;
        /**
         * The granularity, in seconds, of the returned data points.
         */
        metricPeriod?: number;
        /**
         * The statistic to return. It can include any CloudWatch statistic or extended statistic.
         */
        stat?: string;
        /**
         * This defines what unit you want to use when storing the metric.  Enum: `"Seconds" "Microseconds" "Milliseconds" "Bytes" "Kilobytes" "Megabytes" "Gigabytes" "Terabytes" "Bits" "Kilobits" "Megabits" "Gigabits" "Terabits" "Percent" "Count" "Bytes/Second" "Kilobytes/Second" "Megabytes/Second" "Gigabytes/Second" "Terabytes/Second" "Bits/Second" "Kilobits/Second" "Megabits/Second" "Gigabits/Second" "Terabits/Second" "Count/Second" "None"`
         */
        unit?: string;
    }

    export interface VerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStatMetric {
        /**
         * A dimension is a name/value pair that is part of the identity of a metric.You can assign upto 30 dimensions to a metric
         */
        dimensions?: outputs.oceancd.VerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStatMetricDimension[];
        /**
         * The name of the metric.
         */
        metricName: string;
        /**
         * The namespace of the metric.
         */
        namespace?: string;
    }

    export interface VerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStatMetricDimension {
        /**
         * The name of the dimensions. These values must contain only ASCII characters and must include at least one non-whitespace characte
         */
        dimensionName: string;
        /**
         * The value of the dimensions.These values must contain only ASCII characters and must include at least one non-whitespace characte
         */
        dimensionValue: string;
    }

    export interface VerificationTemplateMetricProviderDatadog {
        /**
         * A request for information retrieved from Datadog.
         */
        datadogQuery?: string;
        /**
         * The window of time we are looking at in DataDog.
         */
        duration?: string;
    }

    export interface VerificationTemplateMetricProviderJenkins {
        /**
         * The interval time to poll status.
         */
        jenkinsInterval: string;
        /**
         * List of parameters.
         */
        jenkinsParameters?: outputs.oceancd.VerificationTemplateMetricProviderJenkinsJenkinsParameters;
        /**
         * The Jenkins pipeline name.
         */
        pipelineName: string;
        /**
         * The total jenkins timeout.
         */
        timeout: string;
        /**
         * Host TLS verification.
         */
        tlsVerification?: boolean;
    }

    export interface VerificationTemplateMetricProviderJenkinsJenkinsParameters {
        /**
         * Key of an argument.
         */
        parameterKey: string;
        /**
         * Value of an argument.
         */
        parameterValue: string;
    }

    export interface VerificationTemplateMetricProviderJob {
        /**
         * The job spec require to run the metric.
         */
        specs: outputs.oceancd.VerificationTemplateMetricProviderJobSpec[];
    }

    export interface VerificationTemplateMetricProviderJobSpec {
        /**
         * Specifies the number of retries before marking this job failed.
         */
        backoffLimit?: number;
        /**
         * Describes the pod that will be created when executing a job.
         */
        jobTemplates: outputs.oceancd.VerificationTemplateMetricProviderJobSpecJobTemplate[];
    }

    export interface VerificationTemplateMetricProviderJobSpecJobTemplate {
        /**
         * Specification of the desired behavior of the pod.
         */
        templateSpecs: outputs.oceancd.VerificationTemplateMetricProviderJobSpecJobTemplateTemplateSpec[];
    }

    export interface VerificationTemplateMetricProviderJobSpecJobTemplateTemplateSpec {
        /**
         * A list of containers belonging to the pod.
         */
        containers: outputs.oceancd.VerificationTemplateMetricProviderJobSpecJobTemplateTemplateSpecContainer[];
        /**
         * Restart policy for all containers within the pod. Enum: `"Never" "OnFailure"`
         */
        restartPolicy: string;
    }

    export interface VerificationTemplateMetricProviderJobSpecJobTemplateTemplateSpecContainer {
        /**
         * The entry point of a container.
         */
        commands: string[];
        /**
         * The name of a container.
         */
        containerName: string;
        /**
         * The image name of a container.
         */
        image: string;
    }

    export interface VerificationTemplateMetricProviderNewRelic {
        /**
         * A raw newrelic NRQL query to perform.
         */
        newRelicQuery: string;
        /**
         * The name of the secret holding NR account configuration.
         */
        profile?: string;
    }

    export interface VerificationTemplateMetricProviderPrometheus {
        /**
         * A request for information retrieved from Prometheus.
         */
        prometheusQuery: string;
    }

    export interface VerificationTemplateMetricProviderWeb {
        /**
         * The body of the web metric.
         */
        body?: string;
        /**
         * Skips host TLS verification.
         */
        insecure?: boolean;
        /**
         * A JSON Path to use as the result variable. Default is "{$}"
         */
        jsonPath?: string;
        /**
         * The method of the web metric.  Enum: "GET" "POST" "PUT"
         */
        method?: string;
        /**
         * The timeout for the request in seconds. Default is 10.
         */
        timeoutSeconds?: number;
        /**
         * The address of the web metric.
         */
        url: string;
        /**
         * Optional HTTP headers to use in the request.
         */
        webHeaders?: outputs.oceancd.VerificationTemplateMetricProviderWebWebHeader[];
    }

    export interface VerificationTemplateMetricProviderWebWebHeader {
        /**
         * The name of a header
         */
        webHeaderKey: string;
        /**
         * The value of a header
         */
        webHeaderValue: string;
    }

}

export namespace organization {
    export interface PolicyPolicyContent {
        /**
         * List of permissions statements.
         */
        statements: outputs.organization.PolicyPolicyContentStatement[];
    }

    export interface PolicyPolicyContentStatement {
        /**
         * Set a list of required actions for this permissions statement.
         * Full list of actions can be found in [https://docs.spot.io/account-user-management/user-management/access-policies-actions/](https://docs.spot.io/account-user-management/user-management/access-policies-actions/).
         */
        actions: string[];
        /**
         * Valid values "ALLOW", "DENY".
         */
        effect: string;
        /**
         * Set a list of resources IDs. In order to include all resources in this statement - use "*".
         */
        resources: string[];
    }

    export interface ProgrammaticUserAccount {
        /**
         * Account ID the programmatic user will have access to.
         */
        accountId: string;
        /**
         * (Enum: `"viewer", "editor") Role to be associated with the
         * programmatic user for this account.
         */
        accountRole: string;
    }

    export interface ProgrammaticUserPolicy {
        /**
         * A list of the accounts that the policy should be
         * enforced for the user.
         */
        policyAccountIds?: string[];
        /**
         * Policy ID the programmatic user will have access to.
         */
        policyId: string;
    }

    export interface UserGroupPolicy {
        /**
         * A list of accounts to register with the assigned under the
         * given group (should be existing accounts only).
         */
        accountIds: string[];
        /**
         * A policy to register under the given group
         * (should be existing policy only).
         */
        policyId: string;
    }

    export interface UserPolicy {
        policyAccountIds: string[];
        /**
         * A policy to register under the given group
         * (should be existing policy only).
         */
        policyId: string;
    }

}

export namespace spark {
    export interface OceanCompute {
        /**
         * - Enable/disable the creation of Ocean Spark VNGs during cluster creation.
         */
        createVngs: boolean;
        /**
         * - Enable/disable Ocean Spark taints on the Ocean Spark VNGs. By default, Ocean Spark uses taints to prevent non-Spark workloads from running on Ocean Spark VNGs.
         */
        useTaints: boolean;
    }

    export interface OceanIngress {
        controller?: outputs.spark.OceanIngressController;
        customEndpoint?: outputs.spark.OceanIngressCustomEndpoint;
        loadBalancer?: outputs.spark.OceanIngressLoadBalancer;
        privateLink?: outputs.spark.OceanIngressPrivateLink;
        /**
         * - **DEPRECATED**: Use `load_balancer.service_annotations` instead.
         */
        serviceAnnotations: {[key: string]: string};
    }

    export interface OceanIngressController {
        /**
         * - Should an ingress controller managed by Ocean for Apache Spark be installed on the cluster.
         */
        managed?: boolean;
    }

    export interface OceanIngressCustomEndpoint {
        /**
         * - The address the Ocean for Apache Spark control plane will use when addressing the cluster.
         */
        address?: string;
        /**
         * - Should the Ocean for Apache Spark control plane address the cluster using a custom endpoint. Use this to specify the DNS address of an externally provisioned (unmanaged) load balancer.
         */
        enabled?: boolean;
    }

    export interface OceanIngressLoadBalancer {
        /**
         * - Should a load balancer managed by Ocean for Apache Spark be provisioned for the cluster. Set this to false if you want to use an existing load balancer (only available on AWS).
         */
        managed?: boolean;
        /**
         * - Annotations to add to the ingress controller load balancer service. This is useful to configure properties of the managed load balancer, like the nature of the load balancer (e.g. ELB, NLB, ALB on AWS), the security groups, or various timeouts.
         */
        serviceAnnotations?: {[key: string]: string};
        /**
         * - The ARN of a target group that the Ocean for Apache Spark ingress controller will be bound to. Set this to use an existing load balancer with Ocean for Apache Spark. Has no effect if using a managed load balancer. Only available on AWS.
         */
        targetGroupArn?: string;
    }

    export interface OceanIngressPrivateLink {
        /**
         * - Should the Ocean for Apache Spark control plane address the cluster via an AWS Private Link. Only available on AWS.
         */
        enabled?: boolean;
        /**
         * - The name of the VPC Endpoint Service the Ocean for Apache Spark control plane should bind to.
         */
        vpcEndpointService?: string;
    }

    export interface OceanLogCollection {
        /**
         * - Enable/Disable collecting driver and executor logs. When enabled, logs are stored by NetApp and can be downloaded from the Spot console web interface. The logs are deleted after 30 days.
         */
        collectAppLogs: boolean;
    }

    export interface OceanSpark {
        /**
         * - List of Kubernetes namespaces that should be configured to run Spark applications, in addition to the default Spark application namespace `spark-apps`.
         */
        additionalAppNamespaces: string[];
    }

    export interface OceanWebhook {
        /**
         * - List of ports allowed to use on the host network - if empty default is `25554`.
         */
        hostNetworkPorts: number[];
        /**
         * - Enable/disable host networking for the Spark Operator. Host networking can be useful when using custom CNI plugins like Calico on EKS.
         */
        useHostNetwork: boolean;
    }

    export interface OceanWorkspaces {
        storage: outputs.spark.OceanWorkspacesStorage;
    }

    export interface OceanWorkspacesStorage {
        defaults: outputs.spark.OceanWorkspacesStorageDefaults;
    }

    export interface OceanWorkspacesStorageDefaults {
        /**
         * - The name of the default storage class to use for new workspaces. If not specified, the default storage class of the Kubernetes cluster will be used.
         */
        storageClassName?: string;
    }

}
