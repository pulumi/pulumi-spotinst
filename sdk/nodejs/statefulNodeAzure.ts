// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * Provides a Spotinst stateful node Azure resource.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as spotinst from "@pulumi/spotinst";
 *
 * const testStatefulNodeAzure = new spotinst.StatefulNodeAzure("test_stateful_node_azure", {
 *     name: "example_stateful_node_azure",
 *     region: "eastus",
 *     resourceGroupName: "spotinst-azure",
 *     description: "example_stateful_node_azure_description",
 *     strategy: {
 *         drainingTimeout: 30,
 *         fallbackToOnDemand: true,
 *         optimizationWindows: ["Tue:19:46-Tue:20:46"],
 *         odWindows: ["Wed:19:46-Wed:21:46"],
 *         availabilityVsCost: 100,
 *         vmAdmins: [
 *             "UbuntuUser",
 *             "TestUser",
 *         ],
 *         revertToSpot: {
 *             performAt: "timeWindow",
 *         },
 *         interruptionToleration: {
 *             isEnabled: true,
 *             threshold: 3,
 *             evaluationPeriod: 30,
 *             cooldown: 120,
 *         },
 *         preferredLifeCycle: "od",
 *         capacityReservations: [{
 *             shouldUtilize: true,
 *             utilizationStrategy: "utilizeOverOD",
 *             capacityReservationGroups: [{
 *                 crgName: "crg name",
 *                 crgResourceGroupName: "resourceGroupName",
 *                 crgShouldPrioritize: true,
 *             }],
 *         }],
 *     },
 *     os: "Linux",
 *     vmSizes: {
 *         odSizes: [
 *             "standard_ds1_v2",
 *             "standard_ds2_v2",
 *         ],
 *         spotSizes: [
 *             "standard_ds1_v2",
 *             "standard_ds2_v2",
 *         ],
 *         preferredSpotSizes: ["standard_ds1_v2"],
 *         excludedVmSizes: ["standard_ds2_v3"],
 *         spotSizeAttributes: {
 *             maxCpu: 16,
 *             minCpu: 2,
 *             maxMemory: 48,
 *             minMemory: 2,
 *             maxStorage: 1000,
 *             minStorage: 50,
 *         },
 *     },
 *     zones: [
 *         "1",
 *         "3",
 *     ],
 *     preferredZone: "1",
 *     customData: "",
 *     shutdownScript: "",
 *     userData: "",
 *     vmName: "VMName",
 *     vmNamePrefix: "VMNamePrefix",
 *     licenseType: "SLES_BYOS",
 *     bootDiagnostics: [{
 *         isEnabled: true,
 *         storageUrl: "https://.blob.core.windows.net/test",
 *         type: "unmanaged",
 *     }],
 *     dataDisks: [
 *         {
 *             sizeGb: 1,
 *             lun: 1,
 *             type: "Standard_LRS",
 *         },
 *         {
 *             sizeGb: 10,
 *             lun: 2,
 *             type: "Standard_LRS",
 *         },
 *     ],
 *     extensions: [{
 *         name: "extensionName",
 *         type: "customScript",
 *         publisher: "Microsoft.Azure.Extensions",
 *         apiVersion: "2.0",
 *         minorVersionAutoUpgrade: true,
 *         protectedSettings: {
 *             script: "IyEvYmluL2Jhc2gKZWNobyAibmlyIiA+IC9ob29uaXIudHh0Cg==",
 *         },
 *         publicSettings: {
 *             fileUris: "https://testspot/Azuretest.sh",
 *         },
 *     }],
 *     image: {
 *         marketplaceImages: [{
 *             publisher: "Canonical",
 *             offer: "UbuntuServer",
 *             sku: "16.04-LTS",
 *             version: "latest",
 *         }],
 *         customImages: [{
 *             customImageResourceGroupName: "resourceGroupName",
 *             name: "imageName",
 *         }],
 *         galleries: [{
 *             galleryResourceGroupName: "resourceGroupName",
 *             galleryName: "galleryName",
 *             imageName: "imageName",
 *             versionName: "1.1.0",
 *             spotAccountId: "act-123456",
 *         }],
 *     },
 *     loadBalancers: [{
 *         type: "loadBalancer",
 *         resourceGroupName: "testResourceGroup",
 *         name: "testLoadBalancer",
 *         sku: "Standard",
 *         backendPoolNames: [
 *             "testBackendPool1",
 *             "testBackendPool2",
 *         ],
 *     }],
 *     login: {
 *         userName: "admin",
 *         sshPublicKey: "33a2s1f3g5a1df5g1ad3f2g1adfg56dfg==",
 *     },
 *     managedServiceIdentities: [{
 *         name: "mySI2",
 *         resourceGroupName: "myResourceGroup",
 *         subscriptionId: "12345678-abcd-1234-abcd-123456789ab",
 *     }],
 *     network: {
 *         networkResourceGroupName: "subnetResourceGroup",
 *         virtualNetworkName: "vname",
 *         networkInterfaces: [{
 *             isPrimary: true,
 *             subnetName: "testSubnet",
 *             assignPublicIp: true,
 *             publicIpSku: "Standard",
 *             networkSecurityGroups: [{
 *                 networkResourceGroupName: "test",
 *                 name: "test",
 *             }],
 *             enableIpForwarding: true,
 *             privateIpAddresses: ["172.23.4.20"],
 *             additionalIpConfigurations: [{
 *                 name: "test",
 *                 privateIpAddressVersion: "IPv4",
 *             }],
 *             publicIps: [{
 *                 networkResourceGroupName: "resourceGroup",
 *                 name: "test",
 *             }],
 *             applicationSecurityGroups: [{
 *                 networkResourceGroupName: "AsgResourceGroup",
 *                 name: "AsgName",
 *             }],
 *         }],
 *     },
 *     osDisk: {
 *         sizeGb: 30,
 *         type: "Standard_LRS",
 *         caching: "ReadOnly",
 *     },
 *     secrets: [{
 *         sourceVaults: [{
 *             name: "string",
 *             resourceGroupName: "string",
 *         }],
 *         vaultCertificates: [{
 *             certificateUrl: "string",
 *             certificateStore: "string",
 *         }],
 *     }],
 *     security: {
 *         securityType: "ConfidentialVM",
 *         secureBootEnabled: true,
 *         vtpmEnabled: true,
 *         encryptionAtHost: false,
 *         confidentialOsDiskEncryption: "true",
 *     },
 *     tags: [{
 *         tagKey: "Creator",
 *         tagValue: "string",
 *     }],
 *     health: {
 *         healthCheckTypes: ["vmState"],
 *         unhealthyDuration: 300,
 *         gracePeriod: 120,
 *         autoHealing: true,
 *     },
 *     shouldPersistOsDisk: false,
 *     osDiskPersistenceMode: "reattach",
 *     shouldPersistDataDisks: true,
 *     dataDisksPersistenceMode: "reattach",
 *     shouldPersistNetwork: true,
 *     schedulingTasks: [
 *         {
 *             isEnabled: true,
 *             type: "pause",
 *             cronExpression: "44 10 * * *",
 *         },
 *         {
 *             isEnabled: true,
 *             type: "resume",
 *             cronExpression: "48 10 * * *",
 *         },
 *         {
 *             isEnabled: true,
 *             type: "recycle",
 *             cronExpression: "52 10 * * *",
 *         },
 *     ],
 *     signals: [
 *         {
 *             type: "vmReady",
 *             timeout: 20,
 *         },
 *         {
 *             type: "vmReady",
 *             timeout: 40,
 *         },
 *     ],
 *     proximityPlacementGroups: [{
 *         name: "TestPPG",
 *         resourceGroupName: "TestResourceGroup",
 *     }],
 *     deletes: [{
 *         shouldTerminateVm: true,
 *         networkShouldDeallocate: true,
 *         networkTtlInHours: 0,
 *         diskShouldDeallocate: true,
 *         diskTtlInHours: 0,
 *         snapshotShouldDeallocate: true,
 *         snapshotTtlInHours: 0,
 *         publicIpShouldDeallocate: true,
 *         publicIpTtlInHours: 0,
 *         shouldDeregisterFromLb: true,
 *         shouldRevertToOd: false,
 *     }],
 * });
 * ```
 *
 * # Argument Reference
 *
 * The following arguments are supported:
 *
 * * `name` - (Required) Azure stateful node name.
 * * `region` - (Required) The Azure region your stateful node will be created in.
 * * `resourceGroupName` - (Required) Name of the Resource Group for stateful node.
 * * `description` - (Optional) Describe your Azure stateful node.
 *
 * ## Strategy
 *
 * * `strategy` - (Required) Strategy for stateful node.
 *   * `drainingTimeout` - (Optional, Default `120`) Time (in seconds) to allow the VM be drained from incoming TCP connections and detached from MLB before terminating it during a scale down operation.
 *   * `availabilityVsCost` - (Optional) Set the desired preference for the Spot market VM selection. (100- Availability, 0- cost).
 *   * `fallbackToOnDemand` - (Required) In case of no spots available, Stateful Node will launch an On-demand instance instead.
 *   * `optimizationWindows` - (Optional) Valid format: "ddd:hh:mm-ddd:hh:mm (day:hour(0-23):minute(0-59))", not empty if revertToSpot.performAt = timeWindow.
 *   * `odWindows` - (Optional) Define the time windows in which the underlying VM will be set as an on-demand lifecycle type. During the entire time window, the rest of the strategy processes will be paused.
 *     Switching between on-demand and Spot VM types at the enter/exit of the time window will trigger the recycling of the stateful node. Valid format: "ddd:hh:mm-ddd:hh:mm (day:hour(0-23):minute(0-59))".
 *   * `preferredLifeCycle` - (Optional, Enum `"od", "spot"`, Default `"spot"`) The desired type of VM.
 *   * `revertToSpot` - (Optional) Hold settings for strategy correction - replacing On-Demand for Spot VMs.
 *     * `performAt` - (Required, Enum `"timeWindow", "never", "always"`, Default `"always"`) Settings for maintenance strategy.
 *   * `interruptionToleration` - (Optional) Interruption tolerance settings for the stateful node. When enabled, the stateful node tracks interruption frequency and temporarily switches the node to On-Demand if too many interruptions occur within a defined evaluation window.
 *     * `cooldown` - (Optional) The cooldown period after an interruption occurs before another interruption can be tolerated. Must be set when `isEnabled` is true. Range `120`-`10080`.
 *     * `evaluationPeriod` - (Optional) The time window used to evaluate interruption tolerance. Must be set when `isEnabled` is true. Range `30`-`1440`.
 *     * `isEnabled` - (Optional) Enables interruption tolerance behavior for the Stateful Node.
 *     * `threshold` - (Optional) The maximum number of interruptions allowed within the defined evaluation period. Must be set when `isEnabled` is true. Value `>=3`
 *   * `capacityReservation` - (Optional) On-demand Capacity Reservation group enables you to reserve Compute capacity in an Azure region or an Availability Zone for any duration of time. [CRG can only be created on the Azure end.](https://learn.microsoft.com/en-us/azure/virtual-machines/capacity-reservation-create)
 *     * `shouldUtilize` - (Required) Determines whether capacity reservations should be utilized.
 *     * `utilizationStrategy` - (Required, Enum `"utilizeOverSpot", "utilizeOverOD"`) The priority requested for using CRG. This value will determine if CRG is used ahead of spot VMs or On-demand VMs. (`"utilizeOverOD"`- If picked, we will use CRG only in case On demand should be launched. `"utilizeOverSpot"`- CRG will be preferred over Spot. Only after CRG is fully used, spot VMs can be used.)
 *     * `capacityReservationGroups` - (Optional) List of the desired CRGs to use under the associated Azure subscription. When null we will utilize any available reservation that matches the launch specification.
 *       * `crgName` - (Required) The name of the CRG.
 *       * `crgResourceGroupName` - (Required) Azure resource group name
 *       * `crgShouldPrioritize` - The desired CRG to utilize ahead of other CRGs in the subscription.
 *   * `vmAdmins` - (Optional) Defines Azure identities that are considered VM admins. If the list is empty, the defined behavior is `NONE`, If the list is null, the defined behavior is `ALL`. This applies if the object is not defined. If an identity contains the string, it will be considered permitted to perform the following actions: Stop VM: VM admins can move the VM to a "stopped (deallocated)" state using the Azure console. If triggered by someone else, it is considered an interruption.
 *
 * ## Compute
 *
 * * `os` - (Required, Enum `"Linux", "Windows"`) Type of operating system.
 * * `vmSizes` - (Required) Defines the VM sizes to use when launching VMs.
 *     * `odSizes` - (Required) Available On-Demand sizes.
 *     * `spotSizes` - (Optional) Available Spot-VM sizes. Required if spotSizeAttributes isn't specified.
 *     * `preferredSpotSizes` - (Optional) Prioritize Spot VM sizes when launching Spot VMs for the group. If set, must be a sublist of compute.vmSizes.spotSizes.
 *     * `excludedVmSizes` - (Optional) Defines the VM sizes to exclude when defining spot types with spotSizeAttributes.
 *     * `spotSizeAttributes` - (Optional) Defines values and ranges for attributes of the spot sizes to use when launching VMs. Required if spotSizes isn't specified.
 *       * `maxCpu` - (Optional) Maximum amount of vCPU units.
 *       * `minCpu` - (Optional) Minimum amount of vCPU units.
 *       * `maxMemory` - (Optional) Maximum amount of memory in GiB.
 *       * `minMemory` - (Optional) Minimum amount of memory in GiB.
 *       * `maxStorage` - (Optional) Maximum amount of storage in GiB.
 *       * `minStorage` - (optional) Minimum amount of storage in GiB.
 * * `zones` - (Optional, Enum `"1", "2", "3"`) List of Azure Availability Zones in the defined region. If not defined, Virtual machines will be launched regionally.
 * * `preferredZone` - (Optional, Enum `"1", "2", "3"`) The AZ to prioritize when launching VMs. If no markets are available in the Preferred AZ, VMs are launched in the non-preferred AZ. Must be a sublist of compute.zones.
 * * `customData` - (Optional) This value will hold the YAML in base64 and will be executed upon VM launch.
 * * `shutdownScript` - (Optional) Shutdown script for the stateful node. Value should be passed as a string encoded at Base64 only.
 * * `userData` - (Optional) Define a set of scripts or other metadata that's inserted to an Azure virtual machine at provision time. (Base64 encoded)
 * * `vmName` - (Optional) Set a VM name that will be persisted throughout the entire node lifecycle. This can't be set if `vmNamePrefix` is set.
 * * `vmNamePrefix` - (Optional) Set a VM name prefix to be used for all launched VMs and the VM resources. This can't be set if `vmName` is set.
 * * `licenseType` - (Optional) Specify an existing Azure license type to use when launching new VMs. Valid values for Windows OS: "Windows_Server", "Windows_Client", Valid values for Linux OS: "RHEL_BYOS", "SLES_BYOS"
 *
 * <a id="bootDiagnostics"></a>
 * ## Boot Diagnostics
 *
 * * `bootDiagnostics`
 *   * `isEnabled` - (Optional) Allows you to enable and disable the configuration of boot diagnostics at launch.
 *   * `storageUrl` - (Optional) The storage URI that is used if a type is unmanaged. The storage URI must follow the blob storage URI format ("https://.blob.core.windows.net/"). StorageUri is required if the type is unmanaged. StorageUri must be ‘null’ in case the boot diagnostics type is managed.
 *   * `type` - (Optional, Enum `"managed", "unmanaged"`) Defines the storage type on VM launch in Azure.
 *
 * <a id="dataDisks"></a>
 * ## Data Disks
 *
 * * `dataDisk` - (Optional) The definitions of data disks that will be created and attached to the stateful node's VM.
 *   * `sizeGb` - (Required) The size of the data disk in GB, required if dataDisks is specified.
 *   * `lun` - (Required) The LUN of the data disk.
 *   * `type` - (Required, Enum `"Standard_LRS", "Premium_LRS", "StandardSSD_LRS", "UltraSSD_LRS"`) The type of the data disk.
 *
 * ## Extensions
 *
 * * `extension` - (Optional) An object for an azure extension.
 *   * `name` - (Required) Required on compute.launchSpecification.extensions object.
 *   * `type` - (Required) Required on compute.launchSpecification.extensions object.
 *   * `publisher` - (Required) Required on compute.launchSpecification.extensions object.
 *   * `apiVersion` - (Required) The API version of the extension. Required if extension specified.
 *   * `minorVersionAutoUpgrade` - (Required) Required on compute.launchSpecification.extensions object.
 *   * `protectedSettings` - (Optional) Object for protected settings.
 *   * `publicSettings` - (Optional) Object for public settings.
 *
 * ## Image
 *
 * * `image`
 *   * `marketplaceImage` - (Optional) Select an image from Azure's Marketplace image catalogue. Required if the custom image or gallery image are not specified.
 *     * `publisher` - (Required) Image publisher.
 *     * `offer` - (Required) Image offer.
 *     * `sku` - (Required) Image Stock Keeping Unit, which is the specific version of the image.
 *     * `version` - (Required, Default `"latest"`) Image's version. if version not provided we use "latest".
 *   * `gallery` - (Optional) Gallery image definitions. Required if custom image or marketplace image are not specified.
 *     * `galleryResourceGroupName` - (Required) The resource group name for gallery image.
 *     * `galleryName` - (Required) Name of the gallery.
 *     * `imageName` - (Required) Name of the gallery image.
 *     * `versionName` - (Required) Image's version. Can be in the format x.x.x or 'latest'.
 *     * `spotAccountId` - (Optional) The Spot account ID that connected to the Azure subscription to which the gallery belongs. Relevant only in case of cross-subscription shared galleries. [Read more](https://docs.spot.io/elastigroup/features-azure/shared-image-galleries) about cross-subscription shared galleries in Elastigroup.
 *   * `customImage` - (Optional) Custom image definitions. Required if marketplace image or gallery image are not specified.
 *     * `customImageResourceGroupName` - (Required) The resource group name for custom image.
 *     * `name` - (Required) The name of the custom image.
 *
 * <a id="load balancer"></a>
 * ## Load Balancer
 *
 * * `loadBalancer` - (Optional) Add a load balancer. For Azure Gateway, each Backend Pool is a separate load balancer.
 *   * `type` - (Required, Enum `"loadBalancer", "applicationGateway"`) The type of load balancer.
 *   * `resourceGroupName` - (Required) The Resource Group name of the Load Balancer.
 *   * `name` - (Required) Name of the Application Gateway/Load Balancer.
 *   * `sku` - (Optional)
 *     * if type is `"LoadBalancer"` then possible values are `“Standard", "Basic”`.
 *     * If ApplicationGateway then possible values are
 *       `“Standard_Large”, “Standard_Medium”, “Standard_Small”, “Standard_v2", “WAF_Large”, “WAF_Medium", “WAF_v2"`.
 *   * `backendPoolNames` - (Optional) Name of the Backend Pool to register the Stateful Node VMs to. Each Backend Pool is a separate load balancer. Required if Type is APPLICATION_GATEWAY.
 *
 * ## Login
 *
 * * `login` - (Required) Set admin access for accessing your VMs. Password/SSH is required for Linux.
 *   * `userName` - (Required) username for admin access to VMs.
 *   * `sshPublicKey` - (Optional) SSH for admin access to Linux VMs. Optional for Linux.
 *   * `password` - (Optional) Password for admin access to Windows VMs. Required for Windows.
 *
 * <a id="managedServiceIdentities"></a>
 * ## Managed Service Identities
 *
 * * `managedServiceIdentities` - (Optional) Add a user-assigned managed identity to the Stateful Node's VM.
 *   * `name` - (Required) name of the managed identity.
 *   * `resourceGroupName` - (Required) The Resource Group that the user-assigned managed identity resides in.
 *   * `subscriptionId` - (Optional) Defines the subscription ID of the managed service identities. Required if the managed service identity is in a different subscription. To use a user-assigned managed identity in a different subscription, you must ensure that the spotAccount's Service Principal has access to the defined subscription and that it has the two following permissions:
 *     1. Microsoft.ManagedIdentity/userAssignedIdentities/assign/action
 *     2. Microsoft.ManagedIdentity/userAssignedIdentities/read
 *
 * <a id="proximityPlacementGroups"></a>
 * ## Proximity Placement Groups
 *
 * * `proximityPlacementGroups` - (Optional) Defines the proximity placement group in which the VM will be launched.
 *   * `name` - (Required) name of the proximity placement group.
 *   * `resourceGroupName` - (Required) The Resource Group name of the proximity placement group.
 *
 * ## Network
 *
 * * `network` - (Required) Define the Virtual Network and Subnet for your Stateful Node.
 *   * `networkResourceGroupName` - (Required) Vnet Resource Group Name.
 *   * `virtualNetworkName` - (Required) Virtual Network.
 *   * `networkInterface` - (Required) Define a network interface
 *     * `isPrimary` - (Required) Defines whether the network interface is primary or not.
 *     * `subnetName` - (Required) Subnet name.
 *     * `assignPublicIp` - (Optional) Assign public IP.
 *     * `publicIpSku` - (Optional) Required if assignPublicIp=true values=[Standard/Basic].
 *     * `networkSecurityGroup` - (Optional) Network Security Group.
 *       * `networkResourceGroupName` - (Required) Requires valid security group name.
 *       * `name` - (Required) Requires valid resource group name.
 *     * `enableIpForwarding` - (Optional) Enable IP Forwarding.
 *     * `privateIpAddresses` - (Optional) A list with unique items that every item is a valid IP.
 *     * `additionalIpConfigurations` - (Optional) Additional configuration of network interface.
 *       * `name` - (Required) Configuration name.
 *       * `privateIpAddressVersion` - (Required, Enum `"IPv4", "IPv6"` Default `"IPv4"`) Version of the private IP address.
 *     * `publicIps` - (Optional) Defined a pool of Public Ips (from Azure), that will be associated to the network interface. We will associate one public ip per instance until the pool is exhausted, in which case, we will create a new one.
 *       * `resourceGroupName` - (Required) The resource group of the public ip.
 *       * `name` - (Required) - The name of the public ip.
 *     * `applicationSecurityGroups` - (Optional) Network Security Group.
 *       * `resourceGroupName` - (Required) Requires valid security group name.
 *       * `name` - (Required) Requires valid resource group name.
 *
 * <a id="osDisk"></a>
 * ## OS Disk
 *
 * * `osDisk` - (Optional) Specify OS disk specification other than default.
 *   * `sizeGb` - (Optional, Default `"30"`) The size of the data disk in GB.
 *   * `type` - (Required, Enum `"Standard_LRS", "Premium_LRS", "StandardSSD_LRS"`) The type of the OS disk.
 *   * `caching` - (Optional, Enum `"None", "ReadOnly", "ReadWrite"`) Specifies the host caching requirements. With disk caching enabled, VMs can achieve higher levels of performance. If not specified, the Azure default behavior will be applied.
 *
 * ## Secret
 *
 * * `secret` - (Optional) Set of certificates that should be installed on the VM.
 *   * `sourceVault` - (Required) The key vault reference, contains the required certificates.
 *     * `name` - (Required) The name of the key vault.
 *     * `resourceGroupName` - (Required) The resource group name of the key vault.
 *   * `vaultCertificates` - (Required) The required certificate references.
 *     * `certificateUrl` - (Optional) The URL of the certificate under the key vault.
 *     * `certificateStore` - (Required) The certificate store directory the VM. The directory is created in the LocalMachine account.
 *       * This field is required only when using Windows OS type
 *       * This field must be ‘null’ when the OS type is Linux
 *
 * ## Security
 *
 * * `security` - (Optional) Specifies the Security related profile settings for the virtual machine.
 *     * `secureBootEnabled` - (Optional) Specifies whether secure boot should be enabled on the virtual machine.
 *     * `securityType` - (Optional) Enum: `"Standard", "TrustedLaunch", "ConfidentialVM"` Security type refers to the different security features of a virtual machine. Security features like Trusted launch virtual machines help to improve the security of Azure generation 2 virtual machines.
 *     * `vtpmEnabled` - (Optional) Specifies whether vTPM should be enabled on the virtual machine.
 *     * `encryptionAtHost` - (Optional) Enables the Host Encryption for the virtual machine. The Encryption at host will be disabled unless this property is set to true for the resource.
 *     * `confidentialOsDiskEncryption` - (Optional) Confidential disk encryption binds the disk encryption keys to the VM's TPM, ensuring VM-only access. The security type must be "ConfidentialVM" to enable defining this preference as “true”.
 *
 * ## Tag
 *
 * * `tag` - (Optional) Unique Key-Value pair for all Stateful Node Resources.
 *   * `tagKey` - (Optional) Tag Key for Stateful Node Resources.
 *   * `tagValue` - (Optional) Tag Value for Stateful Node Resources.
 *
 * ## Health
 *
 * * `health` - (Optional) Set the auto healing preferences for unhealthy VMs.
 *   * `healthCheckTypes` - (Optional, Enum `"vmState", "applicationGateway"`) Healthcheck to use to validate VM health.
 *   * `unhealthyDuration` - (Optional) Amount of time to be unhealthy before a replacement is triggered.
 *   * `autoHealing` - (Required) Enable Autohealing of unhealthy VMs.
 *   * `gracePeriod` - (Optional) Period of time to wait for VM to reach healthiness before monitoring for unhealthiness.
 *
 * ## Persistence
 *
 * * `shouldPersistOsDisk` - (Required) Should persist os disk.
 * * `osDiskPersistenceMode` - (Optional, Enum `"reattach", "onLaunch"`)
 * * `shouldPersistDataDisks` - (Required) Should persist data disks.
 * * `dataDisksPersistenceMode` - (Optional, Enum `"reattach", "onLaunch"`)
 * * `shouldPersistNetwork` - (Required) Should persist network.
 *
 * <a id="schedulingTasks"></a>
 * ## Scheduling Tasks
 *
 * * `schedulingTask` - (Optional) Scheduling settings object for stateful node.
 *   * `isEnabled` - (Required) Is scheduled task enabled for stateful node.
 *   * `type` - (Required, Enum `"pause", "resume", "recycle") The type of the scheduled task
 *   * `cronExpression` (Required) A expression which describes when to execute the scheduled task (UTC).
 *
 * ## Signals
 *
 * * `signal` - (Optional) A signal object defined for the stateful node.
 *   * `type` - (Required, Enum `"vmReady", "vmReadyToShutdown"`) The type of the signal defined for the stateful node.
 *   * `timeout` - (Required, Default `"1800"`) The timeout in seconds to hold the vm until a signal is sent. If no signal is sent the vm will be replaced (vmReady) or we will terminate the vm (vmReadyToShutdown) after the timeout.
 *
 * ***
 *
 * <a id="attachDataDisk"></a>
 * ## Attach Data Disk
 *
 * * `attachDataDisk` - (Optional) Create a new data disk and attach it to the stateful node.
 *   * `dataDiskName` - (Required) The name of the created data disk.
 *   * `dataDiskResourceGroupName` - (Required) The resource group name in which the data disk will be created.
 *   * `storageAccountType` - (Required, Enum `"Standard_LRS", "Premium_LRS", "StandardSSD_LRS", "UltraSSD_LRS"`) The type of the data disk.
 *   * `sizeGb` - (Required) The size of the data disk in GB, Required if dataDisks is specified.
 *   * `zone` - (Optional, Enum `"1", "2", "3"`) The Availability Zone in which the data disk will be created. If not defined, the data disk will be created regionally.
 *   * `lun` - (Optional, Default `"orginal"`) The LUN of the data disk. If not defined, the LUN will be set in order.
 *
 * <a id="detachDataDisk"></a>
 * ## Detach Data Disk
 *
 * * `detachDataDisk` - (Optional) Detach a data disk from a stateful node.
 *   * `dataDiskName` - (Required) The name of the detached data disk.
 *   * `dataDiskResourceGroupName` - (Required) The resource group name in which the data disk exists.
 *   * `shouldDeallocate` - (Required) Indicates whether to delete the data disk in addition to detach.
 *   * `ttlInHours` - (Required, Default `"0"`) Hours to keep the disk alive before deletion.
 *
 * <a id="updateState"></a>
 * ## Update State
 *
 * * `updateState` - (Optional) Update the stateful node state.
 *   * `state` - (Required, Enum `"pause", "resume", "recycle"`) New state for the stateful node.
 *
 * <a id="importVm"></a>
 * ## Import VM
 *
 * * `importVm` - (Optional) Import an Azure VM and create a stateful node by providing a node configuration.
 *   * `resourceGroupName` - (Required) Name of the Resource Group for Stateful Node.
 *   * `originalVmName` - (Required) Azure Import Stateful Node Name.
 *   * `drainingTimeout` - (Optional) Hours to keep resources alive.
 *   * `resourcesRetentionTime` - (Optional) Hours to keep resources alive.
 *
 * ## Deallocation Config
 *
 * * `delete` - (Required) Specify deallocation parameters for stateful node deletion.
 *     * `shouldTerminateVm` - (Required) Indicates whether to delete the stateful node's VM.
 *     * `networkShouldDeallocate` - (Optional) Indicates whether to delete the stateful node's network resources.
 *     * `networkTtlInHours` - (Optional, Default: 96) Hours to keep the network resource alive before deletion.
 *     * `diskShouldDeallocate` - (Optional) Indicates whether to delete the stateful node's disk resources.
 *     * `diskTtlInHours` - (Optional, Default: 96) Hours to keep the disk resource alive before deletion.
 *     * `snapshotShouldDeallocate` - (Optional) Indicates whether to delete the stateful node's snapshot resources.
 *     * `snapshotTtlInHours` - (Optional, Default: 96) Hours to keep the snapshots alive before deletion.
 *     * `publicIpShouldDeallocate` - (Optional) Indicates whether to delete the stateful node's public ip resources.
 *     * `publicIpTtlInHours` - (Optional, Default: 96) Hours to keep the public ip alive before deletion.
 *     * `shouldDeregisterFromLb` - (Optional, Default: true) Indicates whether to deregister the stateful node's VM from any type of load balancer. Can be changed to false only when shouldTerminateVms is 'false'.
 *     * `shouldRevertToOd` - (Optional, Default: false) Indicates whether to change the stateful node's VM lifecycle to on-demand. Can be changed to true only when `shouldTerminateVm` is 'false'.
 */
export class StatefulNodeAzure extends pulumi.CustomResource {
    /**
     * Get an existing StatefulNodeAzure resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: StatefulNodeAzureState, opts?: pulumi.CustomResourceOptions): StatefulNodeAzure {
        return new StatefulNodeAzure(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'spotinst:index/statefulNodeAzure:StatefulNodeAzure';

    /**
     * Returns true if the given object is an instance of StatefulNodeAzure.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is StatefulNodeAzure {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === StatefulNodeAzure.__pulumiType;
    }

    declare public readonly attachDataDisks: pulumi.Output<outputs.StatefulNodeAzureAttachDataDisk[] | undefined>;
    declare public readonly bootDiagnostics: pulumi.Output<outputs.StatefulNodeAzureBootDiagnostic[]>;
    declare public readonly customData: pulumi.Output<string>;
    declare public readonly dataDisks: pulumi.Output<outputs.StatefulNodeAzureDataDisk[] | undefined>;
    declare public readonly dataDisksPersistenceMode: pulumi.Output<string>;
    declare public readonly deletes: pulumi.Output<outputs.StatefulNodeAzureDelete[] | undefined>;
    declare public readonly description: pulumi.Output<string>;
    declare public readonly detachDataDisks: pulumi.Output<outputs.StatefulNodeAzureDetachDataDisk[] | undefined>;
    declare public readonly extensions: pulumi.Output<outputs.StatefulNodeAzureExtension[]>;
    declare public readonly health: pulumi.Output<outputs.StatefulNodeAzureHealth>;
    declare public readonly image: pulumi.Output<outputs.StatefulNodeAzureImage | undefined>;
    declare public readonly importVms: pulumi.Output<outputs.StatefulNodeAzureImportVm[] | undefined>;
    declare public readonly licenseType: pulumi.Output<string | undefined>;
    declare public readonly loadBalancers: pulumi.Output<outputs.StatefulNodeAzureLoadBalancer[]>;
    declare public readonly login: pulumi.Output<outputs.StatefulNodeAzureLogin | undefined>;
    declare public readonly managedServiceIdentities: pulumi.Output<outputs.StatefulNodeAzureManagedServiceIdentity[] | undefined>;
    declare public readonly name: pulumi.Output<string>;
    declare public readonly network: pulumi.Output<outputs.StatefulNodeAzureNetwork | undefined>;
    declare public readonly os: pulumi.Output<string>;
    declare public readonly osDisk: pulumi.Output<outputs.StatefulNodeAzureOsDisk | undefined>;
    declare public readonly osDiskPersistenceMode: pulumi.Output<string>;
    declare public readonly preferredZone: pulumi.Output<string>;
    declare public readonly proximityPlacementGroups: pulumi.Output<outputs.StatefulNodeAzureProximityPlacementGroup[]>;
    declare public readonly region: pulumi.Output<string>;
    declare public readonly resourceGroupName: pulumi.Output<string>;
    declare public readonly schedulingTasks: pulumi.Output<outputs.StatefulNodeAzureSchedulingTask[]>;
    declare public readonly secrets: pulumi.Output<outputs.StatefulNodeAzureSecret[] | undefined>;
    declare public readonly security: pulumi.Output<outputs.StatefulNodeAzureSecurity>;
    declare public readonly shouldPersistDataDisks: pulumi.Output<boolean>;
    declare public readonly shouldPersistNetwork: pulumi.Output<boolean>;
    declare public readonly shouldPersistOsDisk: pulumi.Output<boolean>;
    declare public readonly shutdownScript: pulumi.Output<string>;
    declare public readonly signals: pulumi.Output<outputs.StatefulNodeAzureSignal[]>;
    declare public readonly strategy: pulumi.Output<outputs.StatefulNodeAzureStrategy>;
    declare public readonly tags: pulumi.Output<outputs.StatefulNodeAzureTag[]>;
    declare public readonly updateStates: pulumi.Output<outputs.StatefulNodeAzureUpdateState[] | undefined>;
    declare public readonly userData: pulumi.Output<string>;
    declare public readonly vmName: pulumi.Output<string | undefined>;
    declare public readonly vmNamePrefix: pulumi.Output<string | undefined>;
    declare public readonly vmSizes: pulumi.Output<outputs.StatefulNodeAzureVmSizes>;
    declare public readonly zones: pulumi.Output<string[] | undefined>;

    /**
     * Create a StatefulNodeAzure resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: StatefulNodeAzureArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: StatefulNodeAzureArgs | StatefulNodeAzureState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as StatefulNodeAzureState | undefined;
            resourceInputs["attachDataDisks"] = state?.attachDataDisks;
            resourceInputs["bootDiagnostics"] = state?.bootDiagnostics;
            resourceInputs["customData"] = state?.customData;
            resourceInputs["dataDisks"] = state?.dataDisks;
            resourceInputs["dataDisksPersistenceMode"] = state?.dataDisksPersistenceMode;
            resourceInputs["deletes"] = state?.deletes;
            resourceInputs["description"] = state?.description;
            resourceInputs["detachDataDisks"] = state?.detachDataDisks;
            resourceInputs["extensions"] = state?.extensions;
            resourceInputs["health"] = state?.health;
            resourceInputs["image"] = state?.image;
            resourceInputs["importVms"] = state?.importVms;
            resourceInputs["licenseType"] = state?.licenseType;
            resourceInputs["loadBalancers"] = state?.loadBalancers;
            resourceInputs["login"] = state?.login;
            resourceInputs["managedServiceIdentities"] = state?.managedServiceIdentities;
            resourceInputs["name"] = state?.name;
            resourceInputs["network"] = state?.network;
            resourceInputs["os"] = state?.os;
            resourceInputs["osDisk"] = state?.osDisk;
            resourceInputs["osDiskPersistenceMode"] = state?.osDiskPersistenceMode;
            resourceInputs["preferredZone"] = state?.preferredZone;
            resourceInputs["proximityPlacementGroups"] = state?.proximityPlacementGroups;
            resourceInputs["region"] = state?.region;
            resourceInputs["resourceGroupName"] = state?.resourceGroupName;
            resourceInputs["schedulingTasks"] = state?.schedulingTasks;
            resourceInputs["secrets"] = state?.secrets;
            resourceInputs["security"] = state?.security;
            resourceInputs["shouldPersistDataDisks"] = state?.shouldPersistDataDisks;
            resourceInputs["shouldPersistNetwork"] = state?.shouldPersistNetwork;
            resourceInputs["shouldPersistOsDisk"] = state?.shouldPersistOsDisk;
            resourceInputs["shutdownScript"] = state?.shutdownScript;
            resourceInputs["signals"] = state?.signals;
            resourceInputs["strategy"] = state?.strategy;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["updateStates"] = state?.updateStates;
            resourceInputs["userData"] = state?.userData;
            resourceInputs["vmName"] = state?.vmName;
            resourceInputs["vmNamePrefix"] = state?.vmNamePrefix;
            resourceInputs["vmSizes"] = state?.vmSizes;
            resourceInputs["zones"] = state?.zones;
        } else {
            const args = argsOrState as StatefulNodeAzureArgs | undefined;
            if (args?.os === undefined && !opts.urn) {
                throw new Error("Missing required property 'os'");
            }
            if (args?.region === undefined && !opts.urn) {
                throw new Error("Missing required property 'region'");
            }
            if (args?.resourceGroupName === undefined && !opts.urn) {
                throw new Error("Missing required property 'resourceGroupName'");
            }
            if (args?.shouldPersistDataDisks === undefined && !opts.urn) {
                throw new Error("Missing required property 'shouldPersistDataDisks'");
            }
            if (args?.shouldPersistNetwork === undefined && !opts.urn) {
                throw new Error("Missing required property 'shouldPersistNetwork'");
            }
            if (args?.shouldPersistOsDisk === undefined && !opts.urn) {
                throw new Error("Missing required property 'shouldPersistOsDisk'");
            }
            if (args?.strategy === undefined && !opts.urn) {
                throw new Error("Missing required property 'strategy'");
            }
            if (args?.vmSizes === undefined && !opts.urn) {
                throw new Error("Missing required property 'vmSizes'");
            }
            resourceInputs["attachDataDisks"] = args?.attachDataDisks;
            resourceInputs["bootDiagnostics"] = args?.bootDiagnostics;
            resourceInputs["customData"] = args?.customData;
            resourceInputs["dataDisks"] = args?.dataDisks;
            resourceInputs["dataDisksPersistenceMode"] = args?.dataDisksPersistenceMode;
            resourceInputs["deletes"] = args?.deletes;
            resourceInputs["description"] = args?.description;
            resourceInputs["detachDataDisks"] = args?.detachDataDisks;
            resourceInputs["extensions"] = args?.extensions;
            resourceInputs["health"] = args?.health;
            resourceInputs["image"] = args?.image;
            resourceInputs["importVms"] = args?.importVms;
            resourceInputs["licenseType"] = args?.licenseType;
            resourceInputs["loadBalancers"] = args?.loadBalancers;
            resourceInputs["login"] = args?.login;
            resourceInputs["managedServiceIdentities"] = args?.managedServiceIdentities;
            resourceInputs["name"] = args?.name;
            resourceInputs["network"] = args?.network;
            resourceInputs["os"] = args?.os;
            resourceInputs["osDisk"] = args?.osDisk;
            resourceInputs["osDiskPersistenceMode"] = args?.osDiskPersistenceMode;
            resourceInputs["preferredZone"] = args?.preferredZone;
            resourceInputs["proximityPlacementGroups"] = args?.proximityPlacementGroups;
            resourceInputs["region"] = args?.region;
            resourceInputs["resourceGroupName"] = args?.resourceGroupName;
            resourceInputs["schedulingTasks"] = args?.schedulingTasks;
            resourceInputs["secrets"] = args?.secrets;
            resourceInputs["security"] = args?.security;
            resourceInputs["shouldPersistDataDisks"] = args?.shouldPersistDataDisks;
            resourceInputs["shouldPersistNetwork"] = args?.shouldPersistNetwork;
            resourceInputs["shouldPersistOsDisk"] = args?.shouldPersistOsDisk;
            resourceInputs["shutdownScript"] = args?.shutdownScript;
            resourceInputs["signals"] = args?.signals;
            resourceInputs["strategy"] = args?.strategy;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["updateStates"] = args?.updateStates;
            resourceInputs["userData"] = args?.userData;
            resourceInputs["vmName"] = args?.vmName;
            resourceInputs["vmNamePrefix"] = args?.vmNamePrefix;
            resourceInputs["vmSizes"] = args?.vmSizes;
            resourceInputs["zones"] = args?.zones;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(StatefulNodeAzure.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering StatefulNodeAzure resources.
 */
export interface StatefulNodeAzureState {
    attachDataDisks?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureAttachDataDisk>[]>;
    bootDiagnostics?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureBootDiagnostic>[]>;
    customData?: pulumi.Input<string>;
    dataDisks?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureDataDisk>[]>;
    dataDisksPersistenceMode?: pulumi.Input<string>;
    deletes?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureDelete>[]>;
    description?: pulumi.Input<string>;
    detachDataDisks?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureDetachDataDisk>[]>;
    extensions?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureExtension>[]>;
    health?: pulumi.Input<inputs.StatefulNodeAzureHealth>;
    image?: pulumi.Input<inputs.StatefulNodeAzureImage>;
    importVms?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureImportVm>[]>;
    licenseType?: pulumi.Input<string>;
    loadBalancers?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureLoadBalancer>[]>;
    login?: pulumi.Input<inputs.StatefulNodeAzureLogin>;
    managedServiceIdentities?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureManagedServiceIdentity>[]>;
    name?: pulumi.Input<string>;
    network?: pulumi.Input<inputs.StatefulNodeAzureNetwork>;
    os?: pulumi.Input<string>;
    osDisk?: pulumi.Input<inputs.StatefulNodeAzureOsDisk>;
    osDiskPersistenceMode?: pulumi.Input<string>;
    preferredZone?: pulumi.Input<string>;
    proximityPlacementGroups?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureProximityPlacementGroup>[]>;
    region?: pulumi.Input<string>;
    resourceGroupName?: pulumi.Input<string>;
    schedulingTasks?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureSchedulingTask>[]>;
    secrets?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureSecret>[]>;
    security?: pulumi.Input<inputs.StatefulNodeAzureSecurity>;
    shouldPersistDataDisks?: pulumi.Input<boolean>;
    shouldPersistNetwork?: pulumi.Input<boolean>;
    shouldPersistOsDisk?: pulumi.Input<boolean>;
    shutdownScript?: pulumi.Input<string>;
    signals?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureSignal>[]>;
    strategy?: pulumi.Input<inputs.StatefulNodeAzureStrategy>;
    tags?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureTag>[]>;
    updateStates?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureUpdateState>[]>;
    userData?: pulumi.Input<string>;
    vmName?: pulumi.Input<string>;
    vmNamePrefix?: pulumi.Input<string>;
    vmSizes?: pulumi.Input<inputs.StatefulNodeAzureVmSizes>;
    zones?: pulumi.Input<pulumi.Input<string>[]>;
}

/**
 * The set of arguments for constructing a StatefulNodeAzure resource.
 */
export interface StatefulNodeAzureArgs {
    attachDataDisks?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureAttachDataDisk>[]>;
    bootDiagnostics?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureBootDiagnostic>[]>;
    customData?: pulumi.Input<string>;
    dataDisks?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureDataDisk>[]>;
    dataDisksPersistenceMode?: pulumi.Input<string>;
    deletes?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureDelete>[]>;
    description?: pulumi.Input<string>;
    detachDataDisks?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureDetachDataDisk>[]>;
    extensions?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureExtension>[]>;
    health?: pulumi.Input<inputs.StatefulNodeAzureHealth>;
    image?: pulumi.Input<inputs.StatefulNodeAzureImage>;
    importVms?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureImportVm>[]>;
    licenseType?: pulumi.Input<string>;
    loadBalancers?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureLoadBalancer>[]>;
    login?: pulumi.Input<inputs.StatefulNodeAzureLogin>;
    managedServiceIdentities?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureManagedServiceIdentity>[]>;
    name?: pulumi.Input<string>;
    network?: pulumi.Input<inputs.StatefulNodeAzureNetwork>;
    os: pulumi.Input<string>;
    osDisk?: pulumi.Input<inputs.StatefulNodeAzureOsDisk>;
    osDiskPersistenceMode?: pulumi.Input<string>;
    preferredZone?: pulumi.Input<string>;
    proximityPlacementGroups?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureProximityPlacementGroup>[]>;
    region: pulumi.Input<string>;
    resourceGroupName: pulumi.Input<string>;
    schedulingTasks?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureSchedulingTask>[]>;
    secrets?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureSecret>[]>;
    security?: pulumi.Input<inputs.StatefulNodeAzureSecurity>;
    shouldPersistDataDisks: pulumi.Input<boolean>;
    shouldPersistNetwork: pulumi.Input<boolean>;
    shouldPersistOsDisk: pulumi.Input<boolean>;
    shutdownScript?: pulumi.Input<string>;
    signals?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureSignal>[]>;
    strategy: pulumi.Input<inputs.StatefulNodeAzureStrategy>;
    tags?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureTag>[]>;
    updateStates?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureUpdateState>[]>;
    userData?: pulumi.Input<string>;
    vmName?: pulumi.Input<string>;
    vmNamePrefix?: pulumi.Input<string>;
    vmSizes: pulumi.Input<inputs.StatefulNodeAzureVmSizes>;
    zones?: pulumi.Input<pulumi.Input<string>[]>;
}
