# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'DataIntegrationS3',
    'ElastigroupAzureV3BootDiagnostic',
    'ElastigroupAzureV3CapacityReservation',
    'ElastigroupAzureV3CapacityReservationCapacityReservationGroups',
    'ElastigroupAzureV3DataDisk',
    'ElastigroupAzureV3Extension',
    'ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVault',
    'ElastigroupAzureV3Health',
    'ElastigroupAzureV3Image',
    'ElastigroupAzureV3ImageCustom',
    'ElastigroupAzureV3ImageGalleryImage',
    'ElastigroupAzureV3ImageMarketplace',
    'ElastigroupAzureV3LoadBalancer',
    'ElastigroupAzureV3Login',
    'ElastigroupAzureV3ManagedServiceIdentity',
    'ElastigroupAzureV3Network',
    'ElastigroupAzureV3NetworkNetworkInterface',
    'ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig',
    'ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup',
    'ElastigroupAzureV3NetworkNetworkInterfaceSecurityGroup',
    'ElastigroupAzureV3OsDisk',
    'ElastigroupAzureV3ProximityPlacementGroup',
    'ElastigroupAzureV3RevertToSpot',
    'ElastigroupAzureV3ScalingDownPolicy',
    'ElastigroupAzureV3ScalingDownPolicyAction',
    'ElastigroupAzureV3ScalingDownPolicyDimension',
    'ElastigroupAzureV3ScalingUpPolicy',
    'ElastigroupAzureV3ScalingUpPolicyAction',
    'ElastigroupAzureV3ScalingUpPolicyDimension',
    'ElastigroupAzureV3SchedulingTask',
    'ElastigroupAzureV3Secret',
    'ElastigroupAzureV3SecretSourceVault',
    'ElastigroupAzureV3SecretVaultCertificate',
    'ElastigroupAzureV3Security',
    'ElastigroupAzureV3Signal',
    'ElastigroupAzureV3Tag',
    'ElastigroupAzureV3VmSizes',
    'ElastigroupAzureV3VmSizesSpotSizeAttributes',
    'HealthCheckCheck',
    'NotificationCenterComputePolicyConfig',
    'NotificationCenterComputePolicyConfigDynamicRule',
    'NotificationCenterComputePolicyConfigDynamicRuleFilterCondition',
    'NotificationCenterComputePolicyConfigEvent',
    'NotificationCenterRegisteredUser',
    'NotificationCenterSubscription',
    'OceanRightSizingRuleAttachWorkload',
    'OceanRightSizingRuleAttachWorkloadNamespace',
    'OceanRightSizingRuleAttachWorkloadNamespaceLabel',
    'OceanRightSizingRuleAttachWorkloadNamespaceWorkload',
    'OceanRightSizingRuleDetachWorkload',
    'OceanRightSizingRuleDetachWorkloadNamespace',
    'OceanRightSizingRuleDetachWorkloadNamespaceLabel',
    'OceanRightSizingRuleDetachWorkloadNamespaceWorkload',
    'OceanRightSizingRuleRecommendationApplicationBoundary',
    'OceanRightSizingRuleRecommendationApplicationHpa',
    'OceanRightSizingRuleRecommendationApplicationInterval',
    'OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBase',
    'OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBase',
    'OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBase',
    'OceanRightSizingRuleRecommendationApplicationMinThreshold',
    'OceanRightSizingRuleRecommendationApplicationOverheadValue',
    'StatefulNodeAzureAttachDataDisk',
    'StatefulNodeAzureBootDiagnostic',
    'StatefulNodeAzureDataDisk',
    'StatefulNodeAzureDelete',
    'StatefulNodeAzureDetachDataDisk',
    'StatefulNodeAzureExtension',
    'StatefulNodeAzureHealth',
    'StatefulNodeAzureImage',
    'StatefulNodeAzureImageCustomImage',
    'StatefulNodeAzureImageGallery',
    'StatefulNodeAzureImageMarketplaceImage',
    'StatefulNodeAzureImportVm',
    'StatefulNodeAzureLoadBalancer',
    'StatefulNodeAzureLogin',
    'StatefulNodeAzureManagedServiceIdentity',
    'StatefulNodeAzureNetwork',
    'StatefulNodeAzureNetworkNetworkInterface',
    'StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration',
    'StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup',
    'StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup',
    'StatefulNodeAzureNetworkNetworkInterfacePublicIp',
    'StatefulNodeAzureOsDisk',
    'StatefulNodeAzureProximityPlacementGroup',
    'StatefulNodeAzureSchedulingTask',
    'StatefulNodeAzureSecret',
    'StatefulNodeAzureSecretSourceVault',
    'StatefulNodeAzureSecretVaultCertificate',
    'StatefulNodeAzureSecurity',
    'StatefulNodeAzureSignal',
    'StatefulNodeAzureStrategy',
    'StatefulNodeAzureStrategyCapacityReservation',
    'StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup',
    'StatefulNodeAzureStrategyRevertToSpot',
    'StatefulNodeAzureTag',
    'StatefulNodeAzureUpdateState',
    'StatefulNodeAzureVmSizes',
    'StatefulNodeAzureVmSizesSpotSizeAttributes',
]

@pulumi.output_type
class DataIntegrationS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataIntegrationS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataIntegrationS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataIntegrationS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 subdir: Optional[_builtins.str] = None):
        """
        :param _builtins.str subdir: The subdirectory in which your files will be stored within the bucket. Adds the prefix subdir/ to new objects' keys. Can't be null or contain '/'.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        if subdir is not None:
            pulumi.set(__self__, "subdir", subdir)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter
    def subdir(self) -> Optional[_builtins.str]:
        """
        The subdirectory in which your files will be stored within the bucket. Adds the prefix subdir/ to new objects' keys. Can't be null or contain '/'.
        """
        return pulumi.get(self, "subdir")


@pulumi.output_type
class ElastigroupAzureV3BootDiagnostic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "storageUrl":
            suggest = "storage_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3BootDiagnostic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3BootDiagnostic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3BootDiagnostic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: _builtins.bool,
                 type: _builtins.str,
                 storage_url: Optional[_builtins.str] = None):
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "type", type)
        if storage_url is not None:
            pulumi.set(__self__, "storage_url", storage_url)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="storageUrl")
    def storage_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "storage_url")


@pulumi.output_type
class ElastigroupAzureV3CapacityReservation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shouldUtilize":
            suggest = "should_utilize"
        elif key == "utilizationStrategy":
            suggest = "utilization_strategy"
        elif key == "capacityReservationGroups":
            suggest = "capacity_reservation_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3CapacityReservation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3CapacityReservation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3CapacityReservation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 should_utilize: _builtins.bool,
                 utilization_strategy: _builtins.str,
                 capacity_reservation_groups: Optional['outputs.ElastigroupAzureV3CapacityReservationCapacityReservationGroups'] = None):
        pulumi.set(__self__, "should_utilize", should_utilize)
        pulumi.set(__self__, "utilization_strategy", utilization_strategy)
        if capacity_reservation_groups is not None:
            pulumi.set(__self__, "capacity_reservation_groups", capacity_reservation_groups)

    @_builtins.property
    @pulumi.getter(name="shouldUtilize")
    def should_utilize(self) -> _builtins.bool:
        return pulumi.get(self, "should_utilize")

    @_builtins.property
    @pulumi.getter(name="utilizationStrategy")
    def utilization_strategy(self) -> _builtins.str:
        return pulumi.get(self, "utilization_strategy")

    @_builtins.property
    @pulumi.getter(name="capacityReservationGroups")
    def capacity_reservation_groups(self) -> Optional['outputs.ElastigroupAzureV3CapacityReservationCapacityReservationGroups']:
        return pulumi.get(self, "capacity_reservation_groups")


@pulumi.output_type
class ElastigroupAzureV3CapacityReservationCapacityReservationGroups(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crgName":
            suggest = "crg_name"
        elif key == "crgResourceGroupName":
            suggest = "crg_resource_group_name"
        elif key == "crgShouldPrioritize":
            suggest = "crg_should_prioritize"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3CapacityReservationCapacityReservationGroups. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3CapacityReservationCapacityReservationGroups.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3CapacityReservationCapacityReservationGroups.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crg_name: _builtins.str,
                 crg_resource_group_name: _builtins.str,
                 crg_should_prioritize: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "crg_name", crg_name)
        pulumi.set(__self__, "crg_resource_group_name", crg_resource_group_name)
        if crg_should_prioritize is not None:
            pulumi.set(__self__, "crg_should_prioritize", crg_should_prioritize)

    @_builtins.property
    @pulumi.getter(name="crgName")
    def crg_name(self) -> _builtins.str:
        return pulumi.get(self, "crg_name")

    @_builtins.property
    @pulumi.getter(name="crgResourceGroupName")
    def crg_resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "crg_resource_group_name")

    @_builtins.property
    @pulumi.getter(name="crgShouldPrioritize")
    def crg_should_prioritize(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "crg_should_prioritize")


@pulumi.output_type
class ElastigroupAzureV3DataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGb":
            suggest = "size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3DataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3DataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3DataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lun: _builtins.int,
                 size_gb: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "size_gb", size_gb)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def lun(self) -> _builtins.int:
        return pulumi.get(self, "lun")

    @_builtins.property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> _builtins.int:
        return pulumi.get(self, "size_gb")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class ElastigroupAzureV3Extension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "minorVersionAutoUpgrade":
            suggest = "minor_version_auto_upgrade"
        elif key == "enableAutomaticUpgrade":
            suggest = "enable_automatic_upgrade"
        elif key == "protectedSettings":
            suggest = "protected_settings"
        elif key == "protectedSettingsFromKeyVault":
            suggest = "protected_settings_from_key_vault"
        elif key == "publicSettings":
            suggest = "public_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3Extension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3Extension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3Extension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: _builtins.str,
                 minor_version_auto_upgrade: _builtins.bool,
                 name: _builtins.str,
                 publisher: _builtins.str,
                 type: _builtins.str,
                 enable_automatic_upgrade: Optional[_builtins.bool] = None,
                 protected_settings: Optional[Mapping[str, _builtins.str]] = None,
                 protected_settings_from_key_vault: Optional['outputs.ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVault'] = None,
                 public_settings: Optional[Mapping[str, _builtins.str]] = None):
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "minor_version_auto_upgrade", minor_version_auto_upgrade)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "type", type)
        if enable_automatic_upgrade is not None:
            pulumi.set(__self__, "enable_automatic_upgrade", enable_automatic_upgrade)
        if protected_settings is not None:
            pulumi.set(__self__, "protected_settings", protected_settings)
        if protected_settings_from_key_vault is not None:
            pulumi.set(__self__, "protected_settings_from_key_vault", protected_settings_from_key_vault)
        if public_settings is not None:
            pulumi.set(__self__, "public_settings", public_settings)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> _builtins.str:
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter(name="minorVersionAutoUpgrade")
    def minor_version_auto_upgrade(self) -> _builtins.bool:
        return pulumi.get(self, "minor_version_auto_upgrade")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def publisher(self) -> _builtins.str:
        return pulumi.get(self, "publisher")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="enableAutomaticUpgrade")
    def enable_automatic_upgrade(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_automatic_upgrade")

    @_builtins.property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "protected_settings")

    @_builtins.property
    @pulumi.getter(name="protectedSettingsFromKeyVault")
    def protected_settings_from_key_vault(self) -> Optional['outputs.ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVault']:
        return pulumi.get(self, "protected_settings_from_key_vault")

    @_builtins.property
    @pulumi.getter(name="publicSettings")
    def public_settings(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "public_settings")


@pulumi.output_type
class ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretUrl":
            suggest = "secret_url"
        elif key == "sourceVault":
            suggest = "source_vault"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_url: _builtins.str,
                 source_vault: _builtins.str):
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault", source_vault)

    @_builtins.property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> _builtins.str:
        return pulumi.get(self, "secret_url")

    @_builtins.property
    @pulumi.getter(name="sourceVault")
    def source_vault(self) -> _builtins.str:
        return pulumi.get(self, "source_vault")


@pulumi.output_type
class ElastigroupAzureV3Health(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoHealing":
            suggest = "auto_healing"
        elif key == "gracePeriod":
            suggest = "grace_period"
        elif key == "healthCheckTypes":
            suggest = "health_check_types"
        elif key == "unhealthyDuration":
            suggest = "unhealthy_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3Health. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3Health.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3Health.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_healing: Optional[_builtins.bool] = None,
                 grace_period: Optional[_builtins.int] = None,
                 health_check_types: Optional[Sequence[_builtins.str]] = None,
                 unhealthy_duration: Optional[_builtins.int] = None):
        if auto_healing is not None:
            pulumi.set(__self__, "auto_healing", auto_healing)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if health_check_types is not None:
            pulumi.set(__self__, "health_check_types", health_check_types)
        if unhealthy_duration is not None:
            pulumi.set(__self__, "unhealthy_duration", unhealthy_duration)

    @_builtins.property
    @pulumi.getter(name="autoHealing")
    def auto_healing(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "auto_healing")

    @_builtins.property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "grace_period")

    @_builtins.property
    @pulumi.getter(name="healthCheckTypes")
    def health_check_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "health_check_types")

    @_builtins.property
    @pulumi.getter(name="unhealthyDuration")
    def unhealthy_duration(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "unhealthy_duration")


@pulumi.output_type
class ElastigroupAzureV3Image(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "galleryImages":
            suggest = "gallery_images"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3Image. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3Image.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3Image.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customs: Optional[Sequence['outputs.ElastigroupAzureV3ImageCustom']] = None,
                 gallery_images: Optional[Sequence['outputs.ElastigroupAzureV3ImageGalleryImage']] = None,
                 marketplaces: Optional[Sequence['outputs.ElastigroupAzureV3ImageMarketplace']] = None):
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if gallery_images is not None:
            pulumi.set(__self__, "gallery_images", gallery_images)
        if marketplaces is not None:
            pulumi.set(__self__, "marketplaces", marketplaces)

    @_builtins.property
    @pulumi.getter
    def customs(self) -> Optional[Sequence['outputs.ElastigroupAzureV3ImageCustom']]:
        return pulumi.get(self, "customs")

    @_builtins.property
    @pulumi.getter(name="galleryImages")
    def gallery_images(self) -> Optional[Sequence['outputs.ElastigroupAzureV3ImageGalleryImage']]:
        return pulumi.get(self, "gallery_images")

    @_builtins.property
    @pulumi.getter
    def marketplaces(self) -> Optional[Sequence['outputs.ElastigroupAzureV3ImageMarketplace']]:
        return pulumi.get(self, "marketplaces")


@pulumi.output_type
class ElastigroupAzureV3ImageCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageName":
            suggest = "image_name"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3ImageCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3ImageCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3ImageCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_name: _builtins.str,
                 resource_group_name: _builtins.str):
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @_builtins.property
    @pulumi.getter(name="imageName")
    def image_name(self) -> _builtins.str:
        return pulumi.get(self, "image_name")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class ElastigroupAzureV3ImageGalleryImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "galleryName":
            suggest = "gallery_name"
        elif key == "imageName":
            suggest = "image_name"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "spotAccountId":
            suggest = "spot_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3ImageGalleryImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3ImageGalleryImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3ImageGalleryImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gallery_name: _builtins.str,
                 image_name: _builtins.str,
                 resource_group_name: _builtins.str,
                 version: _builtins.str,
                 spot_account_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "gallery_name", gallery_name)
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "version", version)
        if spot_account_id is not None:
            pulumi.set(__self__, "spot_account_id", spot_account_id)

    @_builtins.property
    @pulumi.getter(name="galleryName")
    def gallery_name(self) -> _builtins.str:
        return pulumi.get(self, "gallery_name")

    @_builtins.property
    @pulumi.getter(name="imageName")
    def image_name(self) -> _builtins.str:
        return pulumi.get(self, "image_name")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "resource_group_name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="spotAccountId")
    def spot_account_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spot_account_id")


@pulumi.output_type
class ElastigroupAzureV3ImageMarketplace(dict):
    def __init__(__self__, *,
                 offer: _builtins.str,
                 publisher: _builtins.str,
                 sku: _builtins.str,
                 version: _builtins.str):
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def offer(self) -> _builtins.str:
        return pulumi.get(self, "offer")

    @_builtins.property
    @pulumi.getter
    def publisher(self) -> _builtins.str:
        return pulumi.get(self, "publisher")

    @_builtins.property
    @pulumi.getter
    def sku(self) -> _builtins.str:
        return pulumi.get(self, "sku")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        return pulumi.get(self, "version")


@pulumi.output_type
class ElastigroupAzureV3LoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "backendPoolNames":
            suggest = "backend_pool_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3LoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3LoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3LoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 resource_group_name: _builtins.str,
                 type: _builtins.str,
                 backend_pool_names: Optional[Sequence[_builtins.str]] = None,
                 sku: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "type", type)
        if backend_pool_names is not None:
            pulumi.set(__self__, "backend_pool_names", backend_pool_names)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "resource_group_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="backendPoolNames")
    def backend_pool_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "backend_pool_names")

    @_builtins.property
    @pulumi.getter
    def sku(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sku")


@pulumi.output_type
class ElastigroupAzureV3Login(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userName":
            suggest = "user_name"
        elif key == "sshPublicKey":
            suggest = "ssh_public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3Login. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3Login.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3Login.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_name: _builtins.str,
                 password: Optional[_builtins.str] = None,
                 ssh_public_key: Optional[_builtins.str] = None):
        pulumi.set(__self__, "user_name", user_name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if ssh_public_key is not None:
            pulumi.set(__self__, "ssh_public_key", ssh_public_key)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        return pulumi.get(self, "user_name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="sshPublicKey")
    def ssh_public_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ssh_public_key")


@pulumi.output_type
class ElastigroupAzureV3ManagedServiceIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3ManagedServiceIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3ManagedServiceIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3ManagedServiceIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 resource_group_name: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class ElastigroupAzureV3Network(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "virtualNetworkName":
            suggest = "virtual_network_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3Network. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3Network.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3Network.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_interfaces: Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterface'],
                 resource_group_name: _builtins.str,
                 virtual_network_name: _builtins.str):
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "virtual_network_name", virtual_network_name)

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterface']:
        return pulumi.get(self, "network_interfaces")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "resource_group_name")

    @_builtins.property
    @pulumi.getter(name="virtualNetworkName")
    def virtual_network_name(self) -> _builtins.str:
        return pulumi.get(self, "virtual_network_name")


@pulumi.output_type
class ElastigroupAzureV3NetworkNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "isPrimary":
            suggest = "is_primary"
        elif key == "subnetName":
            suggest = "subnet_name"
        elif key == "additionalIpConfigs":
            suggest = "additional_ip_configs"
        elif key == "applicationSecurityGroups":
            suggest = "application_security_groups"
        elif key == "enableIpForwarding":
            suggest = "enable_ip_forwarding"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"
        elif key == "publicIpSku":
            suggest = "public_ip_sku"
        elif key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3NetworkNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3NetworkNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3NetworkNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assign_public_ip: _builtins.bool,
                 is_primary: _builtins.bool,
                 subnet_name: _builtins.str,
                 additional_ip_configs: Optional[Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig']] = None,
                 application_security_groups: Optional[Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup']] = None,
                 enable_ip_forwarding: Optional[_builtins.bool] = None,
                 private_ip_addresses: Optional[Sequence[_builtins.str]] = None,
                 public_ip_sku: Optional[_builtins.str] = None,
                 security_groups: Optional[Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterfaceSecurityGroup']] = None):
        pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        pulumi.set(__self__, "is_primary", is_primary)
        pulumi.set(__self__, "subnet_name", subnet_name)
        if additional_ip_configs is not None:
            pulumi.set(__self__, "additional_ip_configs", additional_ip_configs)
        if application_security_groups is not None:
            pulumi.set(__self__, "application_security_groups", application_security_groups)
        if enable_ip_forwarding is not None:
            pulumi.set(__self__, "enable_ip_forwarding", enable_ip_forwarding)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if public_ip_sku is not None:
            pulumi.set(__self__, "public_ip_sku", public_ip_sku)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> _builtins.bool:
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> _builtins.bool:
        return pulumi.get(self, "is_primary")

    @_builtins.property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> _builtins.str:
        return pulumi.get(self, "subnet_name")

    @_builtins.property
    @pulumi.getter(name="additionalIpConfigs")
    def additional_ip_configs(self) -> Optional[Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig']]:
        return pulumi.get(self, "additional_ip_configs")

    @_builtins.property
    @pulumi.getter(name="applicationSecurityGroups")
    def application_security_groups(self) -> Optional[Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup']]:
        return pulumi.get(self, "application_security_groups")

    @_builtins.property
    @pulumi.getter(name="enableIpForwarding")
    def enable_ip_forwarding(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_ip_forwarding")

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "private_ip_addresses")

    @_builtins.property
    @pulumi.getter(name="publicIpSku")
    def public_ip_sku(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "public_ip_sku")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterfaceSecurityGroup']]:
        return pulumi.get(self, "security_groups")


@pulumi.output_type
class ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpVersion":
            suggest = "private_ip_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 private_ip_version: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        if private_ip_version is not None:
            pulumi.set(__self__, "private_ip_version", private_ip_version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="privateIpVersion")
    def private_ip_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "private_ip_version")


@pulumi.output_type
class ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 resource_group_name: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class ElastigroupAzureV3NetworkNetworkInterfaceSecurityGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3NetworkNetworkInterfaceSecurityGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3NetworkNetworkInterfaceSecurityGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3NetworkNetworkInterfaceSecurityGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 resource_group_name: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class ElastigroupAzureV3OsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGb":
            suggest = "size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3OsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3OsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3OsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 size_gb: Optional[_builtins.int] = None):
        pulumi.set(__self__, "type", type)
        if size_gb is not None:
            pulumi.set(__self__, "size_gb", size_gb)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "size_gb")


@pulumi.output_type
class ElastigroupAzureV3ProximityPlacementGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3ProximityPlacementGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3ProximityPlacementGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3ProximityPlacementGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 resource_group_name: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class ElastigroupAzureV3RevertToSpot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "performAt":
            suggest = "perform_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3RevertToSpot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3RevertToSpot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3RevertToSpot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 perform_at: _builtins.str):
        pulumi.set(__self__, "perform_at", perform_at)

    @_builtins.property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> _builtins.str:
        return pulumi.get(self, "perform_at")


@pulumi.output_type
class ElastigroupAzureV3ScalingDownPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluationPeriods":
            suggest = "evaluation_periods"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "policyName":
            suggest = "policy_name"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3ScalingDownPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3ScalingDownPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3ScalingDownPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'outputs.ElastigroupAzureV3ScalingDownPolicyAction',
                 cooldown: _builtins.int,
                 evaluation_periods: _builtins.int,
                 metric_name: _builtins.str,
                 namespace: _builtins.str,
                 operator: _builtins.str,
                 period: _builtins.int,
                 policy_name: _builtins.str,
                 statistic: _builtins.str,
                 threshold: _builtins.float,
                 dimensions: Optional[Sequence['outputs.ElastigroupAzureV3ScalingDownPolicyDimension']] = None,
                 is_enabled: Optional[_builtins.bool] = None,
                 source: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "cooldown", cooldown)
        pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "statistic", statistic)
        pulumi.set(__self__, "threshold", threshold)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def action(self) -> 'outputs.ElastigroupAzureV3ScalingDownPolicyAction':
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def cooldown(self) -> _builtins.int:
        return pulumi.get(self, "cooldown")

    @_builtins.property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> _builtins.int:
        return pulumi.get(self, "evaluation_periods")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.int:
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> _builtins.str:
        return pulumi.get(self, "policy_name")

    @_builtins.property
    @pulumi.getter
    def statistic(self) -> _builtins.str:
        return pulumi.get(self, "statistic")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.float:
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ElastigroupAzureV3ScalingDownPolicyDimension']]:
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class ElastigroupAzureV3ScalingDownPolicyAction(dict):
    def __init__(__self__, *,
                 adjustment: Optional[_builtins.str] = None,
                 maximum: Optional[_builtins.str] = None,
                 minimum: Optional[_builtins.str] = None,
                 target: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def adjustment(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "adjustment")

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "maximum")

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "minimum")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ElastigroupAzureV3ScalingDownPolicyDimension(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ElastigroupAzureV3ScalingUpPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluationPeriods":
            suggest = "evaluation_periods"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "policyName":
            suggest = "policy_name"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3ScalingUpPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3ScalingUpPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3ScalingUpPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'outputs.ElastigroupAzureV3ScalingUpPolicyAction',
                 cooldown: _builtins.int,
                 evaluation_periods: _builtins.int,
                 metric_name: _builtins.str,
                 namespace: _builtins.str,
                 operator: _builtins.str,
                 period: _builtins.int,
                 policy_name: _builtins.str,
                 statistic: _builtins.str,
                 threshold: _builtins.float,
                 dimensions: Optional[Sequence['outputs.ElastigroupAzureV3ScalingUpPolicyDimension']] = None,
                 is_enabled: Optional[_builtins.bool] = None,
                 source: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "cooldown", cooldown)
        pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "statistic", statistic)
        pulumi.set(__self__, "threshold", threshold)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def action(self) -> 'outputs.ElastigroupAzureV3ScalingUpPolicyAction':
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def cooldown(self) -> _builtins.int:
        return pulumi.get(self, "cooldown")

    @_builtins.property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> _builtins.int:
        return pulumi.get(self, "evaluation_periods")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.int:
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> _builtins.str:
        return pulumi.get(self, "policy_name")

    @_builtins.property
    @pulumi.getter
    def statistic(self) -> _builtins.str:
        return pulumi.get(self, "statistic")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.float:
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ElastigroupAzureV3ScalingUpPolicyDimension']]:
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class ElastigroupAzureV3ScalingUpPolicyAction(dict):
    def __init__(__self__, *,
                 adjustment: Optional[_builtins.str] = None,
                 maximum: Optional[_builtins.str] = None,
                 minimum: Optional[_builtins.str] = None,
                 target: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def adjustment(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "adjustment")

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "maximum")

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "minimum")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ElastigroupAzureV3ScalingUpPolicyDimension(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ElastigroupAzureV3SchedulingTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "adjustmentPercentage":
            suggest = "adjustment_percentage"
        elif key == "batchSizePercentage":
            suggest = "batch_size_percentage"
        elif key == "gracePeriod":
            suggest = "grace_period"
        elif key == "scaleMaxCapacity":
            suggest = "scale_max_capacity"
        elif key == "scaleMinCapacity":
            suggest = "scale_min_capacity"
        elif key == "scaleTargetCapacity":
            suggest = "scale_target_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3SchedulingTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3SchedulingTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3SchedulingTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression: _builtins.str,
                 is_enabled: _builtins.bool,
                 type: _builtins.str,
                 adjustment: Optional[_builtins.str] = None,
                 adjustment_percentage: Optional[_builtins.str] = None,
                 batch_size_percentage: Optional[_builtins.str] = None,
                 grace_period: Optional[_builtins.str] = None,
                 scale_max_capacity: Optional[_builtins.str] = None,
                 scale_min_capacity: Optional[_builtins.str] = None,
                 scale_target_capacity: Optional[_builtins.str] = None):
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "type", type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if adjustment_percentage is not None:
            pulumi.set(__self__, "adjustment_percentage", adjustment_percentage)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if scale_max_capacity is not None:
            pulumi.set(__self__, "scale_max_capacity", scale_max_capacity)
        if scale_min_capacity is not None:
            pulumi.set(__self__, "scale_min_capacity", scale_min_capacity)
        if scale_target_capacity is not None:
            pulumi.set(__self__, "scale_target_capacity", scale_target_capacity)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> _builtins.str:
        return pulumi.get(self, "cron_expression")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def adjustment(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "adjustment")

    @_builtins.property
    @pulumi.getter(name="adjustmentPercentage")
    def adjustment_percentage(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "adjustment_percentage")

    @_builtins.property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "batch_size_percentage")

    @_builtins.property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "grace_period")

    @_builtins.property
    @pulumi.getter(name="scaleMaxCapacity")
    def scale_max_capacity(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scale_max_capacity")

    @_builtins.property
    @pulumi.getter(name="scaleMinCapacity")
    def scale_min_capacity(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scale_min_capacity")

    @_builtins.property
    @pulumi.getter(name="scaleTargetCapacity")
    def scale_target_capacity(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scale_target_capacity")


@pulumi.output_type
class ElastigroupAzureV3Secret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceVaults":
            suggest = "source_vaults"
        elif key == "vaultCertificates":
            suggest = "vault_certificates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3Secret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3Secret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3Secret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_vaults: Sequence['outputs.ElastigroupAzureV3SecretSourceVault'],
                 vault_certificates: Sequence['outputs.ElastigroupAzureV3SecretVaultCertificate']):
        pulumi.set(__self__, "source_vaults", source_vaults)
        pulumi.set(__self__, "vault_certificates", vault_certificates)

    @_builtins.property
    @pulumi.getter(name="sourceVaults")
    def source_vaults(self) -> Sequence['outputs.ElastigroupAzureV3SecretSourceVault']:
        return pulumi.get(self, "source_vaults")

    @_builtins.property
    @pulumi.getter(name="vaultCertificates")
    def vault_certificates(self) -> Sequence['outputs.ElastigroupAzureV3SecretVaultCertificate']:
        return pulumi.get(self, "vault_certificates")


@pulumi.output_type
class ElastigroupAzureV3SecretSourceVault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3SecretSourceVault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3SecretSourceVault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3SecretSourceVault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 resource_group_name: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class ElastigroupAzureV3SecretVaultCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateStore":
            suggest = "certificate_store"
        elif key == "certificateUrl":
            suggest = "certificate_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3SecretVaultCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3SecretVaultCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3SecretVaultCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_store: _builtins.str,
                 certificate_url: _builtins.str):
        pulumi.set(__self__, "certificate_store", certificate_store)
        pulumi.set(__self__, "certificate_url", certificate_url)

    @_builtins.property
    @pulumi.getter(name="certificateStore")
    def certificate_store(self) -> _builtins.str:
        return pulumi.get(self, "certificate_store")

    @_builtins.property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> _builtins.str:
        return pulumi.get(self, "certificate_url")


@pulumi.output_type
class ElastigroupAzureV3Security(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confidentialOsDiskEncryption":
            suggest = "confidential_os_disk_encryption"
        elif key == "encryptionAtHost":
            suggest = "encryption_at_host"
        elif key == "secureBootEnabled":
            suggest = "secure_boot_enabled"
        elif key == "securityType":
            suggest = "security_type"
        elif key == "vtpmEnabled":
            suggest = "vtpm_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3Security. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3Security.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3Security.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 confidential_os_disk_encryption: Optional[_builtins.bool] = None,
                 encryption_at_host: Optional[_builtins.bool] = None,
                 secure_boot_enabled: Optional[_builtins.bool] = None,
                 security_type: Optional[_builtins.str] = None,
                 vtpm_enabled: Optional[_builtins.bool] = None):
        if confidential_os_disk_encryption is not None:
            pulumi.set(__self__, "confidential_os_disk_encryption", confidential_os_disk_encryption)
        if encryption_at_host is not None:
            pulumi.set(__self__, "encryption_at_host", encryption_at_host)
        if secure_boot_enabled is not None:
            pulumi.set(__self__, "secure_boot_enabled", secure_boot_enabled)
        if security_type is not None:
            pulumi.set(__self__, "security_type", security_type)
        if vtpm_enabled is not None:
            pulumi.set(__self__, "vtpm_enabled", vtpm_enabled)

    @_builtins.property
    @pulumi.getter(name="confidentialOsDiskEncryption")
    def confidential_os_disk_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "confidential_os_disk_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionAtHost")
    def encryption_at_host(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encryption_at_host")

    @_builtins.property
    @pulumi.getter(name="secureBootEnabled")
    def secure_boot_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "secure_boot_enabled")

    @_builtins.property
    @pulumi.getter(name="securityType")
    def security_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "security_type")

    @_builtins.property
    @pulumi.getter(name="vtpmEnabled")
    def vtpm_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "vtpm_enabled")


@pulumi.output_type
class ElastigroupAzureV3Signal(dict):
    def __init__(__self__, *,
                 timeout: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class ElastigroupAzureV3Tag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ElastigroupAzureV3VmSizes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "odSizes":
            suggest = "od_sizes"
        elif key == "excludedVmSizes":
            suggest = "excluded_vm_sizes"
        elif key == "preferredSpotSizes":
            suggest = "preferred_spot_sizes"
        elif key == "spotSizeAttributes":
            suggest = "spot_size_attributes"
        elif key == "spotSizes":
            suggest = "spot_sizes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3VmSizes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3VmSizes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3VmSizes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 od_sizes: Sequence[_builtins.str],
                 excluded_vm_sizes: Optional[Sequence[_builtins.str]] = None,
                 preferred_spot_sizes: Optional[Sequence[_builtins.str]] = None,
                 spot_size_attributes: Optional['outputs.ElastigroupAzureV3VmSizesSpotSizeAttributes'] = None,
                 spot_sizes: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "od_sizes", od_sizes)
        if excluded_vm_sizes is not None:
            pulumi.set(__self__, "excluded_vm_sizes", excluded_vm_sizes)
        if preferred_spot_sizes is not None:
            pulumi.set(__self__, "preferred_spot_sizes", preferred_spot_sizes)
        if spot_size_attributes is not None:
            pulumi.set(__self__, "spot_size_attributes", spot_size_attributes)
        if spot_sizes is not None:
            pulumi.set(__self__, "spot_sizes", spot_sizes)

    @_builtins.property
    @pulumi.getter(name="odSizes")
    def od_sizes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "od_sizes")

    @_builtins.property
    @pulumi.getter(name="excludedVmSizes")
    def excluded_vm_sizes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_vm_sizes")

    @_builtins.property
    @pulumi.getter(name="preferredSpotSizes")
    def preferred_spot_sizes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "preferred_spot_sizes")

    @_builtins.property
    @pulumi.getter(name="spotSizeAttributes")
    def spot_size_attributes(self) -> Optional['outputs.ElastigroupAzureV3VmSizesSpotSizeAttributes']:
        return pulumi.get(self, "spot_size_attributes")

    @_builtins.property
    @pulumi.getter(name="spotSizes")
    def spot_sizes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "spot_sizes")


@pulumi.output_type
class ElastigroupAzureV3VmSizesSpotSizeAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCpu":
            suggest = "max_cpu"
        elif key == "maxMemory":
            suggest = "max_memory"
        elif key == "maxStorage":
            suggest = "max_storage"
        elif key == "minCpu":
            suggest = "min_cpu"
        elif key == "minMemory":
            suggest = "min_memory"
        elif key == "minStorage":
            suggest = "min_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3VmSizesSpotSizeAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3VmSizesSpotSizeAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3VmSizesSpotSizeAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_cpu: Optional[_builtins.int] = None,
                 max_memory: Optional[_builtins.int] = None,
                 max_storage: Optional[_builtins.int] = None,
                 min_cpu: Optional[_builtins.int] = None,
                 min_memory: Optional[_builtins.int] = None,
                 min_storage: Optional[_builtins.int] = None):
        if max_cpu is not None:
            pulumi.set(__self__, "max_cpu", max_cpu)
        if max_memory is not None:
            pulumi.set(__self__, "max_memory", max_memory)
        if max_storage is not None:
            pulumi.set(__self__, "max_storage", max_storage)
        if min_cpu is not None:
            pulumi.set(__self__, "min_cpu", min_cpu)
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)
        if min_storage is not None:
            pulumi.set(__self__, "min_storage", min_storage)

    @_builtins.property
    @pulumi.getter(name="maxCpu")
    def max_cpu(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_cpu")

    @_builtins.property
    @pulumi.getter(name="maxMemory")
    def max_memory(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_memory")

    @_builtins.property
    @pulumi.getter(name="maxStorage")
    def max_storage(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_storage")

    @_builtins.property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_cpu")

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_memory")

    @_builtins.property
    @pulumi.getter(name="minStorage")
    def min_storage(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_storage")


@pulumi.output_type
class HealthCheckCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endPoint":
            suggest = "end_point"
        elif key == "timeOut":
            suggest = "time_out"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HealthCheckCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HealthCheckCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HealthCheckCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthy: _builtins.int,
                 interval: _builtins.int,
                 port: _builtins.int,
                 protocol: _builtins.str,
                 unhealthy: _builtins.int,
                 end_point: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 time_out: Optional[_builtins.int] = None,
                 timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.int healthy: The number of consecutive successful health checks that must occur before declaring an instance healthy.
        :param _builtins.int interval: The amount of time (in seconds) between each health check (minimum: 10).
        :param _builtins.int port: The port to use to connect with the instance.
        :param _builtins.str protocol: The protocol to use to connect with the instance. Valid values: http, https.
        :param _builtins.int unhealthy: The number of consecutive failed health checks that must occur before declaring an instance unhealthy.
        :param _builtins.str endpoint: The destination for the request.
        :param _builtins.int timeout: the amount of time (in seconds) to wait when receiving a response from the health check.
        """
        pulumi.set(__self__, "healthy", healthy)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "unhealthy", unhealthy)
        if end_point is not None:
            pulumi.set(__self__, "end_point", end_point)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if time_out is not None:
            pulumi.set(__self__, "time_out", time_out)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def healthy(self) -> _builtins.int:
        """
        The number of consecutive successful health checks that must occur before declaring an instance healthy.
        """
        return pulumi.get(self, "healthy")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.int:
        """
        The amount of time (in seconds) between each health check (minimum: 10).
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to use to connect with the instance.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The protocol to use to connect with the instance. Valid values: http, https.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def unhealthy(self) -> _builtins.int:
        """
        The number of consecutive failed health checks that must occur before declaring an instance unhealthy.
        """
        return pulumi.get(self, "unhealthy")

    @_builtins.property
    @pulumi.getter(name="endPoint")
    def end_point(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "end_point")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The destination for the request.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="timeOut")
    def time_out(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "time_out")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        the amount of time (in seconds) to wait when receiving a response from the health check.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class NotificationCenterComputePolicyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicRules":
            suggest = "dynamic_rules"
        elif key == "resourceIds":
            suggest = "resource_ids"
        elif key == "shouldIncludeAllResources":
            suggest = "should_include_all_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationCenterComputePolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationCenterComputePolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationCenterComputePolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 events: Sequence['outputs.NotificationCenterComputePolicyConfigEvent'],
                 dynamic_rules: Optional[Sequence['outputs.NotificationCenterComputePolicyConfigDynamicRule']] = None,
                 resource_ids: Optional[Sequence[_builtins.str]] = None,
                 should_include_all_resources: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "events", events)
        if dynamic_rules is not None:
            pulumi.set(__self__, "dynamic_rules", dynamic_rules)
        if resource_ids is not None:
            pulumi.set(__self__, "resource_ids", resource_ids)
        if should_include_all_resources is not None:
            pulumi.set(__self__, "should_include_all_resources", should_include_all_resources)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Sequence['outputs.NotificationCenterComputePolicyConfigEvent']:
        return pulumi.get(self, "events")

    @_builtins.property
    @pulumi.getter(name="dynamicRules")
    def dynamic_rules(self) -> Optional[Sequence['outputs.NotificationCenterComputePolicyConfigDynamicRule']]:
        return pulumi.get(self, "dynamic_rules")

    @_builtins.property
    @pulumi.getter(name="resourceIds")
    def resource_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "resource_ids")

    @_builtins.property
    @pulumi.getter(name="shouldIncludeAllResources")
    def should_include_all_resources(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "should_include_all_resources")


@pulumi.output_type
class NotificationCenterComputePolicyConfigDynamicRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterConditions":
            suggest = "filter_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationCenterComputePolicyConfigDynamicRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationCenterComputePolicyConfigDynamicRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationCenterComputePolicyConfigDynamicRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_conditions: Optional[Sequence['outputs.NotificationCenterComputePolicyConfigDynamicRuleFilterCondition']] = None):
        if filter_conditions is not None:
            pulumi.set(__self__, "filter_conditions", filter_conditions)

    @_builtins.property
    @pulumi.getter(name="filterConditions")
    def filter_conditions(self) -> Optional[Sequence['outputs.NotificationCenterComputePolicyConfigDynamicRuleFilterCondition']]:
        return pulumi.get(self, "filter_conditions")


@pulumi.output_type
class NotificationCenterComputePolicyConfigDynamicRuleFilterCondition(dict):
    def __init__(__self__, *,
                 expression: Optional[_builtins.str] = None,
                 identifier: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None):
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "identifier")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")


@pulumi.output_type
class NotificationCenterComputePolicyConfigEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationCenterComputePolicyConfigEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationCenterComputePolicyConfigEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationCenterComputePolicyConfigEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event: Optional[_builtins.str] = None,
                 event_type: Optional[_builtins.str] = None):
        if event is not None:
            pulumi.set(__self__, "event", event)
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)

    @_builtins.property
    @pulumi.getter
    def event(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "event")

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "event_type")


@pulumi.output_type
class NotificationCenterRegisteredUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subscriptionTypes":
            suggest = "subscription_types"
        elif key == "userEmail":
            suggest = "user_email"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationCenterRegisteredUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationCenterRegisteredUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationCenterRegisteredUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subscription_types: Optional[Sequence[_builtins.str]] = None,
                 user_email: Optional[_builtins.str] = None):
        if subscription_types is not None:
            pulumi.set(__self__, "subscription_types", subscription_types)
        if user_email is not None:
            pulumi.set(__self__, "user_email", user_email)

    @_builtins.property
    @pulumi.getter(name="subscriptionTypes")
    def subscription_types(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "subscription_types")

    @_builtins.property
    @pulumi.getter(name="userEmail")
    def user_email(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_email")


@pulumi.output_type
class NotificationCenterSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subscriptionType":
            suggest = "subscription_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationCenterSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationCenterSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationCenterSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: Optional[_builtins.str] = None,
                 subscription_type: Optional[_builtins.str] = None):
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if subscription_type is not None:
            pulumi.set(__self__, "subscription_type", subscription_type)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="subscriptionType")
    def subscription_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subscription_type")


@pulumi.output_type
class OceanRightSizingRuleAttachWorkload(dict):
    def __init__(__self__, *,
                 namespaces: Sequence['outputs.OceanRightSizingRuleAttachWorkloadNamespace']):
        pulumi.set(__self__, "namespaces", namespaces)

    @_builtins.property
    @pulumi.getter
    def namespaces(self) -> Sequence['outputs.OceanRightSizingRuleAttachWorkloadNamespace']:
        return pulumi.get(self, "namespaces")


@pulumi.output_type
class OceanRightSizingRuleAttachWorkloadNamespace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceName":
            suggest = "namespace_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanRightSizingRuleAttachWorkloadNamespace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanRightSizingRuleAttachWorkloadNamespace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanRightSizingRuleAttachWorkloadNamespace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace_name: _builtins.str,
                 labels: Optional[Sequence['outputs.OceanRightSizingRuleAttachWorkloadNamespaceLabel']] = None,
                 workloads: Optional[Sequence['outputs.OceanRightSizingRuleAttachWorkloadNamespaceWorkload']] = None):
        pulumi.set(__self__, "namespace_name", namespace_name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if workloads is not None:
            pulumi.set(__self__, "workloads", workloads)

    @_builtins.property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> _builtins.str:
        return pulumi.get(self, "namespace_name")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.OceanRightSizingRuleAttachWorkloadNamespaceLabel']]:
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def workloads(self) -> Optional[Sequence['outputs.OceanRightSizingRuleAttachWorkloadNamespaceWorkload']]:
        return pulumi.get(self, "workloads")


@pulumi.output_type
class OceanRightSizingRuleAttachWorkloadNamespaceLabel(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanRightSizingRuleAttachWorkloadNamespaceWorkload(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workloadType":
            suggest = "workload_type"
        elif key == "regexName":
            suggest = "regex_name"
        elif key == "workloadName":
            suggest = "workload_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanRightSizingRuleAttachWorkloadNamespaceWorkload. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanRightSizingRuleAttachWorkloadNamespaceWorkload.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanRightSizingRuleAttachWorkloadNamespaceWorkload.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workload_type: _builtins.str,
                 regex_name: Optional[_builtins.str] = None,
                 workload_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "workload_type", workload_type)
        if regex_name is not None:
            pulumi.set(__self__, "regex_name", regex_name)
        if workload_name is not None:
            pulumi.set(__self__, "workload_name", workload_name)

    @_builtins.property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> _builtins.str:
        return pulumi.get(self, "workload_type")

    @_builtins.property
    @pulumi.getter(name="regexName")
    def regex_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "regex_name")

    @_builtins.property
    @pulumi.getter(name="workloadName")
    def workload_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "workload_name")


@pulumi.output_type
class OceanRightSizingRuleDetachWorkload(dict):
    def __init__(__self__, *,
                 namespaces: Sequence['outputs.OceanRightSizingRuleDetachWorkloadNamespace']):
        pulumi.set(__self__, "namespaces", namespaces)

    @_builtins.property
    @pulumi.getter
    def namespaces(self) -> Sequence['outputs.OceanRightSizingRuleDetachWorkloadNamespace']:
        return pulumi.get(self, "namespaces")


@pulumi.output_type
class OceanRightSizingRuleDetachWorkloadNamespace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceName":
            suggest = "namespace_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanRightSizingRuleDetachWorkloadNamespace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanRightSizingRuleDetachWorkloadNamespace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanRightSizingRuleDetachWorkloadNamespace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace_name: _builtins.str,
                 labels: Optional[Sequence['outputs.OceanRightSizingRuleDetachWorkloadNamespaceLabel']] = None,
                 workloads: Optional[Sequence['outputs.OceanRightSizingRuleDetachWorkloadNamespaceWorkload']] = None):
        pulumi.set(__self__, "namespace_name", namespace_name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if workloads is not None:
            pulumi.set(__self__, "workloads", workloads)

    @_builtins.property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> _builtins.str:
        return pulumi.get(self, "namespace_name")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.OceanRightSizingRuleDetachWorkloadNamespaceLabel']]:
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def workloads(self) -> Optional[Sequence['outputs.OceanRightSizingRuleDetachWorkloadNamespaceWorkload']]:
        return pulumi.get(self, "workloads")


@pulumi.output_type
class OceanRightSizingRuleDetachWorkloadNamespaceLabel(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanRightSizingRuleDetachWorkloadNamespaceWorkload(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workloadType":
            suggest = "workload_type"
        elif key == "regexName":
            suggest = "regex_name"
        elif key == "workloadName":
            suggest = "workload_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanRightSizingRuleDetachWorkloadNamespaceWorkload. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanRightSizingRuleDetachWorkloadNamespaceWorkload.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanRightSizingRuleDetachWorkloadNamespaceWorkload.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workload_type: _builtins.str,
                 regex_name: Optional[_builtins.str] = None,
                 workload_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "workload_type", workload_type)
        if regex_name is not None:
            pulumi.set(__self__, "regex_name", regex_name)
        if workload_name is not None:
            pulumi.set(__self__, "workload_name", workload_name)

    @_builtins.property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> _builtins.str:
        return pulumi.get(self, "workload_type")

    @_builtins.property
    @pulumi.getter(name="regexName")
    def regex_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "regex_name")

    @_builtins.property
    @pulumi.getter(name="workloadName")
    def workload_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "workload_name")


@pulumi.output_type
class OceanRightSizingRuleRecommendationApplicationBoundary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuMax":
            suggest = "cpu_max"
        elif key == "cpuMin":
            suggest = "cpu_min"
        elif key == "memoryMax":
            suggest = "memory_max"
        elif key == "memoryMin":
            suggest = "memory_min"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanRightSizingRuleRecommendationApplicationBoundary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanRightSizingRuleRecommendationApplicationBoundary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanRightSizingRuleRecommendationApplicationBoundary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_max: Optional[_builtins.float] = None,
                 cpu_min: Optional[_builtins.float] = None,
                 memory_max: Optional[_builtins.int] = None,
                 memory_min: Optional[_builtins.int] = None):
        if cpu_max is not None:
            pulumi.set(__self__, "cpu_max", cpu_max)
        if cpu_min is not None:
            pulumi.set(__self__, "cpu_min", cpu_min)
        if memory_max is not None:
            pulumi.set(__self__, "memory_max", memory_max)
        if memory_min is not None:
            pulumi.set(__self__, "memory_min", memory_min)

    @_builtins.property
    @pulumi.getter(name="cpuMax")
    def cpu_max(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "cpu_max")

    @_builtins.property
    @pulumi.getter(name="cpuMin")
    def cpu_min(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "cpu_min")

    @_builtins.property
    @pulumi.getter(name="memoryMax")
    def memory_max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "memory_max")

    @_builtins.property
    @pulumi.getter(name="memoryMin")
    def memory_min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "memory_min")


@pulumi.output_type
class OceanRightSizingRuleRecommendationApplicationHpa(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowHpaRecommendations":
            suggest = "allow_hpa_recommendations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanRightSizingRuleRecommendationApplicationHpa. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanRightSizingRuleRecommendationApplicationHpa.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanRightSizingRuleRecommendationApplicationHpa.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_hpa_recommendations: Optional[_builtins.bool] = None):
        if allow_hpa_recommendations is not None:
            pulumi.set(__self__, "allow_hpa_recommendations", allow_hpa_recommendations)

    @_builtins.property
    @pulumi.getter(name="allowHpaRecommendations")
    def allow_hpa_recommendations(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_hpa_recommendations")


@pulumi.output_type
class OceanRightSizingRuleRecommendationApplicationInterval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repetitionBasis":
            suggest = "repetition_basis"
        elif key == "monthlyRepetitionBases":
            suggest = "monthly_repetition_bases"
        elif key == "weeklyRepetitionBases":
            suggest = "weekly_repetition_bases"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanRightSizingRuleRecommendationApplicationInterval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanRightSizingRuleRecommendationApplicationInterval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanRightSizingRuleRecommendationApplicationInterval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repetition_basis: _builtins.str,
                 monthly_repetition_bases: Optional[Sequence['outputs.OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBase']] = None,
                 weekly_repetition_bases: Optional[Sequence['outputs.OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBase']] = None):
        pulumi.set(__self__, "repetition_basis", repetition_basis)
        if monthly_repetition_bases is not None:
            pulumi.set(__self__, "monthly_repetition_bases", monthly_repetition_bases)
        if weekly_repetition_bases is not None:
            pulumi.set(__self__, "weekly_repetition_bases", weekly_repetition_bases)

    @_builtins.property
    @pulumi.getter(name="repetitionBasis")
    def repetition_basis(self) -> _builtins.str:
        return pulumi.get(self, "repetition_basis")

    @_builtins.property
    @pulumi.getter(name="monthlyRepetitionBases")
    def monthly_repetition_bases(self) -> Optional[Sequence['outputs.OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBase']]:
        return pulumi.get(self, "monthly_repetition_bases")

    @_builtins.property
    @pulumi.getter(name="weeklyRepetitionBases")
    def weekly_repetition_bases(self) -> Optional[Sequence['outputs.OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBase']]:
        return pulumi.get(self, "weekly_repetition_bases")


@pulumi.output_type
class OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalMonths":
            suggest = "interval_months"
        elif key == "weekOfTheMonths":
            suggest = "week_of_the_months"
        elif key == "weeklyRepetitionBases":
            suggest = "weekly_repetition_bases"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_months: Sequence[_builtins.int],
                 week_of_the_months: Sequence[_builtins.str],
                 weekly_repetition_bases: Optional[Sequence['outputs.OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBase']] = None):
        pulumi.set(__self__, "interval_months", interval_months)
        pulumi.set(__self__, "week_of_the_months", week_of_the_months)
        if weekly_repetition_bases is not None:
            pulumi.set(__self__, "weekly_repetition_bases", weekly_repetition_bases)

    @_builtins.property
    @pulumi.getter(name="intervalMonths")
    def interval_months(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "interval_months")

    @_builtins.property
    @pulumi.getter(name="weekOfTheMonths")
    def week_of_the_months(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "week_of_the_months")

    @_builtins.property
    @pulumi.getter(name="weeklyRepetitionBases")
    def weekly_repetition_bases(self) -> Optional[Sequence['outputs.OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBase']]:
        return pulumi.get(self, "weekly_repetition_bases")


@pulumi.output_type
class OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalDays":
            suggest = "interval_days"
        elif key == "intervalHoursEndTime":
            suggest = "interval_hours_end_time"
        elif key == "intervalHoursStartTime":
            suggest = "interval_hours_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_days: Sequence[_builtins.str],
                 interval_hours_end_time: _builtins.str,
                 interval_hours_start_time: _builtins.str):
        pulumi.set(__self__, "interval_days", interval_days)
        pulumi.set(__self__, "interval_hours_end_time", interval_hours_end_time)
        pulumi.set(__self__, "interval_hours_start_time", interval_hours_start_time)

    @_builtins.property
    @pulumi.getter(name="intervalDays")
    def interval_days(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "interval_days")

    @_builtins.property
    @pulumi.getter(name="intervalHoursEndTime")
    def interval_hours_end_time(self) -> _builtins.str:
        return pulumi.get(self, "interval_hours_end_time")

    @_builtins.property
    @pulumi.getter(name="intervalHoursStartTime")
    def interval_hours_start_time(self) -> _builtins.str:
        return pulumi.get(self, "interval_hours_start_time")


@pulumi.output_type
class OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalDays":
            suggest = "interval_days"
        elif key == "intervalHoursEndTime":
            suggest = "interval_hours_end_time"
        elif key == "intervalHoursStartTime":
            suggest = "interval_hours_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_days: Sequence[_builtins.str],
                 interval_hours_end_time: _builtins.str,
                 interval_hours_start_time: _builtins.str):
        pulumi.set(__self__, "interval_days", interval_days)
        pulumi.set(__self__, "interval_hours_end_time", interval_hours_end_time)
        pulumi.set(__self__, "interval_hours_start_time", interval_hours_start_time)

    @_builtins.property
    @pulumi.getter(name="intervalDays")
    def interval_days(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "interval_days")

    @_builtins.property
    @pulumi.getter(name="intervalHoursEndTime")
    def interval_hours_end_time(self) -> _builtins.str:
        return pulumi.get(self, "interval_hours_end_time")

    @_builtins.property
    @pulumi.getter(name="intervalHoursStartTime")
    def interval_hours_start_time(self) -> _builtins.str:
        return pulumi.get(self, "interval_hours_start_time")


@pulumi.output_type
class OceanRightSizingRuleRecommendationApplicationMinThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuPercentage":
            suggest = "cpu_percentage"
        elif key == "memoryPercentage":
            suggest = "memory_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanRightSizingRuleRecommendationApplicationMinThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanRightSizingRuleRecommendationApplicationMinThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanRightSizingRuleRecommendationApplicationMinThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_percentage: Optional[_builtins.float] = None,
                 memory_percentage: Optional[_builtins.float] = None):
        if cpu_percentage is not None:
            pulumi.set(__self__, "cpu_percentage", cpu_percentage)
        if memory_percentage is not None:
            pulumi.set(__self__, "memory_percentage", memory_percentage)

    @_builtins.property
    @pulumi.getter(name="cpuPercentage")
    def cpu_percentage(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "cpu_percentage")

    @_builtins.property
    @pulumi.getter(name="memoryPercentage")
    def memory_percentage(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "memory_percentage")


@pulumi.output_type
class OceanRightSizingRuleRecommendationApplicationOverheadValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuPercentage":
            suggest = "cpu_percentage"
        elif key == "memoryPercentage":
            suggest = "memory_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanRightSizingRuleRecommendationApplicationOverheadValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanRightSizingRuleRecommendationApplicationOverheadValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanRightSizingRuleRecommendationApplicationOverheadValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_percentage: Optional[_builtins.float] = None,
                 memory_percentage: Optional[_builtins.float] = None):
        if cpu_percentage is not None:
            pulumi.set(__self__, "cpu_percentage", cpu_percentage)
        if memory_percentage is not None:
            pulumi.set(__self__, "memory_percentage", memory_percentage)

    @_builtins.property
    @pulumi.getter(name="cpuPercentage")
    def cpu_percentage(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "cpu_percentage")

    @_builtins.property
    @pulumi.getter(name="memoryPercentage")
    def memory_percentage(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "memory_percentage")


@pulumi.output_type
class StatefulNodeAzureAttachDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDiskName":
            suggest = "data_disk_name"
        elif key == "dataDiskResourceGroupName":
            suggest = "data_disk_resource_group_name"
        elif key == "sizeGb":
            suggest = "size_gb"
        elif key == "storageAccountType":
            suggest = "storage_account_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureAttachDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureAttachDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureAttachDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_disk_name: _builtins.str,
                 data_disk_resource_group_name: _builtins.str,
                 size_gb: _builtins.int,
                 storage_account_type: _builtins.str,
                 lun: Optional[_builtins.int] = None,
                 zone: Optional[_builtins.str] = None):
        pulumi.set(__self__, "data_disk_name", data_disk_name)
        pulumi.set(__self__, "data_disk_resource_group_name", data_disk_resource_group_name)
        pulumi.set(__self__, "size_gb", size_gb)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if lun is not None:
            pulumi.set(__self__, "lun", lun)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="dataDiskName")
    def data_disk_name(self) -> _builtins.str:
        return pulumi.get(self, "data_disk_name")

    @_builtins.property
    @pulumi.getter(name="dataDiskResourceGroupName")
    def data_disk_resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "data_disk_resource_group_name")

    @_builtins.property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> _builtins.int:
        return pulumi.get(self, "size_gb")

    @_builtins.property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> _builtins.str:
        return pulumi.get(self, "storage_account_type")

    @_builtins.property
    @pulumi.getter
    def lun(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "lun")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone")


@pulumi.output_type
class StatefulNodeAzureBootDiagnostic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "storageUrl":
            suggest = "storage_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureBootDiagnostic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureBootDiagnostic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureBootDiagnostic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: Optional[_builtins.bool] = None,
                 storage_url: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if storage_url is not None:
            pulumi.set(__self__, "storage_url", storage_url)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="storageUrl")
    def storage_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "storage_url")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class StatefulNodeAzureDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGb":
            suggest = "size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lun: _builtins.int,
                 size_gb: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "size_gb", size_gb)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def lun(self) -> _builtins.int:
        return pulumi.get(self, "lun")

    @_builtins.property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> _builtins.int:
        return pulumi.get(self, "size_gb")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class StatefulNodeAzureDelete(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shouldTerminateVm":
            suggest = "should_terminate_vm"
        elif key == "diskShouldDeallocate":
            suggest = "disk_should_deallocate"
        elif key == "diskTtlInHours":
            suggest = "disk_ttl_in_hours"
        elif key == "networkShouldDeallocate":
            suggest = "network_should_deallocate"
        elif key == "networkTtlInHours":
            suggest = "network_ttl_in_hours"
        elif key == "publicIpShouldDeallocate":
            suggest = "public_ip_should_deallocate"
        elif key == "publicIpTtlInHours":
            suggest = "public_ip_ttl_in_hours"
        elif key == "shouldDeregisterFromLb":
            suggest = "should_deregister_from_lb"
        elif key == "shouldRevertToOd":
            suggest = "should_revert_to_od"
        elif key == "snapshotShouldDeallocate":
            suggest = "snapshot_should_deallocate"
        elif key == "snapshotTtlInHours":
            suggest = "snapshot_ttl_in_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureDelete. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureDelete.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureDelete.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 should_terminate_vm: _builtins.bool,
                 disk_should_deallocate: Optional[_builtins.bool] = None,
                 disk_ttl_in_hours: Optional[_builtins.int] = None,
                 network_should_deallocate: Optional[_builtins.bool] = None,
                 network_ttl_in_hours: Optional[_builtins.int] = None,
                 public_ip_should_deallocate: Optional[_builtins.bool] = None,
                 public_ip_ttl_in_hours: Optional[_builtins.int] = None,
                 should_deregister_from_lb: Optional[_builtins.bool] = None,
                 should_revert_to_od: Optional[_builtins.bool] = None,
                 snapshot_should_deallocate: Optional[_builtins.bool] = None,
                 snapshot_ttl_in_hours: Optional[_builtins.int] = None):
        pulumi.set(__self__, "should_terminate_vm", should_terminate_vm)
        if disk_should_deallocate is not None:
            pulumi.set(__self__, "disk_should_deallocate", disk_should_deallocate)
        if disk_ttl_in_hours is not None:
            pulumi.set(__self__, "disk_ttl_in_hours", disk_ttl_in_hours)
        if network_should_deallocate is not None:
            pulumi.set(__self__, "network_should_deallocate", network_should_deallocate)
        if network_ttl_in_hours is not None:
            pulumi.set(__self__, "network_ttl_in_hours", network_ttl_in_hours)
        if public_ip_should_deallocate is not None:
            pulumi.set(__self__, "public_ip_should_deallocate", public_ip_should_deallocate)
        if public_ip_ttl_in_hours is not None:
            pulumi.set(__self__, "public_ip_ttl_in_hours", public_ip_ttl_in_hours)
        if should_deregister_from_lb is not None:
            pulumi.set(__self__, "should_deregister_from_lb", should_deregister_from_lb)
        if should_revert_to_od is not None:
            pulumi.set(__self__, "should_revert_to_od", should_revert_to_od)
        if snapshot_should_deallocate is not None:
            pulumi.set(__self__, "snapshot_should_deallocate", snapshot_should_deallocate)
        if snapshot_ttl_in_hours is not None:
            pulumi.set(__self__, "snapshot_ttl_in_hours", snapshot_ttl_in_hours)

    @_builtins.property
    @pulumi.getter(name="shouldTerminateVm")
    def should_terminate_vm(self) -> _builtins.bool:
        return pulumi.get(self, "should_terminate_vm")

    @_builtins.property
    @pulumi.getter(name="diskShouldDeallocate")
    def disk_should_deallocate(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disk_should_deallocate")

    @_builtins.property
    @pulumi.getter(name="diskTtlInHours")
    def disk_ttl_in_hours(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "disk_ttl_in_hours")

    @_builtins.property
    @pulumi.getter(name="networkShouldDeallocate")
    def network_should_deallocate(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "network_should_deallocate")

    @_builtins.property
    @pulumi.getter(name="networkTtlInHours")
    def network_ttl_in_hours(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "network_ttl_in_hours")

    @_builtins.property
    @pulumi.getter(name="publicIpShouldDeallocate")
    def public_ip_should_deallocate(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "public_ip_should_deallocate")

    @_builtins.property
    @pulumi.getter(name="publicIpTtlInHours")
    def public_ip_ttl_in_hours(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "public_ip_ttl_in_hours")

    @_builtins.property
    @pulumi.getter(name="shouldDeregisterFromLb")
    def should_deregister_from_lb(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "should_deregister_from_lb")

    @_builtins.property
    @pulumi.getter(name="shouldRevertToOd")
    def should_revert_to_od(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "should_revert_to_od")

    @_builtins.property
    @pulumi.getter(name="snapshotShouldDeallocate")
    def snapshot_should_deallocate(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "snapshot_should_deallocate")

    @_builtins.property
    @pulumi.getter(name="snapshotTtlInHours")
    def snapshot_ttl_in_hours(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "snapshot_ttl_in_hours")


@pulumi.output_type
class StatefulNodeAzureDetachDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDiskName":
            suggest = "data_disk_name"
        elif key == "dataDiskResourceGroupName":
            suggest = "data_disk_resource_group_name"
        elif key == "shouldDeallocate":
            suggest = "should_deallocate"
        elif key == "ttlInHours":
            suggest = "ttl_in_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureDetachDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureDetachDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureDetachDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_disk_name: _builtins.str,
                 data_disk_resource_group_name: _builtins.str,
                 should_deallocate: _builtins.bool,
                 ttl_in_hours: Optional[_builtins.int] = None):
        pulumi.set(__self__, "data_disk_name", data_disk_name)
        pulumi.set(__self__, "data_disk_resource_group_name", data_disk_resource_group_name)
        pulumi.set(__self__, "should_deallocate", should_deallocate)
        if ttl_in_hours is not None:
            pulumi.set(__self__, "ttl_in_hours", ttl_in_hours)

    @_builtins.property
    @pulumi.getter(name="dataDiskName")
    def data_disk_name(self) -> _builtins.str:
        return pulumi.get(self, "data_disk_name")

    @_builtins.property
    @pulumi.getter(name="dataDiskResourceGroupName")
    def data_disk_resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "data_disk_resource_group_name")

    @_builtins.property
    @pulumi.getter(name="shouldDeallocate")
    def should_deallocate(self) -> _builtins.bool:
        return pulumi.get(self, "should_deallocate")

    @_builtins.property
    @pulumi.getter(name="ttlInHours")
    def ttl_in_hours(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ttl_in_hours")


@pulumi.output_type
class StatefulNodeAzureExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "minorVersionAutoUpgrade":
            suggest = "minor_version_auto_upgrade"
        elif key == "protectedSettings":
            suggest = "protected_settings"
        elif key == "publicSettings":
            suggest = "public_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: _builtins.str,
                 minor_version_auto_upgrade: _builtins.bool,
                 name: _builtins.str,
                 publisher: _builtins.str,
                 type: _builtins.str,
                 protected_settings: Optional[Mapping[str, _builtins.str]] = None,
                 public_settings: Optional[Mapping[str, _builtins.str]] = None):
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "minor_version_auto_upgrade", minor_version_auto_upgrade)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "type", type)
        if protected_settings is not None:
            pulumi.set(__self__, "protected_settings", protected_settings)
        if public_settings is not None:
            pulumi.set(__self__, "public_settings", public_settings)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> _builtins.str:
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter(name="minorVersionAutoUpgrade")
    def minor_version_auto_upgrade(self) -> _builtins.bool:
        return pulumi.get(self, "minor_version_auto_upgrade")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def publisher(self) -> _builtins.str:
        return pulumi.get(self, "publisher")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "protected_settings")

    @_builtins.property
    @pulumi.getter(name="publicSettings")
    def public_settings(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "public_settings")


@pulumi.output_type
class StatefulNodeAzureHealth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoHealing":
            suggest = "auto_healing"
        elif key == "healthCheckTypes":
            suggest = "health_check_types"
        elif key == "gracePeriod":
            suggest = "grace_period"
        elif key == "unhealthyDuration":
            suggest = "unhealthy_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureHealth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureHealth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureHealth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_healing: _builtins.bool,
                 health_check_types: Sequence[_builtins.str],
                 grace_period: Optional[_builtins.int] = None,
                 unhealthy_duration: Optional[_builtins.int] = None):
        pulumi.set(__self__, "auto_healing", auto_healing)
        pulumi.set(__self__, "health_check_types", health_check_types)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if unhealthy_duration is not None:
            pulumi.set(__self__, "unhealthy_duration", unhealthy_duration)

    @_builtins.property
    @pulumi.getter(name="autoHealing")
    def auto_healing(self) -> _builtins.bool:
        return pulumi.get(self, "auto_healing")

    @_builtins.property
    @pulumi.getter(name="healthCheckTypes")
    def health_check_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "health_check_types")

    @_builtins.property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "grace_period")

    @_builtins.property
    @pulumi.getter(name="unhealthyDuration")
    def unhealthy_duration(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "unhealthy_duration")


@pulumi.output_type
class StatefulNodeAzureImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customImages":
            suggest = "custom_images"
        elif key == "marketplaceImages":
            suggest = "marketplace_images"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_images: Optional[Sequence['outputs.StatefulNodeAzureImageCustomImage']] = None,
                 galleries: Optional[Sequence['outputs.StatefulNodeAzureImageGallery']] = None,
                 marketplace_images: Optional[Sequence['outputs.StatefulNodeAzureImageMarketplaceImage']] = None):
        if custom_images is not None:
            pulumi.set(__self__, "custom_images", custom_images)
        if galleries is not None:
            pulumi.set(__self__, "galleries", galleries)
        if marketplace_images is not None:
            pulumi.set(__self__, "marketplace_images", marketplace_images)

    @_builtins.property
    @pulumi.getter(name="customImages")
    def custom_images(self) -> Optional[Sequence['outputs.StatefulNodeAzureImageCustomImage']]:
        return pulumi.get(self, "custom_images")

    @_builtins.property
    @pulumi.getter
    def galleries(self) -> Optional[Sequence['outputs.StatefulNodeAzureImageGallery']]:
        return pulumi.get(self, "galleries")

    @_builtins.property
    @pulumi.getter(name="marketplaceImages")
    def marketplace_images(self) -> Optional[Sequence['outputs.StatefulNodeAzureImageMarketplaceImage']]:
        return pulumi.get(self, "marketplace_images")


@pulumi.output_type
class StatefulNodeAzureImageCustomImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customImageResourceGroupName":
            suggest = "custom_image_resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureImageCustomImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureImageCustomImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureImageCustomImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_image_resource_group_name: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "custom_image_resource_group_name", custom_image_resource_group_name)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="customImageResourceGroupName")
    def custom_image_resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "custom_image_resource_group_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class StatefulNodeAzureImageGallery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "galleryName":
            suggest = "gallery_name"
        elif key == "galleryResourceGroupName":
            suggest = "gallery_resource_group_name"
        elif key == "imageName":
            suggest = "image_name"
        elif key == "versionName":
            suggest = "version_name"
        elif key == "spotAccountId":
            suggest = "spot_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureImageGallery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureImageGallery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureImageGallery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gallery_name: _builtins.str,
                 gallery_resource_group_name: _builtins.str,
                 image_name: _builtins.str,
                 version_name: _builtins.str,
                 spot_account_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "gallery_name", gallery_name)
        pulumi.set(__self__, "gallery_resource_group_name", gallery_resource_group_name)
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "version_name", version_name)
        if spot_account_id is not None:
            pulumi.set(__self__, "spot_account_id", spot_account_id)

    @_builtins.property
    @pulumi.getter(name="galleryName")
    def gallery_name(self) -> _builtins.str:
        return pulumi.get(self, "gallery_name")

    @_builtins.property
    @pulumi.getter(name="galleryResourceGroupName")
    def gallery_resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "gallery_resource_group_name")

    @_builtins.property
    @pulumi.getter(name="imageName")
    def image_name(self) -> _builtins.str:
        return pulumi.get(self, "image_name")

    @_builtins.property
    @pulumi.getter(name="versionName")
    def version_name(self) -> _builtins.str:
        return pulumi.get(self, "version_name")

    @_builtins.property
    @pulumi.getter(name="spotAccountId")
    def spot_account_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spot_account_id")


@pulumi.output_type
class StatefulNodeAzureImageMarketplaceImage(dict):
    def __init__(__self__, *,
                 offer: _builtins.str,
                 publisher: _builtins.str,
                 sku: _builtins.str,
                 version: _builtins.str):
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def offer(self) -> _builtins.str:
        return pulumi.get(self, "offer")

    @_builtins.property
    @pulumi.getter
    def publisher(self) -> _builtins.str:
        return pulumi.get(self, "publisher")

    @_builtins.property
    @pulumi.getter
    def sku(self) -> _builtins.str:
        return pulumi.get(self, "sku")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        return pulumi.get(self, "version")


@pulumi.output_type
class StatefulNodeAzureImportVm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originalVmName":
            suggest = "original_vm_name"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "drainingTimeout":
            suggest = "draining_timeout"
        elif key == "resourcesRetentionTime":
            suggest = "resources_retention_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureImportVm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureImportVm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureImportVm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 original_vm_name: _builtins.str,
                 resource_group_name: _builtins.str,
                 draining_timeout: Optional[_builtins.int] = None,
                 resources_retention_time: Optional[_builtins.int] = None):
        pulumi.set(__self__, "original_vm_name", original_vm_name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        if draining_timeout is not None:
            pulumi.set(__self__, "draining_timeout", draining_timeout)
        if resources_retention_time is not None:
            pulumi.set(__self__, "resources_retention_time", resources_retention_time)

    @_builtins.property
    @pulumi.getter(name="originalVmName")
    def original_vm_name(self) -> _builtins.str:
        return pulumi.get(self, "original_vm_name")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "resource_group_name")

    @_builtins.property
    @pulumi.getter(name="drainingTimeout")
    def draining_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "draining_timeout")

    @_builtins.property
    @pulumi.getter(name="resourcesRetentionTime")
    def resources_retention_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "resources_retention_time")


@pulumi.output_type
class StatefulNodeAzureLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendPoolNames":
            suggest = "backend_pool_names"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_pool_names: Sequence[_builtins.str],
                 name: _builtins.str,
                 resource_group_name: _builtins.str,
                 type: _builtins.str,
                 sku: Optional[_builtins.str] = None):
        pulumi.set(__self__, "backend_pool_names", backend_pool_names)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "type", type)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)

    @_builtins.property
    @pulumi.getter(name="backendPoolNames")
    def backend_pool_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "backend_pool_names")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "resource_group_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def sku(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sku")


@pulumi.output_type
class StatefulNodeAzureLogin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userName":
            suggest = "user_name"
        elif key == "sshPublicKey":
            suggest = "ssh_public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureLogin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureLogin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureLogin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_name: _builtins.str,
                 password: Optional[_builtins.str] = None,
                 ssh_public_key: Optional[_builtins.str] = None):
        pulumi.set(__self__, "user_name", user_name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if ssh_public_key is not None:
            pulumi.set(__self__, "ssh_public_key", ssh_public_key)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        return pulumi.get(self, "user_name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="sshPublicKey")
    def ssh_public_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ssh_public_key")


@pulumi.output_type
class StatefulNodeAzureManagedServiceIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "subscriptionId":
            suggest = "subscription_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureManagedServiceIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureManagedServiceIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureManagedServiceIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 resource_group_name: _builtins.str,
                 subscription_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "resource_group_name")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subscription_id")


@pulumi.output_type
class StatefulNodeAzureNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "networkResourceGroupName":
            suggest = "network_resource_group_name"
        elif key == "virtualNetworkName":
            suggest = "virtual_network_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_interfaces: Sequence['outputs.StatefulNodeAzureNetworkNetworkInterface'],
                 network_resource_group_name: _builtins.str,
                 virtual_network_name: _builtins.str):
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "network_resource_group_name", network_resource_group_name)
        pulumi.set(__self__, "virtual_network_name", virtual_network_name)

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.StatefulNodeAzureNetworkNetworkInterface']:
        return pulumi.get(self, "network_interfaces")

    @_builtins.property
    @pulumi.getter(name="networkResourceGroupName")
    def network_resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "network_resource_group_name")

    @_builtins.property
    @pulumi.getter(name="virtualNetworkName")
    def virtual_network_name(self) -> _builtins.str:
        return pulumi.get(self, "virtual_network_name")


@pulumi.output_type
class StatefulNodeAzureNetworkNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPrimary":
            suggest = "is_primary"
        elif key == "subnetName":
            suggest = "subnet_name"
        elif key == "additionalIpConfigurations":
            suggest = "additional_ip_configurations"
        elif key == "applicationSecurityGroups":
            suggest = "application_security_groups"
        elif key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "enableIpForwarding":
            suggest = "enable_ip_forwarding"
        elif key == "networkSecurityGroups":
            suggest = "network_security_groups"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"
        elif key == "publicIpSku":
            suggest = "public_ip_sku"
        elif key == "publicIps":
            suggest = "public_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureNetworkNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureNetworkNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureNetworkNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_primary: _builtins.bool,
                 subnet_name: _builtins.str,
                 additional_ip_configurations: Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration']] = None,
                 application_security_groups: Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup']] = None,
                 assign_public_ip: Optional[_builtins.bool] = None,
                 enable_ip_forwarding: Optional[_builtins.bool] = None,
                 network_security_groups: Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup']] = None,
                 private_ip_addresses: Optional[Sequence[_builtins.str]] = None,
                 public_ip_sku: Optional[_builtins.str] = None,
                 public_ips: Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfacePublicIp']] = None):
        pulumi.set(__self__, "is_primary", is_primary)
        pulumi.set(__self__, "subnet_name", subnet_name)
        if additional_ip_configurations is not None:
            pulumi.set(__self__, "additional_ip_configurations", additional_ip_configurations)
        if application_security_groups is not None:
            pulumi.set(__self__, "application_security_groups", application_security_groups)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if enable_ip_forwarding is not None:
            pulumi.set(__self__, "enable_ip_forwarding", enable_ip_forwarding)
        if network_security_groups is not None:
            pulumi.set(__self__, "network_security_groups", network_security_groups)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if public_ip_sku is not None:
            pulumi.set(__self__, "public_ip_sku", public_ip_sku)
        if public_ips is not None:
            pulumi.set(__self__, "public_ips", public_ips)

    @_builtins.property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> _builtins.bool:
        return pulumi.get(self, "is_primary")

    @_builtins.property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> _builtins.str:
        return pulumi.get(self, "subnet_name")

    @_builtins.property
    @pulumi.getter(name="additionalIpConfigurations")
    def additional_ip_configurations(self) -> Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration']]:
        return pulumi.get(self, "additional_ip_configurations")

    @_builtins.property
    @pulumi.getter(name="applicationSecurityGroups")
    def application_security_groups(self) -> Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup']]:
        return pulumi.get(self, "application_security_groups")

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "assign_public_ip")

    @_builtins.property
    @pulumi.getter(name="enableIpForwarding")
    def enable_ip_forwarding(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_ip_forwarding")

    @_builtins.property
    @pulumi.getter(name="networkSecurityGroups")
    def network_security_groups(self) -> Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup']]:
        return pulumi.get(self, "network_security_groups")

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "private_ip_addresses")

    @_builtins.property
    @pulumi.getter(name="publicIpSku")
    def public_ip_sku(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "public_ip_sku")

    @_builtins.property
    @pulumi.getter(name="publicIps")
    def public_ips(self) -> Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfacePublicIp']]:
        return pulumi.get(self, "public_ips")


@pulumi.output_type
class StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddressVersion":
            suggest = "private_ip_address_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 private_ip_address_version: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_ip_address_version", private_ip_address_version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="privateIpAddressVersion")
    def private_ip_address_version(self) -> _builtins.str:
        return pulumi.get(self, "private_ip_address_version")


@pulumi.output_type
class StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkResourceGroupName":
            suggest = "network_resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 network_resource_group_name: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_resource_group_name", network_resource_group_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkResourceGroupName")
    def network_resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "network_resource_group_name")


@pulumi.output_type
class StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkResourceGroupName":
            suggest = "network_resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 network_resource_group_name: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_resource_group_name is not None:
            pulumi.set(__self__, "network_resource_group_name", network_resource_group_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkResourceGroupName")
    def network_resource_group_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network_resource_group_name")


@pulumi.output_type
class StatefulNodeAzureNetworkNetworkInterfacePublicIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkResourceGroupName":
            suggest = "network_resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureNetworkNetworkInterfacePublicIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureNetworkNetworkInterfacePublicIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureNetworkNetworkInterfacePublicIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 network_resource_group_name: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_resource_group_name", network_resource_group_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkResourceGroupName")
    def network_resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "network_resource_group_name")


@pulumi.output_type
class StatefulNodeAzureOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGb":
            suggest = "size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 caching: Optional[_builtins.str] = None,
                 size_gb: Optional[_builtins.int] = None):
        pulumi.set(__self__, "type", type)
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if size_gb is not None:
            pulumi.set(__self__, "size_gb", size_gb)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def caching(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "caching")

    @_builtins.property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "size_gb")


@pulumi.output_type
class StatefulNodeAzureProximityPlacementGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureProximityPlacementGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureProximityPlacementGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureProximityPlacementGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 resource_group_name: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class StatefulNodeAzureSchedulingTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureSchedulingTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureSchedulingTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureSchedulingTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression: _builtins.str,
                 is_enabled: _builtins.bool,
                 type: _builtins.str):
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> _builtins.str:
        return pulumi.get(self, "cron_expression")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class StatefulNodeAzureSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceVaults":
            suggest = "source_vaults"
        elif key == "vaultCertificates":
            suggest = "vault_certificates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_vaults: Sequence['outputs.StatefulNodeAzureSecretSourceVault'],
                 vault_certificates: Sequence['outputs.StatefulNodeAzureSecretVaultCertificate']):
        pulumi.set(__self__, "source_vaults", source_vaults)
        pulumi.set(__self__, "vault_certificates", vault_certificates)

    @_builtins.property
    @pulumi.getter(name="sourceVaults")
    def source_vaults(self) -> Sequence['outputs.StatefulNodeAzureSecretSourceVault']:
        return pulumi.get(self, "source_vaults")

    @_builtins.property
    @pulumi.getter(name="vaultCertificates")
    def vault_certificates(self) -> Sequence['outputs.StatefulNodeAzureSecretVaultCertificate']:
        return pulumi.get(self, "vault_certificates")


@pulumi.output_type
class StatefulNodeAzureSecretSourceVault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureSecretSourceVault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureSecretSourceVault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureSecretSourceVault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 resource_group_name: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class StatefulNodeAzureSecretVaultCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateStore":
            suggest = "certificate_store"
        elif key == "certificateUrl":
            suggest = "certificate_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureSecretVaultCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureSecretVaultCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureSecretVaultCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_store: Optional[_builtins.str] = None,
                 certificate_url: Optional[_builtins.str] = None):
        if certificate_store is not None:
            pulumi.set(__self__, "certificate_store", certificate_store)
        if certificate_url is not None:
            pulumi.set(__self__, "certificate_url", certificate_url)

    @_builtins.property
    @pulumi.getter(name="certificateStore")
    def certificate_store(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "certificate_store")

    @_builtins.property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "certificate_url")


@pulumi.output_type
class StatefulNodeAzureSecurity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confidentialOsDiskEncryption":
            suggest = "confidential_os_disk_encryption"
        elif key == "encryptionAtHost":
            suggest = "encryption_at_host"
        elif key == "secureBootEnabled":
            suggest = "secure_boot_enabled"
        elif key == "securityType":
            suggest = "security_type"
        elif key == "vtpmEnabled":
            suggest = "vtpm_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureSecurity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureSecurity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureSecurity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 confidential_os_disk_encryption: Optional[_builtins.str] = None,
                 encryption_at_host: Optional[_builtins.bool] = None,
                 secure_boot_enabled: Optional[_builtins.bool] = None,
                 security_type: Optional[_builtins.str] = None,
                 vtpm_enabled: Optional[_builtins.bool] = None):
        if confidential_os_disk_encryption is not None:
            pulumi.set(__self__, "confidential_os_disk_encryption", confidential_os_disk_encryption)
        if encryption_at_host is not None:
            pulumi.set(__self__, "encryption_at_host", encryption_at_host)
        if secure_boot_enabled is not None:
            pulumi.set(__self__, "secure_boot_enabled", secure_boot_enabled)
        if security_type is not None:
            pulumi.set(__self__, "security_type", security_type)
        if vtpm_enabled is not None:
            pulumi.set(__self__, "vtpm_enabled", vtpm_enabled)

    @_builtins.property
    @pulumi.getter(name="confidentialOsDiskEncryption")
    def confidential_os_disk_encryption(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "confidential_os_disk_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionAtHost")
    def encryption_at_host(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "encryption_at_host")

    @_builtins.property
    @pulumi.getter(name="secureBootEnabled")
    def secure_boot_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "secure_boot_enabled")

    @_builtins.property
    @pulumi.getter(name="securityType")
    def security_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "security_type")

    @_builtins.property
    @pulumi.getter(name="vtpmEnabled")
    def vtpm_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "vtpm_enabled")


@pulumi.output_type
class StatefulNodeAzureSignal(dict):
    def __init__(__self__, *,
                 timeout: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class StatefulNodeAzureStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackToOnDemand":
            suggest = "fallback_to_on_demand"
        elif key == "availabilityVsCost":
            suggest = "availability_vs_cost"
        elif key == "capacityReservations":
            suggest = "capacity_reservations"
        elif key == "drainingTimeout":
            suggest = "draining_timeout"
        elif key == "odWindows":
            suggest = "od_windows"
        elif key == "optimizationWindows":
            suggest = "optimization_windows"
        elif key == "preferredLifeCycle":
            suggest = "preferred_life_cycle"
        elif key == "revertToSpot":
            suggest = "revert_to_spot"
        elif key == "vmAdmins":
            suggest = "vm_admins"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_to_on_demand: _builtins.bool,
                 availability_vs_cost: Optional[_builtins.int] = None,
                 capacity_reservations: Optional[Sequence['outputs.StatefulNodeAzureStrategyCapacityReservation']] = None,
                 draining_timeout: Optional[_builtins.int] = None,
                 od_windows: Optional[Sequence[_builtins.str]] = None,
                 optimization_windows: Optional[Sequence[_builtins.str]] = None,
                 preferred_life_cycle: Optional[_builtins.str] = None,
                 revert_to_spot: Optional['outputs.StatefulNodeAzureStrategyRevertToSpot'] = None,
                 vm_admins: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "fallback_to_on_demand", fallback_to_on_demand)
        if availability_vs_cost is not None:
            pulumi.set(__self__, "availability_vs_cost", availability_vs_cost)
        if capacity_reservations is not None:
            pulumi.set(__self__, "capacity_reservations", capacity_reservations)
        if draining_timeout is not None:
            pulumi.set(__self__, "draining_timeout", draining_timeout)
        if od_windows is not None:
            pulumi.set(__self__, "od_windows", od_windows)
        if optimization_windows is not None:
            pulumi.set(__self__, "optimization_windows", optimization_windows)
        if preferred_life_cycle is not None:
            pulumi.set(__self__, "preferred_life_cycle", preferred_life_cycle)
        if revert_to_spot is not None:
            pulumi.set(__self__, "revert_to_spot", revert_to_spot)
        if vm_admins is not None:
            pulumi.set(__self__, "vm_admins", vm_admins)

    @_builtins.property
    @pulumi.getter(name="fallbackToOnDemand")
    def fallback_to_on_demand(self) -> _builtins.bool:
        return pulumi.get(self, "fallback_to_on_demand")

    @_builtins.property
    @pulumi.getter(name="availabilityVsCost")
    def availability_vs_cost(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "availability_vs_cost")

    @_builtins.property
    @pulumi.getter(name="capacityReservations")
    def capacity_reservations(self) -> Optional[Sequence['outputs.StatefulNodeAzureStrategyCapacityReservation']]:
        return pulumi.get(self, "capacity_reservations")

    @_builtins.property
    @pulumi.getter(name="drainingTimeout")
    def draining_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "draining_timeout")

    @_builtins.property
    @pulumi.getter(name="odWindows")
    def od_windows(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "od_windows")

    @_builtins.property
    @pulumi.getter(name="optimizationWindows")
    def optimization_windows(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "optimization_windows")

    @_builtins.property
    @pulumi.getter(name="preferredLifeCycle")
    def preferred_life_cycle(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "preferred_life_cycle")

    @_builtins.property
    @pulumi.getter(name="revertToSpot")
    def revert_to_spot(self) -> Optional['outputs.StatefulNodeAzureStrategyRevertToSpot']:
        return pulumi.get(self, "revert_to_spot")

    @_builtins.property
    @pulumi.getter(name="vmAdmins")
    def vm_admins(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "vm_admins")


@pulumi.output_type
class StatefulNodeAzureStrategyCapacityReservation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shouldUtilize":
            suggest = "should_utilize"
        elif key == "utilizationStrategy":
            suggest = "utilization_strategy"
        elif key == "capacityReservationGroups":
            suggest = "capacity_reservation_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureStrategyCapacityReservation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureStrategyCapacityReservation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureStrategyCapacityReservation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 should_utilize: _builtins.bool,
                 utilization_strategy: _builtins.str,
                 capacity_reservation_groups: Optional[Sequence['outputs.StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup']] = None):
        pulumi.set(__self__, "should_utilize", should_utilize)
        pulumi.set(__self__, "utilization_strategy", utilization_strategy)
        if capacity_reservation_groups is not None:
            pulumi.set(__self__, "capacity_reservation_groups", capacity_reservation_groups)

    @_builtins.property
    @pulumi.getter(name="shouldUtilize")
    def should_utilize(self) -> _builtins.bool:
        return pulumi.get(self, "should_utilize")

    @_builtins.property
    @pulumi.getter(name="utilizationStrategy")
    def utilization_strategy(self) -> _builtins.str:
        return pulumi.get(self, "utilization_strategy")

    @_builtins.property
    @pulumi.getter(name="capacityReservationGroups")
    def capacity_reservation_groups(self) -> Optional[Sequence['outputs.StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup']]:
        return pulumi.get(self, "capacity_reservation_groups")


@pulumi.output_type
class StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crgName":
            suggest = "crg_name"
        elif key == "crgResourceGroupName":
            suggest = "crg_resource_group_name"
        elif key == "crgShouldPrioritize":
            suggest = "crg_should_prioritize"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crg_name: _builtins.str,
                 crg_resource_group_name: _builtins.str,
                 crg_should_prioritize: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "crg_name", crg_name)
        pulumi.set(__self__, "crg_resource_group_name", crg_resource_group_name)
        if crg_should_prioritize is not None:
            pulumi.set(__self__, "crg_should_prioritize", crg_should_prioritize)

    @_builtins.property
    @pulumi.getter(name="crgName")
    def crg_name(self) -> _builtins.str:
        return pulumi.get(self, "crg_name")

    @_builtins.property
    @pulumi.getter(name="crgResourceGroupName")
    def crg_resource_group_name(self) -> _builtins.str:
        return pulumi.get(self, "crg_resource_group_name")

    @_builtins.property
    @pulumi.getter(name="crgShouldPrioritize")
    def crg_should_prioritize(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "crg_should_prioritize")


@pulumi.output_type
class StatefulNodeAzureStrategyRevertToSpot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "performAt":
            suggest = "perform_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureStrategyRevertToSpot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureStrategyRevertToSpot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureStrategyRevertToSpot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 perform_at: _builtins.str):
        pulumi.set(__self__, "perform_at", perform_at)

    @_builtins.property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> _builtins.str:
        return pulumi.get(self, "perform_at")


@pulumi.output_type
class StatefulNodeAzureTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"
        elif key == "tagValue":
            suggest = "tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_key: _builtins.str,
                 tag_value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @_builtins.property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> _builtins.str:
        return pulumi.get(self, "tag_key")

    @_builtins.property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tag_value")


@pulumi.output_type
class StatefulNodeAzureUpdateState(dict):
    def __init__(__self__, *,
                 state: _builtins.str):
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")


@pulumi.output_type
class StatefulNodeAzureVmSizes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "odSizes":
            suggest = "od_sizes"
        elif key == "excludedVmSizes":
            suggest = "excluded_vm_sizes"
        elif key == "preferredSpotSizes":
            suggest = "preferred_spot_sizes"
        elif key == "spotSizeAttributes":
            suggest = "spot_size_attributes"
        elif key == "spotSizes":
            suggest = "spot_sizes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureVmSizes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureVmSizes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureVmSizes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 od_sizes: Sequence[_builtins.str],
                 excluded_vm_sizes: Optional[Sequence[_builtins.str]] = None,
                 preferred_spot_sizes: Optional[Sequence[_builtins.str]] = None,
                 spot_size_attributes: Optional['outputs.StatefulNodeAzureVmSizesSpotSizeAttributes'] = None,
                 spot_sizes: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "od_sizes", od_sizes)
        if excluded_vm_sizes is not None:
            pulumi.set(__self__, "excluded_vm_sizes", excluded_vm_sizes)
        if preferred_spot_sizes is not None:
            pulumi.set(__self__, "preferred_spot_sizes", preferred_spot_sizes)
        if spot_size_attributes is not None:
            pulumi.set(__self__, "spot_size_attributes", spot_size_attributes)
        if spot_sizes is not None:
            pulumi.set(__self__, "spot_sizes", spot_sizes)

    @_builtins.property
    @pulumi.getter(name="odSizes")
    def od_sizes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "od_sizes")

    @_builtins.property
    @pulumi.getter(name="excludedVmSizes")
    def excluded_vm_sizes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "excluded_vm_sizes")

    @_builtins.property
    @pulumi.getter(name="preferredSpotSizes")
    def preferred_spot_sizes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "preferred_spot_sizes")

    @_builtins.property
    @pulumi.getter(name="spotSizeAttributes")
    def spot_size_attributes(self) -> Optional['outputs.StatefulNodeAzureVmSizesSpotSizeAttributes']:
        return pulumi.get(self, "spot_size_attributes")

    @_builtins.property
    @pulumi.getter(name="spotSizes")
    def spot_sizes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "spot_sizes")


@pulumi.output_type
class StatefulNodeAzureVmSizesSpotSizeAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCpu":
            suggest = "max_cpu"
        elif key == "maxMemory":
            suggest = "max_memory"
        elif key == "maxStorage":
            suggest = "max_storage"
        elif key == "minCpu":
            suggest = "min_cpu"
        elif key == "minMemory":
            suggest = "min_memory"
        elif key == "minStorage":
            suggest = "min_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureVmSizesSpotSizeAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureVmSizesSpotSizeAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureVmSizesSpotSizeAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_cpu: Optional[_builtins.int] = None,
                 max_memory: Optional[_builtins.int] = None,
                 max_storage: Optional[_builtins.int] = None,
                 min_cpu: Optional[_builtins.int] = None,
                 min_memory: Optional[_builtins.int] = None,
                 min_storage: Optional[_builtins.int] = None):
        if max_cpu is not None:
            pulumi.set(__self__, "max_cpu", max_cpu)
        if max_memory is not None:
            pulumi.set(__self__, "max_memory", max_memory)
        if max_storage is not None:
            pulumi.set(__self__, "max_storage", max_storage)
        if min_cpu is not None:
            pulumi.set(__self__, "min_cpu", min_cpu)
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)
        if min_storage is not None:
            pulumi.set(__self__, "min_storage", min_storage)

    @_builtins.property
    @pulumi.getter(name="maxCpu")
    def max_cpu(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_cpu")

    @_builtins.property
    @pulumi.getter(name="maxMemory")
    def max_memory(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_memory")

    @_builtins.property
    @pulumi.getter(name="maxStorage")
    def max_storage(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_storage")

    @_builtins.property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_cpu")

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_memory")

    @_builtins.property
    @pulumi.getter(name="minStorage")
    def min_storage(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_storage")


