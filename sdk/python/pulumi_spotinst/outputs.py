# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'DataIntegrationS3',
    'ElastigroupAzureV3Image',
    'ElastigroupAzureV3ImageCustom',
    'ElastigroupAzureV3ImageMarketplace',
    'ElastigroupAzureV3Login',
    'ElastigroupAzureV3ManagedServiceIdentity',
    'ElastigroupAzureV3Network',
    'ElastigroupAzureV3NetworkNetworkInterface',
    'ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig',
    'ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup',
    'ElastigroupAzureV3Tag',
    'HealthCheckCheck',
    'StatefulNodeAzureAttachDataDisk',
    'StatefulNodeAzureBootDiagnostic',
    'StatefulNodeAzureDataDisk',
    'StatefulNodeAzureDelete',
    'StatefulNodeAzureDetachDataDisk',
    'StatefulNodeAzureExtension',
    'StatefulNodeAzureHealth',
    'StatefulNodeAzureImage',
    'StatefulNodeAzureImageCustomImage',
    'StatefulNodeAzureImageGallery',
    'StatefulNodeAzureImageMarketplaceImage',
    'StatefulNodeAzureImportVm',
    'StatefulNodeAzureLoadBalancer',
    'StatefulNodeAzureLogin',
    'StatefulNodeAzureManagedServiceIdentity',
    'StatefulNodeAzureNetwork',
    'StatefulNodeAzureNetworkNetworkInterface',
    'StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration',
    'StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup',
    'StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup',
    'StatefulNodeAzureNetworkNetworkInterfacePublicIp',
    'StatefulNodeAzureOsDisk',
    'StatefulNodeAzureSchedulingTask',
    'StatefulNodeAzureSecret',
    'StatefulNodeAzureSecretSourceVault',
    'StatefulNodeAzureSecretVaultCertificate',
    'StatefulNodeAzureSecurity',
    'StatefulNodeAzureSignal',
    'StatefulNodeAzureStrategy',
    'StatefulNodeAzureStrategyCapacityReservation',
    'StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup',
    'StatefulNodeAzureStrategyRevertToSpot',
    'StatefulNodeAzureTag',
    'StatefulNodeAzureUpdateState',
]

@pulumi.output_type
class DataIntegrationS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataIntegrationS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataIntegrationS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataIntegrationS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 subdir: Optional[str] = None):
        """
        :param str subdir: The subdirectory in which your files will be stored within the bucket. Adds the prefix subdir/ to new objects' keys. Can't be null or contain '/'.
        """
        DataIntegrationS3._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            subdir=subdir,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: str,
             subdir: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']

        _setter("bucket_name", bucket_name)
        if subdir is not None:
            _setter("subdir", subdir)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter
    def subdir(self) -> Optional[str]:
        """
        The subdirectory in which your files will be stored within the bucket. Adds the prefix subdir/ to new objects' keys. Can't be null or contain '/'.
        """
        return pulumi.get(self, "subdir")


@pulumi.output_type
class ElastigroupAzureV3Image(dict):
    def __init__(__self__, *,
                 customs: Optional[Sequence['outputs.ElastigroupAzureV3ImageCustom']] = None,
                 marketplaces: Optional[Sequence['outputs.ElastigroupAzureV3ImageMarketplace']] = None):
        ElastigroupAzureV3Image._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            customs=customs,
            marketplaces=marketplaces,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             customs: Optional[Sequence['outputs.ElastigroupAzureV3ImageCustom']] = None,
             marketplaces: Optional[Sequence['outputs.ElastigroupAzureV3ImageMarketplace']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if customs is not None:
            _setter("customs", customs)
        if marketplaces is not None:
            _setter("marketplaces", marketplaces)

    @property
    @pulumi.getter
    def customs(self) -> Optional[Sequence['outputs.ElastigroupAzureV3ImageCustom']]:
        return pulumi.get(self, "customs")

    @property
    @pulumi.getter
    def marketplaces(self) -> Optional[Sequence['outputs.ElastigroupAzureV3ImageMarketplace']]:
        return pulumi.get(self, "marketplaces")


@pulumi.output_type
class ElastigroupAzureV3ImageCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageName":
            suggest = "image_name"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3ImageCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3ImageCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3ImageCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_name: str,
                 resource_group_name: str):
        ElastigroupAzureV3ImageCustom._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            image_name=image_name,
            resource_group_name=resource_group_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             image_name: str,
             resource_group_name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'imageName' in kwargs:
            image_name = kwargs['imageName']
        if 'resourceGroupName' in kwargs:
            resource_group_name = kwargs['resourceGroupName']

        _setter("image_name", image_name)
        _setter("resource_group_name", resource_group_name)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class ElastigroupAzureV3ImageMarketplace(dict):
    def __init__(__self__, *,
                 offer: str,
                 publisher: str,
                 sku: str,
                 version: str):
        ElastigroupAzureV3ImageMarketplace._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            offer=offer,
            publisher=publisher,
            sku=sku,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             offer: str,
             publisher: str,
             sku: str,
             version: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("offer", offer)
        _setter("publisher", publisher)
        _setter("sku", sku)
        _setter("version", version)

    @property
    @pulumi.getter
    def offer(self) -> str:
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> str:
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class ElastigroupAzureV3Login(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userName":
            suggest = "user_name"
        elif key == "sshPublicKey":
            suggest = "ssh_public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3Login. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3Login.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3Login.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_name: str,
                 password: Optional[str] = None,
                 ssh_public_key: Optional[str] = None):
        ElastigroupAzureV3Login._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            user_name=user_name,
            password=password,
            ssh_public_key=ssh_public_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             user_name: str,
             password: Optional[str] = None,
             ssh_public_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'userName' in kwargs:
            user_name = kwargs['userName']
        if 'sshPublicKey' in kwargs:
            ssh_public_key = kwargs['sshPublicKey']

        _setter("user_name", user_name)
        if password is not None:
            _setter("password", password)
        if ssh_public_key is not None:
            _setter("ssh_public_key", ssh_public_key)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="sshPublicKey")
    def ssh_public_key(self) -> Optional[str]:
        return pulumi.get(self, "ssh_public_key")


@pulumi.output_type
class ElastigroupAzureV3ManagedServiceIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3ManagedServiceIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3ManagedServiceIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3ManagedServiceIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 resource_group_name: str):
        ElastigroupAzureV3ManagedServiceIdentity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            resource_group_name=resource_group_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             resource_group_name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'resourceGroupName' in kwargs:
            resource_group_name = kwargs['resourceGroupName']

        _setter("name", name)
        _setter("resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class ElastigroupAzureV3Network(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "virtualNetworkName":
            suggest = "virtual_network_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3Network. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3Network.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3Network.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_interfaces: Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterface'],
                 resource_group_name: str,
                 virtual_network_name: str):
        ElastigroupAzureV3Network._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_interfaces=network_interfaces,
            resource_group_name=resource_group_name,
            virtual_network_name=virtual_network_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_interfaces: Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterface'],
             resource_group_name: str,
             virtual_network_name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'networkInterfaces' in kwargs:
            network_interfaces = kwargs['networkInterfaces']
        if 'resourceGroupName' in kwargs:
            resource_group_name = kwargs['resourceGroupName']
        if 'virtualNetworkName' in kwargs:
            virtual_network_name = kwargs['virtualNetworkName']

        _setter("network_interfaces", network_interfaces)
        _setter("resource_group_name", resource_group_name)
        _setter("virtual_network_name", virtual_network_name)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterface']:
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="virtualNetworkName")
    def virtual_network_name(self) -> str:
        return pulumi.get(self, "virtual_network_name")


@pulumi.output_type
class ElastigroupAzureV3NetworkNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "isPrimary":
            suggest = "is_primary"
        elif key == "subnetName":
            suggest = "subnet_name"
        elif key == "additionalIpConfigs":
            suggest = "additional_ip_configs"
        elif key == "applicationSecurityGroups":
            suggest = "application_security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3NetworkNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3NetworkNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3NetworkNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assign_public_ip: bool,
                 is_primary: bool,
                 subnet_name: str,
                 additional_ip_configs: Optional[Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig']] = None,
                 application_security_groups: Optional[Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup']] = None):
        ElastigroupAzureV3NetworkNetworkInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assign_public_ip=assign_public_ip,
            is_primary=is_primary,
            subnet_name=subnet_name,
            additional_ip_configs=additional_ip_configs,
            application_security_groups=application_security_groups,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assign_public_ip: bool,
             is_primary: bool,
             subnet_name: str,
             additional_ip_configs: Optional[Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig']] = None,
             application_security_groups: Optional[Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'assignPublicIp' in kwargs:
            assign_public_ip = kwargs['assignPublicIp']
        if 'isPrimary' in kwargs:
            is_primary = kwargs['isPrimary']
        if 'subnetName' in kwargs:
            subnet_name = kwargs['subnetName']
        if 'additionalIpConfigs' in kwargs:
            additional_ip_configs = kwargs['additionalIpConfigs']
        if 'applicationSecurityGroups' in kwargs:
            application_security_groups = kwargs['applicationSecurityGroups']

        _setter("assign_public_ip", assign_public_ip)
        _setter("is_primary", is_primary)
        _setter("subnet_name", subnet_name)
        if additional_ip_configs is not None:
            _setter("additional_ip_configs", additional_ip_configs)
        if application_security_groups is not None:
            _setter("application_security_groups", application_security_groups)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> bool:
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> bool:
        return pulumi.get(self, "is_primary")

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> str:
        return pulumi.get(self, "subnet_name")

    @property
    @pulumi.getter(name="additionalIpConfigs")
    def additional_ip_configs(self) -> Optional[Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig']]:
        return pulumi.get(self, "additional_ip_configs")

    @property
    @pulumi.getter(name="applicationSecurityGroups")
    def application_security_groups(self) -> Optional[Sequence['outputs.ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup']]:
        return pulumi.get(self, "application_security_groups")


@pulumi.output_type
class ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpVersion":
            suggest = "private_ip_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 private_ip_version: Optional[str] = None):
        ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            private_ip_version=private_ip_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             private_ip_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateIpVersion' in kwargs:
            private_ip_version = kwargs['privateIpVersion']

        _setter("name", name)
        if private_ip_version is not None:
            _setter("private_ip_version", private_ip_version)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpVersion")
    def private_ip_version(self) -> Optional[str]:
        return pulumi.get(self, "private_ip_version")


@pulumi.output_type
class ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 resource_group_name: str):
        ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            resource_group_name=resource_group_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             resource_group_name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'resourceGroupName' in kwargs:
            resource_group_name = kwargs['resourceGroupName']

        _setter("name", name)
        _setter("resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class ElastigroupAzureV3Tag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        ElastigroupAzureV3Tag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class HealthCheckCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endPoint":
            suggest = "end_point"
        elif key == "timeOut":
            suggest = "time_out"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HealthCheckCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HealthCheckCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HealthCheckCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 healthy: int,
                 interval: int,
                 port: int,
                 protocol: str,
                 unhealthy: int,
                 end_point: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 time_out: Optional[int] = None,
                 timeout: Optional[int] = None):
        """
        :param int healthy: The number of consecutive successful health checks that must occur before declaring an instance healthy.
        :param int interval: The amount of time (in seconds) between each health check (minimum: 10).
        :param int port: The port of the Spotinst HCS (default: 80).
        :param str protocol: The protocol to use to connect with the instance. Valid values: http, https.
        :param int unhealthy: The number of consecutive failed health checks that must occur before declaring an instance unhealthy.
        :param str endpoint: The destination for the request.
        :param int timeout: the amount of time (in seconds) to wait when receiving a response from the health check.
        """
        HealthCheckCheck._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            healthy=healthy,
            interval=interval,
            port=port,
            protocol=protocol,
            unhealthy=unhealthy,
            end_point=end_point,
            endpoint=endpoint,
            time_out=time_out,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             healthy: int,
             interval: int,
             port: int,
             protocol: str,
             unhealthy: int,
             end_point: Optional[str] = None,
             endpoint: Optional[str] = None,
             time_out: Optional[int] = None,
             timeout: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'endPoint' in kwargs:
            end_point = kwargs['endPoint']
        if 'timeOut' in kwargs:
            time_out = kwargs['timeOut']

        _setter("healthy", healthy)
        _setter("interval", interval)
        _setter("port", port)
        _setter("protocol", protocol)
        _setter("unhealthy", unhealthy)
        if end_point is not None:
            _setter("end_point", end_point)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if time_out is not None:
            _setter("time_out", time_out)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter
    def healthy(self) -> int:
        """
        The number of consecutive successful health checks that must occur before declaring an instance healthy.
        """
        return pulumi.get(self, "healthy")

    @property
    @pulumi.getter
    def interval(self) -> int:
        """
        The amount of time (in seconds) between each health check (minimum: 10).
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port of the Spotinst HCS (default: 80).
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol to use to connect with the instance. Valid values: http, https.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def unhealthy(self) -> int:
        """
        The number of consecutive failed health checks that must occur before declaring an instance unhealthy.
        """
        return pulumi.get(self, "unhealthy")

    @property
    @pulumi.getter(name="endPoint")
    def end_point(self) -> Optional[str]:
        return pulumi.get(self, "end_point")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        The destination for the request.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="timeOut")
    def time_out(self) -> Optional[int]:
        return pulumi.get(self, "time_out")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        the amount of time (in seconds) to wait when receiving a response from the health check.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class StatefulNodeAzureAttachDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDiskName":
            suggest = "data_disk_name"
        elif key == "dataDiskResourceGroupName":
            suggest = "data_disk_resource_group_name"
        elif key == "sizeGb":
            suggest = "size_gb"
        elif key == "storageAccountType":
            suggest = "storage_account_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureAttachDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureAttachDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureAttachDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_disk_name: str,
                 data_disk_resource_group_name: str,
                 size_gb: int,
                 storage_account_type: str,
                 lun: Optional[int] = None,
                 zone: Optional[str] = None):
        StatefulNodeAzureAttachDataDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_disk_name=data_disk_name,
            data_disk_resource_group_name=data_disk_resource_group_name,
            size_gb=size_gb,
            storage_account_type=storage_account_type,
            lun=lun,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_disk_name: str,
             data_disk_resource_group_name: str,
             size_gb: int,
             storage_account_type: str,
             lun: Optional[int] = None,
             zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dataDiskName' in kwargs:
            data_disk_name = kwargs['dataDiskName']
        if 'dataDiskResourceGroupName' in kwargs:
            data_disk_resource_group_name = kwargs['dataDiskResourceGroupName']
        if 'sizeGb' in kwargs:
            size_gb = kwargs['sizeGb']
        if 'storageAccountType' in kwargs:
            storage_account_type = kwargs['storageAccountType']

        _setter("data_disk_name", data_disk_name)
        _setter("data_disk_resource_group_name", data_disk_resource_group_name)
        _setter("size_gb", size_gb)
        _setter("storage_account_type", storage_account_type)
        if lun is not None:
            _setter("lun", lun)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="dataDiskName")
    def data_disk_name(self) -> str:
        return pulumi.get(self, "data_disk_name")

    @property
    @pulumi.getter(name="dataDiskResourceGroupName")
    def data_disk_resource_group_name(self) -> str:
        return pulumi.get(self, "data_disk_resource_group_name")

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> int:
        return pulumi.get(self, "size_gb")

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> str:
        return pulumi.get(self, "storage_account_type")

    @property
    @pulumi.getter
    def lun(self) -> Optional[int]:
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        return pulumi.get(self, "zone")


@pulumi.output_type
class StatefulNodeAzureBootDiagnostic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "storageUrl":
            suggest = "storage_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureBootDiagnostic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureBootDiagnostic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureBootDiagnostic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: Optional[bool] = None,
                 storage_url: Optional[str] = None,
                 type: Optional[str] = None):
        StatefulNodeAzureBootDiagnostic._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_enabled=is_enabled,
            storage_url=storage_url,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_enabled: Optional[bool] = None,
             storage_url: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if 'storageUrl' in kwargs:
            storage_url = kwargs['storageUrl']

        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if storage_url is not None:
            _setter("storage_url", storage_url)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="storageUrl")
    def storage_url(self) -> Optional[str]:
        return pulumi.get(self, "storage_url")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class StatefulNodeAzureDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGb":
            suggest = "size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lun: int,
                 size_gb: int,
                 type: str):
        StatefulNodeAzureDataDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lun=lun,
            size_gb=size_gb,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lun: int,
             size_gb: int,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'sizeGb' in kwargs:
            size_gb = kwargs['sizeGb']

        _setter("lun", lun)
        _setter("size_gb", size_gb)
        _setter("type", type)

    @property
    @pulumi.getter
    def lun(self) -> int:
        return pulumi.get(self, "lun")

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> int:
        return pulumi.get(self, "size_gb")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class StatefulNodeAzureDelete(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskShouldDeallocate":
            suggest = "disk_should_deallocate"
        elif key == "networkShouldDeallocate":
            suggest = "network_should_deallocate"
        elif key == "publicIpShouldDeallocate":
            suggest = "public_ip_should_deallocate"
        elif key == "shouldTerminateVm":
            suggest = "should_terminate_vm"
        elif key == "snapshotShouldDeallocate":
            suggest = "snapshot_should_deallocate"
        elif key == "diskTtlInHours":
            suggest = "disk_ttl_in_hours"
        elif key == "networkTtlInHours":
            suggest = "network_ttl_in_hours"
        elif key == "publicIpTtlInHours":
            suggest = "public_ip_ttl_in_hours"
        elif key == "snapshotTtlInHours":
            suggest = "snapshot_ttl_in_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureDelete. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureDelete.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureDelete.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_should_deallocate: bool,
                 network_should_deallocate: bool,
                 public_ip_should_deallocate: bool,
                 should_terminate_vm: bool,
                 snapshot_should_deallocate: bool,
                 disk_ttl_in_hours: Optional[int] = None,
                 network_ttl_in_hours: Optional[int] = None,
                 public_ip_ttl_in_hours: Optional[int] = None,
                 snapshot_ttl_in_hours: Optional[int] = None):
        StatefulNodeAzureDelete._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disk_should_deallocate=disk_should_deallocate,
            network_should_deallocate=network_should_deallocate,
            public_ip_should_deallocate=public_ip_should_deallocate,
            should_terminate_vm=should_terminate_vm,
            snapshot_should_deallocate=snapshot_should_deallocate,
            disk_ttl_in_hours=disk_ttl_in_hours,
            network_ttl_in_hours=network_ttl_in_hours,
            public_ip_ttl_in_hours=public_ip_ttl_in_hours,
            snapshot_ttl_in_hours=snapshot_ttl_in_hours,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disk_should_deallocate: bool,
             network_should_deallocate: bool,
             public_ip_should_deallocate: bool,
             should_terminate_vm: bool,
             snapshot_should_deallocate: bool,
             disk_ttl_in_hours: Optional[int] = None,
             network_ttl_in_hours: Optional[int] = None,
             public_ip_ttl_in_hours: Optional[int] = None,
             snapshot_ttl_in_hours: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'diskShouldDeallocate' in kwargs:
            disk_should_deallocate = kwargs['diskShouldDeallocate']
        if 'networkShouldDeallocate' in kwargs:
            network_should_deallocate = kwargs['networkShouldDeallocate']
        if 'publicIpShouldDeallocate' in kwargs:
            public_ip_should_deallocate = kwargs['publicIpShouldDeallocate']
        if 'shouldTerminateVm' in kwargs:
            should_terminate_vm = kwargs['shouldTerminateVm']
        if 'snapshotShouldDeallocate' in kwargs:
            snapshot_should_deallocate = kwargs['snapshotShouldDeallocate']
        if 'diskTtlInHours' in kwargs:
            disk_ttl_in_hours = kwargs['diskTtlInHours']
        if 'networkTtlInHours' in kwargs:
            network_ttl_in_hours = kwargs['networkTtlInHours']
        if 'publicIpTtlInHours' in kwargs:
            public_ip_ttl_in_hours = kwargs['publicIpTtlInHours']
        if 'snapshotTtlInHours' in kwargs:
            snapshot_ttl_in_hours = kwargs['snapshotTtlInHours']

        _setter("disk_should_deallocate", disk_should_deallocate)
        _setter("network_should_deallocate", network_should_deallocate)
        _setter("public_ip_should_deallocate", public_ip_should_deallocate)
        _setter("should_terminate_vm", should_terminate_vm)
        _setter("snapshot_should_deallocate", snapshot_should_deallocate)
        if disk_ttl_in_hours is not None:
            _setter("disk_ttl_in_hours", disk_ttl_in_hours)
        if network_ttl_in_hours is not None:
            _setter("network_ttl_in_hours", network_ttl_in_hours)
        if public_ip_ttl_in_hours is not None:
            _setter("public_ip_ttl_in_hours", public_ip_ttl_in_hours)
        if snapshot_ttl_in_hours is not None:
            _setter("snapshot_ttl_in_hours", snapshot_ttl_in_hours)

    @property
    @pulumi.getter(name="diskShouldDeallocate")
    def disk_should_deallocate(self) -> bool:
        return pulumi.get(self, "disk_should_deallocate")

    @property
    @pulumi.getter(name="networkShouldDeallocate")
    def network_should_deallocate(self) -> bool:
        return pulumi.get(self, "network_should_deallocate")

    @property
    @pulumi.getter(name="publicIpShouldDeallocate")
    def public_ip_should_deallocate(self) -> bool:
        return pulumi.get(self, "public_ip_should_deallocate")

    @property
    @pulumi.getter(name="shouldTerminateVm")
    def should_terminate_vm(self) -> bool:
        return pulumi.get(self, "should_terminate_vm")

    @property
    @pulumi.getter(name="snapshotShouldDeallocate")
    def snapshot_should_deallocate(self) -> bool:
        return pulumi.get(self, "snapshot_should_deallocate")

    @property
    @pulumi.getter(name="diskTtlInHours")
    def disk_ttl_in_hours(self) -> Optional[int]:
        return pulumi.get(self, "disk_ttl_in_hours")

    @property
    @pulumi.getter(name="networkTtlInHours")
    def network_ttl_in_hours(self) -> Optional[int]:
        return pulumi.get(self, "network_ttl_in_hours")

    @property
    @pulumi.getter(name="publicIpTtlInHours")
    def public_ip_ttl_in_hours(self) -> Optional[int]:
        return pulumi.get(self, "public_ip_ttl_in_hours")

    @property
    @pulumi.getter(name="snapshotTtlInHours")
    def snapshot_ttl_in_hours(self) -> Optional[int]:
        return pulumi.get(self, "snapshot_ttl_in_hours")


@pulumi.output_type
class StatefulNodeAzureDetachDataDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDiskName":
            suggest = "data_disk_name"
        elif key == "dataDiskResourceGroupName":
            suggest = "data_disk_resource_group_name"
        elif key == "shouldDeallocate":
            suggest = "should_deallocate"
        elif key == "ttlInHours":
            suggest = "ttl_in_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureDetachDataDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureDetachDataDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureDetachDataDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_disk_name: str,
                 data_disk_resource_group_name: str,
                 should_deallocate: bool,
                 ttl_in_hours: Optional[int] = None):
        StatefulNodeAzureDetachDataDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_disk_name=data_disk_name,
            data_disk_resource_group_name=data_disk_resource_group_name,
            should_deallocate=should_deallocate,
            ttl_in_hours=ttl_in_hours,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_disk_name: str,
             data_disk_resource_group_name: str,
             should_deallocate: bool,
             ttl_in_hours: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dataDiskName' in kwargs:
            data_disk_name = kwargs['dataDiskName']
        if 'dataDiskResourceGroupName' in kwargs:
            data_disk_resource_group_name = kwargs['dataDiskResourceGroupName']
        if 'shouldDeallocate' in kwargs:
            should_deallocate = kwargs['shouldDeallocate']
        if 'ttlInHours' in kwargs:
            ttl_in_hours = kwargs['ttlInHours']

        _setter("data_disk_name", data_disk_name)
        _setter("data_disk_resource_group_name", data_disk_resource_group_name)
        _setter("should_deallocate", should_deallocate)
        if ttl_in_hours is not None:
            _setter("ttl_in_hours", ttl_in_hours)

    @property
    @pulumi.getter(name="dataDiskName")
    def data_disk_name(self) -> str:
        return pulumi.get(self, "data_disk_name")

    @property
    @pulumi.getter(name="dataDiskResourceGroupName")
    def data_disk_resource_group_name(self) -> str:
        return pulumi.get(self, "data_disk_resource_group_name")

    @property
    @pulumi.getter(name="shouldDeallocate")
    def should_deallocate(self) -> bool:
        return pulumi.get(self, "should_deallocate")

    @property
    @pulumi.getter(name="ttlInHours")
    def ttl_in_hours(self) -> Optional[int]:
        return pulumi.get(self, "ttl_in_hours")


@pulumi.output_type
class StatefulNodeAzureExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "minorVersionAutoUpgrade":
            suggest = "minor_version_auto_upgrade"
        elif key == "protectedSettings":
            suggest = "protected_settings"
        elif key == "publicSettings":
            suggest = "public_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: str,
                 minor_version_auto_upgrade: bool,
                 name: str,
                 publisher: str,
                 type: str,
                 protected_settings: Optional[Mapping[str, Any]] = None,
                 public_settings: Optional[Mapping[str, Any]] = None):
        StatefulNodeAzureExtension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_version=api_version,
            minor_version_auto_upgrade=minor_version_auto_upgrade,
            name=name,
            publisher=publisher,
            type=type,
            protected_settings=protected_settings,
            public_settings=public_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_version: str,
             minor_version_auto_upgrade: bool,
             name: str,
             publisher: str,
             type: str,
             protected_settings: Optional[Mapping[str, Any]] = None,
             public_settings: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'apiVersion' in kwargs:
            api_version = kwargs['apiVersion']
        if 'minorVersionAutoUpgrade' in kwargs:
            minor_version_auto_upgrade = kwargs['minorVersionAutoUpgrade']
        if 'protectedSettings' in kwargs:
            protected_settings = kwargs['protectedSettings']
        if 'publicSettings' in kwargs:
            public_settings = kwargs['publicSettings']

        _setter("api_version", api_version)
        _setter("minor_version_auto_upgrade", minor_version_auto_upgrade)
        _setter("name", name)
        _setter("publisher", publisher)
        _setter("type", type)
        if protected_settings is not None:
            _setter("protected_settings", protected_settings)
        if public_settings is not None:
            _setter("public_settings", public_settings)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> str:
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="minorVersionAutoUpgrade")
    def minor_version_auto_upgrade(self) -> bool:
        return pulumi.get(self, "minor_version_auto_upgrade")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "protected_settings")

    @property
    @pulumi.getter(name="publicSettings")
    def public_settings(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "public_settings")


@pulumi.output_type
class StatefulNodeAzureHealth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoHealing":
            suggest = "auto_healing"
        elif key == "healthCheckTypes":
            suggest = "health_check_types"
        elif key == "gracePeriod":
            suggest = "grace_period"
        elif key == "unhealthyDuration":
            suggest = "unhealthy_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureHealth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureHealth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureHealth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_healing: bool,
                 health_check_types: Sequence[str],
                 grace_period: Optional[int] = None,
                 unhealthy_duration: Optional[int] = None):
        StatefulNodeAzureHealth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_healing=auto_healing,
            health_check_types=health_check_types,
            grace_period=grace_period,
            unhealthy_duration=unhealthy_duration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_healing: bool,
             health_check_types: Sequence[str],
             grace_period: Optional[int] = None,
             unhealthy_duration: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'autoHealing' in kwargs:
            auto_healing = kwargs['autoHealing']
        if 'healthCheckTypes' in kwargs:
            health_check_types = kwargs['healthCheckTypes']
        if 'gracePeriod' in kwargs:
            grace_period = kwargs['gracePeriod']
        if 'unhealthyDuration' in kwargs:
            unhealthy_duration = kwargs['unhealthyDuration']

        _setter("auto_healing", auto_healing)
        _setter("health_check_types", health_check_types)
        if grace_period is not None:
            _setter("grace_period", grace_period)
        if unhealthy_duration is not None:
            _setter("unhealthy_duration", unhealthy_duration)

    @property
    @pulumi.getter(name="autoHealing")
    def auto_healing(self) -> bool:
        return pulumi.get(self, "auto_healing")

    @property
    @pulumi.getter(name="healthCheckTypes")
    def health_check_types(self) -> Sequence[str]:
        return pulumi.get(self, "health_check_types")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        return pulumi.get(self, "grace_period")

    @property
    @pulumi.getter(name="unhealthyDuration")
    def unhealthy_duration(self) -> Optional[int]:
        return pulumi.get(self, "unhealthy_duration")


@pulumi.output_type
class StatefulNodeAzureImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customImages":
            suggest = "custom_images"
        elif key == "marketplaceImages":
            suggest = "marketplace_images"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_images: Optional[Sequence['outputs.StatefulNodeAzureImageCustomImage']] = None,
                 galleries: Optional[Sequence['outputs.StatefulNodeAzureImageGallery']] = None,
                 marketplace_images: Optional[Sequence['outputs.StatefulNodeAzureImageMarketplaceImage']] = None):
        StatefulNodeAzureImage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_images=custom_images,
            galleries=galleries,
            marketplace_images=marketplace_images,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_images: Optional[Sequence['outputs.StatefulNodeAzureImageCustomImage']] = None,
             galleries: Optional[Sequence['outputs.StatefulNodeAzureImageGallery']] = None,
             marketplace_images: Optional[Sequence['outputs.StatefulNodeAzureImageMarketplaceImage']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customImages' in kwargs:
            custom_images = kwargs['customImages']
        if 'marketplaceImages' in kwargs:
            marketplace_images = kwargs['marketplaceImages']

        if custom_images is not None:
            _setter("custom_images", custom_images)
        if galleries is not None:
            _setter("galleries", galleries)
        if marketplace_images is not None:
            _setter("marketplace_images", marketplace_images)

    @property
    @pulumi.getter(name="customImages")
    def custom_images(self) -> Optional[Sequence['outputs.StatefulNodeAzureImageCustomImage']]:
        return pulumi.get(self, "custom_images")

    @property
    @pulumi.getter
    def galleries(self) -> Optional[Sequence['outputs.StatefulNodeAzureImageGallery']]:
        return pulumi.get(self, "galleries")

    @property
    @pulumi.getter(name="marketplaceImages")
    def marketplace_images(self) -> Optional[Sequence['outputs.StatefulNodeAzureImageMarketplaceImage']]:
        return pulumi.get(self, "marketplace_images")


@pulumi.output_type
class StatefulNodeAzureImageCustomImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customImageResourceGroupName":
            suggest = "custom_image_resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureImageCustomImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureImageCustomImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureImageCustomImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_image_resource_group_name: str,
                 name: str):
        StatefulNodeAzureImageCustomImage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_image_resource_group_name=custom_image_resource_group_name,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_image_resource_group_name: str,
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customImageResourceGroupName' in kwargs:
            custom_image_resource_group_name = kwargs['customImageResourceGroupName']

        _setter("custom_image_resource_group_name", custom_image_resource_group_name)
        _setter("name", name)

    @property
    @pulumi.getter(name="customImageResourceGroupName")
    def custom_image_resource_group_name(self) -> str:
        return pulumi.get(self, "custom_image_resource_group_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class StatefulNodeAzureImageGallery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "galleryName":
            suggest = "gallery_name"
        elif key == "galleryResourceGroupName":
            suggest = "gallery_resource_group_name"
        elif key == "imageName":
            suggest = "image_name"
        elif key == "versionName":
            suggest = "version_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureImageGallery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureImageGallery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureImageGallery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gallery_name: str,
                 gallery_resource_group_name: str,
                 image_name: str,
                 version_name: str):
        StatefulNodeAzureImageGallery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gallery_name=gallery_name,
            gallery_resource_group_name=gallery_resource_group_name,
            image_name=image_name,
            version_name=version_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gallery_name: str,
             gallery_resource_group_name: str,
             image_name: str,
             version_name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'galleryName' in kwargs:
            gallery_name = kwargs['galleryName']
        if 'galleryResourceGroupName' in kwargs:
            gallery_resource_group_name = kwargs['galleryResourceGroupName']
        if 'imageName' in kwargs:
            image_name = kwargs['imageName']
        if 'versionName' in kwargs:
            version_name = kwargs['versionName']

        _setter("gallery_name", gallery_name)
        _setter("gallery_resource_group_name", gallery_resource_group_name)
        _setter("image_name", image_name)
        _setter("version_name", version_name)

    @property
    @pulumi.getter(name="galleryName")
    def gallery_name(self) -> str:
        return pulumi.get(self, "gallery_name")

    @property
    @pulumi.getter(name="galleryResourceGroupName")
    def gallery_resource_group_name(self) -> str:
        return pulumi.get(self, "gallery_resource_group_name")

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="versionName")
    def version_name(self) -> str:
        return pulumi.get(self, "version_name")


@pulumi.output_type
class StatefulNodeAzureImageMarketplaceImage(dict):
    def __init__(__self__, *,
                 offer: str,
                 publisher: str,
                 sku: str,
                 version: str):
        StatefulNodeAzureImageMarketplaceImage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            offer=offer,
            publisher=publisher,
            sku=sku,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             offer: str,
             publisher: str,
             sku: str,
             version: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("offer", offer)
        _setter("publisher", publisher)
        _setter("sku", sku)
        _setter("version", version)

    @property
    @pulumi.getter
    def offer(self) -> str:
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> str:
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class StatefulNodeAzureImportVm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originalVmName":
            suggest = "original_vm_name"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "drainingTimeout":
            suggest = "draining_timeout"
        elif key == "resourcesRetentionTime":
            suggest = "resources_retention_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureImportVm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureImportVm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureImportVm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 original_vm_name: str,
                 resource_group_name: str,
                 draining_timeout: Optional[int] = None,
                 resources_retention_time: Optional[int] = None):
        StatefulNodeAzureImportVm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            original_vm_name=original_vm_name,
            resource_group_name=resource_group_name,
            draining_timeout=draining_timeout,
            resources_retention_time=resources_retention_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             original_vm_name: str,
             resource_group_name: str,
             draining_timeout: Optional[int] = None,
             resources_retention_time: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'originalVmName' in kwargs:
            original_vm_name = kwargs['originalVmName']
        if 'resourceGroupName' in kwargs:
            resource_group_name = kwargs['resourceGroupName']
        if 'drainingTimeout' in kwargs:
            draining_timeout = kwargs['drainingTimeout']
        if 'resourcesRetentionTime' in kwargs:
            resources_retention_time = kwargs['resourcesRetentionTime']

        _setter("original_vm_name", original_vm_name)
        _setter("resource_group_name", resource_group_name)
        if draining_timeout is not None:
            _setter("draining_timeout", draining_timeout)
        if resources_retention_time is not None:
            _setter("resources_retention_time", resources_retention_time)

    @property
    @pulumi.getter(name="originalVmName")
    def original_vm_name(self) -> str:
        return pulumi.get(self, "original_vm_name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="drainingTimeout")
    def draining_timeout(self) -> Optional[int]:
        return pulumi.get(self, "draining_timeout")

    @property
    @pulumi.getter(name="resourcesRetentionTime")
    def resources_retention_time(self) -> Optional[int]:
        return pulumi.get(self, "resources_retention_time")


@pulumi.output_type
class StatefulNodeAzureLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendPoolNames":
            suggest = "backend_pool_names"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_pool_names: Sequence[str],
                 name: str,
                 resource_group_name: str,
                 type: str,
                 sku: Optional[str] = None):
        StatefulNodeAzureLoadBalancer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_pool_names=backend_pool_names,
            name=name,
            resource_group_name=resource_group_name,
            type=type,
            sku=sku,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_pool_names: Sequence[str],
             name: str,
             resource_group_name: str,
             type: str,
             sku: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'backendPoolNames' in kwargs:
            backend_pool_names = kwargs['backendPoolNames']
        if 'resourceGroupName' in kwargs:
            resource_group_name = kwargs['resourceGroupName']

        _setter("backend_pool_names", backend_pool_names)
        _setter("name", name)
        _setter("resource_group_name", resource_group_name)
        _setter("type", type)
        if sku is not None:
            _setter("sku", sku)

    @property
    @pulumi.getter(name="backendPoolNames")
    def backend_pool_names(self) -> Sequence[str]:
        return pulumi.get(self, "backend_pool_names")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def sku(self) -> Optional[str]:
        return pulumi.get(self, "sku")


@pulumi.output_type
class StatefulNodeAzureLogin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userName":
            suggest = "user_name"
        elif key == "sshPublicKey":
            suggest = "ssh_public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureLogin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureLogin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureLogin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_name: str,
                 password: Optional[str] = None,
                 ssh_public_key: Optional[str] = None):
        StatefulNodeAzureLogin._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            user_name=user_name,
            password=password,
            ssh_public_key=ssh_public_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             user_name: str,
             password: Optional[str] = None,
             ssh_public_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'userName' in kwargs:
            user_name = kwargs['userName']
        if 'sshPublicKey' in kwargs:
            ssh_public_key = kwargs['sshPublicKey']

        _setter("user_name", user_name)
        if password is not None:
            _setter("password", password)
        if ssh_public_key is not None:
            _setter("ssh_public_key", ssh_public_key)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="sshPublicKey")
    def ssh_public_key(self) -> Optional[str]:
        return pulumi.get(self, "ssh_public_key")


@pulumi.output_type
class StatefulNodeAzureManagedServiceIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureManagedServiceIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureManagedServiceIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureManagedServiceIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 resource_group_name: str):
        StatefulNodeAzureManagedServiceIdentity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            resource_group_name=resource_group_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             resource_group_name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'resourceGroupName' in kwargs:
            resource_group_name = kwargs['resourceGroupName']

        _setter("name", name)
        _setter("resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class StatefulNodeAzureNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "networkResourceGroupName":
            suggest = "network_resource_group_name"
        elif key == "virtualNetworkName":
            suggest = "virtual_network_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_interfaces: Sequence['outputs.StatefulNodeAzureNetworkNetworkInterface'],
                 network_resource_group_name: str,
                 virtual_network_name: str):
        StatefulNodeAzureNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_interfaces=network_interfaces,
            network_resource_group_name=network_resource_group_name,
            virtual_network_name=virtual_network_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_interfaces: Sequence['outputs.StatefulNodeAzureNetworkNetworkInterface'],
             network_resource_group_name: str,
             virtual_network_name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'networkInterfaces' in kwargs:
            network_interfaces = kwargs['networkInterfaces']
        if 'networkResourceGroupName' in kwargs:
            network_resource_group_name = kwargs['networkResourceGroupName']
        if 'virtualNetworkName' in kwargs:
            virtual_network_name = kwargs['virtualNetworkName']

        _setter("network_interfaces", network_interfaces)
        _setter("network_resource_group_name", network_resource_group_name)
        _setter("virtual_network_name", virtual_network_name)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.StatefulNodeAzureNetworkNetworkInterface']:
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter(name="networkResourceGroupName")
    def network_resource_group_name(self) -> str:
        return pulumi.get(self, "network_resource_group_name")

    @property
    @pulumi.getter(name="virtualNetworkName")
    def virtual_network_name(self) -> str:
        return pulumi.get(self, "virtual_network_name")


@pulumi.output_type
class StatefulNodeAzureNetworkNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPrimary":
            suggest = "is_primary"
        elif key == "subnetName":
            suggest = "subnet_name"
        elif key == "additionalIpConfigurations":
            suggest = "additional_ip_configurations"
        elif key == "applicationSecurityGroups":
            suggest = "application_security_groups"
        elif key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "enableIpForwarding":
            suggest = "enable_ip_forwarding"
        elif key == "networkSecurityGroups":
            suggest = "network_security_groups"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"
        elif key == "publicIpSku":
            suggest = "public_ip_sku"
        elif key == "publicIps":
            suggest = "public_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureNetworkNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureNetworkNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureNetworkNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_primary: bool,
                 subnet_name: str,
                 additional_ip_configurations: Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration']] = None,
                 application_security_groups: Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup']] = None,
                 assign_public_ip: Optional[bool] = None,
                 enable_ip_forwarding: Optional[bool] = None,
                 network_security_groups: Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup']] = None,
                 private_ip_addresses: Optional[Sequence[str]] = None,
                 public_ip_sku: Optional[str] = None,
                 public_ips: Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfacePublicIp']] = None):
        StatefulNodeAzureNetworkNetworkInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_primary=is_primary,
            subnet_name=subnet_name,
            additional_ip_configurations=additional_ip_configurations,
            application_security_groups=application_security_groups,
            assign_public_ip=assign_public_ip,
            enable_ip_forwarding=enable_ip_forwarding,
            network_security_groups=network_security_groups,
            private_ip_addresses=private_ip_addresses,
            public_ip_sku=public_ip_sku,
            public_ips=public_ips,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_primary: bool,
             subnet_name: str,
             additional_ip_configurations: Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration']] = None,
             application_security_groups: Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup']] = None,
             assign_public_ip: Optional[bool] = None,
             enable_ip_forwarding: Optional[bool] = None,
             network_security_groups: Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup']] = None,
             private_ip_addresses: Optional[Sequence[str]] = None,
             public_ip_sku: Optional[str] = None,
             public_ips: Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfacePublicIp']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isPrimary' in kwargs:
            is_primary = kwargs['isPrimary']
        if 'subnetName' in kwargs:
            subnet_name = kwargs['subnetName']
        if 'additionalIpConfigurations' in kwargs:
            additional_ip_configurations = kwargs['additionalIpConfigurations']
        if 'applicationSecurityGroups' in kwargs:
            application_security_groups = kwargs['applicationSecurityGroups']
        if 'assignPublicIp' in kwargs:
            assign_public_ip = kwargs['assignPublicIp']
        if 'enableIpForwarding' in kwargs:
            enable_ip_forwarding = kwargs['enableIpForwarding']
        if 'networkSecurityGroups' in kwargs:
            network_security_groups = kwargs['networkSecurityGroups']
        if 'privateIpAddresses' in kwargs:
            private_ip_addresses = kwargs['privateIpAddresses']
        if 'publicIpSku' in kwargs:
            public_ip_sku = kwargs['publicIpSku']
        if 'publicIps' in kwargs:
            public_ips = kwargs['publicIps']

        _setter("is_primary", is_primary)
        _setter("subnet_name", subnet_name)
        if additional_ip_configurations is not None:
            _setter("additional_ip_configurations", additional_ip_configurations)
        if application_security_groups is not None:
            _setter("application_security_groups", application_security_groups)
        if assign_public_ip is not None:
            _setter("assign_public_ip", assign_public_ip)
        if enable_ip_forwarding is not None:
            _setter("enable_ip_forwarding", enable_ip_forwarding)
        if network_security_groups is not None:
            _setter("network_security_groups", network_security_groups)
        if private_ip_addresses is not None:
            _setter("private_ip_addresses", private_ip_addresses)
        if public_ip_sku is not None:
            _setter("public_ip_sku", public_ip_sku)
        if public_ips is not None:
            _setter("public_ips", public_ips)

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> bool:
        return pulumi.get(self, "is_primary")

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> str:
        return pulumi.get(self, "subnet_name")

    @property
    @pulumi.getter(name="additionalIpConfigurations")
    def additional_ip_configurations(self) -> Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration']]:
        return pulumi.get(self, "additional_ip_configurations")

    @property
    @pulumi.getter(name="applicationSecurityGroups")
    def application_security_groups(self) -> Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup']]:
        return pulumi.get(self, "application_security_groups")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter(name="enableIpForwarding")
    def enable_ip_forwarding(self) -> Optional[bool]:
        return pulumi.get(self, "enable_ip_forwarding")

    @property
    @pulumi.getter(name="networkSecurityGroups")
    def network_security_groups(self) -> Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup']]:
        return pulumi.get(self, "network_security_groups")

    @property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "private_ip_addresses")

    @property
    @pulumi.getter(name="publicIpSku")
    def public_ip_sku(self) -> Optional[str]:
        return pulumi.get(self, "public_ip_sku")

    @property
    @pulumi.getter(name="publicIps")
    def public_ips(self) -> Optional[Sequence['outputs.StatefulNodeAzureNetworkNetworkInterfacePublicIp']]:
        return pulumi.get(self, "public_ips")


@pulumi.output_type
class StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddressVersion":
            suggest = "private_ip_address_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 private_ip_address_version: str):
        StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            private_ip_address_version=private_ip_address_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             private_ip_address_version: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateIpAddressVersion' in kwargs:
            private_ip_address_version = kwargs['privateIpAddressVersion']

        _setter("name", name)
        _setter("private_ip_address_version", private_ip_address_version)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpAddressVersion")
    def private_ip_address_version(self) -> str:
        return pulumi.get(self, "private_ip_address_version")


@pulumi.output_type
class StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkResourceGroupName":
            suggest = "network_resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 network_resource_group_name: str):
        StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            network_resource_group_name=network_resource_group_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             network_resource_group_name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'networkResourceGroupName' in kwargs:
            network_resource_group_name = kwargs['networkResourceGroupName']

        _setter("name", name)
        _setter("network_resource_group_name", network_resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkResourceGroupName")
    def network_resource_group_name(self) -> str:
        return pulumi.get(self, "network_resource_group_name")


@pulumi.output_type
class StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkResourceGroupName":
            suggest = "network_resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 network_resource_group_name: Optional[str] = None):
        StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            network_resource_group_name=network_resource_group_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             network_resource_group_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'networkResourceGroupName' in kwargs:
            network_resource_group_name = kwargs['networkResourceGroupName']

        if name is not None:
            _setter("name", name)
        if network_resource_group_name is not None:
            _setter("network_resource_group_name", network_resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkResourceGroupName")
    def network_resource_group_name(self) -> Optional[str]:
        return pulumi.get(self, "network_resource_group_name")


@pulumi.output_type
class StatefulNodeAzureNetworkNetworkInterfacePublicIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkResourceGroupName":
            suggest = "network_resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureNetworkNetworkInterfacePublicIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureNetworkNetworkInterfacePublicIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureNetworkNetworkInterfacePublicIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 network_resource_group_name: str):
        StatefulNodeAzureNetworkNetworkInterfacePublicIp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            network_resource_group_name=network_resource_group_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             network_resource_group_name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'networkResourceGroupName' in kwargs:
            network_resource_group_name = kwargs['networkResourceGroupName']

        _setter("name", name)
        _setter("network_resource_group_name", network_resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkResourceGroupName")
    def network_resource_group_name(self) -> str:
        return pulumi.get(self, "network_resource_group_name")


@pulumi.output_type
class StatefulNodeAzureOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGb":
            suggest = "size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 size_gb: Optional[int] = None):
        StatefulNodeAzureOsDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            size_gb=size_gb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             size_gb: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'sizeGb' in kwargs:
            size_gb = kwargs['sizeGb']

        _setter("type", type)
        if size_gb is not None:
            _setter("size_gb", size_gb)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> Optional[int]:
        return pulumi.get(self, "size_gb")


@pulumi.output_type
class StatefulNodeAzureSchedulingTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureSchedulingTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureSchedulingTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureSchedulingTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression: str,
                 is_enabled: bool,
                 type: str):
        StatefulNodeAzureSchedulingTask._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cron_expression=cron_expression,
            is_enabled=is_enabled,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cron_expression: str,
             is_enabled: bool,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cronExpression' in kwargs:
            cron_expression = kwargs['cronExpression']
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']

        _setter("cron_expression", cron_expression)
        _setter("is_enabled", is_enabled)
        _setter("type", type)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> str:
        return pulumi.get(self, "cron_expression")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class StatefulNodeAzureSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceVaults":
            suggest = "source_vaults"
        elif key == "vaultCertificates":
            suggest = "vault_certificates"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_vaults: Sequence['outputs.StatefulNodeAzureSecretSourceVault'],
                 vault_certificates: Sequence['outputs.StatefulNodeAzureSecretVaultCertificate']):
        StatefulNodeAzureSecret._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_vaults=source_vaults,
            vault_certificates=vault_certificates,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_vaults: Sequence['outputs.StatefulNodeAzureSecretSourceVault'],
             vault_certificates: Sequence['outputs.StatefulNodeAzureSecretVaultCertificate'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'sourceVaults' in kwargs:
            source_vaults = kwargs['sourceVaults']
        if 'vaultCertificates' in kwargs:
            vault_certificates = kwargs['vaultCertificates']

        _setter("source_vaults", source_vaults)
        _setter("vault_certificates", vault_certificates)

    @property
    @pulumi.getter(name="sourceVaults")
    def source_vaults(self) -> Sequence['outputs.StatefulNodeAzureSecretSourceVault']:
        return pulumi.get(self, "source_vaults")

    @property
    @pulumi.getter(name="vaultCertificates")
    def vault_certificates(self) -> Sequence['outputs.StatefulNodeAzureSecretVaultCertificate']:
        return pulumi.get(self, "vault_certificates")


@pulumi.output_type
class StatefulNodeAzureSecretSourceVault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureSecretSourceVault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureSecretSourceVault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureSecretSourceVault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 resource_group_name: str):
        StatefulNodeAzureSecretSourceVault._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            resource_group_name=resource_group_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             resource_group_name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'resourceGroupName' in kwargs:
            resource_group_name = kwargs['resourceGroupName']

        _setter("name", name)
        _setter("resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class StatefulNodeAzureSecretVaultCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateStore":
            suggest = "certificate_store"
        elif key == "certificateUrl":
            suggest = "certificate_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureSecretVaultCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureSecretVaultCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureSecretVaultCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_store: Optional[str] = None,
                 certificate_url: Optional[str] = None):
        StatefulNodeAzureSecretVaultCertificate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_store=certificate_store,
            certificate_url=certificate_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_store: Optional[str] = None,
             certificate_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'certificateStore' in kwargs:
            certificate_store = kwargs['certificateStore']
        if 'certificateUrl' in kwargs:
            certificate_url = kwargs['certificateUrl']

        if certificate_store is not None:
            _setter("certificate_store", certificate_store)
        if certificate_url is not None:
            _setter("certificate_url", certificate_url)

    @property
    @pulumi.getter(name="certificateStore")
    def certificate_store(self) -> Optional[str]:
        return pulumi.get(self, "certificate_store")

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[str]:
        return pulumi.get(self, "certificate_url")


@pulumi.output_type
class StatefulNodeAzureSecurity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secureBootEnabled":
            suggest = "secure_boot_enabled"
        elif key == "securityType":
            suggest = "security_type"
        elif key == "vtpmEnabled":
            suggest = "vtpm_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureSecurity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureSecurity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureSecurity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secure_boot_enabled: Optional[bool] = None,
                 security_type: Optional[str] = None,
                 vtpm_enabled: Optional[bool] = None):
        StatefulNodeAzureSecurity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secure_boot_enabled=secure_boot_enabled,
            security_type=security_type,
            vtpm_enabled=vtpm_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secure_boot_enabled: Optional[bool] = None,
             security_type: Optional[str] = None,
             vtpm_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'secureBootEnabled' in kwargs:
            secure_boot_enabled = kwargs['secureBootEnabled']
        if 'securityType' in kwargs:
            security_type = kwargs['securityType']
        if 'vtpmEnabled' in kwargs:
            vtpm_enabled = kwargs['vtpmEnabled']

        if secure_boot_enabled is not None:
            _setter("secure_boot_enabled", secure_boot_enabled)
        if security_type is not None:
            _setter("security_type", security_type)
        if vtpm_enabled is not None:
            _setter("vtpm_enabled", vtpm_enabled)

    @property
    @pulumi.getter(name="secureBootEnabled")
    def secure_boot_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "secure_boot_enabled")

    @property
    @pulumi.getter(name="securityType")
    def security_type(self) -> Optional[str]:
        return pulumi.get(self, "security_type")

    @property
    @pulumi.getter(name="vtpmEnabled")
    def vtpm_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "vtpm_enabled")


@pulumi.output_type
class StatefulNodeAzureSignal(dict):
    def __init__(__self__, *,
                 timeout: int,
                 type: str):
        StatefulNodeAzureSignal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            timeout=timeout,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             timeout: int,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("timeout", timeout)
        _setter("type", type)

    @property
    @pulumi.getter
    def timeout(self) -> int:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class StatefulNodeAzureStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackToOnDemand":
            suggest = "fallback_to_on_demand"
        elif key == "capacityReservations":
            suggest = "capacity_reservations"
        elif key == "drainingTimeout":
            suggest = "draining_timeout"
        elif key == "optimizationWindows":
            suggest = "optimization_windows"
        elif key == "preferredLifeCycle":
            suggest = "preferred_life_cycle"
        elif key == "revertToSpot":
            suggest = "revert_to_spot"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_to_on_demand: bool,
                 capacity_reservations: Optional[Sequence['outputs.StatefulNodeAzureStrategyCapacityReservation']] = None,
                 draining_timeout: Optional[int] = None,
                 optimization_windows: Optional[Sequence[str]] = None,
                 preferred_life_cycle: Optional[str] = None,
                 revert_to_spot: Optional['outputs.StatefulNodeAzureStrategyRevertToSpot'] = None):
        StatefulNodeAzureStrategy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_to_on_demand=fallback_to_on_demand,
            capacity_reservations=capacity_reservations,
            draining_timeout=draining_timeout,
            optimization_windows=optimization_windows,
            preferred_life_cycle=preferred_life_cycle,
            revert_to_spot=revert_to_spot,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_to_on_demand: bool,
             capacity_reservations: Optional[Sequence['outputs.StatefulNodeAzureStrategyCapacityReservation']] = None,
             draining_timeout: Optional[int] = None,
             optimization_windows: Optional[Sequence[str]] = None,
             preferred_life_cycle: Optional[str] = None,
             revert_to_spot: Optional['outputs.StatefulNodeAzureStrategyRevertToSpot'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'fallbackToOnDemand' in kwargs:
            fallback_to_on_demand = kwargs['fallbackToOnDemand']
        if 'capacityReservations' in kwargs:
            capacity_reservations = kwargs['capacityReservations']
        if 'drainingTimeout' in kwargs:
            draining_timeout = kwargs['drainingTimeout']
        if 'optimizationWindows' in kwargs:
            optimization_windows = kwargs['optimizationWindows']
        if 'preferredLifeCycle' in kwargs:
            preferred_life_cycle = kwargs['preferredLifeCycle']
        if 'revertToSpot' in kwargs:
            revert_to_spot = kwargs['revertToSpot']

        _setter("fallback_to_on_demand", fallback_to_on_demand)
        if capacity_reservations is not None:
            _setter("capacity_reservations", capacity_reservations)
        if draining_timeout is not None:
            _setter("draining_timeout", draining_timeout)
        if optimization_windows is not None:
            _setter("optimization_windows", optimization_windows)
        if preferred_life_cycle is not None:
            _setter("preferred_life_cycle", preferred_life_cycle)
        if revert_to_spot is not None:
            _setter("revert_to_spot", revert_to_spot)

    @property
    @pulumi.getter(name="fallbackToOnDemand")
    def fallback_to_on_demand(self) -> bool:
        return pulumi.get(self, "fallback_to_on_demand")

    @property
    @pulumi.getter(name="capacityReservations")
    def capacity_reservations(self) -> Optional[Sequence['outputs.StatefulNodeAzureStrategyCapacityReservation']]:
        return pulumi.get(self, "capacity_reservations")

    @property
    @pulumi.getter(name="drainingTimeout")
    def draining_timeout(self) -> Optional[int]:
        return pulumi.get(self, "draining_timeout")

    @property
    @pulumi.getter(name="optimizationWindows")
    def optimization_windows(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "optimization_windows")

    @property
    @pulumi.getter(name="preferredLifeCycle")
    def preferred_life_cycle(self) -> Optional[str]:
        return pulumi.get(self, "preferred_life_cycle")

    @property
    @pulumi.getter(name="revertToSpot")
    def revert_to_spot(self) -> Optional['outputs.StatefulNodeAzureStrategyRevertToSpot']:
        return pulumi.get(self, "revert_to_spot")


@pulumi.output_type
class StatefulNodeAzureStrategyCapacityReservation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shouldUtilize":
            suggest = "should_utilize"
        elif key == "utilizationStrategy":
            suggest = "utilization_strategy"
        elif key == "capacityReservationGroups":
            suggest = "capacity_reservation_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureStrategyCapacityReservation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureStrategyCapacityReservation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureStrategyCapacityReservation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 should_utilize: bool,
                 utilization_strategy: str,
                 capacity_reservation_groups: Optional[Sequence['outputs.StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup']] = None):
        StatefulNodeAzureStrategyCapacityReservation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            should_utilize=should_utilize,
            utilization_strategy=utilization_strategy,
            capacity_reservation_groups=capacity_reservation_groups,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             should_utilize: bool,
             utilization_strategy: str,
             capacity_reservation_groups: Optional[Sequence['outputs.StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'shouldUtilize' in kwargs:
            should_utilize = kwargs['shouldUtilize']
        if 'utilizationStrategy' in kwargs:
            utilization_strategy = kwargs['utilizationStrategy']
        if 'capacityReservationGroups' in kwargs:
            capacity_reservation_groups = kwargs['capacityReservationGroups']

        _setter("should_utilize", should_utilize)
        _setter("utilization_strategy", utilization_strategy)
        if capacity_reservation_groups is not None:
            _setter("capacity_reservation_groups", capacity_reservation_groups)

    @property
    @pulumi.getter(name="shouldUtilize")
    def should_utilize(self) -> bool:
        return pulumi.get(self, "should_utilize")

    @property
    @pulumi.getter(name="utilizationStrategy")
    def utilization_strategy(self) -> str:
        return pulumi.get(self, "utilization_strategy")

    @property
    @pulumi.getter(name="capacityReservationGroups")
    def capacity_reservation_groups(self) -> Optional[Sequence['outputs.StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup']]:
        return pulumi.get(self, "capacity_reservation_groups")


@pulumi.output_type
class StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crgName":
            suggest = "crg_name"
        elif key == "crgResourceGroupName":
            suggest = "crg_resource_group_name"
        elif key == "crgShouldPrioritize":
            suggest = "crg_should_prioritize"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crg_name: str,
                 crg_resource_group_name: str,
                 crg_should_prioritize: Optional[bool] = None):
        StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            crg_name=crg_name,
            crg_resource_group_name=crg_resource_group_name,
            crg_should_prioritize=crg_should_prioritize,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             crg_name: str,
             crg_resource_group_name: str,
             crg_should_prioritize: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'crgName' in kwargs:
            crg_name = kwargs['crgName']
        if 'crgResourceGroupName' in kwargs:
            crg_resource_group_name = kwargs['crgResourceGroupName']
        if 'crgShouldPrioritize' in kwargs:
            crg_should_prioritize = kwargs['crgShouldPrioritize']

        _setter("crg_name", crg_name)
        _setter("crg_resource_group_name", crg_resource_group_name)
        if crg_should_prioritize is not None:
            _setter("crg_should_prioritize", crg_should_prioritize)

    @property
    @pulumi.getter(name="crgName")
    def crg_name(self) -> str:
        return pulumi.get(self, "crg_name")

    @property
    @pulumi.getter(name="crgResourceGroupName")
    def crg_resource_group_name(self) -> str:
        return pulumi.get(self, "crg_resource_group_name")

    @property
    @pulumi.getter(name="crgShouldPrioritize")
    def crg_should_prioritize(self) -> Optional[bool]:
        return pulumi.get(self, "crg_should_prioritize")


@pulumi.output_type
class StatefulNodeAzureStrategyRevertToSpot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "performAt":
            suggest = "perform_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureStrategyRevertToSpot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureStrategyRevertToSpot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureStrategyRevertToSpot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 perform_at: str):
        StatefulNodeAzureStrategyRevertToSpot._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            perform_at=perform_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             perform_at: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'performAt' in kwargs:
            perform_at = kwargs['performAt']

        _setter("perform_at", perform_at)

    @property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> str:
        return pulumi.get(self, "perform_at")


@pulumi.output_type
class StatefulNodeAzureTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"
        elif key == "tagValue":
            suggest = "tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatefulNodeAzureTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatefulNodeAzureTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatefulNodeAzureTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_key: str,
                 tag_value: Optional[str] = None):
        StatefulNodeAzureTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tag_key=tag_key,
            tag_value=tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tag_key: str,
             tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'tagKey' in kwargs:
            tag_key = kwargs['tagKey']
        if 'tagValue' in kwargs:
            tag_value = kwargs['tagValue']

        _setter("tag_key", tag_key)
        if tag_value is not None:
            _setter("tag_value", tag_value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> str:
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[str]:
        return pulumi.get(self, "tag_value")


@pulumi.output_type
class StatefulNodeAzureUpdateState(dict):
    def __init__(__self__, *,
                 state: str):
        StatefulNodeAzureUpdateState._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")


