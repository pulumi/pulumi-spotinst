# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'ElastigroupBackendServiceArgs',
    'ElastigroupBackendServiceNamedPortArgs',
    'ElastigroupDiskArgs',
    'ElastigroupDiskInitializeParamArgs',
    'ElastigroupGpuArgs',
    'ElastigroupInstanceTypesCustomArgs',
    'ElastigroupIntegrationDockerSwarmArgs',
    'ElastigroupIntegrationGkeArgs',
    'ElastigroupIntegrationGkeAutoscaleDownArgs',
    'ElastigroupIntegrationGkeAutoscaleHeadroomArgs',
    'ElastigroupIntegrationGkeAutoscaleLabelArgs',
    'ElastigroupLabelArgs',
    'ElastigroupMetadataArgs',
    'ElastigroupNetworkInterfaceArgs',
    'ElastigroupNetworkInterfaceAccessConfigArgs',
    'ElastigroupNetworkInterfaceAliasIpRangeArgs',
    'ElastigroupScalingDownPolicyArgs',
    'ElastigroupScalingDownPolicyDimensionArgs',
    'ElastigroupScalingUpPolicyArgs',
    'ElastigroupScalingUpPolicyDimensionArgs',
    'ElastigroupScheduledTaskArgs',
    'ElastigroupSubnetArgs',
]

@pulumi.input_type
class ElastigroupBackendServiceArgs:
    def __init__(__self__, *,
                 service_name: pulumi.Input[str],
                 location_type: Optional[pulumi.Input[str]] = None,
                 named_ports: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupBackendServiceNamedPortArgs']]]] = None,
                 scheme: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_name: The name of the backend service.
        :param pulumi.Input[str] location_type: Sets which location the backend services will be active. Valid values: `regional`, `global`.
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupBackendServiceNamedPortArgs']]] named_ports: Describes a named port and a list of ports.
        :param pulumi.Input[str] scheme: Use when `location_type` is "regional". Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: `INTERNAL`, `EXTERNAL`.
        """
        ElastigroupBackendServiceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service_name=service_name,
            location_type=location_type,
            named_ports=named_ports,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service_name: pulumi.Input[str],
             location_type: Optional[pulumi.Input[str]] = None,
             named_ports: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupBackendServiceNamedPortArgs']]]] = None,
             scheme: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if 'locationType' in kwargs:
            location_type = kwargs['locationType']
        if 'namedPorts' in kwargs:
            named_ports = kwargs['namedPorts']

        _setter("service_name", service_name)
        if location_type is not None:
            _setter("location_type", location_type)
        if named_ports is not None:
            _setter("named_ports", named_ports)
        if scheme is not None:
            _setter("scheme", scheme)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[str]:
        """
        The name of the backend service.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="locationType")
    def location_type(self) -> Optional[pulumi.Input[str]]:
        """
        Sets which location the backend services will be active. Valid values: `regional`, `global`.
        """
        return pulumi.get(self, "location_type")

    @location_type.setter
    def location_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location_type", value)

    @property
    @pulumi.getter(name="namedPorts")
    def named_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupBackendServiceNamedPortArgs']]]]:
        """
        Describes a named port and a list of ports.
        """
        return pulumi.get(self, "named_ports")

    @named_ports.setter
    def named_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupBackendServiceNamedPortArgs']]]]):
        pulumi.set(self, "named_ports", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Use when `location_type` is "regional". Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: `INTERNAL`, `EXTERNAL`.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)


@pulumi.input_type
class ElastigroupBackendServiceNamedPortArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 ports: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: The group name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ports: A list of ports.
               
               Usage:
               
               ```python
               import pulumi
               ```
        """
        ElastigroupBackendServiceNamedPortArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            ports=ports,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             ports: pulumi.Input[Sequence[pulumi.Input[str]]],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("ports", ports)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The group name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of ports.

        Usage:

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ports", value)


@pulumi.input_type
class ElastigroupDiskArgs:
    def __init__(__self__, *,
                 auto_delete: Optional[pulumi.Input[bool]] = None,
                 boot: Optional[pulumi.Input[bool]] = None,
                 device_name: Optional[pulumi.Input[str]] = None,
                 initialize_params: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupDiskInitializeParamArgs']]]] = None,
                 interface: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] auto_delete: Specifies whether the disk will be auto-deleted when the instance is deleted.
        :param pulumi.Input[bool] boot: Indicates that this is a boot disk. The virtual machine will use the first partition of the disk for its root filesystem.
        :param pulumi.Input[str] device_name: Specifies a unique device name of your choice.
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupDiskInitializeParamArgs']]] initialize_params: Specifies the parameters for a new disk that will be created alongside the new instance. Use initialization parameters to create boot disks or local SSDs attached to the new instance.
        :param pulumi.Input[str] interface: Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME.
        :param pulumi.Input[str] mode: The mode in which to attach this disk, either READ_WRITE or READ_ONLY.
        :param pulumi.Input[str] source: Specifies a valid partial or full URL to an existing Persistent Disk resource. This field is only applicable for persistent disks.
        :param pulumi.Input[str] type: Specifies the type of disk, either SCRATCH or PERSISTENT.
        """
        ElastigroupDiskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_delete=auto_delete,
            boot=boot,
            device_name=device_name,
            initialize_params=initialize_params,
            interface=interface,
            mode=mode,
            source=source,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_delete: Optional[pulumi.Input[bool]] = None,
             boot: Optional[pulumi.Input[bool]] = None,
             device_name: Optional[pulumi.Input[str]] = None,
             initialize_params: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupDiskInitializeParamArgs']]]] = None,
             interface: Optional[pulumi.Input[str]] = None,
             mode: Optional[pulumi.Input[str]] = None,
             source: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'autoDelete' in kwargs:
            auto_delete = kwargs['autoDelete']
        if 'deviceName' in kwargs:
            device_name = kwargs['deviceName']
        if 'initializeParams' in kwargs:
            initialize_params = kwargs['initializeParams']

        if auto_delete is not None:
            _setter("auto_delete", auto_delete)
        if boot is not None:
            _setter("boot", boot)
        if device_name is not None:
            _setter("device_name", device_name)
        if initialize_params is not None:
            _setter("initialize_params", initialize_params)
        if interface is not None:
            _setter("interface", interface)
        if mode is not None:
            _setter("mode", mode)
        if source is not None:
            _setter("source", source)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the disk will be auto-deleted when the instance is deleted.
        """
        return pulumi.get(self, "auto_delete")

    @auto_delete.setter
    def auto_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_delete", value)

    @property
    @pulumi.getter
    def boot(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates that this is a boot disk. The virtual machine will use the first partition of the disk for its root filesystem.
        """
        return pulumi.get(self, "boot")

    @boot.setter
    def boot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boot", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a unique device name of your choice.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupDiskInitializeParamArgs']]]]:
        """
        Specifies the parameters for a new disk that will be created alongside the new instance. Use initialization parameters to create boot disks or local SSDs attached to the new instance.
        """
        return pulumi.get(self, "initialize_params")

    @initialize_params.setter
    def initialize_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupDiskInitializeParamArgs']]]]):
        pulumi.set(self, "initialize_params", value)

    @property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME.
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        The mode in which to attach this disk, either READ_WRITE or READ_ONLY.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a valid partial or full URL to an existing Persistent Disk resource. This field is only applicable for persistent disks.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the type of disk, either SCRATCH or PERSISTENT.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ElastigroupDiskInitializeParamArgs:
    def __init__(__self__, *,
                 source_image: pulumi.Input[str],
                 disk_size_gb: Optional[pulumi.Input[str]] = None,
                 disk_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] source_image: A source image used to create the disk. You can provide a private (custom) image, and Compute Engine will use the corresponding image from your project.
               
               Usage:
               
               ```python
               import pulumi
               ```
        :param pulumi.Input[str] disk_size_gb: Specifies disk size in gigabytes. Must be in increments of 2.
        :param pulumi.Input[str] disk_type: Specifies the disk type to use to create the instance. Valid values: pd-ssd, local-ssd.
        """
        ElastigroupDiskInitializeParamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_image=source_image,
            disk_size_gb=disk_size_gb,
            disk_type=disk_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_image: pulumi.Input[str],
             disk_size_gb: Optional[pulumi.Input[str]] = None,
             disk_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'sourceImage' in kwargs:
            source_image = kwargs['sourceImage']
        if 'diskSizeGb' in kwargs:
            disk_size_gb = kwargs['diskSizeGb']
        if 'diskType' in kwargs:
            disk_type = kwargs['diskType']

        _setter("source_image", source_image)
        if disk_size_gb is not None:
            _setter("disk_size_gb", disk_size_gb)
        if disk_type is not None:
            _setter("disk_type", disk_type)

    @property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> pulumi.Input[str]:
        """
        A source image used to create the disk. You can provide a private (custom) image, and Compute Engine will use the corresponding image from your project.

        Usage:

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "source_image")

    @source_image.setter
    def source_image(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_image", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies disk size in gigabytes. Must be in increments of 2.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the disk type to use to create the instance. Valid values: pd-ssd, local-ssd.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_type", value)


@pulumi.input_type
class ElastigroupGpuArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] count: The number of GPUs. Must be 0, 2, 4, 6, 8.
               
               Usage:
               
               ```python
               import pulumi
               ```
        :param pulumi.Input[str] type: The type of GPU instance. Valid values: `nvidia-tesla-v100`, `nvidia-tesla-p100`, `nvidia-tesla-k80`.
        """
        ElastigroupGpuArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: pulumi.Input[int],
             type: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("count", count)
        _setter("type", type)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of GPUs. Must be 0, 2, 4, 6, 8.

        Usage:

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of GPU instance. Valid values: `nvidia-tesla-v100`, `nvidia-tesla-p100`, `nvidia-tesla-k80`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ElastigroupInstanceTypesCustomArgs:
    def __init__(__self__, *,
                 memory_gib: pulumi.Input[int],
                 vcpu: pulumi.Input[int]):
        """
        :param pulumi.Input[int] memory_gib: The memory (in GiB) in the custom instance types. GCP has a number of limitations on accepted memory values.For more information, see the GCP documentation (here.)[https://cloud.google.com/compute/docs/instances/creating-instance-with-custom-machine-type#specifications]
        """
        ElastigroupInstanceTypesCustomArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            memory_gib=memory_gib,
            vcpu=vcpu,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             memory_gib: pulumi.Input[int],
             vcpu: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'memoryGib' in kwargs:
            memory_gib = kwargs['memoryGib']

        _setter("memory_gib", memory_gib)
        _setter("vcpu", vcpu)

    @property
    @pulumi.getter(name="memoryGib")
    def memory_gib(self) -> pulumi.Input[int]:
        """
        The memory (in GiB) in the custom instance types. GCP has a number of limitations on accepted memory values.For more information, see the GCP documentation (here.)[https://cloud.google.com/compute/docs/instances/creating-instance-with-custom-machine-type#specifications]
        """
        return pulumi.get(self, "memory_gib")

    @memory_gib.setter
    def memory_gib(self, value: pulumi.Input[int]):
        pulumi.set(self, "memory_gib", value)

    @property
    @pulumi.getter
    def vcpu(self) -> pulumi.Input[int]:
        return pulumi.get(self, "vcpu")

    @vcpu.setter
    def vcpu(self, value: pulumi.Input[int]):
        pulumi.set(self, "vcpu", value)


@pulumi.input_type
class ElastigroupIntegrationDockerSwarmArgs:
    def __init__(__self__, *,
                 master_host: pulumi.Input[str],
                 master_port: pulumi.Input[int]):
        """
        :param pulumi.Input[str] master_host: IP or FQDN of one of your swarm managers.
        :param pulumi.Input[int] master_port: Network port used by your swarm.
               
               Usage:
               
               ```python
               import pulumi
               ```
        """
        ElastigroupIntegrationDockerSwarmArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            master_host=master_host,
            master_port=master_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             master_host: pulumi.Input[str],
             master_port: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'masterHost' in kwargs:
            master_host = kwargs['masterHost']
        if 'masterPort' in kwargs:
            master_port = kwargs['masterPort']

        _setter("master_host", master_host)
        _setter("master_port", master_port)

    @property
    @pulumi.getter(name="masterHost")
    def master_host(self) -> pulumi.Input[str]:
        """
        IP or FQDN of one of your swarm managers.
        """
        return pulumi.get(self, "master_host")

    @master_host.setter
    def master_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "master_host", value)

    @property
    @pulumi.getter(name="masterPort")
    def master_port(self) -> pulumi.Input[int]:
        """
        Network port used by your swarm.

        Usage:

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "master_port")

    @master_port.setter
    def master_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "master_port", value)


@pulumi.input_type
class ElastigroupIntegrationGkeArgs:
    def __init__(__self__, *,
                 auto_update: Optional[pulumi.Input[bool]] = None,
                 autoscale_cooldown: Optional[pulumi.Input[int]] = None,
                 autoscale_down: Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleDownArgs']] = None,
                 autoscale_headroom: Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleHeadroomArgs']] = None,
                 autoscale_is_auto_config: Optional[pulumi.Input[bool]] = None,
                 autoscale_is_enabled: Optional[pulumi.Input[bool]] = None,
                 autoscale_labels: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationGkeAutoscaleLabelArgs']]]] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None):
        ElastigroupIntegrationGkeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_update=auto_update,
            autoscale_cooldown=autoscale_cooldown,
            autoscale_down=autoscale_down,
            autoscale_headroom=autoscale_headroom,
            autoscale_is_auto_config=autoscale_is_auto_config,
            autoscale_is_enabled=autoscale_is_enabled,
            autoscale_labels=autoscale_labels,
            cluster_id=cluster_id,
            location=location,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_update: Optional[pulumi.Input[bool]] = None,
             autoscale_cooldown: Optional[pulumi.Input[int]] = None,
             autoscale_down: Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleDownArgs']] = None,
             autoscale_headroom: Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleHeadroomArgs']] = None,
             autoscale_is_auto_config: Optional[pulumi.Input[bool]] = None,
             autoscale_is_enabled: Optional[pulumi.Input[bool]] = None,
             autoscale_labels: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationGkeAutoscaleLabelArgs']]]] = None,
             cluster_id: Optional[pulumi.Input[str]] = None,
             location: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'autoUpdate' in kwargs:
            auto_update = kwargs['autoUpdate']
        if 'autoscaleCooldown' in kwargs:
            autoscale_cooldown = kwargs['autoscaleCooldown']
        if 'autoscaleDown' in kwargs:
            autoscale_down = kwargs['autoscaleDown']
        if 'autoscaleHeadroom' in kwargs:
            autoscale_headroom = kwargs['autoscaleHeadroom']
        if 'autoscaleIsAutoConfig' in kwargs:
            autoscale_is_auto_config = kwargs['autoscaleIsAutoConfig']
        if 'autoscaleIsEnabled' in kwargs:
            autoscale_is_enabled = kwargs['autoscaleIsEnabled']
        if 'autoscaleLabels' in kwargs:
            autoscale_labels = kwargs['autoscaleLabels']
        if 'clusterId' in kwargs:
            cluster_id = kwargs['clusterId']

        if auto_update is not None:
            _setter("auto_update", auto_update)
        if autoscale_cooldown is not None:
            _setter("autoscale_cooldown", autoscale_cooldown)
        if autoscale_down is not None:
            _setter("autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            _setter("autoscale_headroom", autoscale_headroom)
        if autoscale_is_auto_config is not None:
            _setter("autoscale_is_auto_config", autoscale_is_auto_config)
        if autoscale_is_enabled is not None:
            _setter("autoscale_is_enabled", autoscale_is_enabled)
        if autoscale_labels is not None:
            _setter("autoscale_labels", autoscale_labels)
        if cluster_id is not None:
            _setter("cluster_id", cluster_id)
        if location is not None:
            _setter("location", location)

    @property
    @pulumi.getter(name="autoUpdate")
    def auto_update(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "auto_update")

    @auto_update.setter
    def auto_update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_update", value)

    @property
    @pulumi.getter(name="autoscaleCooldown")
    def autoscale_cooldown(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "autoscale_cooldown")

    @autoscale_cooldown.setter
    def autoscale_cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autoscale_cooldown", value)

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleDownArgs']]:
        return pulumi.get(self, "autoscale_down")

    @autoscale_down.setter
    def autoscale_down(self, value: Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleDownArgs']]):
        pulumi.set(self, "autoscale_down", value)

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleHeadroomArgs']]:
        return pulumi.get(self, "autoscale_headroom")

    @autoscale_headroom.setter
    def autoscale_headroom(self, value: Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleHeadroomArgs']]):
        pulumi.set(self, "autoscale_headroom", value)

    @property
    @pulumi.getter(name="autoscaleIsAutoConfig")
    def autoscale_is_auto_config(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "autoscale_is_auto_config")

    @autoscale_is_auto_config.setter
    def autoscale_is_auto_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale_is_auto_config", value)

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "autoscale_is_enabled")

    @autoscale_is_enabled.setter
    def autoscale_is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale_is_enabled", value)

    @property
    @pulumi.getter(name="autoscaleLabels")
    def autoscale_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationGkeAutoscaleLabelArgs']]]]:
        return pulumi.get(self, "autoscale_labels")

    @autoscale_labels.setter
    def autoscale_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationGkeAutoscaleLabelArgs']]]]):
        pulumi.set(self, "autoscale_labels", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)


@pulumi.input_type
class ElastigroupIntegrationGkeAutoscaleDownArgs:
    def __init__(__self__, *,
                 evaluation_periods: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] evaluation_periods: Number of consecutive periods in which the threshold must be met in order to trigger a scaling action.
        """
        ElastigroupIntegrationGkeAutoscaleDownArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            evaluation_periods=evaluation_periods,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             evaluation_periods: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'evaluationPeriods' in kwargs:
            evaluation_periods = kwargs['evaluationPeriods']

        if evaluation_periods is not None:
            _setter("evaluation_periods", evaluation_periods)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        """
        Number of consecutive periods in which the threshold must be met in order to trigger a scaling action.
        """
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)


@pulumi.input_type
class ElastigroupIntegrationGkeAutoscaleHeadroomArgs:
    def __init__(__self__, *,
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None,
                 num_of_units: Optional[pulumi.Input[int]] = None):
        ElastigroupIntegrationGkeAutoscaleHeadroomArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_per_unit=cpu_per_unit,
            memory_per_unit=memory_per_unit,
            num_of_units=num_of_units,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_per_unit: Optional[pulumi.Input[int]] = None,
             memory_per_unit: Optional[pulumi.Input[int]] = None,
             num_of_units: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cpuPerUnit' in kwargs:
            cpu_per_unit = kwargs['cpuPerUnit']
        if 'memoryPerUnit' in kwargs:
            memory_per_unit = kwargs['memoryPerUnit']
        if 'numOfUnits' in kwargs:
            num_of_units = kwargs['numOfUnits']

        if cpu_per_unit is not None:
            _setter("cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            _setter("memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            _setter("num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_of_units", value)


@pulumi.input_type
class ElastigroupIntegrationGkeAutoscaleLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Labels key.
        :param pulumi.Input[str] value: Labels value.
        """
        ElastigroupIntegrationGkeAutoscaleLabelArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Labels key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Labels value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ElastigroupLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Labels key.
        :param pulumi.Input[str] value: Labels value.
        """
        ElastigroupLabelArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Labels key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Labels value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ElastigroupMetadataArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Labels key.
        :param pulumi.Input[str] value: Labels value.
        """
        ElastigroupMetadataArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Labels key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Labels value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ElastigroupNetworkInterfaceArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[str],
                 access_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAccessConfigArgs']]]] = None,
                 alias_ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAliasIpRangeArgs']]]] = None):
        """
        :param pulumi.Input[str] network: Network resource for this group.
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAccessConfigArgs']]] access_configs: Array of configurations.
        """
        ElastigroupNetworkInterfaceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network=network,
            access_configs=access_configs,
            alias_ip_ranges=alias_ip_ranges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network: pulumi.Input[str],
             access_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAccessConfigArgs']]]] = None,
             alias_ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAliasIpRangeArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accessConfigs' in kwargs:
            access_configs = kwargs['accessConfigs']
        if 'aliasIpRanges' in kwargs:
            alias_ip_ranges = kwargs['aliasIpRanges']

        _setter("network", network)
        if access_configs is not None:
            _setter("access_configs", access_configs)
        if alias_ip_ranges is not None:
            _setter("alias_ip_ranges", alias_ip_ranges)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[str]:
        """
        Network resource for this group.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[str]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAccessConfigArgs']]]]:
        """
        Array of configurations.
        """
        return pulumi.get(self, "access_configs")

    @access_configs.setter
    def access_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAccessConfigArgs']]]]):
        pulumi.set(self, "access_configs", value)

    @property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAliasIpRangeArgs']]]]:
        return pulumi.get(self, "alias_ip_ranges")

    @alias_ip_ranges.setter
    def alias_ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAliasIpRangeArgs']]]]):
        pulumi.set(self, "alias_ip_ranges", value)


@pulumi.input_type
class ElastigroupNetworkInterfaceAccessConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The group name.
        :param pulumi.Input[str] type: Specifies the type of disk, either SCRATCH or PERSISTENT.
        """
        ElastigroupNetworkInterfaceAccessConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The group name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the type of disk, either SCRATCH or PERSISTENT.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ElastigroupNetworkInterfaceAliasIpRangeArgs:
    def __init__(__self__, *,
                 ip_cidr_range: pulumi.Input[str],
                 subnetwork_range_name: pulumi.Input[str]):
        ElastigroupNetworkInterfaceAliasIpRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_cidr_range=ip_cidr_range,
            subnetwork_range_name=subnetwork_range_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_cidr_range: pulumi.Input[str],
             subnetwork_range_name: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ipCidrRange' in kwargs:
            ip_cidr_range = kwargs['ipCidrRange']
        if 'subnetworkRangeName' in kwargs:
            subnetwork_range_name = kwargs['subnetworkRangeName']

        _setter("ip_cidr_range", ip_cidr_range)
        _setter("subnetwork_range_name", subnetwork_range_name)

    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> pulumi.Input[str]:
        return pulumi.get(self, "ip_cidr_range")

    @ip_cidr_range.setter
    def ip_cidr_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_cidr_range", value)

    @property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "subnetwork_range_name")

    @subnetwork_range_name.setter
    def subnetwork_range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnetwork_range_name", value)


@pulumi.input_type
class ElastigroupScalingDownPolicyArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 policy_name: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 unit: pulumi.Input[str],
                 action_type: Optional[pulumi.Input[str]] = None,
                 adjustment: Optional[pulumi.Input[int]] = None,
                 cooldown: Optional[pulumi.Input[int]] = None,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgs']]]] = None,
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 statistic: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric_name: Metric to monitor. Valid values: "Percentage CPU", "Network In", "Network Out", "Disk Read Bytes", "Disk Write Bytes", "Disk Write Operations/Sec", "Disk Read Operations/Sec".
        :param pulumi.Input[str] policy_name: Name of scaling policy.
        :param pulumi.Input[float] threshold: The value at which the scaling action is triggered.
        :param pulumi.Input[str] action_type: Type of scaling action to take when the scaling policy is triggered. Valid values: "adjustment", "setMinTarget", "updateCapacity", "percentageAdjustment"
        :param pulumi.Input[int] adjustment: Value to which the action type will be adjusted. Required if using "numeric" or "percentageAdjustment" action types.
        :param pulumi.Input[int] cooldown: Time (seconds) to wait after a scaling action before resuming monitoring.
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgs']]] dimensions: A list of dimensions describing qualities of the metric.
        :param pulumi.Input[int] evaluation_periods: Number of consecutive periods in which the threshold must be met in order to trigger a scaling action.
        :param pulumi.Input[str] operator: The operator used to evaluate the threshold against the current metric value. Valid values: "gt" (greater than), "get" (greater-than or equal), "lt" (less than), "lte" (less than or equal).
        :param pulumi.Input[int] period: Amount of time (seconds) for which the threshold must be met in order to trigger the scaling action.
        :param pulumi.Input[str] source: Specifies a valid partial or full URL to an existing Persistent Disk resource. This field is only applicable for persistent disks.
        :param pulumi.Input[str] statistic: Statistic by which to evaluate the selected metric. Valid values: "AVERAGE", "SAMPLE_COUNT", "SUM", "MINIMUM", "MAXIMUM", "PERCENTILE", "COUNT".
        """
        ElastigroupScalingDownPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_name=metric_name,
            namespace=namespace,
            policy_name=policy_name,
            threshold=threshold,
            unit=unit,
            action_type=action_type,
            adjustment=adjustment,
            cooldown=cooldown,
            dimensions=dimensions,
            evaluation_periods=evaluation_periods,
            operator=operator,
            period=period,
            source=source,
            statistic=statistic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_name: pulumi.Input[str],
             namespace: pulumi.Input[str],
             policy_name: pulumi.Input[str],
             threshold: pulumi.Input[float],
             unit: pulumi.Input[str],
             action_type: Optional[pulumi.Input[str]] = None,
             adjustment: Optional[pulumi.Input[int]] = None,
             cooldown: Optional[pulumi.Input[int]] = None,
             dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgs']]]] = None,
             evaluation_periods: Optional[pulumi.Input[int]] = None,
             operator: Optional[pulumi.Input[str]] = None,
             period: Optional[pulumi.Input[int]] = None,
             source: Optional[pulumi.Input[str]] = None,
             statistic: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if 'policyName' in kwargs:
            policy_name = kwargs['policyName']
        if 'actionType' in kwargs:
            action_type = kwargs['actionType']
        if 'evaluationPeriods' in kwargs:
            evaluation_periods = kwargs['evaluationPeriods']

        _setter("metric_name", metric_name)
        _setter("namespace", namespace)
        _setter("policy_name", policy_name)
        _setter("threshold", threshold)
        _setter("unit", unit)
        if action_type is not None:
            _setter("action_type", action_type)
        if adjustment is not None:
            _setter("adjustment", adjustment)
        if cooldown is not None:
            _setter("cooldown", cooldown)
        if dimensions is not None:
            _setter("dimensions", dimensions)
        if evaluation_periods is not None:
            _setter("evaluation_periods", evaluation_periods)
        if operator is not None:
            _setter("operator", operator)
        if period is not None:
            _setter("period", period)
        if source is not None:
            _setter("source", source)
        if statistic is not None:
            _setter("statistic", statistic)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        Metric to monitor. Valid values: "Percentage CPU", "Network In", "Network Out", "Disk Read Bytes", "Disk Write Bytes", "Disk Write Operations/Sec", "Disk Read Operations/Sec".
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> pulumi.Input[str]:
        """
        Name of scaling policy.
        """
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_name", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        The value at which the scaling action is triggered.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of scaling action to take when the scaling policy is triggered. Valid values: "adjustment", "setMinTarget", "updateCapacity", "percentageAdjustment"
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[int]]:
        """
        Value to which the action type will be adjusted. Required if using "numeric" or "percentageAdjustment" action types.
        """
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[int]]:
        """
        Time (seconds) to wait after a scaling action before resuming monitoring.
        """
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgs']]]]:
        """
        A list of dimensions describing qualities of the metric.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        """
        Number of consecutive periods in which the threshold must be met in order to trigger a scaling action.
        """
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator used to evaluate the threshold against the current metric value. Valid values: "gt" (greater than), "get" (greater-than or equal), "lt" (less than), "lte" (less than or equal).
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        """
        Amount of time (seconds) for which the threshold must be met in order to trigger the scaling action.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a valid partial or full URL to an existing Persistent Disk resource. This field is only applicable for persistent disks.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input[str]]:
        """
        Statistic by which to evaluate the selected metric. Valid values: "AVERAGE", "SAMPLE_COUNT", "SUM", "MINIMUM", "MAXIMUM", "PERCENTILE", "COUNT".
        """
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statistic", value)


@pulumi.input_type
class ElastigroupScalingDownPolicyDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The group name.
        :param pulumi.Input[str] value: Labels value.
        """
        ElastigroupScalingDownPolicyDimensionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The group name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Labels value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ElastigroupScalingUpPolicyArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 policy_name: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 unit: pulumi.Input[str],
                 action_type: Optional[pulumi.Input[str]] = None,
                 adjustment: Optional[pulumi.Input[int]] = None,
                 cooldown: Optional[pulumi.Input[int]] = None,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgs']]]] = None,
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 statistic: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric_name: Metric to monitor. Valid values: "Percentage CPU", "Network In", "Network Out", "Disk Read Bytes", "Disk Write Bytes", "Disk Write Operations/Sec", "Disk Read Operations/Sec".
        :param pulumi.Input[str] policy_name: Name of scaling policy.
        :param pulumi.Input[float] threshold: The value at which the scaling action is triggered.
        :param pulumi.Input[str] action_type: Type of scaling action to take when the scaling policy is triggered. Valid values: "adjustment", "setMinTarget", "updateCapacity", "percentageAdjustment"
        :param pulumi.Input[int] adjustment: Value to which the action type will be adjusted. Required if using "numeric" or "percentageAdjustment" action types.
        :param pulumi.Input[int] cooldown: Time (seconds) to wait after a scaling action before resuming monitoring.
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgs']]] dimensions: A list of dimensions describing qualities of the metric.
        :param pulumi.Input[int] evaluation_periods: Number of consecutive periods in which the threshold must be met in order to trigger a scaling action.
        :param pulumi.Input[str] operator: The operator used to evaluate the threshold against the current metric value. Valid values: "gt" (greater than), "get" (greater-than or equal), "lt" (less than), "lte" (less than or equal).
        :param pulumi.Input[int] period: Amount of time (seconds) for which the threshold must be met in order to trigger the scaling action.
        :param pulumi.Input[str] source: Specifies a valid partial or full URL to an existing Persistent Disk resource. This field is only applicable for persistent disks.
        :param pulumi.Input[str] statistic: Statistic by which to evaluate the selected metric. Valid values: "AVERAGE", "SAMPLE_COUNT", "SUM", "MINIMUM", "MAXIMUM", "PERCENTILE", "COUNT".
        """
        ElastigroupScalingUpPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_name=metric_name,
            namespace=namespace,
            policy_name=policy_name,
            threshold=threshold,
            unit=unit,
            action_type=action_type,
            adjustment=adjustment,
            cooldown=cooldown,
            dimensions=dimensions,
            evaluation_periods=evaluation_periods,
            operator=operator,
            period=period,
            source=source,
            statistic=statistic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_name: pulumi.Input[str],
             namespace: pulumi.Input[str],
             policy_name: pulumi.Input[str],
             threshold: pulumi.Input[float],
             unit: pulumi.Input[str],
             action_type: Optional[pulumi.Input[str]] = None,
             adjustment: Optional[pulumi.Input[int]] = None,
             cooldown: Optional[pulumi.Input[int]] = None,
             dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgs']]]] = None,
             evaluation_periods: Optional[pulumi.Input[int]] = None,
             operator: Optional[pulumi.Input[str]] = None,
             period: Optional[pulumi.Input[int]] = None,
             source: Optional[pulumi.Input[str]] = None,
             statistic: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'metricName' in kwargs:
            metric_name = kwargs['metricName']
        if 'policyName' in kwargs:
            policy_name = kwargs['policyName']
        if 'actionType' in kwargs:
            action_type = kwargs['actionType']
        if 'evaluationPeriods' in kwargs:
            evaluation_periods = kwargs['evaluationPeriods']

        _setter("metric_name", metric_name)
        _setter("namespace", namespace)
        _setter("policy_name", policy_name)
        _setter("threshold", threshold)
        _setter("unit", unit)
        if action_type is not None:
            _setter("action_type", action_type)
        if adjustment is not None:
            _setter("adjustment", adjustment)
        if cooldown is not None:
            _setter("cooldown", cooldown)
        if dimensions is not None:
            _setter("dimensions", dimensions)
        if evaluation_periods is not None:
            _setter("evaluation_periods", evaluation_periods)
        if operator is not None:
            _setter("operator", operator)
        if period is not None:
            _setter("period", period)
        if source is not None:
            _setter("source", source)
        if statistic is not None:
            _setter("statistic", statistic)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        Metric to monitor. Valid values: "Percentage CPU", "Network In", "Network Out", "Disk Read Bytes", "Disk Write Bytes", "Disk Write Operations/Sec", "Disk Read Operations/Sec".
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> pulumi.Input[str]:
        """
        Name of scaling policy.
        """
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_name", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        The value at which the scaling action is triggered.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of scaling action to take when the scaling policy is triggered. Valid values: "adjustment", "setMinTarget", "updateCapacity", "percentageAdjustment"
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[int]]:
        """
        Value to which the action type will be adjusted. Required if using "numeric" or "percentageAdjustment" action types.
        """
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[int]]:
        """
        Time (seconds) to wait after a scaling action before resuming monitoring.
        """
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgs']]]]:
        """
        A list of dimensions describing qualities of the metric.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        """
        Number of consecutive periods in which the threshold must be met in order to trigger a scaling action.
        """
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator used to evaluate the threshold against the current metric value. Valid values: "gt" (greater than), "get" (greater-than or equal), "lt" (less than), "lte" (less than or equal).
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        """
        Amount of time (seconds) for which the threshold must be met in order to trigger the scaling action.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a valid partial or full URL to an existing Persistent Disk resource. This field is only applicable for persistent disks.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input[str]]:
        """
        Statistic by which to evaluate the selected metric. Valid values: "AVERAGE", "SAMPLE_COUNT", "SUM", "MINIMUM", "MAXIMUM", "PERCENTILE", "COUNT".
        """
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statistic", value)


@pulumi.input_type
class ElastigroupScalingUpPolicyDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The group name.
        :param pulumi.Input[str] value: Labels value.
        """
        ElastigroupScalingUpPolicyDimensionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The group name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Labels value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ElastigroupScheduledTaskArgs:
    def __init__(__self__, *,
                 task_type: pulumi.Input[str],
                 cron_expression: Optional[pulumi.Input[str]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 max_capacity: Optional[pulumi.Input[str]] = None,
                 min_capacity: Optional[pulumi.Input[str]] = None,
                 target_capacity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] task_type: The task type to run. Valid values: `"setCapacity"`.
        :param pulumi.Input[str] cron_expression: A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
        :param pulumi.Input[bool] is_enabled: Setting the task to being enabled or disabled.
        :param pulumi.Input[str] max_capacity: The maximum number of instances the group should have.
               
               Usage:
               
               ```python
               import pulumi
               ```
        :param pulumi.Input[str] min_capacity: The minimum number of instances the group should have.
        :param pulumi.Input[str] target_capacity: The desired number of instances the group should have.
        """
        ElastigroupScheduledTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            task_type=task_type,
            cron_expression=cron_expression,
            is_enabled=is_enabled,
            max_capacity=max_capacity,
            min_capacity=min_capacity,
            target_capacity=target_capacity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             task_type: pulumi.Input[str],
             cron_expression: Optional[pulumi.Input[str]] = None,
             is_enabled: Optional[pulumi.Input[bool]] = None,
             max_capacity: Optional[pulumi.Input[str]] = None,
             min_capacity: Optional[pulumi.Input[str]] = None,
             target_capacity: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'taskType' in kwargs:
            task_type = kwargs['taskType']
        if 'cronExpression' in kwargs:
            cron_expression = kwargs['cronExpression']
        if 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if 'maxCapacity' in kwargs:
            max_capacity = kwargs['maxCapacity']
        if 'minCapacity' in kwargs:
            min_capacity = kwargs['minCapacity']
        if 'targetCapacity' in kwargs:
            target_capacity = kwargs['targetCapacity']

        _setter("task_type", task_type)
        if cron_expression is not None:
            _setter("cron_expression", cron_expression)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if max_capacity is not None:
            _setter("max_capacity", max_capacity)
        if min_capacity is not None:
            _setter("min_capacity", min_capacity)
        if target_capacity is not None:
            _setter("target_capacity", target_capacity)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input[str]:
        """
        The task type to run. Valid values: `"setCapacity"`.
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_type", value)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[str]]:
        """
        A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting the task to being enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum number of instances the group should have.

        Usage:

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "max_capacity")

    @max_capacity.setter
    def max_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_capacity", value)

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum number of instances the group should have.
        """
        return pulumi.get(self, "min_capacity")

    @min_capacity.setter
    def min_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_capacity", value)

    @property
    @pulumi.getter(name="targetCapacity")
    def target_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The desired number of instances the group should have.
        """
        return pulumi.get(self, "target_capacity")

    @target_capacity.setter
    def target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_capacity", value)


@pulumi.input_type
class ElastigroupSubnetArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[str],
                 subnet_names: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] region: The region for the group of subnets.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_names: The names of the subnets in the region.
        """
        ElastigroupSubnetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            region=region,
            subnet_names=subnet_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             region: pulumi.Input[str],
             subnet_names: pulumi.Input[Sequence[pulumi.Input[str]]],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'subnetNames' in kwargs:
            subnet_names = kwargs['subnetNames']

        _setter("region", region)
        _setter("subnet_names", subnet_names)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The region for the group of subnets.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="subnetNames")
    def subnet_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The names of the subnets in the region.
        """
        return pulumi.get(self, "subnet_names")

    @subnet_names.setter
    def subnet_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnet_names", value)


