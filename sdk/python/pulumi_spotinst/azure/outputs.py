# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'ElastigroupHealthCheck',
    'ElastigroupImage',
    'ElastigroupImageCustom',
    'ElastigroupImageMarketplace',
    'ElastigroupIntegrationKubernetes',
    'ElastigroupIntegrationMultaiRuntime',
    'ElastigroupLoadBalancer',
    'ElastigroupLogin',
    'ElastigroupManagedServiceIdentity',
    'ElastigroupNetwork',
    'ElastigroupNetworkAdditionalIpConfig',
    'ElastigroupScalingDownPolicy',
    'ElastigroupScalingDownPolicyDimension',
    'ElastigroupScalingUpPolicy',
    'ElastigroupScalingUpPolicyDimension',
    'ElastigroupScheduledTask',
    'ElastigroupStrategy',
    'ElastigroupUpdatePolicy',
    'ElastigroupUpdatePolicyRollConfig',
    'OceanAutoscaler',
    'OceanAutoscalerAutoscaleDown',
    'OceanAutoscalerAutoscaleHeadroom',
    'OceanAutoscalerAutoscaleHeadroomAutomatic',
    'OceanAutoscalerResourceLimits',
    'OceanExtension',
    'OceanHealth',
    'OceanImage',
    'OceanImageMarketplace',
    'OceanLoadBalancer',
    'OceanManagedServiceIdentity',
    'OceanNetwork',
    'OceanNetworkNetworkInterface',
    'OceanNetworkNetworkInterfaceAdditionalIpConfig',
    'OceanNetworkNetworkInterfaceSecurityGroup',
    'OceanOsDisk',
    'OceanStrategy',
    'OceanTag',
    'OceanVirtualNodeGroupAutoscale',
    'OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom',
    'OceanVirtualNodeGroupLabel',
    'OceanVirtualNodeGroupLaunchSpecification',
    'OceanVirtualNodeGroupLaunchSpecificationOsDisk',
    'OceanVirtualNodeGroupLaunchSpecificationTag',
    'OceanVirtualNodeGroupResourceLimit',
    'OceanVirtualNodeGroupTaint',
    'OceanVmSize',
]

@pulumi.output_type
class ElastigroupHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthCheckType":
            suggest = "health_check_type"
        elif key == "autoHealing":
            suggest = "auto_healing"
        elif key == "gracePeriod":
            suggest = "grace_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 health_check_type: str,
                 auto_healing: Optional[bool] = None,
                 grace_period: Optional[int] = None):
        """
        :param str health_check_type: Sets the health check type to use. Valid values: `"INSTANCE_STATE"`, `"NONE"`.
        :param bool auto_healing: Enable auto-healing of unhealthy VMs.
        :param int grace_period: Sets the grace period for new instances to become healthy.
        """
        pulumi.set(__self__, "health_check_type", health_check_type)
        if auto_healing is not None:
            pulumi.set(__self__, "auto_healing", auto_healing)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> str:
        """
        Sets the health check type to use. Valid values: `"INSTANCE_STATE"`, `"NONE"`.
        """
        return pulumi.get(self, "health_check_type")

    @property
    @pulumi.getter(name="autoHealing")
    def auto_healing(self) -> Optional[bool]:
        """
        Enable auto-healing of unhealthy VMs.
        """
        return pulumi.get(self, "auto_healing")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        """
        Sets the grace period for new instances to become healthy.
        """
        return pulumi.get(self, "grace_period")


@pulumi.output_type
class ElastigroupImage(dict):
    def __init__(__self__, *,
                 customs: Optional[Sequence['outputs.ElastigroupImageCustom']] = None,
                 marketplaces: Optional[Sequence['outputs.ElastigroupImageMarketplace']] = None):
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if marketplaces is not None:
            pulumi.set(__self__, "marketplaces", marketplaces)

    @property
    @pulumi.getter
    def customs(self) -> Optional[Sequence['outputs.ElastigroupImageCustom']]:
        return pulumi.get(self, "customs")

    @property
    @pulumi.getter
    def marketplaces(self) -> Optional[Sequence['outputs.ElastigroupImageMarketplace']]:
        return pulumi.get(self, "marketplaces")


@pulumi.output_type
class ElastigroupImageCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageName":
            suggest = "image_name"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupImageCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupImageCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupImageCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_name: str,
                 resource_group_name: str):
        """
        :param str image_name: Name of the custom image. Required if resource_group_name is specified.
        :param str resource_group_name: Vnet Resource Group Name.
        """
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        """
        Name of the custom image. Required if resource_group_name is specified.
        """
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        Vnet Resource Group Name.
        """
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class ElastigroupImageMarketplace(dict):
    def __init__(__self__, *,
                 offer: str,
                 publisher: str,
                 sku: str):
        """
        :param str offer: Name of the image to use. Required if publisher is specified.
        :param str publisher: Image publisher. Required if resource_group_name is not specified.
        :param str sku: Image's Stock Keeping Unit, which is the specific version of the image. Required if publisher is specified.
        """
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)

    @property
    @pulumi.getter
    def offer(self) -> str:
        """
        Name of the image to use. Required if publisher is specified.
        """
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        Image publisher. Required if resource_group_name is not specified.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> str:
        """
        Image's Stock Keeping Unit, which is the specific version of the image. Required if publisher is specified.
        """
        return pulumi.get(self, "sku")


@pulumi.output_type
class ElastigroupIntegrationKubernetes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterIdentifier":
            suggest = "cluster_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupIntegrationKubernetes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupIntegrationKubernetes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupIntegrationKubernetes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_identifier: str):
        """
        :param str cluster_identifier: The cluster ID.
        """
        pulumi.set(__self__, "cluster_identifier", cluster_identifier)

    @property
    @pulumi.getter(name="clusterIdentifier")
    def cluster_identifier(self) -> str:
        """
        The cluster ID.
        """
        return pulumi.get(self, "cluster_identifier")


@pulumi.output_type
class ElastigroupIntegrationMultaiRuntime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentId":
            suggest = "deployment_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupIntegrationMultaiRuntime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupIntegrationMultaiRuntime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupIntegrationMultaiRuntime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment_id: str):
        """
        :param str deployment_id: The deployment id you want to get
        """
        pulumi.set(__self__, "deployment_id", deployment_id)

    @property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> str:
        """
        The deployment id you want to get
        """
        return pulumi.get(self, "deployment_id")


@pulumi.output_type
class ElastigroupLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoWeight":
            suggest = "auto_weight"
        elif key == "balancerId":
            suggest = "balancer_id"
        elif key == "targetSetId":
            suggest = "target_set_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 auto_weight: Optional[bool] = None,
                 balancer_id: Optional[str] = None,
                 target_set_id: Optional[str] = None):
        """
        :param str type: The resource type. Valid values: CLASSIC, TARGET_GROUP, MULTAI_TARGET_SET.
        :param str balancer_id: The balancer ID.
        :param str target_set_id: The scale set ID associated with the load balancer.
        """
        pulumi.set(__self__, "type", type)
        if auto_weight is not None:
            pulumi.set(__self__, "auto_weight", auto_weight)
        if balancer_id is not None:
            pulumi.set(__self__, "balancer_id", balancer_id)
        if target_set_id is not None:
            pulumi.set(__self__, "target_set_id", target_set_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The resource type. Valid values: CLASSIC, TARGET_GROUP, MULTAI_TARGET_SET.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="autoWeight")
    def auto_weight(self) -> Optional[bool]:
        return pulumi.get(self, "auto_weight")

    @property
    @pulumi.getter(name="balancerId")
    def balancer_id(self) -> Optional[str]:
        """
        The balancer ID.
        """
        return pulumi.get(self, "balancer_id")

    @property
    @pulumi.getter(name="targetSetId")
    def target_set_id(self) -> Optional[str]:
        """
        The scale set ID associated with the load balancer.
        """
        return pulumi.get(self, "target_set_id")


@pulumi.output_type
class ElastigroupLogin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userName":
            suggest = "user_name"
        elif key == "sshPublicKey":
            suggest = "ssh_public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupLogin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupLogin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupLogin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_name: str,
                 password: Optional[str] = None,
                 ssh_public_key: Optional[str] = None):
        """
        :param str user_name: Set admin access for accessing your VMs.
        :param str password: Password for admin access to Windows VMs. Required for Windows product types.
        :param str ssh_public_key: SSH for admin access to Linux VMs. Required for Linux product types.
        """
        pulumi.set(__self__, "user_name", user_name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if ssh_public_key is not None:
            pulumi.set(__self__, "ssh_public_key", ssh_public_key)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        Set admin access for accessing your VMs.
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password for admin access to Windows VMs. Required for Windows product types.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="sshPublicKey")
    def ssh_public_key(self) -> Optional[str]:
        """
        SSH for admin access to Linux VMs. Required for Linux product types.
        """
        return pulumi.get(self, "ssh_public_key")


@pulumi.output_type
class ElastigroupManagedServiceIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupManagedServiceIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupManagedServiceIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupManagedServiceIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 resource_group_name: str):
        """
        :param str name: The dimension name.
        :param str resource_group_name: Vnet Resource Group Name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The dimension name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        Vnet Resource Group Name.
        """
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class ElastigroupNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "subnetName":
            suggest = "subnet_name"
        elif key == "virtualNetworkName":
            suggest = "virtual_network_name"
        elif key == "additionalIpConfigs":
            suggest = "additional_ip_configs"
        elif key == "assignPublicIp":
            suggest = "assign_public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_group_name: str,
                 subnet_name: str,
                 virtual_network_name: str,
                 additional_ip_configs: Optional[Sequence['outputs.ElastigroupNetworkAdditionalIpConfig']] = None,
                 assign_public_ip: Optional[bool] = None):
        """
        :param str resource_group_name: Vnet Resource Group Name.
        :param str subnet_name: ID of subnet.
        :param str virtual_network_name: Name of Vnet.
        :param Sequence['ElastigroupNetworkAdditionalIpConfigArgs'] additional_ip_configs: Array of additional IP configuration objects.
        """
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "subnet_name", subnet_name)
        pulumi.set(__self__, "virtual_network_name", virtual_network_name)
        if additional_ip_configs is not None:
            pulumi.set(__self__, "additional_ip_configs", additional_ip_configs)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        Vnet Resource Group Name.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> str:
        """
        ID of subnet.
        """
        return pulumi.get(self, "subnet_name")

    @property
    @pulumi.getter(name="virtualNetworkName")
    def virtual_network_name(self) -> str:
        """
        Name of Vnet.
        """
        return pulumi.get(self, "virtual_network_name")

    @property
    @pulumi.getter(name="additionalIpConfigs")
    def additional_ip_configs(self) -> Optional[Sequence['outputs.ElastigroupNetworkAdditionalIpConfig']]:
        """
        Array of additional IP configuration objects.
        """
        return pulumi.get(self, "additional_ip_configs")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        return pulumi.get(self, "assign_public_ip")


@pulumi.output_type
class ElastigroupNetworkAdditionalIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpVersion":
            suggest = "private_ip_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupNetworkAdditionalIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupNetworkAdditionalIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupNetworkAdditionalIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 private_ip_version: Optional[str] = None):
        """
        :param str name: The dimension name.
        :param str private_ip_version: Available from Azure Api-Version 2017-03-30 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Valid values: `IPv4`, `IPv6`.
        """
        pulumi.set(__self__, "name", name)
        if private_ip_version is not None:
            pulumi.set(__self__, "private_ip_version", private_ip_version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The dimension name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpVersion")
    def private_ip_version(self) -> Optional[str]:
        """
        Available from Azure Api-Version 2017-03-30 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Valid values: `IPv4`, `IPv6`.
        """
        return pulumi.get(self, "private_ip_version")


@pulumi.output_type
class ElastigroupScalingDownPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "policyName":
            suggest = "policy_name"
        elif key == "actionType":
            suggest = "action_type"
        elif key == "evaluationPeriods":
            suggest = "evaluation_periods"
        elif key == "maxTargetCapacity":
            suggest = "max_target_capacity"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupScalingDownPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupScalingDownPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupScalingDownPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 policy_name: str,
                 threshold: float,
                 action_type: Optional[str] = None,
                 adjustment: Optional[str] = None,
                 cooldown: Optional[int] = None,
                 dimensions: Optional[Sequence['outputs.ElastigroupScalingDownPolicyDimension']] = None,
                 evaluation_periods: Optional[int] = None,
                 max_target_capacity: Optional[str] = None,
                 maximum: Optional[str] = None,
                 min_target_capacity: Optional[str] = None,
                 minimum: Optional[str] = None,
                 operator: Optional[str] = None,
                 period: Optional[int] = None,
                 statistic: Optional[str] = None,
                 target: Optional[str] = None,
                 unit: Optional[str] = None):
        """
        :param str metric_name: Metric to monitor by Azure metric display name.
        :param str namespace: The namespace for the alarm's associated metric. Valid values:
        :param str policy_name: The name of the policy.
        :param float threshold: The value against which the specified statistic is compared.
        :param str action_type: The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`.
        :param str adjustment: The number of instances to add/remove to/from the target capacity when scale is needed.
        :param int cooldown: The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
        :param Sequence['ElastigroupScalingDownPolicyDimensionArgs'] dimensions: A list of dimensions describing qualities of the metric. Required when `namespace` is defined AND not `"Microsoft.Compute"`.
        :param int evaluation_periods: The number of periods over which data is compared to the specified threshold.
        :param str max_target_capacity: . The number of the desired target (and maximum) capacity
        :param str maximum: The maximal number of instances to have in the group.
        :param str min_target_capacity: . The number of the desired target (and minimum) capacity
        :param str minimum: The minimal number of instances to have in the group.
        :param str operator: The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
        :param int period: The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
        :param str statistic: The metric statistics to return. Valid values: `average`.
        :param str target: The target number of instances to have in the group.
        :param str unit: The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        Metric to monitor by Azure metric display name.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace for the alarm's associated metric. Valid values:
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> str:
        """
        The name of the policy.
        """
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        The value against which the specified statistic is compared.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        """
        The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        """
        The number of instances to add/remove to/from the target capacity when scale is needed.
        """
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[int]:
        """
        The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
        """
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ElastigroupScalingDownPolicyDimension']]:
        """
        A list of dimensions describing qualities of the metric. Required when `namespace` is defined AND not `"Microsoft.Compute"`.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        """
        The number of periods over which data is compared to the specified threshold.
        """
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[str]:
        """
        . The number of the desired target (and maximum) capacity
        """
        return pulumi.get(self, "max_target_capacity")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[str]:
        """
        The maximal number of instances to have in the group.
        """
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[str]:
        """
        . The number of the desired target (and minimum) capacity
        """
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[str]:
        """
        The minimal number of instances to have in the group.
        """
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        """
        The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        """
        The metric statistics to return. Valid values: `average`.
        """
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        The target number of instances to have in the group.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class ElastigroupScalingDownPolicyDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: The dimension name.
        :param str value: The dimension value.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The dimension name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The dimension value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ElastigroupScalingUpPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "policyName":
            suggest = "policy_name"
        elif key == "actionType":
            suggest = "action_type"
        elif key == "evaluationPeriods":
            suggest = "evaluation_periods"
        elif key == "maxTargetCapacity":
            suggest = "max_target_capacity"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupScalingUpPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupScalingUpPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupScalingUpPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 policy_name: str,
                 threshold: float,
                 action_type: Optional[str] = None,
                 adjustment: Optional[str] = None,
                 cooldown: Optional[int] = None,
                 dimensions: Optional[Sequence['outputs.ElastigroupScalingUpPolicyDimension']] = None,
                 evaluation_periods: Optional[int] = None,
                 max_target_capacity: Optional[str] = None,
                 maximum: Optional[str] = None,
                 min_target_capacity: Optional[str] = None,
                 minimum: Optional[str] = None,
                 operator: Optional[str] = None,
                 period: Optional[int] = None,
                 statistic: Optional[str] = None,
                 target: Optional[str] = None,
                 unit: Optional[str] = None):
        """
        :param str metric_name: Metric to monitor by Azure metric display name.
        :param str namespace: The namespace for the alarm's associated metric. Valid values:
        :param str policy_name: The name of the policy.
        :param float threshold: The value against which the specified statistic is compared.
        :param str action_type: The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`.
        :param str adjustment: The number of instances to add/remove to/from the target capacity when scale is needed.
        :param int cooldown: The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
        :param Sequence['ElastigroupScalingUpPolicyDimensionArgs'] dimensions: A list of dimensions describing qualities of the metric. Required when `namespace` is defined AND not `"Microsoft.Compute"`.
        :param int evaluation_periods: The number of periods over which data is compared to the specified threshold.
        :param str max_target_capacity: . The number of the desired target (and maximum) capacity
        :param str maximum: The maximal number of instances to have in the group.
        :param str min_target_capacity: . The number of the desired target (and minimum) capacity
        :param str minimum: The minimal number of instances to have in the group.
        :param str operator: The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
        :param int period: The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
        :param str statistic: The metric statistics to return. Valid values: `average`.
        :param str target: The target number of instances to have in the group.
        :param str unit: The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        Metric to monitor by Azure metric display name.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The namespace for the alarm's associated metric. Valid values:
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> str:
        """
        The name of the policy.
        """
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        The value against which the specified statistic is compared.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        """
        The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        """
        The number of instances to add/remove to/from the target capacity when scale is needed.
        """
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[int]:
        """
        The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
        """
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ElastigroupScalingUpPolicyDimension']]:
        """
        A list of dimensions describing qualities of the metric. Required when `namespace` is defined AND not `"Microsoft.Compute"`.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        """
        The number of periods over which data is compared to the specified threshold.
        """
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[str]:
        """
        . The number of the desired target (and maximum) capacity
        """
        return pulumi.get(self, "max_target_capacity")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[str]:
        """
        The maximal number of instances to have in the group.
        """
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[str]:
        """
        . The number of the desired target (and minimum) capacity
        """
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[str]:
        """
        The minimal number of instances to have in the group.
        """
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        """
        The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        """
        The metric statistics to return. Valid values: `average`.
        """
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        The target number of instances to have in the group.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class ElastigroupScalingUpPolicyDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: The dimension name.
        :param str value: The dimension value.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The dimension name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The dimension value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ElastigroupScheduledTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "adjustmentPercentage":
            suggest = "adjustment_percentage"
        elif key == "batchSizePercentage":
            suggest = "batch_size_percentage"
        elif key == "gracePeriod":
            suggest = "grace_period"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "scaleMaxCapacity":
            suggest = "scale_max_capacity"
        elif key == "scaleMinCapacity":
            suggest = "scale_min_capacity"
        elif key == "scaleTargetCapacity":
            suggest = "scale_target_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupScheduledTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupScheduledTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupScheduledTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression: str,
                 task_type: str,
                 adjustment: Optional[str] = None,
                 adjustment_percentage: Optional[str] = None,
                 batch_size_percentage: Optional[str] = None,
                 grace_period: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 scale_max_capacity: Optional[str] = None,
                 scale_min_capacity: Optional[str] = None,
                 scale_target_capacity: Optional[str] = None):
        """
        :param str cron_expression: A valid cron expression (`* * * * *`). The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script.
        :param str task_type: The task type to run. Valid Values: `backup_ami`, `scale`, `scaleUp`, `roll`, `statefulUpdateCapacity`, `statefulRecycle`.
        :param str adjustment: The number of instances to add/remove to/from the target capacity when scale is needed.
        :param str adjustment_percentage: The percent of instances to add/remove to/from the target capacity when scale is needed.
        :param str batch_size_percentage: Sets the percentage of the instances to deploy in each batch.
        :param str grace_period: Sets the grace period for new instances to become healthy.
        :param bool is_enabled: Describes whether the task is enabled. When true the task should run when false it should not run.
        :param str scale_max_capacity: The max capacity of the group. Required when ‘task_type' is ‘scale'.
        :param str scale_min_capacity: The min capacity of the group. Should be used when choosing ‘task_type' of ‘scale'.
        :param str scale_target_capacity: The target capacity of the group. Should be used when choosing ‘task_type' of ‘scale'.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "task_type", task_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if adjustment_percentage is not None:
            pulumi.set(__self__, "adjustment_percentage", adjustment_percentage)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if scale_max_capacity is not None:
            pulumi.set(__self__, "scale_max_capacity", scale_max_capacity)
        if scale_min_capacity is not None:
            pulumi.set(__self__, "scale_min_capacity", scale_min_capacity)
        if scale_target_capacity is not None:
            pulumi.set(__self__, "scale_target_capacity", scale_target_capacity)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> str:
        """
        A valid cron expression (`* * * * *`). The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script.
        """
        return pulumi.get(self, "cron_expression")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        The task type to run. Valid Values: `backup_ami`, `scale`, `scaleUp`, `roll`, `statefulUpdateCapacity`, `statefulRecycle`.
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        """
        The number of instances to add/remove to/from the target capacity when scale is needed.
        """
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter(name="adjustmentPercentage")
    def adjustment_percentage(self) -> Optional[str]:
        """
        The percent of instances to add/remove to/from the target capacity when scale is needed.
        """
        return pulumi.get(self, "adjustment_percentage")

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[str]:
        """
        Sets the percentage of the instances to deploy in each batch.
        """
        return pulumi.get(self, "batch_size_percentage")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[str]:
        """
        Sets the grace period for new instances to become healthy.
        """
        return pulumi.get(self, "grace_period")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Describes whether the task is enabled. When true the task should run when false it should not run.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="scaleMaxCapacity")
    def scale_max_capacity(self) -> Optional[str]:
        """
        The max capacity of the group. Required when ‘task_type' is ‘scale'.
        """
        return pulumi.get(self, "scale_max_capacity")

    @property
    @pulumi.getter(name="scaleMinCapacity")
    def scale_min_capacity(self) -> Optional[str]:
        """
        The min capacity of the group. Should be used when choosing ‘task_type' of ‘scale'.
        """
        return pulumi.get(self, "scale_min_capacity")

    @property
    @pulumi.getter(name="scaleTargetCapacity")
    def scale_target_capacity(self) -> Optional[str]:
        """
        The target capacity of the group. Should be used when choosing ‘task_type' of ‘scale'.
        """
        return pulumi.get(self, "scale_target_capacity")


@pulumi.output_type
class ElastigroupStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainingTimeout":
            suggest = "draining_timeout"
        elif key == "lowPriorityPercentage":
            suggest = "low_priority_percentage"
        elif key == "odCount":
            suggest = "od_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 draining_timeout: Optional[int] = None,
                 low_priority_percentage: Optional[int] = None,
                 od_count: Optional[int] = None):
        """
        :param int draining_timeout: Time (seconds) to allow the instance to be drained from incoming TCP connections and detached from MLB before terminating it during a scale-down operation.
        :param int low_priority_percentage: Percentage of Low Priority instances to maintain. Required if `od_count` is not specified.
        :param int od_count: Number of On-Demand instances to maintain. Required if low_priority_percentage is not specified.
        """
        if draining_timeout is not None:
            pulumi.set(__self__, "draining_timeout", draining_timeout)
        if low_priority_percentage is not None:
            pulumi.set(__self__, "low_priority_percentage", low_priority_percentage)
        if od_count is not None:
            pulumi.set(__self__, "od_count", od_count)

    @property
    @pulumi.getter(name="drainingTimeout")
    def draining_timeout(self) -> Optional[int]:
        """
        Time (seconds) to allow the instance to be drained from incoming TCP connections and detached from MLB before terminating it during a scale-down operation.
        """
        return pulumi.get(self, "draining_timeout")

    @property
    @pulumi.getter(name="lowPriorityPercentage")
    def low_priority_percentage(self) -> Optional[int]:
        """
        Percentage of Low Priority instances to maintain. Required if `od_count` is not specified.
        """
        return pulumi.get(self, "low_priority_percentage")

    @property
    @pulumi.getter(name="odCount")
    def od_count(self) -> Optional[int]:
        """
        Number of On-Demand instances to maintain. Required if low_priority_percentage is not specified.
        """
        return pulumi.get(self, "od_count")


@pulumi.output_type
class ElastigroupUpdatePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shouldRoll":
            suggest = "should_roll"
        elif key == "rollConfig":
            suggest = "roll_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupUpdatePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupUpdatePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupUpdatePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 should_roll: bool,
                 roll_config: Optional['outputs.ElastigroupUpdatePolicyRollConfig'] = None):
        """
        :param bool should_roll: Sets the enablement of the roll option.
        :param 'ElastigroupUpdatePolicyRollConfigArgs' roll_config: While used, you can control whether the group should perform a deployment after an update to the configuration.
        """
        pulumi.set(__self__, "should_roll", should_roll)
        if roll_config is not None:
            pulumi.set(__self__, "roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> bool:
        """
        Sets the enablement of the roll option.
        """
        return pulumi.get(self, "should_roll")

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional['outputs.ElastigroupUpdatePolicyRollConfig']:
        """
        While used, you can control whether the group should perform a deployment after an update to the configuration.
        """
        return pulumi.get(self, "roll_config")


@pulumi.output_type
class ElastigroupUpdatePolicyRollConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchSizePercentage":
            suggest = "batch_size_percentage"
        elif key == "gracePeriod":
            suggest = "grace_period"
        elif key == "healthCheckType":
            suggest = "health_check_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupUpdatePolicyRollConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupUpdatePolicyRollConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupUpdatePolicyRollConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_size_percentage: int,
                 grace_period: Optional[int] = None,
                 health_check_type: Optional[str] = None):
        """
        :param int batch_size_percentage: Sets the percentage of the instances to deploy in each batch.
        :param int grace_period: Sets the grace period for new instances to become healthy.
        :param str health_check_type: Sets the health check type to use. Valid values: `"INSTANCE_STATE"`, `"NONE"`.
        """
        pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if health_check_type is not None:
            pulumi.set(__self__, "health_check_type", health_check_type)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> int:
        """
        Sets the percentage of the instances to deploy in each batch.
        """
        return pulumi.get(self, "batch_size_percentage")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        """
        Sets the grace period for new instances to become healthy.
        """
        return pulumi.get(self, "grace_period")

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> Optional[str]:
        """
        Sets the health check type to use. Valid values: `"INSTANCE_STATE"`, `"NONE"`.
        """
        return pulumi.get(self, "health_check_type")


@pulumi.output_type
class OceanAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoscaleDown":
            suggest = "autoscale_down"
        elif key == "autoscaleHeadroom":
            suggest = "autoscale_headroom"
        elif key == "autoscaleIsEnabled":
            suggest = "autoscale_is_enabled"
        elif key == "resourceLimits":
            suggest = "resource_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale_down: Optional['outputs.OceanAutoscalerAutoscaleDown'] = None,
                 autoscale_headroom: Optional['outputs.OceanAutoscalerAutoscaleHeadroom'] = None,
                 autoscale_is_enabled: Optional[bool] = None,
                 resource_limits: Optional['outputs.OceanAutoscalerResourceLimits'] = None):
        """
        :param 'OceanAutoscalerAutoscaleDownArgs' autoscale_down: Auto Scaling scale down operations.
        :param 'OceanAutoscalerAutoscaleHeadroomArgs' autoscale_headroom: Spare Resource Capacity Management feature enables fast assignment of Pods without having to wait for new resources to be launched.
        :param bool autoscale_is_enabled: Enable the Ocean Kubernetes Autoscaler.
        :param 'OceanAutoscalerResourceLimitsArgs' resource_limits: Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        if autoscale_down is not None:
            pulumi.set(__self__, "autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)
        if autoscale_is_enabled is not None:
            pulumi.set(__self__, "autoscale_is_enabled", autoscale_is_enabled)
        if resource_limits is not None:
            pulumi.set(__self__, "resource_limits", resource_limits)

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional['outputs.OceanAutoscalerAutoscaleDown']:
        """
        Auto Scaling scale down operations.
        """
        return pulumi.get(self, "autoscale_down")

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional['outputs.OceanAutoscalerAutoscaleHeadroom']:
        """
        Spare Resource Capacity Management feature enables fast assignment of Pods without having to wait for new resources to be launched.
        """
        return pulumi.get(self, "autoscale_headroom")

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[bool]:
        """
        Enable the Ocean Kubernetes Autoscaler.
        """
        return pulumi.get(self, "autoscale_is_enabled")

    @property
    @pulumi.getter(name="resourceLimits")
    def resource_limits(self) -> Optional['outputs.OceanAutoscalerResourceLimits']:
        """
        Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        return pulumi.get(self, "resource_limits")


@pulumi.output_type
class OceanAutoscalerAutoscaleDown(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxScaleDownPercentage":
            suggest = "max_scale_down_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanAutoscalerAutoscaleDown. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanAutoscalerAutoscaleDown.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanAutoscalerAutoscaleDown.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_scale_down_percentage: Optional[float] = None):
        """
        :param float max_scale_down_percentage: Would represent the maximum % to scale-down.
        """
        if max_scale_down_percentage is not None:
            pulumi.set(__self__, "max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[float]:
        """
        Would represent the maximum % to scale-down.
        """
        return pulumi.get(self, "max_scale_down_percentage")


@pulumi.output_type
class OceanAutoscalerAutoscaleHeadroom(dict):
    def __init__(__self__, *,
                 automatic: Optional['outputs.OceanAutoscalerAutoscaleHeadroomAutomatic'] = None):
        """
        :param 'OceanAutoscalerAutoscaleHeadroomAutomaticArgs' automatic: Automatic headroom configuration.
        """
        if automatic is not None:
            pulumi.set(__self__, "automatic", automatic)

    @property
    @pulumi.getter
    def automatic(self) -> Optional['outputs.OceanAutoscalerAutoscaleHeadroomAutomatic']:
        """
        Automatic headroom configuration.
        """
        return pulumi.get(self, "automatic")


@pulumi.output_type
class OceanAutoscalerAutoscaleHeadroomAutomatic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanAutoscalerAutoscaleHeadroomAutomatic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanAutoscalerAutoscaleHeadroomAutomatic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanAutoscalerAutoscaleHeadroomAutomatic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: Optional[bool] = None,
                 percentage: Optional[int] = None):
        """
        :param bool is_enabled: Enable automatic headroom. When set to `true`, Ocean configures and optimizes headroom automatically.
        :param int percentage: Optionally set a number between 0-100 to control the percentage of total cluster resources dedicated to headroom. Relevant when `isEnabled` is toggled on.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Enable automatic headroom. When set to `true`, Ocean configures and optimizes headroom automatically.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def percentage(self) -> Optional[int]:
        """
        Optionally set a number between 0-100 to control the percentage of total cluster resources dedicated to headroom. Relevant when `isEnabled` is toggled on.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class OceanAutoscalerResourceLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxMemoryGib":
            suggest = "max_memory_gib"
        elif key == "maxVcpu":
            suggest = "max_vcpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanAutoscalerResourceLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanAutoscalerResourceLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanAutoscalerResourceLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_memory_gib: Optional[int] = None,
                 max_vcpu: Optional[int] = None):
        """
        :param int max_memory_gib: The maximum memory in GiB units that can be allocated to the cluster.
        :param int max_vcpu: The maximum cpu in vCpu units that can be allocated to the cluster.
        """
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[int]:
        """
        The maximum memory in GiB units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_memory_gib")

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[int]:
        """
        The maximum cpu in vCpu units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_vcpu")


@pulumi.output_type
class OceanExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "minorVersionAutoUpgrade":
            suggest = "minor_version_auto_upgrade"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 minor_version_auto_upgrade: Optional[bool] = None,
                 name: Optional[str] = None,
                 publisher: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str api_version: API version of the extension.
        :param bool minor_version_auto_upgrade: Toggles whether auto upgrades are allowed.
        :param str name: Name of the Load Balancer.
        :param str publisher: Image publisher.
        :param str type: The type of load balancer. Supported value: `loadBalancer`
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if minor_version_auto_upgrade is not None:
            pulumi.set(__self__, "minor_version_auto_upgrade", minor_version_auto_upgrade)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the extension.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="minorVersionAutoUpgrade")
    def minor_version_auto_upgrade(self) -> Optional[bool]:
        """
        Toggles whether auto upgrades are allowed.
        """
        return pulumi.get(self, "minor_version_auto_upgrade")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[str]:
        """
        Image publisher.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of load balancer. Supported value: `loadBalancer`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OceanHealth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gracePeriod":
            suggest = "grace_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanHealth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanHealth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanHealth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grace_period: Optional[int] = None):
        """
        :param int grace_period: The amount of time to wait, in seconds, from the moment the instance has launched before monitoring its health checks.
        """
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        """
        The amount of time to wait, in seconds, from the moment the instance has launched before monitoring its health checks.
        """
        return pulumi.get(self, "grace_period")


@pulumi.output_type
class OceanImage(dict):
    def __init__(__self__, *,
                 marketplaces: Optional[Sequence['outputs.OceanImageMarketplace']] = None):
        """
        :param Sequence['OceanImageMarketplaceArgs'] marketplaces: Select an image from Azure's Marketplace image catalogue.
        """
        if marketplaces is not None:
            pulumi.set(__self__, "marketplaces", marketplaces)

    @property
    @pulumi.getter
    def marketplaces(self) -> Optional[Sequence['outputs.OceanImageMarketplace']]:
        """
        Select an image from Azure's Marketplace image catalogue.
        """
        return pulumi.get(self, "marketplaces")


@pulumi.output_type
class OceanImageMarketplace(dict):
    def __init__(__self__, *,
                 offer: Optional[str] = None,
                 publisher: Optional[str] = None,
                 sku: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str offer: Image name.
        :param str publisher: Image publisher.
        :param str sku: Image Stock Keeping Unit (which is the specific version of the image).
        :param str version: Image version.
        """
        if offer is not None:
            pulumi.set(__self__, "offer", offer)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def offer(self) -> Optional[str]:
        """
        Image name.
        """
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[str]:
        """
        Image publisher.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> Optional[str]:
        """
        Image Stock Keeping Unit (which is the specific version of the image).
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Image version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class OceanLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendPoolNames":
            suggest = "backend_pool_names"
        elif key == "loadBalancerSku":
            suggest = "load_balancer_sku"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_pool_names: Optional[Sequence[str]] = None,
                 load_balancer_sku: Optional[str] = None,
                 name: Optional[str] = None,
                 resource_group_name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param Sequence[str] backend_pool_names: Names of the Backend Pools to register the Cluster VMs to. Each Backend Pool is a separate load balancer.
        :param str load_balancer_sku: Supported values: `Standard`, `Basic`.
        :param str name: Name of the Load Balancer.
        :param str resource_group_name: The Resource Group name of the Load Balancer.
        :param str type: The type of load balancer. Supported value: `loadBalancer`
        """
        if backend_pool_names is not None:
            pulumi.set(__self__, "backend_pool_names", backend_pool_names)
        if load_balancer_sku is not None:
            pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="backendPoolNames")
    def backend_pool_names(self) -> Optional[Sequence[str]]:
        """
        Names of the Backend Pools to register the Cluster VMs to. Each Backend Pool is a separate load balancer.
        """
        return pulumi.get(self, "backend_pool_names")

    @property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[str]:
        """
        Supported values: `Standard`, `Basic`.
        """
        return pulumi.get(self, "load_balancer_sku")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[str]:
        """
        The Resource Group name of the Load Balancer.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of load balancer. Supported value: `loadBalancer`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OceanManagedServiceIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanManagedServiceIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanManagedServiceIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanManagedServiceIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 resource_group_name: str):
        """
        :param str name: Name of the Load Balancer.
        :param str resource_group_name: The Resource Group name of the Load Balancer.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        The Resource Group name of the Load Balancer.
        """
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class OceanNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "virtualNetworkName":
            suggest = "virtual_network_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_interfaces: Optional[Sequence['outputs.OceanNetworkNetworkInterface']] = None,
                 resource_group_name: Optional[str] = None,
                 virtual_network_name: Optional[str] = None):
        """
        :param Sequence['OceanNetworkNetworkInterfaceArgs'] network_interfaces: A list of virtual network interfaces. The publicIpSku must be identical between all the network interfaces. One network interface must be set as the primary.
        :param str resource_group_name: The Resource Group name of the Load Balancer.
        :param str virtual_network_name: Virtual network.
        """
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if virtual_network_name is not None:
            pulumi.set(__self__, "virtual_network_name", virtual_network_name)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.OceanNetworkNetworkInterface']]:
        """
        A list of virtual network interfaces. The publicIpSku must be identical between all the network interfaces. One network interface must be set as the primary.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[str]:
        """
        The Resource Group name of the Load Balancer.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="virtualNetworkName")
    def virtual_network_name(self) -> Optional[str]:
        """
        Virtual network.
        """
        return pulumi.get(self, "virtual_network_name")


@pulumi.output_type
class OceanNetworkNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalIpConfigs":
            suggest = "additional_ip_configs"
        elif key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "isPrimary":
            suggest = "is_primary"
        elif key == "securityGroup":
            suggest = "security_group"
        elif key == "subnetName":
            suggest = "subnet_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNetworkNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNetworkNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNetworkNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_ip_configs: Optional[Sequence['outputs.OceanNetworkNetworkInterfaceAdditionalIpConfig']] = None,
                 assign_public_ip: Optional[bool] = None,
                 is_primary: Optional[bool] = None,
                 security_group: Optional['outputs.OceanNetworkNetworkInterfaceSecurityGroup'] = None,
                 subnet_name: Optional[str] = None):
        """
        :param Sequence['OceanNetworkNetworkInterfaceAdditionalIpConfigArgs'] additional_ip_configs: Additional configuration of network interface. The name fields between all the `additional_ip_config` must be unique.
        :param bool assign_public_ip: Assign public IP.
        :param bool is_primary: Defines whether the network interface is primary or not.
        :param str subnet_name: Subnet name.
        """
        if additional_ip_configs is not None:
            pulumi.set(__self__, "additional_ip_configs", additional_ip_configs)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if is_primary is not None:
            pulumi.set(__self__, "is_primary", is_primary)
        if security_group is not None:
            pulumi.set(__self__, "security_group", security_group)
        if subnet_name is not None:
            pulumi.set(__self__, "subnet_name", subnet_name)

    @property
    @pulumi.getter(name="additionalIpConfigs")
    def additional_ip_configs(self) -> Optional[Sequence['outputs.OceanNetworkNetworkInterfaceAdditionalIpConfig']]:
        """
        Additional configuration of network interface. The name fields between all the `additional_ip_config` must be unique.
        """
        return pulumi.get(self, "additional_ip_configs")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        Assign public IP.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> Optional[bool]:
        """
        Defines whether the network interface is primary or not.
        """
        return pulumi.get(self, "is_primary")

    @property
    @pulumi.getter(name="securityGroup")
    def security_group(self) -> Optional['outputs.OceanNetworkNetworkInterfaceSecurityGroup']:
        return pulumi.get(self, "security_group")

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[str]:
        """
        Subnet name.
        """
        return pulumi.get(self, "subnet_name")


@pulumi.output_type
class OceanNetworkNetworkInterfaceAdditionalIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpVersion":
            suggest = "private_ip_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNetworkNetworkInterfaceAdditionalIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNetworkNetworkInterfaceAdditionalIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNetworkNetworkInterfaceAdditionalIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 private_ip_version: Optional[str] = None):
        """
        :param str name: Name of the Load Balancer.
        :param str private_ip_version: Supported values: `IPv4`, `IPv6`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ip_version is not None:
            pulumi.set(__self__, "private_ip_version", private_ip_version)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpVersion")
    def private_ip_version(self) -> Optional[str]:
        """
        Supported values: `IPv4`, `IPv6`.
        """
        return pulumi.get(self, "private_ip_version")


@pulumi.output_type
class OceanNetworkNetworkInterfaceSecurityGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNetworkNetworkInterfaceSecurityGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNetworkNetworkInterfaceSecurityGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNetworkNetworkInterfaceSecurityGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 resource_group_name: Optional[str] = None):
        """
        :param str name: Name of the Load Balancer.
        :param str resource_group_name: The Resource Group name of the Load Balancer.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[str]:
        """
        The Resource Group name of the Load Balancer.
        """
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class OceanOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGb":
            suggest = "size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_gb: int,
                 type: Optional[str] = None):
        """
        :param int size_gb: The size of the OS disk in GB.
        :param str type: The type of load balancer. Supported value: `loadBalancer`
        """
        pulumi.set(__self__, "size_gb", size_gb)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> int:
        """
        The size of the OS disk in GB.
        """
        return pulumi.get(self, "size_gb")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of load balancer. Supported value: `loadBalancer`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OceanStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackToOndemand":
            suggest = "fallback_to_ondemand"
        elif key == "spotPercentage":
            suggest = "spot_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_to_ondemand: Optional[bool] = None,
                 spot_percentage: Optional[int] = None):
        """
        :param bool fallback_to_ondemand: If no spot instance markets are available, enable Ocean to launch on-demand instances instead.
        :param int spot_percentage: Percentage of Spot VMs to maintain.
        """
        if fallback_to_ondemand is not None:
            pulumi.set(__self__, "fallback_to_ondemand", fallback_to_ondemand)
        if spot_percentage is not None:
            pulumi.set(__self__, "spot_percentage", spot_percentage)

    @property
    @pulumi.getter(name="fallbackToOndemand")
    def fallback_to_ondemand(self) -> Optional[bool]:
        """
        If no spot instance markets are available, enable Ocean to launch on-demand instances instead.
        """
        return pulumi.get(self, "fallback_to_ondemand")

    @property
    @pulumi.getter(name="spotPercentage")
    def spot_percentage(self) -> Optional[int]:
        """
        Percentage of Spot VMs to maintain.
        """
        return pulumi.get(self, "spot_percentage")


@pulumi.output_type
class OceanTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: Tag key.
        :param str value: Tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanVirtualNodeGroupAutoscale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoscaleHeadroom":
            suggest = "autoscale_headroom"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanVirtualNodeGroupAutoscale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanVirtualNodeGroupAutoscale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanVirtualNodeGroupAutoscale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale_headroom: Optional['outputs.OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom'] = None):
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional['outputs.OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom']:
        return pulumi.get(self, "autoscale_headroom")


@pulumi.output_type
class OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numOfUnits":
            suggest = "num_of_units"
        elif key == "cpuPerUnit":
            suggest = "cpu_per_unit"
        elif key == "gpuPerUnit":
            suggest = "gpu_per_unit"
        elif key == "memoryPerUnit":
            suggest = "memory_per_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_of_units: int,
                 cpu_per_unit: Optional[int] = None,
                 gpu_per_unit: Optional[int] = None,
                 memory_per_unit: Optional[int] = None):
        """
        :param int num_of_units: The number of headroom units to maintain, where each unit has the defined CPU, memory and GPU.
        :param int cpu_per_unit: Configure the number of CPUs to allocate for the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param int gpu_per_unit: How many GPU cores should be allocated for headroom unit.
        :param int memory_per_unit: Configure the amount of memory (MiB) to allocate the headroom.
        """
        pulumi.set(__self__, "num_of_units", num_of_units)
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> int:
        """
        The number of headroom units to maintain, where each unit has the defined CPU, memory and GPU.
        """
        return pulumi.get(self, "num_of_units")

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[int]:
        """
        Configure the number of CPUs to allocate for the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[int]:
        """
        How many GPU cores should be allocated for headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[int]:
        """
        Configure the amount of memory (MiB) to allocate the headroom.
        """
        return pulumi.get(self, "memory_per_unit")


@pulumi.output_type
class OceanVirtualNodeGroupLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str key: Tag Key for Vms in the cluster.
        :param str value: Tag Value for VMs in the cluster.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Tag Key for Vms in the cluster.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Tag Value for VMs in the cluster.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanVirtualNodeGroupLaunchSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "osDisk":
            suggest = "os_disk"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanVirtualNodeGroupLaunchSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanVirtualNodeGroupLaunchSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanVirtualNodeGroupLaunchSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 os_disk: Optional['outputs.OceanVirtualNodeGroupLaunchSpecificationOsDisk'] = None,
                 tags: Optional[Sequence['outputs.OceanVirtualNodeGroupLaunchSpecificationTag']] = None):
        """
        :param 'OceanVirtualNodeGroupLaunchSpecificationOsDiskArgs' os_disk: Specify OS disk specification other than default.
        :param Sequence['OceanVirtualNodeGroupLaunchSpecificationTagArgs'] tags: Additional key-value pairs to be used to tag the VMs in the virtual node group.
        """
        if os_disk is not None:
            pulumi.set(__self__, "os_disk", os_disk)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="osDisk")
    def os_disk(self) -> Optional['outputs.OceanVirtualNodeGroupLaunchSpecificationOsDisk']:
        """
        Specify OS disk specification other than default.
        """
        return pulumi.get(self, "os_disk")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.OceanVirtualNodeGroupLaunchSpecificationTag']]:
        """
        Additional key-value pairs to be used to tag the VMs in the virtual node group.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class OceanVirtualNodeGroupLaunchSpecificationOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGb":
            suggest = "size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanVirtualNodeGroupLaunchSpecificationOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanVirtualNodeGroupLaunchSpecificationOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanVirtualNodeGroupLaunchSpecificationOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_gb: int,
                 type: Optional[str] = None):
        """
        :param int size_gb: The size of the OS disk in GB, Required if dataDisks is specified.
        :param str type: The type of the OS disk. Valid values: `"Standard_LRS"`, `"Premium_LRS"`, `"StandardSSD_LRS"`.
        """
        pulumi.set(__self__, "size_gb", size_gb)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> int:
        """
        The size of the OS disk in GB, Required if dataDisks is specified.
        """
        return pulumi.get(self, "size_gb")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the OS disk. Valid values: `"Standard_LRS"`, `"Premium_LRS"`, `"StandardSSD_LRS"`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OceanVirtualNodeGroupLaunchSpecificationTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: Tag Key for Vms in the cluster.
        :param str value: Tag Value for VMs in the cluster.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Tag Key for Vms in the cluster.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Tag Value for VMs in the cluster.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanVirtualNodeGroupResourceLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxInstanceCount":
            suggest = "max_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanVirtualNodeGroupResourceLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanVirtualNodeGroupResourceLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanVirtualNodeGroupResourceLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_instance_count: Optional[int] = None):
        """
        :param int max_instance_count: Option to set a maximum number of instances per virtual node group. If set, value must be greater than or equal to 0.
        """
        if max_instance_count is not None:
            pulumi.set(__self__, "max_instance_count", max_instance_count)

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> Optional[int]:
        """
        Option to set a maximum number of instances per virtual node group. If set, value must be greater than or equal to 0.
        """
        return pulumi.get(self, "max_instance_count")


@pulumi.output_type
class OceanVirtualNodeGroupTaint(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: str):
        """
        :param str effect: The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`, `"PreferNoExecute"`.
        :param str key: Tag Key for Vms in the cluster.
        :param str value: Tag Value for VMs in the cluster.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`, `"PreferNoExecute"`.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Tag Key for Vms in the cluster.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Tag Value for VMs in the cluster.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanVmSize(dict):
    def __init__(__self__, *,
                 whitelists: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] whitelists: VM types allowed in the Ocean cluster.
        """
        if whitelists is not None:
            pulumi.set(__self__, "whitelists", whitelists)

    @property
    @pulumi.getter
    def whitelists(self) -> Optional[Sequence[str]]:
        """
        VM types allowed in the Ocean cluster.
        """
        return pulumi.get(self, "whitelists")


