# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'ElastigroupHealthCheck',
    'ElastigroupImage',
    'ElastigroupImageCustom',
    'ElastigroupImageMarketplace',
    'ElastigroupIntegrationKubernetes',
    'ElastigroupIntegrationMultaiRuntime',
    'ElastigroupLoadBalancer',
    'ElastigroupLogin',
    'ElastigroupManagedServiceIdentity',
    'ElastigroupNetwork',
    'ElastigroupNetworkAdditionalIpConfig',
    'ElastigroupScalingDownPolicy',
    'ElastigroupScalingDownPolicyDimension',
    'ElastigroupScalingUpPolicy',
    'ElastigroupScalingUpPolicyDimension',
    'ElastigroupScheduledTask',
    'ElastigroupStrategy',
    'ElastigroupUpdatePolicy',
    'ElastigroupUpdatePolicyRollConfig',
    'OceanAutoscaler',
    'OceanAutoscalerAutoscaleDown',
    'OceanAutoscalerAutoscaleHeadroom',
    'OceanAutoscalerAutoscaleHeadroomAutomatic',
    'OceanAutoscalerResourceLimits',
    'OceanExtension',
    'OceanHealth',
    'OceanImage',
    'OceanImageMarketplace',
    'OceanLoadBalancer',
    'OceanManagedServiceIdentity',
    'OceanNetwork',
    'OceanNetworkNetworkInterface',
    'OceanNetworkNetworkInterfaceAdditionalIpConfig',
    'OceanNetworkNetworkInterfaceSecurityGroup',
    'OceanNpAutoscaler',
    'OceanNpAutoscalerAutoscaleDown',
    'OceanNpAutoscalerAutoscaleHeadroom',
    'OceanNpAutoscalerAutoscaleHeadroomAutomatic',
    'OceanNpAutoscalerResourceLimits',
    'OceanNpFilters',
    'OceanNpHeadroom',
    'OceanNpHealth',
    'OceanNpScheduling',
    'OceanNpSchedulingShutdownHours',
    'OceanNpTaint',
    'OceanNpVirtualNodeGroupFilters',
    'OceanNpVirtualNodeGroupHeadroom',
    'OceanNpVirtualNodeGroupTaint',
    'OceanOsDisk',
    'OceanStrategy',
    'OceanTag',
    'OceanVirtualNodeGroupAutoscale',
    'OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom',
    'OceanVirtualNodeGroupLabel',
    'OceanVirtualNodeGroupLaunchSpecification',
    'OceanVirtualNodeGroupLaunchSpecificationOsDisk',
    'OceanVirtualNodeGroupLaunchSpecificationTag',
    'OceanVirtualNodeGroupResourceLimit',
    'OceanVirtualNodeGroupTaint',
    'OceanVmSize',
]

@pulumi.output_type
class ElastigroupHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthCheckType":
            suggest = "health_check_type"
        elif key == "autoHealing":
            suggest = "auto_healing"
        elif key == "gracePeriod":
            suggest = "grace_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 health_check_type: str,
                 auto_healing: Optional[bool] = None,
                 grace_period: Optional[int] = None):
        pulumi.set(__self__, "health_check_type", health_check_type)
        if auto_healing is not None:
            pulumi.set(__self__, "auto_healing", auto_healing)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> str:
        return pulumi.get(self, "health_check_type")

    @property
    @pulumi.getter(name="autoHealing")
    def auto_healing(self) -> Optional[bool]:
        return pulumi.get(self, "auto_healing")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        return pulumi.get(self, "grace_period")


@pulumi.output_type
class ElastigroupImage(dict):
    def __init__(__self__, *,
                 customs: Optional[Sequence['outputs.ElastigroupImageCustom']] = None,
                 marketplaces: Optional[Sequence['outputs.ElastigroupImageMarketplace']] = None):
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if marketplaces is not None:
            pulumi.set(__self__, "marketplaces", marketplaces)

    @property
    @pulumi.getter
    def customs(self) -> Optional[Sequence['outputs.ElastigroupImageCustom']]:
        return pulumi.get(self, "customs")

    @property
    @pulumi.getter
    def marketplaces(self) -> Optional[Sequence['outputs.ElastigroupImageMarketplace']]:
        return pulumi.get(self, "marketplaces")


@pulumi.output_type
class ElastigroupImageCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageName":
            suggest = "image_name"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupImageCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupImageCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupImageCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_name: str,
                 resource_group_name: str):
        """
        :param str resource_group_name: Name of the Azure Resource Group where the Managed Service Identity is located.
        """
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        Name of the Azure Resource Group where the Managed Service Identity is located.
        """
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class ElastigroupImageMarketplace(dict):
    def __init__(__self__, *,
                 offer: str,
                 publisher: str,
                 sku: str):
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)

    @property
    @pulumi.getter
    def offer(self) -> str:
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> str:
        return pulumi.get(self, "sku")


@pulumi.output_type
class ElastigroupIntegrationKubernetes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterIdentifier":
            suggest = "cluster_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupIntegrationKubernetes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupIntegrationKubernetes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupIntegrationKubernetes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_identifier: str):
        pulumi.set(__self__, "cluster_identifier", cluster_identifier)

    @property
    @pulumi.getter(name="clusterIdentifier")
    def cluster_identifier(self) -> str:
        return pulumi.get(self, "cluster_identifier")


@pulumi.output_type
class ElastigroupIntegrationMultaiRuntime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentId":
            suggest = "deployment_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupIntegrationMultaiRuntime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupIntegrationMultaiRuntime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupIntegrationMultaiRuntime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment_id: str):
        pulumi.set(__self__, "deployment_id", deployment_id)

    @property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> str:
        return pulumi.get(self, "deployment_id")


@pulumi.output_type
class ElastigroupLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoWeight":
            suggest = "auto_weight"
        elif key == "balancerId":
            suggest = "balancer_id"
        elif key == "targetSetId":
            suggest = "target_set_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 auto_weight: Optional[bool] = None,
                 balancer_id: Optional[str] = None,
                 target_set_id: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if auto_weight is not None:
            pulumi.set(__self__, "auto_weight", auto_weight)
        if balancer_id is not None:
            pulumi.set(__self__, "balancer_id", balancer_id)
        if target_set_id is not None:
            pulumi.set(__self__, "target_set_id", target_set_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="autoWeight")
    def auto_weight(self) -> Optional[bool]:
        return pulumi.get(self, "auto_weight")

    @property
    @pulumi.getter(name="balancerId")
    def balancer_id(self) -> Optional[str]:
        return pulumi.get(self, "balancer_id")

    @property
    @pulumi.getter(name="targetSetId")
    def target_set_id(self) -> Optional[str]:
        return pulumi.get(self, "target_set_id")


@pulumi.output_type
class ElastigroupLogin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userName":
            suggest = "user_name"
        elif key == "sshPublicKey":
            suggest = "ssh_public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupLogin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupLogin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupLogin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_name: str,
                 password: Optional[str] = None,
                 ssh_public_key: Optional[str] = None):
        pulumi.set(__self__, "user_name", user_name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if ssh_public_key is not None:
            pulumi.set(__self__, "ssh_public_key", ssh_public_key)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="sshPublicKey")
    def ssh_public_key(self) -> Optional[str]:
        return pulumi.get(self, "ssh_public_key")


@pulumi.output_type
class ElastigroupManagedServiceIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupManagedServiceIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupManagedServiceIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupManagedServiceIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 resource_group_name: str):
        """
        :param str name: Name of the Managed Service Identity.
        :param str resource_group_name: Name of the Azure Resource Group where the Managed Service Identity is located.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Managed Service Identity.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        Name of the Azure Resource Group where the Managed Service Identity is located.
        """
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class ElastigroupNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "subnetName":
            suggest = "subnet_name"
        elif key == "virtualNetworkName":
            suggest = "virtual_network_name"
        elif key == "additionalIpConfigs":
            suggest = "additional_ip_configs"
        elif key == "assignPublicIp":
            suggest = "assign_public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_group_name: str,
                 subnet_name: str,
                 virtual_network_name: str,
                 additional_ip_configs: Optional[Sequence['outputs.ElastigroupNetworkAdditionalIpConfig']] = None,
                 assign_public_ip: Optional[bool] = None):
        """
        :param str resource_group_name: Name of the Azure Resource Group where the Managed Service Identity is located.
        """
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "subnet_name", subnet_name)
        pulumi.set(__self__, "virtual_network_name", virtual_network_name)
        if additional_ip_configs is not None:
            pulumi.set(__self__, "additional_ip_configs", additional_ip_configs)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        Name of the Azure Resource Group where the Managed Service Identity is located.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> str:
        return pulumi.get(self, "subnet_name")

    @property
    @pulumi.getter(name="virtualNetworkName")
    def virtual_network_name(self) -> str:
        return pulumi.get(self, "virtual_network_name")

    @property
    @pulumi.getter(name="additionalIpConfigs")
    def additional_ip_configs(self) -> Optional[Sequence['outputs.ElastigroupNetworkAdditionalIpConfig']]:
        return pulumi.get(self, "additional_ip_configs")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        return pulumi.get(self, "assign_public_ip")


@pulumi.output_type
class ElastigroupNetworkAdditionalIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpVersion":
            suggest = "private_ip_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupNetworkAdditionalIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupNetworkAdditionalIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupNetworkAdditionalIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 private_ip_version: Optional[str] = None):
        """
        :param str name: Name of the Managed Service Identity.
        """
        pulumi.set(__self__, "name", name)
        if private_ip_version is not None:
            pulumi.set(__self__, "private_ip_version", private_ip_version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Managed Service Identity.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpVersion")
    def private_ip_version(self) -> Optional[str]:
        return pulumi.get(self, "private_ip_version")


@pulumi.output_type
class ElastigroupScalingDownPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "policyName":
            suggest = "policy_name"
        elif key == "actionType":
            suggest = "action_type"
        elif key == "evaluationPeriods":
            suggest = "evaluation_periods"
        elif key == "maxTargetCapacity":
            suggest = "max_target_capacity"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupScalingDownPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupScalingDownPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupScalingDownPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 policy_name: str,
                 threshold: float,
                 action_type: Optional[str] = None,
                 adjustment: Optional[str] = None,
                 cooldown: Optional[int] = None,
                 dimensions: Optional[Sequence['outputs.ElastigroupScalingDownPolicyDimension']] = None,
                 evaluation_periods: Optional[int] = None,
                 max_target_capacity: Optional[str] = None,
                 maximum: Optional[str] = None,
                 min_target_capacity: Optional[str] = None,
                 minimum: Optional[str] = None,
                 operator: Optional[str] = None,
                 period: Optional[int] = None,
                 statistic: Optional[str] = None,
                 target: Optional[str] = None,
                 unit: Optional[str] = None):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> str:
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[int]:
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ElastigroupScalingDownPolicyDimension']]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "max_target_capacity")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[str]:
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[str]:
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class ElastigroupScalingDownPolicyDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: Name of the Managed Service Identity.
        :param str value: Tag Value for Vms in Elastigroup.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Managed Service Identity.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Tag Value for Vms in Elastigroup.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ElastigroupScalingUpPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "policyName":
            suggest = "policy_name"
        elif key == "actionType":
            suggest = "action_type"
        elif key == "evaluationPeriods":
            suggest = "evaluation_periods"
        elif key == "maxTargetCapacity":
            suggest = "max_target_capacity"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupScalingUpPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupScalingUpPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupScalingUpPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 policy_name: str,
                 threshold: float,
                 action_type: Optional[str] = None,
                 adjustment: Optional[str] = None,
                 cooldown: Optional[int] = None,
                 dimensions: Optional[Sequence['outputs.ElastigroupScalingUpPolicyDimension']] = None,
                 evaluation_periods: Optional[int] = None,
                 max_target_capacity: Optional[str] = None,
                 maximum: Optional[str] = None,
                 min_target_capacity: Optional[str] = None,
                 minimum: Optional[str] = None,
                 operator: Optional[str] = None,
                 period: Optional[int] = None,
                 statistic: Optional[str] = None,
                 target: Optional[str] = None,
                 unit: Optional[str] = None):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> str:
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[int]:
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ElastigroupScalingUpPolicyDimension']]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "max_target_capacity")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[str]:
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[str]:
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class ElastigroupScalingUpPolicyDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: Name of the Managed Service Identity.
        :param str value: Tag Value for Vms in Elastigroup.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Managed Service Identity.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Tag Value for Vms in Elastigroup.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ElastigroupScheduledTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "adjustmentPercentage":
            suggest = "adjustment_percentage"
        elif key == "batchSizePercentage":
            suggest = "batch_size_percentage"
        elif key == "gracePeriod":
            suggest = "grace_period"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "scaleMaxCapacity":
            suggest = "scale_max_capacity"
        elif key == "scaleMinCapacity":
            suggest = "scale_min_capacity"
        elif key == "scaleTargetCapacity":
            suggest = "scale_target_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupScheduledTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupScheduledTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupScheduledTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression: str,
                 task_type: str,
                 adjustment: Optional[str] = None,
                 adjustment_percentage: Optional[str] = None,
                 batch_size_percentage: Optional[str] = None,
                 grace_period: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 scale_max_capacity: Optional[str] = None,
                 scale_min_capacity: Optional[str] = None,
                 scale_target_capacity: Optional[str] = None):
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "task_type", task_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if adjustment_percentage is not None:
            pulumi.set(__self__, "adjustment_percentage", adjustment_percentage)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if scale_max_capacity is not None:
            pulumi.set(__self__, "scale_max_capacity", scale_max_capacity)
        if scale_min_capacity is not None:
            pulumi.set(__self__, "scale_min_capacity", scale_min_capacity)
        if scale_target_capacity is not None:
            pulumi.set(__self__, "scale_target_capacity", scale_target_capacity)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> str:
        return pulumi.get(self, "cron_expression")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter(name="adjustmentPercentage")
    def adjustment_percentage(self) -> Optional[str]:
        return pulumi.get(self, "adjustment_percentage")

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[str]:
        return pulumi.get(self, "batch_size_percentage")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[str]:
        return pulumi.get(self, "grace_period")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="scaleMaxCapacity")
    def scale_max_capacity(self) -> Optional[str]:
        return pulumi.get(self, "scale_max_capacity")

    @property
    @pulumi.getter(name="scaleMinCapacity")
    def scale_min_capacity(self) -> Optional[str]:
        return pulumi.get(self, "scale_min_capacity")

    @property
    @pulumi.getter(name="scaleTargetCapacity")
    def scale_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "scale_target_capacity")


@pulumi.output_type
class ElastigroupStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainingTimeout":
            suggest = "draining_timeout"
        elif key == "lowPriorityPercentage":
            suggest = "low_priority_percentage"
        elif key == "odCount":
            suggest = "od_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 draining_timeout: Optional[int] = None,
                 low_priority_percentage: Optional[int] = None,
                 od_count: Optional[int] = None):
        if draining_timeout is not None:
            pulumi.set(__self__, "draining_timeout", draining_timeout)
        if low_priority_percentage is not None:
            pulumi.set(__self__, "low_priority_percentage", low_priority_percentage)
        if od_count is not None:
            pulumi.set(__self__, "od_count", od_count)

    @property
    @pulumi.getter(name="drainingTimeout")
    def draining_timeout(self) -> Optional[int]:
        return pulumi.get(self, "draining_timeout")

    @property
    @pulumi.getter(name="lowPriorityPercentage")
    def low_priority_percentage(self) -> Optional[int]:
        return pulumi.get(self, "low_priority_percentage")

    @property
    @pulumi.getter(name="odCount")
    def od_count(self) -> Optional[int]:
        return pulumi.get(self, "od_count")


@pulumi.output_type
class ElastigroupUpdatePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shouldRoll":
            suggest = "should_roll"
        elif key == "rollConfig":
            suggest = "roll_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupUpdatePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupUpdatePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupUpdatePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 should_roll: bool,
                 roll_config: Optional['outputs.ElastigroupUpdatePolicyRollConfig'] = None):
        pulumi.set(__self__, "should_roll", should_roll)
        if roll_config is not None:
            pulumi.set(__self__, "roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> bool:
        return pulumi.get(self, "should_roll")

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional['outputs.ElastigroupUpdatePolicyRollConfig']:
        return pulumi.get(self, "roll_config")


@pulumi.output_type
class ElastigroupUpdatePolicyRollConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchSizePercentage":
            suggest = "batch_size_percentage"
        elif key == "gracePeriod":
            suggest = "grace_period"
        elif key == "healthCheckType":
            suggest = "health_check_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupUpdatePolicyRollConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupUpdatePolicyRollConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupUpdatePolicyRollConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_size_percentage: int,
                 grace_period: Optional[int] = None,
                 health_check_type: Optional[str] = None):
        pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if health_check_type is not None:
            pulumi.set(__self__, "health_check_type", health_check_type)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> int:
        return pulumi.get(self, "batch_size_percentage")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        return pulumi.get(self, "grace_period")

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> Optional[str]:
        return pulumi.get(self, "health_check_type")


@pulumi.output_type
class OceanAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoscaleDown":
            suggest = "autoscale_down"
        elif key == "autoscaleHeadroom":
            suggest = "autoscale_headroom"
        elif key == "autoscaleIsEnabled":
            suggest = "autoscale_is_enabled"
        elif key == "resourceLimits":
            suggest = "resource_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale_down: Optional['outputs.OceanAutoscalerAutoscaleDown'] = None,
                 autoscale_headroom: Optional['outputs.OceanAutoscalerAutoscaleHeadroom'] = None,
                 autoscale_is_enabled: Optional[bool] = None,
                 resource_limits: Optional['outputs.OceanAutoscalerResourceLimits'] = None):
        """
        :param 'OceanAutoscalerAutoscaleDownArgs' autoscale_down: Auto Scaling scale down operations.
        :param 'OceanAutoscalerAutoscaleHeadroomArgs' autoscale_headroom: Spare Resource Capacity Management feature enables fast assignment of Pods without having to wait for new resources to be launched.
        :param bool autoscale_is_enabled: Enable the Ocean Kubernetes Autoscaler.
        :param 'OceanAutoscalerResourceLimitsArgs' resource_limits: Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        if autoscale_down is not None:
            pulumi.set(__self__, "autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)
        if autoscale_is_enabled is not None:
            pulumi.set(__self__, "autoscale_is_enabled", autoscale_is_enabled)
        if resource_limits is not None:
            pulumi.set(__self__, "resource_limits", resource_limits)

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional['outputs.OceanAutoscalerAutoscaleDown']:
        """
        Auto Scaling scale down operations.
        """
        return pulumi.get(self, "autoscale_down")

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional['outputs.OceanAutoscalerAutoscaleHeadroom']:
        """
        Spare Resource Capacity Management feature enables fast assignment of Pods without having to wait for new resources to be launched.
        """
        return pulumi.get(self, "autoscale_headroom")

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[bool]:
        """
        Enable the Ocean Kubernetes Autoscaler.
        """
        return pulumi.get(self, "autoscale_is_enabled")

    @property
    @pulumi.getter(name="resourceLimits")
    def resource_limits(self) -> Optional['outputs.OceanAutoscalerResourceLimits']:
        """
        Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        return pulumi.get(self, "resource_limits")


@pulumi.output_type
class OceanAutoscalerAutoscaleDown(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxScaleDownPercentage":
            suggest = "max_scale_down_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanAutoscalerAutoscaleDown. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanAutoscalerAutoscaleDown.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanAutoscalerAutoscaleDown.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_scale_down_percentage: Optional[float] = None):
        """
        :param float max_scale_down_percentage: Would represent the maximum % to scale-down.
        """
        if max_scale_down_percentage is not None:
            pulumi.set(__self__, "max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[float]:
        """
        Would represent the maximum % to scale-down.
        """
        return pulumi.get(self, "max_scale_down_percentage")


@pulumi.output_type
class OceanAutoscalerAutoscaleHeadroom(dict):
    def __init__(__self__, *,
                 automatic: Optional['outputs.OceanAutoscalerAutoscaleHeadroomAutomatic'] = None):
        """
        :param 'OceanAutoscalerAutoscaleHeadroomAutomaticArgs' automatic: Automatic headroom configuration.
        """
        if automatic is not None:
            pulumi.set(__self__, "automatic", automatic)

    @property
    @pulumi.getter
    def automatic(self) -> Optional['outputs.OceanAutoscalerAutoscaleHeadroomAutomatic']:
        """
        Automatic headroom configuration.
        """
        return pulumi.get(self, "automatic")


@pulumi.output_type
class OceanAutoscalerAutoscaleHeadroomAutomatic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanAutoscalerAutoscaleHeadroomAutomatic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanAutoscalerAutoscaleHeadroomAutomatic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanAutoscalerAutoscaleHeadroomAutomatic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: Optional[bool] = None,
                 percentage: Optional[int] = None):
        """
        :param bool is_enabled: Enable automatic headroom. When set to `true`, Ocean configures and optimizes headroom automatically.
        :param int percentage: Optionally set a number between 0-100 to control the percentage of total cluster resources dedicated to headroom. Relevant when `isEnabled` is toggled on.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Enable automatic headroom. When set to `true`, Ocean configures and optimizes headroom automatically.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def percentage(self) -> Optional[int]:
        """
        Optionally set a number between 0-100 to control the percentage of total cluster resources dedicated to headroom. Relevant when `isEnabled` is toggled on.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class OceanAutoscalerResourceLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxMemoryGib":
            suggest = "max_memory_gib"
        elif key == "maxVcpu":
            suggest = "max_vcpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanAutoscalerResourceLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanAutoscalerResourceLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanAutoscalerResourceLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_memory_gib: Optional[int] = None,
                 max_vcpu: Optional[int] = None):
        """
        :param int max_memory_gib: The maximum memory in GiB units that can be allocated to the cluster.
        :param int max_vcpu: The maximum cpu in vCpu units that can be allocated to the cluster.
        """
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[int]:
        """
        The maximum memory in GiB units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_memory_gib")

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[int]:
        """
        The maximum cpu in vCpu units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_vcpu")


@pulumi.output_type
class OceanExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "minorVersionAutoUpgrade":
            suggest = "minor_version_auto_upgrade"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 minor_version_auto_upgrade: Optional[bool] = None,
                 name: Optional[str] = None,
                 publisher: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str api_version: API version of the extension.
        :param bool minor_version_auto_upgrade: Toggles whether auto upgrades are allowed.
        :param str name: Name of the Load Balancer.
        :param str publisher: Image publisher.
        :param str type: The type of load balancer. Supported value: `loadBalancer`
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if minor_version_auto_upgrade is not None:
            pulumi.set(__self__, "minor_version_auto_upgrade", minor_version_auto_upgrade)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the extension.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="minorVersionAutoUpgrade")
    def minor_version_auto_upgrade(self) -> Optional[bool]:
        """
        Toggles whether auto upgrades are allowed.
        """
        return pulumi.get(self, "minor_version_auto_upgrade")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[str]:
        """
        Image publisher.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of load balancer. Supported value: `loadBalancer`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OceanHealth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gracePeriod":
            suggest = "grace_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanHealth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanHealth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanHealth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grace_period: Optional[int] = None):
        """
        :param int grace_period: The amount of time to wait, in seconds, from the moment the instance has launched before monitoring its health checks.
        """
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        """
        The amount of time to wait, in seconds, from the moment the instance has launched before monitoring its health checks.
        """
        return pulumi.get(self, "grace_period")


@pulumi.output_type
class OceanImage(dict):
    def __init__(__self__, *,
                 marketplaces: Optional[Sequence['outputs.OceanImageMarketplace']] = None):
        """
        :param Sequence['OceanImageMarketplaceArgs'] marketplaces: Select an image from Azure's Marketplace image catalogue.
        """
        if marketplaces is not None:
            pulumi.set(__self__, "marketplaces", marketplaces)

    @property
    @pulumi.getter
    def marketplaces(self) -> Optional[Sequence['outputs.OceanImageMarketplace']]:
        """
        Select an image from Azure's Marketplace image catalogue.
        """
        return pulumi.get(self, "marketplaces")


@pulumi.output_type
class OceanImageMarketplace(dict):
    def __init__(__self__, *,
                 offer: Optional[str] = None,
                 publisher: Optional[str] = None,
                 sku: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str offer: Image name.
        :param str publisher: Image publisher.
        :param str sku: Image Stock Keeping Unit (which is the specific version of the image).
        :param str version: Image version.
        """
        if offer is not None:
            pulumi.set(__self__, "offer", offer)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def offer(self) -> Optional[str]:
        """
        Image name.
        """
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[str]:
        """
        Image publisher.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> Optional[str]:
        """
        Image Stock Keeping Unit (which is the specific version of the image).
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Image version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class OceanLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendPoolNames":
            suggest = "backend_pool_names"
        elif key == "loadBalancerSku":
            suggest = "load_balancer_sku"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_pool_names: Optional[Sequence[str]] = None,
                 load_balancer_sku: Optional[str] = None,
                 name: Optional[str] = None,
                 resource_group_name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param Sequence[str] backend_pool_names: Names of the Backend Pools to register the Cluster VMs to. Each Backend Pool is a separate load balancer.
        :param str load_balancer_sku: Supported values: `Standard`, `Basic`.
        :param str name: Name of the Load Balancer.
        :param str resource_group_name: The Resource Group name of the Load Balancer.
        :param str type: The type of load balancer. Supported value: `loadBalancer`
        """
        if backend_pool_names is not None:
            pulumi.set(__self__, "backend_pool_names", backend_pool_names)
        if load_balancer_sku is not None:
            pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="backendPoolNames")
    def backend_pool_names(self) -> Optional[Sequence[str]]:
        """
        Names of the Backend Pools to register the Cluster VMs to. Each Backend Pool is a separate load balancer.
        """
        return pulumi.get(self, "backend_pool_names")

    @property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[str]:
        """
        Supported values: `Standard`, `Basic`.
        """
        return pulumi.get(self, "load_balancer_sku")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[str]:
        """
        The Resource Group name of the Load Balancer.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of load balancer. Supported value: `loadBalancer`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OceanManagedServiceIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanManagedServiceIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanManagedServiceIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanManagedServiceIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 resource_group_name: str):
        """
        :param str name: Name of the Load Balancer.
        :param str resource_group_name: The Resource Group name of the Load Balancer.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        The Resource Group name of the Load Balancer.
        """
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class OceanNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "virtualNetworkName":
            suggest = "virtual_network_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_interfaces: Optional[Sequence['outputs.OceanNetworkNetworkInterface']] = None,
                 resource_group_name: Optional[str] = None,
                 virtual_network_name: Optional[str] = None):
        """
        :param Sequence['OceanNetworkNetworkInterfaceArgs'] network_interfaces: A list of virtual network interfaces. The publicIpSku must be identical between all the network interfaces. One network interface must be set as the primary.
        :param str resource_group_name: The Resource Group name of the Load Balancer.
        :param str virtual_network_name: Virtual network.
        """
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if virtual_network_name is not None:
            pulumi.set(__self__, "virtual_network_name", virtual_network_name)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.OceanNetworkNetworkInterface']]:
        """
        A list of virtual network interfaces. The publicIpSku must be identical between all the network interfaces. One network interface must be set as the primary.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[str]:
        """
        The Resource Group name of the Load Balancer.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="virtualNetworkName")
    def virtual_network_name(self) -> Optional[str]:
        """
        Virtual network.
        """
        return pulumi.get(self, "virtual_network_name")


@pulumi.output_type
class OceanNetworkNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalIpConfigs":
            suggest = "additional_ip_configs"
        elif key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "isPrimary":
            suggest = "is_primary"
        elif key == "securityGroup":
            suggest = "security_group"
        elif key == "subnetName":
            suggest = "subnet_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNetworkNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNetworkNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNetworkNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_ip_configs: Optional[Sequence['outputs.OceanNetworkNetworkInterfaceAdditionalIpConfig']] = None,
                 assign_public_ip: Optional[bool] = None,
                 is_primary: Optional[bool] = None,
                 security_group: Optional['outputs.OceanNetworkNetworkInterfaceSecurityGroup'] = None,
                 subnet_name: Optional[str] = None):
        """
        :param Sequence['OceanNetworkNetworkInterfaceAdditionalIpConfigArgs'] additional_ip_configs: Additional configuration of network interface. The name fields between all the `additional_ip_config` must be unique.
        :param bool assign_public_ip: Assign public IP.
        :param bool is_primary: Defines whether the network interface is primary or not.
        :param str subnet_name: Subnet name.
        """
        if additional_ip_configs is not None:
            pulumi.set(__self__, "additional_ip_configs", additional_ip_configs)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if is_primary is not None:
            pulumi.set(__self__, "is_primary", is_primary)
        if security_group is not None:
            pulumi.set(__self__, "security_group", security_group)
        if subnet_name is not None:
            pulumi.set(__self__, "subnet_name", subnet_name)

    @property
    @pulumi.getter(name="additionalIpConfigs")
    def additional_ip_configs(self) -> Optional[Sequence['outputs.OceanNetworkNetworkInterfaceAdditionalIpConfig']]:
        """
        Additional configuration of network interface. The name fields between all the `additional_ip_config` must be unique.
        """
        return pulumi.get(self, "additional_ip_configs")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        Assign public IP.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> Optional[bool]:
        """
        Defines whether the network interface is primary or not.
        """
        return pulumi.get(self, "is_primary")

    @property
    @pulumi.getter(name="securityGroup")
    def security_group(self) -> Optional['outputs.OceanNetworkNetworkInterfaceSecurityGroup']:
        return pulumi.get(self, "security_group")

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[str]:
        """
        Subnet name.
        """
        return pulumi.get(self, "subnet_name")


@pulumi.output_type
class OceanNetworkNetworkInterfaceAdditionalIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpVersion":
            suggest = "private_ip_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNetworkNetworkInterfaceAdditionalIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNetworkNetworkInterfaceAdditionalIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNetworkNetworkInterfaceAdditionalIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 private_ip_version: Optional[str] = None):
        """
        :param str name: Name of the Load Balancer.
        :param str private_ip_version: Supported values: `IPv4`, `IPv6`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ip_version is not None:
            pulumi.set(__self__, "private_ip_version", private_ip_version)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpVersion")
    def private_ip_version(self) -> Optional[str]:
        """
        Supported values: `IPv4`, `IPv6`.
        """
        return pulumi.get(self, "private_ip_version")


@pulumi.output_type
class OceanNetworkNetworkInterfaceSecurityGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNetworkNetworkInterfaceSecurityGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNetworkNetworkInterfaceSecurityGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNetworkNetworkInterfaceSecurityGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 resource_group_name: Optional[str] = None):
        """
        :param str name: Name of the Load Balancer.
        :param str resource_group_name: The Resource Group name of the Load Balancer.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[str]:
        """
        The Resource Group name of the Load Balancer.
        """
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class OceanNpAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoscaleDown":
            suggest = "autoscale_down"
        elif key == "autoscaleHeadroom":
            suggest = "autoscale_headroom"
        elif key == "autoscaleIsEnabled":
            suggest = "autoscale_is_enabled"
        elif key == "resourceLimits":
            suggest = "resource_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale_down: Optional['outputs.OceanNpAutoscalerAutoscaleDown'] = None,
                 autoscale_headroom: Optional['outputs.OceanNpAutoscalerAutoscaleHeadroom'] = None,
                 autoscale_is_enabled: Optional[bool] = None,
                 resource_limits: Optional['outputs.OceanNpAutoscalerResourceLimits'] = None):
        if autoscale_down is not None:
            pulumi.set(__self__, "autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)
        if autoscale_is_enabled is not None:
            pulumi.set(__self__, "autoscale_is_enabled", autoscale_is_enabled)
        if resource_limits is not None:
            pulumi.set(__self__, "resource_limits", resource_limits)

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional['outputs.OceanNpAutoscalerAutoscaleDown']:
        return pulumi.get(self, "autoscale_down")

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional['outputs.OceanNpAutoscalerAutoscaleHeadroom']:
        return pulumi.get(self, "autoscale_headroom")

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "autoscale_is_enabled")

    @property
    @pulumi.getter(name="resourceLimits")
    def resource_limits(self) -> Optional['outputs.OceanNpAutoscalerResourceLimits']:
        return pulumi.get(self, "resource_limits")


@pulumi.output_type
class OceanNpAutoscalerAutoscaleDown(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxScaleDownPercentage":
            suggest = "max_scale_down_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpAutoscalerAutoscaleDown. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpAutoscalerAutoscaleDown.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpAutoscalerAutoscaleDown.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_scale_down_percentage: Optional[int] = None):
        if max_scale_down_percentage is not None:
            pulumi.set(__self__, "max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[int]:
        return pulumi.get(self, "max_scale_down_percentage")


@pulumi.output_type
class OceanNpAutoscalerAutoscaleHeadroom(dict):
    def __init__(__self__, *,
                 automatic: Optional['outputs.OceanNpAutoscalerAutoscaleHeadroomAutomatic'] = None):
        if automatic is not None:
            pulumi.set(__self__, "automatic", automatic)

    @property
    @pulumi.getter
    def automatic(self) -> Optional['outputs.OceanNpAutoscalerAutoscaleHeadroomAutomatic']:
        return pulumi.get(self, "automatic")


@pulumi.output_type
class OceanNpAutoscalerAutoscaleHeadroomAutomatic(dict):
    def __init__(__self__, *,
                 percentage: Optional[int] = None):
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[int]:
        return pulumi.get(self, "percentage")


@pulumi.output_type
class OceanNpAutoscalerResourceLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxMemoryGib":
            suggest = "max_memory_gib"
        elif key == "maxVcpu":
            suggest = "max_vcpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpAutoscalerResourceLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpAutoscalerResourceLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpAutoscalerResourceLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_memory_gib: Optional[int] = None,
                 max_vcpu: Optional[int] = None):
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[int]:
        return pulumi.get(self, "max_memory_gib")

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[int]:
        return pulumi.get(self, "max_vcpu")


@pulumi.output_type
class OceanNpFilters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratedNetworking":
            suggest = "accelerated_networking"
        elif key == "diskPerformance":
            suggest = "disk_performance"
        elif key == "excludeSeries":
            suggest = "exclude_series"
        elif key == "maxGpu":
            suggest = "max_gpu"
        elif key == "maxMemoryGib":
            suggest = "max_memory_gib"
        elif key == "maxVcpu":
            suggest = "max_vcpu"
        elif key == "minData":
            suggest = "min_data"
        elif key == "minGpu":
            suggest = "min_gpu"
        elif key == "minMemoryGib":
            suggest = "min_memory_gib"
        elif key == "minNics":
            suggest = "min_nics"
        elif key == "minVcpu":
            suggest = "min_vcpu"
        elif key == "vmTypes":
            suggest = "vm_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerated_networking: Optional[str] = None,
                 architectures: Optional[Sequence[str]] = None,
                 disk_performance: Optional[str] = None,
                 exclude_series: Optional[Sequence[str]] = None,
                 max_gpu: Optional[float] = None,
                 max_memory_gib: Optional[float] = None,
                 max_vcpu: Optional[int] = None,
                 min_data: Optional[int] = None,
                 min_gpu: Optional[float] = None,
                 min_memory_gib: Optional[float] = None,
                 min_nics: Optional[int] = None,
                 min_vcpu: Optional[int] = None,
                 series: Optional[Sequence[str]] = None,
                 vm_types: Optional[Sequence[str]] = None):
        if accelerated_networking is not None:
            pulumi.set(__self__, "accelerated_networking", accelerated_networking)
        if architectures is not None:
            pulumi.set(__self__, "architectures", architectures)
        if disk_performance is not None:
            pulumi.set(__self__, "disk_performance", disk_performance)
        if exclude_series is not None:
            pulumi.set(__self__, "exclude_series", exclude_series)
        if max_gpu is not None:
            pulumi.set(__self__, "max_gpu", max_gpu)
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)
        if min_data is not None:
            pulumi.set(__self__, "min_data", min_data)
        if min_gpu is not None:
            pulumi.set(__self__, "min_gpu", min_gpu)
        if min_memory_gib is not None:
            pulumi.set(__self__, "min_memory_gib", min_memory_gib)
        if min_nics is not None:
            pulumi.set(__self__, "min_nics", min_nics)
        if min_vcpu is not None:
            pulumi.set(__self__, "min_vcpu", min_vcpu)
        if series is not None:
            pulumi.set(__self__, "series", series)
        if vm_types is not None:
            pulumi.set(__self__, "vm_types", vm_types)

    @property
    @pulumi.getter(name="acceleratedNetworking")
    def accelerated_networking(self) -> Optional[str]:
        return pulumi.get(self, "accelerated_networking")

    @property
    @pulumi.getter
    def architectures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "architectures")

    @property
    @pulumi.getter(name="diskPerformance")
    def disk_performance(self) -> Optional[str]:
        return pulumi.get(self, "disk_performance")

    @property
    @pulumi.getter(name="excludeSeries")
    def exclude_series(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclude_series")

    @property
    @pulumi.getter(name="maxGpu")
    def max_gpu(self) -> Optional[float]:
        return pulumi.get(self, "max_gpu")

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[float]:
        return pulumi.get(self, "max_memory_gib")

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[int]:
        return pulumi.get(self, "max_vcpu")

    @property
    @pulumi.getter(name="minData")
    def min_data(self) -> Optional[int]:
        return pulumi.get(self, "min_data")

    @property
    @pulumi.getter(name="minGpu")
    def min_gpu(self) -> Optional[float]:
        return pulumi.get(self, "min_gpu")

    @property
    @pulumi.getter(name="minMemoryGib")
    def min_memory_gib(self) -> Optional[float]:
        return pulumi.get(self, "min_memory_gib")

    @property
    @pulumi.getter(name="minNics")
    def min_nics(self) -> Optional[int]:
        return pulumi.get(self, "min_nics")

    @property
    @pulumi.getter(name="minVcpu")
    def min_vcpu(self) -> Optional[int]:
        return pulumi.get(self, "min_vcpu")

    @property
    @pulumi.getter
    def series(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "series")

    @property
    @pulumi.getter(name="vmTypes")
    def vm_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "vm_types")


@pulumi.output_type
class OceanNpHeadroom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuPerUnit":
            suggest = "cpu_per_unit"
        elif key == "gpuPerUnit":
            suggest = "gpu_per_unit"
        elif key == "memoryPerUnit":
            suggest = "memory_per_unit"
        elif key == "numOfUnits":
            suggest = "num_of_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpHeadroom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpHeadroom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpHeadroom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_per_unit: Optional[int] = None,
                 gpu_per_unit: Optional[int] = None,
                 memory_per_unit: Optional[int] = None,
                 num_of_units: Optional[int] = None):
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "cpu_per_unit")

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "gpu_per_unit")

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "memory_per_unit")

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[int]:
        return pulumi.get(self, "num_of_units")


@pulumi.output_type
class OceanNpHealth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gracePeriod":
            suggest = "grace_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpHealth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpHealth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpHealth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grace_period: Optional[int] = None):
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        return pulumi.get(self, "grace_period")


@pulumi.output_type
class OceanNpScheduling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shutdownHours":
            suggest = "shutdown_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpScheduling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpScheduling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpScheduling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 shutdown_hours: Optional['outputs.OceanNpSchedulingShutdownHours'] = None):
        if shutdown_hours is not None:
            pulumi.set(__self__, "shutdown_hours", shutdown_hours)

    @property
    @pulumi.getter(name="shutdownHours")
    def shutdown_hours(self) -> Optional['outputs.OceanNpSchedulingShutdownHours']:
        return pulumi.get(self, "shutdown_hours")


@pulumi.output_type
class OceanNpSchedulingShutdownHours(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeWindows":
            suggest = "time_windows"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpSchedulingShutdownHours. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpSchedulingShutdownHours.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpSchedulingShutdownHours.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_windows: Sequence[str],
                 is_enabled: Optional[bool] = None):
        pulumi.set(__self__, "time_windows", time_windows)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Sequence[str]:
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")


@pulumi.output_type
class OceanNpTaint(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: str):
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanNpVirtualNodeGroupFilters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratedNetworking":
            suggest = "accelerated_networking"
        elif key == "diskPerformance":
            suggest = "disk_performance"
        elif key == "excludeSeries":
            suggest = "exclude_series"
        elif key == "maxGpu":
            suggest = "max_gpu"
        elif key == "maxMemoryGib":
            suggest = "max_memory_gib"
        elif key == "maxVcpu":
            suggest = "max_vcpu"
        elif key == "minData":
            suggest = "min_data"
        elif key == "minGpu":
            suggest = "min_gpu"
        elif key == "minMemoryGib":
            suggest = "min_memory_gib"
        elif key == "minNics":
            suggest = "min_nics"
        elif key == "minVcpu":
            suggest = "min_vcpu"
        elif key == "vmTypes":
            suggest = "vm_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpVirtualNodeGroupFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpVirtualNodeGroupFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpVirtualNodeGroupFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerated_networking: Optional[str] = None,
                 architectures: Optional[Sequence[str]] = None,
                 disk_performance: Optional[str] = None,
                 exclude_series: Optional[Sequence[str]] = None,
                 max_gpu: Optional[float] = None,
                 max_memory_gib: Optional[float] = None,
                 max_vcpu: Optional[int] = None,
                 min_data: Optional[int] = None,
                 min_gpu: Optional[float] = None,
                 min_memory_gib: Optional[float] = None,
                 min_nics: Optional[int] = None,
                 min_vcpu: Optional[int] = None,
                 series: Optional[Sequence[str]] = None,
                 vm_types: Optional[Sequence[str]] = None):
        if accelerated_networking is not None:
            pulumi.set(__self__, "accelerated_networking", accelerated_networking)
        if architectures is not None:
            pulumi.set(__self__, "architectures", architectures)
        if disk_performance is not None:
            pulumi.set(__self__, "disk_performance", disk_performance)
        if exclude_series is not None:
            pulumi.set(__self__, "exclude_series", exclude_series)
        if max_gpu is not None:
            pulumi.set(__self__, "max_gpu", max_gpu)
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)
        if min_data is not None:
            pulumi.set(__self__, "min_data", min_data)
        if min_gpu is not None:
            pulumi.set(__self__, "min_gpu", min_gpu)
        if min_memory_gib is not None:
            pulumi.set(__self__, "min_memory_gib", min_memory_gib)
        if min_nics is not None:
            pulumi.set(__self__, "min_nics", min_nics)
        if min_vcpu is not None:
            pulumi.set(__self__, "min_vcpu", min_vcpu)
        if series is not None:
            pulumi.set(__self__, "series", series)
        if vm_types is not None:
            pulumi.set(__self__, "vm_types", vm_types)

    @property
    @pulumi.getter(name="acceleratedNetworking")
    def accelerated_networking(self) -> Optional[str]:
        return pulumi.get(self, "accelerated_networking")

    @property
    @pulumi.getter
    def architectures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "architectures")

    @property
    @pulumi.getter(name="diskPerformance")
    def disk_performance(self) -> Optional[str]:
        return pulumi.get(self, "disk_performance")

    @property
    @pulumi.getter(name="excludeSeries")
    def exclude_series(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclude_series")

    @property
    @pulumi.getter(name="maxGpu")
    def max_gpu(self) -> Optional[float]:
        return pulumi.get(self, "max_gpu")

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[float]:
        return pulumi.get(self, "max_memory_gib")

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[int]:
        return pulumi.get(self, "max_vcpu")

    @property
    @pulumi.getter(name="minData")
    def min_data(self) -> Optional[int]:
        return pulumi.get(self, "min_data")

    @property
    @pulumi.getter(name="minGpu")
    def min_gpu(self) -> Optional[float]:
        return pulumi.get(self, "min_gpu")

    @property
    @pulumi.getter(name="minMemoryGib")
    def min_memory_gib(self) -> Optional[float]:
        return pulumi.get(self, "min_memory_gib")

    @property
    @pulumi.getter(name="minNics")
    def min_nics(self) -> Optional[int]:
        return pulumi.get(self, "min_nics")

    @property
    @pulumi.getter(name="minVcpu")
    def min_vcpu(self) -> Optional[int]:
        return pulumi.get(self, "min_vcpu")

    @property
    @pulumi.getter
    def series(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "series")

    @property
    @pulumi.getter(name="vmTypes")
    def vm_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "vm_types")


@pulumi.output_type
class OceanNpVirtualNodeGroupHeadroom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuPerUnit":
            suggest = "cpu_per_unit"
        elif key == "gpuPerUnit":
            suggest = "gpu_per_unit"
        elif key == "memoryPerUnit":
            suggest = "memory_per_unit"
        elif key == "numOfUnits":
            suggest = "num_of_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpVirtualNodeGroupHeadroom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpVirtualNodeGroupHeadroom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpVirtualNodeGroupHeadroom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_per_unit: Optional[int] = None,
                 gpu_per_unit: Optional[int] = None,
                 memory_per_unit: Optional[int] = None,
                 num_of_units: Optional[int] = None):
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "cpu_per_unit")

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "gpu_per_unit")

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "memory_per_unit")

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[int]:
        return pulumi.get(self, "num_of_units")


@pulumi.output_type
class OceanNpVirtualNodeGroupTaint(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: str):
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGb":
            suggest = "size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_gb: int,
                 type: Optional[str] = None):
        """
        :param int size_gb: The size of the OS disk in GB.
        :param str type: The type of load balancer. Supported value: `loadBalancer`
        """
        pulumi.set(__self__, "size_gb", size_gb)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> int:
        """
        The size of the OS disk in GB.
        """
        return pulumi.get(self, "size_gb")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of load balancer. Supported value: `loadBalancer`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OceanStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackToOndemand":
            suggest = "fallback_to_ondemand"
        elif key == "spotPercentage":
            suggest = "spot_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_to_ondemand: Optional[bool] = None,
                 spot_percentage: Optional[int] = None):
        """
        :param bool fallback_to_ondemand: If no spot instance markets are available, enable Ocean to launch on-demand instances instead.
        :param int spot_percentage: Percentage of Spot VMs to maintain.
        """
        if fallback_to_ondemand is not None:
            pulumi.set(__self__, "fallback_to_ondemand", fallback_to_ondemand)
        if spot_percentage is not None:
            pulumi.set(__self__, "spot_percentage", spot_percentage)

    @property
    @pulumi.getter(name="fallbackToOndemand")
    def fallback_to_ondemand(self) -> Optional[bool]:
        """
        If no spot instance markets are available, enable Ocean to launch on-demand instances instead.
        """
        return pulumi.get(self, "fallback_to_ondemand")

    @property
    @pulumi.getter(name="spotPercentage")
    def spot_percentage(self) -> Optional[int]:
        """
        Percentage of Spot VMs to maintain.
        """
        return pulumi.get(self, "spot_percentage")


@pulumi.output_type
class OceanTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: Tag key.
        :param str value: Tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanVirtualNodeGroupAutoscale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoHeadroomPercentage":
            suggest = "auto_headroom_percentage"
        elif key == "autoscaleHeadrooms":
            suggest = "autoscale_headrooms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanVirtualNodeGroupAutoscale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanVirtualNodeGroupAutoscale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanVirtualNodeGroupAutoscale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_headroom_percentage: Optional[int] = None,
                 autoscale_headrooms: Optional[Sequence['outputs.OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom']] = None):
        """
        :param int auto_headroom_percentage: Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when `cluster.autoScaler.headroom.automatic.is_enabled` = true is set on the Ocean cluster.
        """
        if auto_headroom_percentage is not None:
            pulumi.set(__self__, "auto_headroom_percentage", auto_headroom_percentage)
        if autoscale_headrooms is not None:
            pulumi.set(__self__, "autoscale_headrooms", autoscale_headrooms)

    @property
    @pulumi.getter(name="autoHeadroomPercentage")
    def auto_headroom_percentage(self) -> Optional[int]:
        """
        Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when `cluster.autoScaler.headroom.automatic.is_enabled` = true is set on the Ocean cluster.
        """
        return pulumi.get(self, "auto_headroom_percentage")

    @property
    @pulumi.getter(name="autoscaleHeadrooms")
    def autoscale_headrooms(self) -> Optional[Sequence['outputs.OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom']]:
        return pulumi.get(self, "autoscale_headrooms")


@pulumi.output_type
class OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numOfUnits":
            suggest = "num_of_units"
        elif key == "cpuPerUnit":
            suggest = "cpu_per_unit"
        elif key == "gpuPerUnit":
            suggest = "gpu_per_unit"
        elif key == "memoryPerUnit":
            suggest = "memory_per_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_of_units: int,
                 cpu_per_unit: Optional[int] = None,
                 gpu_per_unit: Optional[int] = None,
                 memory_per_unit: Optional[int] = None):
        """
        :param int num_of_units: The number of headroom units to maintain, where each unit has the defined CPU, memory and GPU.
        :param int cpu_per_unit: Configure the number of CPUs to allocate for the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param int gpu_per_unit: How many GPU cores should be allocated for headroom unit.
        :param int memory_per_unit: Configure the amount of memory (MiB) to allocate the headroom.
        """
        pulumi.set(__self__, "num_of_units", num_of_units)
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> int:
        """
        The number of headroom units to maintain, where each unit has the defined CPU, memory and GPU.
        """
        return pulumi.get(self, "num_of_units")

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[int]:
        """
        Configure the number of CPUs to allocate for the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[int]:
        """
        How many GPU cores should be allocated for headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[int]:
        """
        Configure the amount of memory (MiB) to allocate the headroom.
        """
        return pulumi.get(self, "memory_per_unit")


@pulumi.output_type
class OceanVirtualNodeGroupLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str key: Tag Key for Vms in the cluster.
        :param str value: Tag Value for VMs in the cluster.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Tag Key for Vms in the cluster.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Tag Value for VMs in the cluster.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanVirtualNodeGroupLaunchSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPods":
            suggest = "max_pods"
        elif key == "osDisk":
            suggest = "os_disk"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanVirtualNodeGroupLaunchSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanVirtualNodeGroupLaunchSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanVirtualNodeGroupLaunchSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_pods: Optional[int] = None,
                 os_disk: Optional['outputs.OceanVirtualNodeGroupLaunchSpecificationOsDisk'] = None,
                 tags: Optional[Sequence['outputs.OceanVirtualNodeGroupLaunchSpecificationTag']] = None):
        """
        :param int max_pods: The maximum number of pods per node in an AKS cluster.
        :param 'OceanVirtualNodeGroupLaunchSpecificationOsDiskArgs' os_disk: Specify OS disk specification other than default.
        :param Sequence['OceanVirtualNodeGroupLaunchSpecificationTagArgs'] tags: Additional key-value pairs to be used to tag the VMs in the virtual node group.
        """
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if os_disk is not None:
            pulumi.set(__self__, "os_disk", os_disk)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[int]:
        """
        The maximum number of pods per node in an AKS cluster.
        """
        return pulumi.get(self, "max_pods")

    @property
    @pulumi.getter(name="osDisk")
    def os_disk(self) -> Optional['outputs.OceanVirtualNodeGroupLaunchSpecificationOsDisk']:
        """
        Specify OS disk specification other than default.
        """
        return pulumi.get(self, "os_disk")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.OceanVirtualNodeGroupLaunchSpecificationTag']]:
        """
        Additional key-value pairs to be used to tag the VMs in the virtual node group.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class OceanVirtualNodeGroupLaunchSpecificationOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGb":
            suggest = "size_gb"
        elif key == "utilizeEphemeralStorage":
            suggest = "utilize_ephemeral_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanVirtualNodeGroupLaunchSpecificationOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanVirtualNodeGroupLaunchSpecificationOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanVirtualNodeGroupLaunchSpecificationOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_gb: int,
                 type: Optional[str] = None,
                 utilize_ephemeral_storage: Optional[bool] = None):
        """
        :param int size_gb: The size of the OS disk in GB, Required if dataDisks is specified.
        :param str type: The type of the OS disk. Valid values: `"Standard_LRS"`, `"Premium_LRS"`, `"StandardSSD_LRS"`.
        :param bool utilize_ephemeral_storage: Flag to enable/disable the Ephemeral OS Disk utilization.
        """
        pulumi.set(__self__, "size_gb", size_gb)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if utilize_ephemeral_storage is not None:
            pulumi.set(__self__, "utilize_ephemeral_storage", utilize_ephemeral_storage)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> int:
        """
        The size of the OS disk in GB, Required if dataDisks is specified.
        """
        return pulumi.get(self, "size_gb")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the OS disk. Valid values: `"Standard_LRS"`, `"Premium_LRS"`, `"StandardSSD_LRS"`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="utilizeEphemeralStorage")
    def utilize_ephemeral_storage(self) -> Optional[bool]:
        """
        Flag to enable/disable the Ephemeral OS Disk utilization.
        """
        return pulumi.get(self, "utilize_ephemeral_storage")


@pulumi.output_type
class OceanVirtualNodeGroupLaunchSpecificationTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: Tag Key for Vms in the cluster.
        :param str value: Tag Value for VMs in the cluster.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Tag Key for Vms in the cluster.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Tag Value for VMs in the cluster.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanVirtualNodeGroupResourceLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxInstanceCount":
            suggest = "max_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanVirtualNodeGroupResourceLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanVirtualNodeGroupResourceLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanVirtualNodeGroupResourceLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_instance_count: Optional[int] = None):
        """
        :param int max_instance_count: Option to set a maximum number of instances per virtual node group. If set, value must be greater than or equal to 0.
        """
        if max_instance_count is not None:
            pulumi.set(__self__, "max_instance_count", max_instance_count)

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> Optional[int]:
        """
        Option to set a maximum number of instances per virtual node group. If set, value must be greater than or equal to 0.
        """
        return pulumi.get(self, "max_instance_count")


@pulumi.output_type
class OceanVirtualNodeGroupTaint(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: str):
        """
        :param str effect: The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`, `"PreferNoExecute"`.
        :param str key: Tag Key for Vms in the cluster.
        :param str value: Tag Value for VMs in the cluster.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`, `"PreferNoExecute"`.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Tag Key for Vms in the cluster.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Tag Value for VMs in the cluster.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanVmSize(dict):
    def __init__(__self__, *,
                 whitelists: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] whitelists: VM types allowed in the Ocean cluster.
        """
        if whitelists is not None:
            pulumi.set(__self__, "whitelists", whitelists)

    @property
    @pulumi.getter
    def whitelists(self) -> Optional[Sequence[str]]:
        """
        VM types allowed in the Ocean cluster.
        """
        return pulumi.get(self, "whitelists")


