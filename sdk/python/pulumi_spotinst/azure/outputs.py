# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'ElastigroupHealthCheck',
    'ElastigroupImage',
    'ElastigroupImageCustom',
    'ElastigroupImageMarketplace',
    'ElastigroupIntegrationKubernetes',
    'ElastigroupIntegrationMultaiRuntime',
    'ElastigroupLoadBalancer',
    'ElastigroupLogin',
    'ElastigroupManagedServiceIdentity',
    'ElastigroupNetwork',
    'ElastigroupNetworkAdditionalIpConfig',
    'ElastigroupScalingDownPolicy',
    'ElastigroupScalingDownPolicyDimension',
    'ElastigroupScalingUpPolicy',
    'ElastigroupScalingUpPolicyDimension',
    'ElastigroupScheduledTask',
    'ElastigroupStrategy',
    'ElastigroupUpdatePolicy',
    'ElastigroupUpdatePolicyRollConfig',
    'OceanAutoscaler',
    'OceanAutoscalerAutoscaleDown',
    'OceanAutoscalerAutoscaleHeadroom',
    'OceanAutoscalerAutoscaleHeadroomAutomatic',
    'OceanAutoscalerResourceLimits',
    'OceanExtension',
    'OceanHealth',
    'OceanImage',
    'OceanImageMarketplace',
    'OceanLoadBalancer',
    'OceanManagedServiceIdentity',
    'OceanNetwork',
    'OceanNetworkNetworkInterface',
    'OceanNetworkNetworkInterfaceAdditionalIpConfig',
    'OceanNetworkNetworkInterfaceSecurityGroup',
    'OceanNpAutoscaler',
    'OceanNpAutoscalerAutoscaleDown',
    'OceanNpAutoscalerAutoscaleHeadroom',
    'OceanNpAutoscalerAutoscaleHeadroomAutomatic',
    'OceanNpAutoscalerResourceLimits',
    'OceanNpFilters',
    'OceanNpHeadroom',
    'OceanNpHealth',
    'OceanNpScheduling',
    'OceanNpSchedulingShutdownHours',
    'OceanNpTaint',
    'OceanNpVirtualNodeGroupFilters',
    'OceanNpVirtualNodeGroupHeadroom',
    'OceanNpVirtualNodeGroupTaint',
    'OceanOsDisk',
    'OceanStrategy',
    'OceanTag',
    'OceanVirtualNodeGroupAutoscale',
    'OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom',
    'OceanVirtualNodeGroupLabel',
    'OceanVirtualNodeGroupLaunchSpecification',
    'OceanVirtualNodeGroupLaunchSpecificationOsDisk',
    'OceanVirtualNodeGroupLaunchSpecificationTag',
    'OceanVirtualNodeGroupResourceLimit',
    'OceanVirtualNodeGroupTaint',
    'OceanVmSize',
]

@pulumi.output_type
class ElastigroupHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthCheckType":
            suggest = "health_check_type"
        elif key == "autoHealing":
            suggest = "auto_healing"
        elif key == "gracePeriod":
            suggest = "grace_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 health_check_type: str,
                 auto_healing: Optional[bool] = None,
                 grace_period: Optional[int] = None):
        ElastigroupHealthCheck._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            health_check_type=health_check_type,
            auto_healing=auto_healing,
            grace_period=grace_period,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             health_check_type: str,
             auto_healing: Optional[bool] = None,
             grace_period: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("health_check_type", health_check_type)
        if auto_healing is not None:
            _setter("auto_healing", auto_healing)
        if grace_period is not None:
            _setter("grace_period", grace_period)

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> str:
        return pulumi.get(self, "health_check_type")

    @property
    @pulumi.getter(name="autoHealing")
    def auto_healing(self) -> Optional[bool]:
        return pulumi.get(self, "auto_healing")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        return pulumi.get(self, "grace_period")


@pulumi.output_type
class ElastigroupImage(dict):
    def __init__(__self__, *,
                 customs: Optional[Sequence['outputs.ElastigroupImageCustom']] = None,
                 marketplaces: Optional[Sequence['outputs.ElastigroupImageMarketplace']] = None):
        ElastigroupImage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            customs=customs,
            marketplaces=marketplaces,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             customs: Optional[Sequence['outputs.ElastigroupImageCustom']] = None,
             marketplaces: Optional[Sequence['outputs.ElastigroupImageMarketplace']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if customs is not None:
            _setter("customs", customs)
        if marketplaces is not None:
            _setter("marketplaces", marketplaces)

    @property
    @pulumi.getter
    def customs(self) -> Optional[Sequence['outputs.ElastigroupImageCustom']]:
        return pulumi.get(self, "customs")

    @property
    @pulumi.getter
    def marketplaces(self) -> Optional[Sequence['outputs.ElastigroupImageMarketplace']]:
        return pulumi.get(self, "marketplaces")


@pulumi.output_type
class ElastigroupImageCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageName":
            suggest = "image_name"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupImageCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupImageCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupImageCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_name: str,
                 resource_group_name: str):
        """
        :param str resource_group_name: Name of the Azure Resource Group where the Managed Service Identity is located.
        """
        ElastigroupImageCustom._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            image_name=image_name,
            resource_group_name=resource_group_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             image_name: str,
             resource_group_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("image_name", image_name)
        _setter("resource_group_name", resource_group_name)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> str:
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        Name of the Azure Resource Group where the Managed Service Identity is located.
        """
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class ElastigroupImageMarketplace(dict):
    def __init__(__self__, *,
                 offer: str,
                 publisher: str,
                 sku: str):
        ElastigroupImageMarketplace._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            offer=offer,
            publisher=publisher,
            sku=sku,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             offer: str,
             publisher: str,
             sku: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("offer", offer)
        _setter("publisher", publisher)
        _setter("sku", sku)

    @property
    @pulumi.getter
    def offer(self) -> str:
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> str:
        return pulumi.get(self, "sku")


@pulumi.output_type
class ElastigroupIntegrationKubernetes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterIdentifier":
            suggest = "cluster_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupIntegrationKubernetes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupIntegrationKubernetes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupIntegrationKubernetes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_identifier: str):
        ElastigroupIntegrationKubernetes._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_identifier=cluster_identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_identifier: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cluster_identifier", cluster_identifier)

    @property
    @pulumi.getter(name="clusterIdentifier")
    def cluster_identifier(self) -> str:
        return pulumi.get(self, "cluster_identifier")


@pulumi.output_type
class ElastigroupIntegrationMultaiRuntime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentId":
            suggest = "deployment_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupIntegrationMultaiRuntime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupIntegrationMultaiRuntime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupIntegrationMultaiRuntime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment_id: str):
        ElastigroupIntegrationMultaiRuntime._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            deployment_id=deployment_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             deployment_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("deployment_id", deployment_id)

    @property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> str:
        return pulumi.get(self, "deployment_id")


@pulumi.output_type
class ElastigroupLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoWeight":
            suggest = "auto_weight"
        elif key == "balancerId":
            suggest = "balancer_id"
        elif key == "targetSetId":
            suggest = "target_set_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 auto_weight: Optional[bool] = None,
                 balancer_id: Optional[str] = None,
                 target_set_id: Optional[str] = None):
        ElastigroupLoadBalancer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            auto_weight=auto_weight,
            balancer_id=balancer_id,
            target_set_id=target_set_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             auto_weight: Optional[bool] = None,
             balancer_id: Optional[str] = None,
             target_set_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if auto_weight is not None:
            _setter("auto_weight", auto_weight)
        if balancer_id is not None:
            _setter("balancer_id", balancer_id)
        if target_set_id is not None:
            _setter("target_set_id", target_set_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="autoWeight")
    def auto_weight(self) -> Optional[bool]:
        return pulumi.get(self, "auto_weight")

    @property
    @pulumi.getter(name="balancerId")
    def balancer_id(self) -> Optional[str]:
        return pulumi.get(self, "balancer_id")

    @property
    @pulumi.getter(name="targetSetId")
    def target_set_id(self) -> Optional[str]:
        return pulumi.get(self, "target_set_id")


@pulumi.output_type
class ElastigroupLogin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userName":
            suggest = "user_name"
        elif key == "sshPublicKey":
            suggest = "ssh_public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupLogin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupLogin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupLogin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_name: str,
                 password: Optional[str] = None,
                 ssh_public_key: Optional[str] = None):
        ElastigroupLogin._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            user_name=user_name,
            password=password,
            ssh_public_key=ssh_public_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             user_name: str,
             password: Optional[str] = None,
             ssh_public_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("user_name", user_name)
        if password is not None:
            _setter("password", password)
        if ssh_public_key is not None:
            _setter("ssh_public_key", ssh_public_key)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="sshPublicKey")
    def ssh_public_key(self) -> Optional[str]:
        return pulumi.get(self, "ssh_public_key")


@pulumi.output_type
class ElastigroupManagedServiceIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupManagedServiceIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupManagedServiceIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupManagedServiceIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 resource_group_name: str):
        """
        :param str name: Name of the Managed Service Identity.
        :param str resource_group_name: Name of the Azure Resource Group where the Managed Service Identity is located.
        """
        ElastigroupManagedServiceIdentity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            resource_group_name=resource_group_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             resource_group_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Managed Service Identity.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        Name of the Azure Resource Group where the Managed Service Identity is located.
        """
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class ElastigroupNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "subnetName":
            suggest = "subnet_name"
        elif key == "virtualNetworkName":
            suggest = "virtual_network_name"
        elif key == "additionalIpConfigs":
            suggest = "additional_ip_configs"
        elif key == "assignPublicIp":
            suggest = "assign_public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_group_name: str,
                 subnet_name: str,
                 virtual_network_name: str,
                 additional_ip_configs: Optional[Sequence['outputs.ElastigroupNetworkAdditionalIpConfig']] = None,
                 assign_public_ip: Optional[bool] = None):
        """
        :param str resource_group_name: Name of the Azure Resource Group where the Managed Service Identity is located.
        """
        ElastigroupNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_group_name=resource_group_name,
            subnet_name=subnet_name,
            virtual_network_name=virtual_network_name,
            additional_ip_configs=additional_ip_configs,
            assign_public_ip=assign_public_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_group_name: str,
             subnet_name: str,
             virtual_network_name: str,
             additional_ip_configs: Optional[Sequence['outputs.ElastigroupNetworkAdditionalIpConfig']] = None,
             assign_public_ip: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("resource_group_name", resource_group_name)
        _setter("subnet_name", subnet_name)
        _setter("virtual_network_name", virtual_network_name)
        if additional_ip_configs is not None:
            _setter("additional_ip_configs", additional_ip_configs)
        if assign_public_ip is not None:
            _setter("assign_public_ip", assign_public_ip)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        Name of the Azure Resource Group where the Managed Service Identity is located.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> str:
        return pulumi.get(self, "subnet_name")

    @property
    @pulumi.getter(name="virtualNetworkName")
    def virtual_network_name(self) -> str:
        return pulumi.get(self, "virtual_network_name")

    @property
    @pulumi.getter(name="additionalIpConfigs")
    def additional_ip_configs(self) -> Optional[Sequence['outputs.ElastigroupNetworkAdditionalIpConfig']]:
        return pulumi.get(self, "additional_ip_configs")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        return pulumi.get(self, "assign_public_ip")


@pulumi.output_type
class ElastigroupNetworkAdditionalIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpVersion":
            suggest = "private_ip_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupNetworkAdditionalIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupNetworkAdditionalIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupNetworkAdditionalIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 private_ip_version: Optional[str] = None):
        """
        :param str name: Name of the Managed Service Identity.
        """
        ElastigroupNetworkAdditionalIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            private_ip_version=private_ip_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             private_ip_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if private_ip_version is not None:
            _setter("private_ip_version", private_ip_version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Managed Service Identity.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpVersion")
    def private_ip_version(self) -> Optional[str]:
        return pulumi.get(self, "private_ip_version")


@pulumi.output_type
class ElastigroupScalingDownPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "policyName":
            suggest = "policy_name"
        elif key == "actionType":
            suggest = "action_type"
        elif key == "evaluationPeriods":
            suggest = "evaluation_periods"
        elif key == "maxTargetCapacity":
            suggest = "max_target_capacity"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupScalingDownPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupScalingDownPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupScalingDownPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 policy_name: str,
                 threshold: float,
                 action_type: Optional[str] = None,
                 adjustment: Optional[str] = None,
                 cooldown: Optional[int] = None,
                 dimensions: Optional[Sequence['outputs.ElastigroupScalingDownPolicyDimension']] = None,
                 evaluation_periods: Optional[int] = None,
                 max_target_capacity: Optional[str] = None,
                 maximum: Optional[str] = None,
                 min_target_capacity: Optional[str] = None,
                 minimum: Optional[str] = None,
                 operator: Optional[str] = None,
                 period: Optional[int] = None,
                 statistic: Optional[str] = None,
                 target: Optional[str] = None,
                 unit: Optional[str] = None):
        ElastigroupScalingDownPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_name=metric_name,
            namespace=namespace,
            policy_name=policy_name,
            threshold=threshold,
            action_type=action_type,
            adjustment=adjustment,
            cooldown=cooldown,
            dimensions=dimensions,
            evaluation_periods=evaluation_periods,
            max_target_capacity=max_target_capacity,
            maximum=maximum,
            min_target_capacity=min_target_capacity,
            minimum=minimum,
            operator=operator,
            period=period,
            statistic=statistic,
            target=target,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_name: str,
             namespace: str,
             policy_name: str,
             threshold: float,
             action_type: Optional[str] = None,
             adjustment: Optional[str] = None,
             cooldown: Optional[int] = None,
             dimensions: Optional[Sequence['outputs.ElastigroupScalingDownPolicyDimension']] = None,
             evaluation_periods: Optional[int] = None,
             max_target_capacity: Optional[str] = None,
             maximum: Optional[str] = None,
             min_target_capacity: Optional[str] = None,
             minimum: Optional[str] = None,
             operator: Optional[str] = None,
             period: Optional[int] = None,
             statistic: Optional[str] = None,
             target: Optional[str] = None,
             unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric_name", metric_name)
        _setter("namespace", namespace)
        _setter("policy_name", policy_name)
        _setter("threshold", threshold)
        if action_type is not None:
            _setter("action_type", action_type)
        if adjustment is not None:
            _setter("adjustment", adjustment)
        if cooldown is not None:
            _setter("cooldown", cooldown)
        if dimensions is not None:
            _setter("dimensions", dimensions)
        if evaluation_periods is not None:
            _setter("evaluation_periods", evaluation_periods)
        if max_target_capacity is not None:
            _setter("max_target_capacity", max_target_capacity)
        if maximum is not None:
            _setter("maximum", maximum)
        if min_target_capacity is not None:
            _setter("min_target_capacity", min_target_capacity)
        if minimum is not None:
            _setter("minimum", minimum)
        if operator is not None:
            _setter("operator", operator)
        if period is not None:
            _setter("period", period)
        if statistic is not None:
            _setter("statistic", statistic)
        if target is not None:
            _setter("target", target)
        if unit is not None:
            _setter("unit", unit)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> str:
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[int]:
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ElastigroupScalingDownPolicyDimension']]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "max_target_capacity")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[str]:
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[str]:
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class ElastigroupScalingDownPolicyDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: Name of the Managed Service Identity.
        :param str value: Tag Value for Vms in Elastigroup.
        """
        ElastigroupScalingDownPolicyDimension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Managed Service Identity.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Tag Value for Vms in Elastigroup.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ElastigroupScalingUpPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "policyName":
            suggest = "policy_name"
        elif key == "actionType":
            suggest = "action_type"
        elif key == "evaluationPeriods":
            suggest = "evaluation_periods"
        elif key == "maxTargetCapacity":
            suggest = "max_target_capacity"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupScalingUpPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupScalingUpPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupScalingUpPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 policy_name: str,
                 threshold: float,
                 action_type: Optional[str] = None,
                 adjustment: Optional[str] = None,
                 cooldown: Optional[int] = None,
                 dimensions: Optional[Sequence['outputs.ElastigroupScalingUpPolicyDimension']] = None,
                 evaluation_periods: Optional[int] = None,
                 max_target_capacity: Optional[str] = None,
                 maximum: Optional[str] = None,
                 min_target_capacity: Optional[str] = None,
                 minimum: Optional[str] = None,
                 operator: Optional[str] = None,
                 period: Optional[int] = None,
                 statistic: Optional[str] = None,
                 target: Optional[str] = None,
                 unit: Optional[str] = None):
        ElastigroupScalingUpPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_name=metric_name,
            namespace=namespace,
            policy_name=policy_name,
            threshold=threshold,
            action_type=action_type,
            adjustment=adjustment,
            cooldown=cooldown,
            dimensions=dimensions,
            evaluation_periods=evaluation_periods,
            max_target_capacity=max_target_capacity,
            maximum=maximum,
            min_target_capacity=min_target_capacity,
            minimum=minimum,
            operator=operator,
            period=period,
            statistic=statistic,
            target=target,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_name: str,
             namespace: str,
             policy_name: str,
             threshold: float,
             action_type: Optional[str] = None,
             adjustment: Optional[str] = None,
             cooldown: Optional[int] = None,
             dimensions: Optional[Sequence['outputs.ElastigroupScalingUpPolicyDimension']] = None,
             evaluation_periods: Optional[int] = None,
             max_target_capacity: Optional[str] = None,
             maximum: Optional[str] = None,
             min_target_capacity: Optional[str] = None,
             minimum: Optional[str] = None,
             operator: Optional[str] = None,
             period: Optional[int] = None,
             statistic: Optional[str] = None,
             target: Optional[str] = None,
             unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric_name", metric_name)
        _setter("namespace", namespace)
        _setter("policy_name", policy_name)
        _setter("threshold", threshold)
        if action_type is not None:
            _setter("action_type", action_type)
        if adjustment is not None:
            _setter("adjustment", adjustment)
        if cooldown is not None:
            _setter("cooldown", cooldown)
        if dimensions is not None:
            _setter("dimensions", dimensions)
        if evaluation_periods is not None:
            _setter("evaluation_periods", evaluation_periods)
        if max_target_capacity is not None:
            _setter("max_target_capacity", max_target_capacity)
        if maximum is not None:
            _setter("maximum", maximum)
        if min_target_capacity is not None:
            _setter("min_target_capacity", min_target_capacity)
        if minimum is not None:
            _setter("minimum", minimum)
        if operator is not None:
            _setter("operator", operator)
        if period is not None:
            _setter("period", period)
        if statistic is not None:
            _setter("statistic", statistic)
        if target is not None:
            _setter("target", target)
        if unit is not None:
            _setter("unit", unit)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> str:
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[int]:
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ElastigroupScalingUpPolicyDimension']]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "max_target_capacity")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[str]:
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[str]:
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class ElastigroupScalingUpPolicyDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: Name of the Managed Service Identity.
        :param str value: Tag Value for Vms in Elastigroup.
        """
        ElastigroupScalingUpPolicyDimension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Managed Service Identity.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Tag Value for Vms in Elastigroup.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ElastigroupScheduledTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "adjustmentPercentage":
            suggest = "adjustment_percentage"
        elif key == "batchSizePercentage":
            suggest = "batch_size_percentage"
        elif key == "gracePeriod":
            suggest = "grace_period"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "scaleMaxCapacity":
            suggest = "scale_max_capacity"
        elif key == "scaleMinCapacity":
            suggest = "scale_min_capacity"
        elif key == "scaleTargetCapacity":
            suggest = "scale_target_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupScheduledTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupScheduledTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupScheduledTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression: str,
                 task_type: str,
                 adjustment: Optional[str] = None,
                 adjustment_percentage: Optional[str] = None,
                 batch_size_percentage: Optional[str] = None,
                 grace_period: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 scale_max_capacity: Optional[str] = None,
                 scale_min_capacity: Optional[str] = None,
                 scale_target_capacity: Optional[str] = None):
        ElastigroupScheduledTask._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cron_expression=cron_expression,
            task_type=task_type,
            adjustment=adjustment,
            adjustment_percentage=adjustment_percentage,
            batch_size_percentage=batch_size_percentage,
            grace_period=grace_period,
            is_enabled=is_enabled,
            scale_max_capacity=scale_max_capacity,
            scale_min_capacity=scale_min_capacity,
            scale_target_capacity=scale_target_capacity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cron_expression: str,
             task_type: str,
             adjustment: Optional[str] = None,
             adjustment_percentage: Optional[str] = None,
             batch_size_percentage: Optional[str] = None,
             grace_period: Optional[str] = None,
             is_enabled: Optional[bool] = None,
             scale_max_capacity: Optional[str] = None,
             scale_min_capacity: Optional[str] = None,
             scale_target_capacity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cron_expression", cron_expression)
        _setter("task_type", task_type)
        if adjustment is not None:
            _setter("adjustment", adjustment)
        if adjustment_percentage is not None:
            _setter("adjustment_percentage", adjustment_percentage)
        if batch_size_percentage is not None:
            _setter("batch_size_percentage", batch_size_percentage)
        if grace_period is not None:
            _setter("grace_period", grace_period)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if scale_max_capacity is not None:
            _setter("scale_max_capacity", scale_max_capacity)
        if scale_min_capacity is not None:
            _setter("scale_min_capacity", scale_min_capacity)
        if scale_target_capacity is not None:
            _setter("scale_target_capacity", scale_target_capacity)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> str:
        return pulumi.get(self, "cron_expression")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter(name="adjustmentPercentage")
    def adjustment_percentage(self) -> Optional[str]:
        return pulumi.get(self, "adjustment_percentage")

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[str]:
        return pulumi.get(self, "batch_size_percentage")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[str]:
        return pulumi.get(self, "grace_period")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="scaleMaxCapacity")
    def scale_max_capacity(self) -> Optional[str]:
        return pulumi.get(self, "scale_max_capacity")

    @property
    @pulumi.getter(name="scaleMinCapacity")
    def scale_min_capacity(self) -> Optional[str]:
        return pulumi.get(self, "scale_min_capacity")

    @property
    @pulumi.getter(name="scaleTargetCapacity")
    def scale_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "scale_target_capacity")


@pulumi.output_type
class ElastigroupStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainingTimeout":
            suggest = "draining_timeout"
        elif key == "lowPriorityPercentage":
            suggest = "low_priority_percentage"
        elif key == "odCount":
            suggest = "od_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 draining_timeout: Optional[int] = None,
                 low_priority_percentage: Optional[int] = None,
                 od_count: Optional[int] = None):
        ElastigroupStrategy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            draining_timeout=draining_timeout,
            low_priority_percentage=low_priority_percentage,
            od_count=od_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             draining_timeout: Optional[int] = None,
             low_priority_percentage: Optional[int] = None,
             od_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if draining_timeout is not None:
            _setter("draining_timeout", draining_timeout)
        if low_priority_percentage is not None:
            _setter("low_priority_percentage", low_priority_percentage)
        if od_count is not None:
            _setter("od_count", od_count)

    @property
    @pulumi.getter(name="drainingTimeout")
    def draining_timeout(self) -> Optional[int]:
        return pulumi.get(self, "draining_timeout")

    @property
    @pulumi.getter(name="lowPriorityPercentage")
    def low_priority_percentage(self) -> Optional[int]:
        return pulumi.get(self, "low_priority_percentage")

    @property
    @pulumi.getter(name="odCount")
    def od_count(self) -> Optional[int]:
        return pulumi.get(self, "od_count")


@pulumi.output_type
class ElastigroupUpdatePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shouldRoll":
            suggest = "should_roll"
        elif key == "rollConfig":
            suggest = "roll_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupUpdatePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupUpdatePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupUpdatePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 should_roll: bool,
                 roll_config: Optional['outputs.ElastigroupUpdatePolicyRollConfig'] = None):
        ElastigroupUpdatePolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            should_roll=should_roll,
            roll_config=roll_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             should_roll: bool,
             roll_config: Optional['outputs.ElastigroupUpdatePolicyRollConfig'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("should_roll", should_roll)
        if roll_config is not None:
            _setter("roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> bool:
        return pulumi.get(self, "should_roll")

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional['outputs.ElastigroupUpdatePolicyRollConfig']:
        return pulumi.get(self, "roll_config")


@pulumi.output_type
class ElastigroupUpdatePolicyRollConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchSizePercentage":
            suggest = "batch_size_percentage"
        elif key == "gracePeriod":
            suggest = "grace_period"
        elif key == "healthCheckType":
            suggest = "health_check_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupUpdatePolicyRollConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupUpdatePolicyRollConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupUpdatePolicyRollConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_size_percentage: int,
                 grace_period: Optional[int] = None,
                 health_check_type: Optional[str] = None):
        ElastigroupUpdatePolicyRollConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            batch_size_percentage=batch_size_percentage,
            grace_period=grace_period,
            health_check_type=health_check_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             batch_size_percentage: int,
             grace_period: Optional[int] = None,
             health_check_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("batch_size_percentage", batch_size_percentage)
        if grace_period is not None:
            _setter("grace_period", grace_period)
        if health_check_type is not None:
            _setter("health_check_type", health_check_type)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> int:
        return pulumi.get(self, "batch_size_percentage")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        return pulumi.get(self, "grace_period")

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> Optional[str]:
        return pulumi.get(self, "health_check_type")


@pulumi.output_type
class OceanAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoscaleDown":
            suggest = "autoscale_down"
        elif key == "autoscaleHeadroom":
            suggest = "autoscale_headroom"
        elif key == "autoscaleIsEnabled":
            suggest = "autoscale_is_enabled"
        elif key == "resourceLimits":
            suggest = "resource_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale_down: Optional['outputs.OceanAutoscalerAutoscaleDown'] = None,
                 autoscale_headroom: Optional['outputs.OceanAutoscalerAutoscaleHeadroom'] = None,
                 autoscale_is_enabled: Optional[bool] = None,
                 resource_limits: Optional['outputs.OceanAutoscalerResourceLimits'] = None):
        """
        :param 'OceanAutoscalerAutoscaleDownArgs' autoscale_down: Auto Scaling scale down operations.
        :param 'OceanAutoscalerAutoscaleHeadroomArgs' autoscale_headroom: Spare Resource Capacity Management feature enables fast assignment of Pods without having to wait for new resources to be launched.
        :param bool autoscale_is_enabled: Enable the Ocean Kubernetes Autoscaler.
        :param 'OceanAutoscalerResourceLimitsArgs' resource_limits: Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        OceanAutoscaler._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoscale_down=autoscale_down,
            autoscale_headroom=autoscale_headroom,
            autoscale_is_enabled=autoscale_is_enabled,
            resource_limits=resource_limits,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoscale_down: Optional['outputs.OceanAutoscalerAutoscaleDown'] = None,
             autoscale_headroom: Optional['outputs.OceanAutoscalerAutoscaleHeadroom'] = None,
             autoscale_is_enabled: Optional[bool] = None,
             resource_limits: Optional['outputs.OceanAutoscalerResourceLimits'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if autoscale_down is not None:
            _setter("autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            _setter("autoscale_headroom", autoscale_headroom)
        if autoscale_is_enabled is not None:
            _setter("autoscale_is_enabled", autoscale_is_enabled)
        if resource_limits is not None:
            _setter("resource_limits", resource_limits)

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional['outputs.OceanAutoscalerAutoscaleDown']:
        """
        Auto Scaling scale down operations.
        """
        return pulumi.get(self, "autoscale_down")

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional['outputs.OceanAutoscalerAutoscaleHeadroom']:
        """
        Spare Resource Capacity Management feature enables fast assignment of Pods without having to wait for new resources to be launched.
        """
        return pulumi.get(self, "autoscale_headroom")

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[bool]:
        """
        Enable the Ocean Kubernetes Autoscaler.
        """
        return pulumi.get(self, "autoscale_is_enabled")

    @property
    @pulumi.getter(name="resourceLimits")
    def resource_limits(self) -> Optional['outputs.OceanAutoscalerResourceLimits']:
        """
        Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        return pulumi.get(self, "resource_limits")


@pulumi.output_type
class OceanAutoscalerAutoscaleDown(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxScaleDownPercentage":
            suggest = "max_scale_down_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanAutoscalerAutoscaleDown. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanAutoscalerAutoscaleDown.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanAutoscalerAutoscaleDown.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_scale_down_percentage: Optional[float] = None):
        """
        :param float max_scale_down_percentage: Would represent the maximum % to scale-down.
        """
        OceanAutoscalerAutoscaleDown._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_scale_down_percentage=max_scale_down_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_scale_down_percentage: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_scale_down_percentage is not None:
            _setter("max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[float]:
        """
        Would represent the maximum % to scale-down.
        """
        return pulumi.get(self, "max_scale_down_percentage")


@pulumi.output_type
class OceanAutoscalerAutoscaleHeadroom(dict):
    def __init__(__self__, *,
                 automatic: Optional['outputs.OceanAutoscalerAutoscaleHeadroomAutomatic'] = None):
        """
        :param 'OceanAutoscalerAutoscaleHeadroomAutomaticArgs' automatic: Automatic headroom configuration.
        """
        OceanAutoscalerAutoscaleHeadroom._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            automatic=automatic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             automatic: Optional['outputs.OceanAutoscalerAutoscaleHeadroomAutomatic'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if automatic is not None:
            _setter("automatic", automatic)

    @property
    @pulumi.getter
    def automatic(self) -> Optional['outputs.OceanAutoscalerAutoscaleHeadroomAutomatic']:
        """
        Automatic headroom configuration.
        """
        return pulumi.get(self, "automatic")


@pulumi.output_type
class OceanAutoscalerAutoscaleHeadroomAutomatic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanAutoscalerAutoscaleHeadroomAutomatic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanAutoscalerAutoscaleHeadroomAutomatic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanAutoscalerAutoscaleHeadroomAutomatic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: Optional[bool] = None,
                 percentage: Optional[int] = None):
        """
        :param bool is_enabled: Enable automatic headroom. When set to `true`, Ocean configures and optimizes headroom automatically.
        :param int percentage: Optionally set a number between 0-100 to control the percentage of total cluster resources dedicated to headroom. Relevant when `isEnabled` is toggled on.
        """
        OceanAutoscalerAutoscaleHeadroomAutomatic._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_enabled=is_enabled,
            percentage=percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_enabled: Optional[bool] = None,
             percentage: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if percentage is not None:
            _setter("percentage", percentage)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Enable automatic headroom. When set to `true`, Ocean configures and optimizes headroom automatically.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def percentage(self) -> Optional[int]:
        """
        Optionally set a number between 0-100 to control the percentage of total cluster resources dedicated to headroom. Relevant when `isEnabled` is toggled on.
        """
        return pulumi.get(self, "percentage")


@pulumi.output_type
class OceanAutoscalerResourceLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxMemoryGib":
            suggest = "max_memory_gib"
        elif key == "maxVcpu":
            suggest = "max_vcpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanAutoscalerResourceLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanAutoscalerResourceLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanAutoscalerResourceLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_memory_gib: Optional[int] = None,
                 max_vcpu: Optional[int] = None):
        """
        :param int max_memory_gib: The maximum memory in GiB units that can be allocated to the cluster.
        :param int max_vcpu: The maximum cpu in vCpu units that can be allocated to the cluster.
        """
        OceanAutoscalerResourceLimits._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_memory_gib=max_memory_gib,
            max_vcpu=max_vcpu,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_memory_gib: Optional[int] = None,
             max_vcpu: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_memory_gib is not None:
            _setter("max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            _setter("max_vcpu", max_vcpu)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[int]:
        """
        The maximum memory in GiB units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_memory_gib")

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[int]:
        """
        The maximum cpu in vCpu units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_vcpu")


@pulumi.output_type
class OceanExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "minorVersionAutoUpgrade":
            suggest = "minor_version_auto_upgrade"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 minor_version_auto_upgrade: Optional[bool] = None,
                 name: Optional[str] = None,
                 publisher: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str api_version: API version of the extension.
        :param bool minor_version_auto_upgrade: Toggles whether auto upgrades are allowed.
        :param str name: Name of the Load Balancer.
        :param str publisher: Image publisher.
        :param str type: The type of load balancer. Supported value: `loadBalancer`
        """
        OceanExtension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_version=api_version,
            minor_version_auto_upgrade=minor_version_auto_upgrade,
            name=name,
            publisher=publisher,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_version: Optional[str] = None,
             minor_version_auto_upgrade: Optional[bool] = None,
             name: Optional[str] = None,
             publisher: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if api_version is not None:
            _setter("api_version", api_version)
        if minor_version_auto_upgrade is not None:
            _setter("minor_version_auto_upgrade", minor_version_auto_upgrade)
        if name is not None:
            _setter("name", name)
        if publisher is not None:
            _setter("publisher", publisher)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the extension.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="minorVersionAutoUpgrade")
    def minor_version_auto_upgrade(self) -> Optional[bool]:
        """
        Toggles whether auto upgrades are allowed.
        """
        return pulumi.get(self, "minor_version_auto_upgrade")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[str]:
        """
        Image publisher.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of load balancer. Supported value: `loadBalancer`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OceanHealth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gracePeriod":
            suggest = "grace_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanHealth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanHealth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanHealth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grace_period: Optional[int] = None):
        """
        :param int grace_period: The amount of time to wait, in seconds, from the moment the instance has launched before monitoring its health checks.
        """
        OceanHealth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grace_period=grace_period,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grace_period: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if grace_period is not None:
            _setter("grace_period", grace_period)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        """
        The amount of time to wait, in seconds, from the moment the instance has launched before monitoring its health checks.
        """
        return pulumi.get(self, "grace_period")


@pulumi.output_type
class OceanImage(dict):
    def __init__(__self__, *,
                 marketplaces: Optional[Sequence['outputs.OceanImageMarketplace']] = None):
        """
        :param Sequence['OceanImageMarketplaceArgs'] marketplaces: Select an image from Azure's Marketplace image catalogue.
        """
        OceanImage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            marketplaces=marketplaces,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             marketplaces: Optional[Sequence['outputs.OceanImageMarketplace']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if marketplaces is not None:
            _setter("marketplaces", marketplaces)

    @property
    @pulumi.getter
    def marketplaces(self) -> Optional[Sequence['outputs.OceanImageMarketplace']]:
        """
        Select an image from Azure's Marketplace image catalogue.
        """
        return pulumi.get(self, "marketplaces")


@pulumi.output_type
class OceanImageMarketplace(dict):
    def __init__(__self__, *,
                 offer: Optional[str] = None,
                 publisher: Optional[str] = None,
                 sku: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str offer: Image name.
        :param str publisher: Image publisher.
        :param str sku: Image Stock Keeping Unit (which is the specific version of the image).
        :param str version: Image version.
        """
        OceanImageMarketplace._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            offer=offer,
            publisher=publisher,
            sku=sku,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             offer: Optional[str] = None,
             publisher: Optional[str] = None,
             sku: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if offer is not None:
            _setter("offer", offer)
        if publisher is not None:
            _setter("publisher", publisher)
        if sku is not None:
            _setter("sku", sku)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def offer(self) -> Optional[str]:
        """
        Image name.
        """
        return pulumi.get(self, "offer")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[str]:
        """
        Image publisher.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def sku(self) -> Optional[str]:
        """
        Image Stock Keeping Unit (which is the specific version of the image).
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Image version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class OceanLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendPoolNames":
            suggest = "backend_pool_names"
        elif key == "loadBalancerSku":
            suggest = "load_balancer_sku"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_pool_names: Optional[Sequence[str]] = None,
                 load_balancer_sku: Optional[str] = None,
                 name: Optional[str] = None,
                 resource_group_name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param Sequence[str] backend_pool_names: Names of the Backend Pools to register the Cluster VMs to. Each Backend Pool is a separate load balancer.
        :param str load_balancer_sku: Supported values: `Standard`, `Basic`.
        :param str name: Name of the Load Balancer.
        :param str resource_group_name: The Resource Group name of the Load Balancer.
        :param str type: The type of load balancer. Supported value: `loadBalancer`
        """
        OceanLoadBalancer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_pool_names=backend_pool_names,
            load_balancer_sku=load_balancer_sku,
            name=name,
            resource_group_name=resource_group_name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_pool_names: Optional[Sequence[str]] = None,
             load_balancer_sku: Optional[str] = None,
             name: Optional[str] = None,
             resource_group_name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if backend_pool_names is not None:
            _setter("backend_pool_names", backend_pool_names)
        if load_balancer_sku is not None:
            _setter("load_balancer_sku", load_balancer_sku)
        if name is not None:
            _setter("name", name)
        if resource_group_name is not None:
            _setter("resource_group_name", resource_group_name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="backendPoolNames")
    def backend_pool_names(self) -> Optional[Sequence[str]]:
        """
        Names of the Backend Pools to register the Cluster VMs to. Each Backend Pool is a separate load balancer.
        """
        return pulumi.get(self, "backend_pool_names")

    @property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[str]:
        """
        Supported values: `Standard`, `Basic`.
        """
        return pulumi.get(self, "load_balancer_sku")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[str]:
        """
        The Resource Group name of the Load Balancer.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of load balancer. Supported value: `loadBalancer`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OceanManagedServiceIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanManagedServiceIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanManagedServiceIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanManagedServiceIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 resource_group_name: str):
        """
        :param str name: Name of the Load Balancer.
        :param str resource_group_name: The Resource Group name of the Load Balancer.
        """
        OceanManagedServiceIdentity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            resource_group_name=resource_group_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             resource_group_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        The Resource Group name of the Load Balancer.
        """
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class OceanNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "virtualNetworkName":
            suggest = "virtual_network_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_interfaces: Optional[Sequence['outputs.OceanNetworkNetworkInterface']] = None,
                 resource_group_name: Optional[str] = None,
                 virtual_network_name: Optional[str] = None):
        """
        :param Sequence['OceanNetworkNetworkInterfaceArgs'] network_interfaces: A list of virtual network interfaces. The publicIpSku must be identical between all the network interfaces. One network interface must be set as the primary.
        :param str resource_group_name: The Resource Group name of the Load Balancer.
        :param str virtual_network_name: Virtual network.
        """
        OceanNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_interfaces=network_interfaces,
            resource_group_name=resource_group_name,
            virtual_network_name=virtual_network_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_interfaces: Optional[Sequence['outputs.OceanNetworkNetworkInterface']] = None,
             resource_group_name: Optional[str] = None,
             virtual_network_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if network_interfaces is not None:
            _setter("network_interfaces", network_interfaces)
        if resource_group_name is not None:
            _setter("resource_group_name", resource_group_name)
        if virtual_network_name is not None:
            _setter("virtual_network_name", virtual_network_name)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.OceanNetworkNetworkInterface']]:
        """
        A list of virtual network interfaces. The publicIpSku must be identical between all the network interfaces. One network interface must be set as the primary.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[str]:
        """
        The Resource Group name of the Load Balancer.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="virtualNetworkName")
    def virtual_network_name(self) -> Optional[str]:
        """
        Virtual network.
        """
        return pulumi.get(self, "virtual_network_name")


@pulumi.output_type
class OceanNetworkNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalIpConfigs":
            suggest = "additional_ip_configs"
        elif key == "assignPublicIp":
            suggest = "assign_public_ip"
        elif key == "isPrimary":
            suggest = "is_primary"
        elif key == "securityGroup":
            suggest = "security_group"
        elif key == "subnetName":
            suggest = "subnet_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNetworkNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNetworkNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNetworkNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_ip_configs: Optional[Sequence['outputs.OceanNetworkNetworkInterfaceAdditionalIpConfig']] = None,
                 assign_public_ip: Optional[bool] = None,
                 is_primary: Optional[bool] = None,
                 security_group: Optional['outputs.OceanNetworkNetworkInterfaceSecurityGroup'] = None,
                 subnet_name: Optional[str] = None):
        """
        :param Sequence['OceanNetworkNetworkInterfaceAdditionalIpConfigArgs'] additional_ip_configs: Additional configuration of network interface. The name fields between all the `additional_ip_config` must be unique.
        :param bool assign_public_ip: Assign public IP.
        :param bool is_primary: Defines whether the network interface is primary or not.
        :param str subnet_name: Subnet name.
        """
        OceanNetworkNetworkInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_ip_configs=additional_ip_configs,
            assign_public_ip=assign_public_ip,
            is_primary=is_primary,
            security_group=security_group,
            subnet_name=subnet_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_ip_configs: Optional[Sequence['outputs.OceanNetworkNetworkInterfaceAdditionalIpConfig']] = None,
             assign_public_ip: Optional[bool] = None,
             is_primary: Optional[bool] = None,
             security_group: Optional['outputs.OceanNetworkNetworkInterfaceSecurityGroup'] = None,
             subnet_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if additional_ip_configs is not None:
            _setter("additional_ip_configs", additional_ip_configs)
        if assign_public_ip is not None:
            _setter("assign_public_ip", assign_public_ip)
        if is_primary is not None:
            _setter("is_primary", is_primary)
        if security_group is not None:
            _setter("security_group", security_group)
        if subnet_name is not None:
            _setter("subnet_name", subnet_name)

    @property
    @pulumi.getter(name="additionalIpConfigs")
    def additional_ip_configs(self) -> Optional[Sequence['outputs.OceanNetworkNetworkInterfaceAdditionalIpConfig']]:
        """
        Additional configuration of network interface. The name fields between all the `additional_ip_config` must be unique.
        """
        return pulumi.get(self, "additional_ip_configs")

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[bool]:
        """
        Assign public IP.
        """
        return pulumi.get(self, "assign_public_ip")

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> Optional[bool]:
        """
        Defines whether the network interface is primary or not.
        """
        return pulumi.get(self, "is_primary")

    @property
    @pulumi.getter(name="securityGroup")
    def security_group(self) -> Optional['outputs.OceanNetworkNetworkInterfaceSecurityGroup']:
        return pulumi.get(self, "security_group")

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[str]:
        """
        Subnet name.
        """
        return pulumi.get(self, "subnet_name")


@pulumi.output_type
class OceanNetworkNetworkInterfaceAdditionalIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpVersion":
            suggest = "private_ip_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNetworkNetworkInterfaceAdditionalIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNetworkNetworkInterfaceAdditionalIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNetworkNetworkInterfaceAdditionalIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 private_ip_version: Optional[str] = None):
        """
        :param str name: Name of the Load Balancer.
        :param str private_ip_version: Supported values: `IPv4`, `IPv6`.
        """
        OceanNetworkNetworkInterfaceAdditionalIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            private_ip_version=private_ip_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             private_ip_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if private_ip_version is not None:
            _setter("private_ip_version", private_ip_version)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpVersion")
    def private_ip_version(self) -> Optional[str]:
        """
        Supported values: `IPv4`, `IPv6`.
        """
        return pulumi.get(self, "private_ip_version")


@pulumi.output_type
class OceanNetworkNetworkInterfaceSecurityGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNetworkNetworkInterfaceSecurityGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNetworkNetworkInterfaceSecurityGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNetworkNetworkInterfaceSecurityGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 resource_group_name: Optional[str] = None):
        """
        :param str name: Name of the Load Balancer.
        :param str resource_group_name: The Resource Group name of the Load Balancer.
        """
        OceanNetworkNetworkInterfaceSecurityGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            resource_group_name=resource_group_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             resource_group_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if resource_group_name is not None:
            _setter("resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Load Balancer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[str]:
        """
        The Resource Group name of the Load Balancer.
        """
        return pulumi.get(self, "resource_group_name")


@pulumi.output_type
class OceanNpAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoscaleDown":
            suggest = "autoscale_down"
        elif key == "autoscaleHeadroom":
            suggest = "autoscale_headroom"
        elif key == "autoscaleIsEnabled":
            suggest = "autoscale_is_enabled"
        elif key == "resourceLimits":
            suggest = "resource_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale_down: Optional['outputs.OceanNpAutoscalerAutoscaleDown'] = None,
                 autoscale_headroom: Optional['outputs.OceanNpAutoscalerAutoscaleHeadroom'] = None,
                 autoscale_is_enabled: Optional[bool] = None,
                 resource_limits: Optional['outputs.OceanNpAutoscalerResourceLimits'] = None):
        OceanNpAutoscaler._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoscale_down=autoscale_down,
            autoscale_headroom=autoscale_headroom,
            autoscale_is_enabled=autoscale_is_enabled,
            resource_limits=resource_limits,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoscale_down: Optional['outputs.OceanNpAutoscalerAutoscaleDown'] = None,
             autoscale_headroom: Optional['outputs.OceanNpAutoscalerAutoscaleHeadroom'] = None,
             autoscale_is_enabled: Optional[bool] = None,
             resource_limits: Optional['outputs.OceanNpAutoscalerResourceLimits'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if autoscale_down is not None:
            _setter("autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            _setter("autoscale_headroom", autoscale_headroom)
        if autoscale_is_enabled is not None:
            _setter("autoscale_is_enabled", autoscale_is_enabled)
        if resource_limits is not None:
            _setter("resource_limits", resource_limits)

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional['outputs.OceanNpAutoscalerAutoscaleDown']:
        return pulumi.get(self, "autoscale_down")

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional['outputs.OceanNpAutoscalerAutoscaleHeadroom']:
        return pulumi.get(self, "autoscale_headroom")

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "autoscale_is_enabled")

    @property
    @pulumi.getter(name="resourceLimits")
    def resource_limits(self) -> Optional['outputs.OceanNpAutoscalerResourceLimits']:
        return pulumi.get(self, "resource_limits")


@pulumi.output_type
class OceanNpAutoscalerAutoscaleDown(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxScaleDownPercentage":
            suggest = "max_scale_down_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpAutoscalerAutoscaleDown. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpAutoscalerAutoscaleDown.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpAutoscalerAutoscaleDown.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_scale_down_percentage: Optional[int] = None):
        OceanNpAutoscalerAutoscaleDown._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_scale_down_percentage=max_scale_down_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_scale_down_percentage: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_scale_down_percentage is not None:
            _setter("max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[int]:
        return pulumi.get(self, "max_scale_down_percentage")


@pulumi.output_type
class OceanNpAutoscalerAutoscaleHeadroom(dict):
    def __init__(__self__, *,
                 automatic: Optional['outputs.OceanNpAutoscalerAutoscaleHeadroomAutomatic'] = None):
        OceanNpAutoscalerAutoscaleHeadroom._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            automatic=automatic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             automatic: Optional['outputs.OceanNpAutoscalerAutoscaleHeadroomAutomatic'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if automatic is not None:
            _setter("automatic", automatic)

    @property
    @pulumi.getter
    def automatic(self) -> Optional['outputs.OceanNpAutoscalerAutoscaleHeadroomAutomatic']:
        return pulumi.get(self, "automatic")


@pulumi.output_type
class OceanNpAutoscalerAutoscaleHeadroomAutomatic(dict):
    def __init__(__self__, *,
                 percentage: Optional[int] = None):
        OceanNpAutoscalerAutoscaleHeadroomAutomatic._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            percentage=percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             percentage: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if percentage is not None:
            _setter("percentage", percentage)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[int]:
        return pulumi.get(self, "percentage")


@pulumi.output_type
class OceanNpAutoscalerResourceLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxMemoryGib":
            suggest = "max_memory_gib"
        elif key == "maxVcpu":
            suggest = "max_vcpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpAutoscalerResourceLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpAutoscalerResourceLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpAutoscalerResourceLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_memory_gib: Optional[int] = None,
                 max_vcpu: Optional[int] = None):
        OceanNpAutoscalerResourceLimits._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_memory_gib=max_memory_gib,
            max_vcpu=max_vcpu,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_memory_gib: Optional[int] = None,
             max_vcpu: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_memory_gib is not None:
            _setter("max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            _setter("max_vcpu", max_vcpu)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[int]:
        return pulumi.get(self, "max_memory_gib")

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[int]:
        return pulumi.get(self, "max_vcpu")


@pulumi.output_type
class OceanNpFilters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeSeries":
            suggest = "exclude_series"
        elif key == "maxMemoryGib":
            suggest = "max_memory_gib"
        elif key == "maxVcpu":
            suggest = "max_vcpu"
        elif key == "minMemoryGib":
            suggest = "min_memory_gib"
        elif key == "minVcpu":
            suggest = "min_vcpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 architectures: Optional[Sequence[str]] = None,
                 exclude_series: Optional[Sequence[str]] = None,
                 max_memory_gib: Optional[float] = None,
                 max_vcpu: Optional[int] = None,
                 min_memory_gib: Optional[float] = None,
                 min_vcpu: Optional[int] = None,
                 series: Optional[Sequence[str]] = None):
        OceanNpFilters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            architectures=architectures,
            exclude_series=exclude_series,
            max_memory_gib=max_memory_gib,
            max_vcpu=max_vcpu,
            min_memory_gib=min_memory_gib,
            min_vcpu=min_vcpu,
            series=series,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             architectures: Optional[Sequence[str]] = None,
             exclude_series: Optional[Sequence[str]] = None,
             max_memory_gib: Optional[float] = None,
             max_vcpu: Optional[int] = None,
             min_memory_gib: Optional[float] = None,
             min_vcpu: Optional[int] = None,
             series: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if architectures is not None:
            _setter("architectures", architectures)
        if exclude_series is not None:
            _setter("exclude_series", exclude_series)
        if max_memory_gib is not None:
            _setter("max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            _setter("max_vcpu", max_vcpu)
        if min_memory_gib is not None:
            _setter("min_memory_gib", min_memory_gib)
        if min_vcpu is not None:
            _setter("min_vcpu", min_vcpu)
        if series is not None:
            _setter("series", series)

    @property
    @pulumi.getter
    def architectures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "architectures")

    @property
    @pulumi.getter(name="excludeSeries")
    def exclude_series(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclude_series")

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[float]:
        return pulumi.get(self, "max_memory_gib")

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[int]:
        return pulumi.get(self, "max_vcpu")

    @property
    @pulumi.getter(name="minMemoryGib")
    def min_memory_gib(self) -> Optional[float]:
        return pulumi.get(self, "min_memory_gib")

    @property
    @pulumi.getter(name="minVcpu")
    def min_vcpu(self) -> Optional[int]:
        return pulumi.get(self, "min_vcpu")

    @property
    @pulumi.getter
    def series(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "series")


@pulumi.output_type
class OceanNpHeadroom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuPerUnit":
            suggest = "cpu_per_unit"
        elif key == "gpuPerUnit":
            suggest = "gpu_per_unit"
        elif key == "memoryPerUnit":
            suggest = "memory_per_unit"
        elif key == "numOfUnits":
            suggest = "num_of_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpHeadroom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpHeadroom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpHeadroom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_per_unit: Optional[int] = None,
                 gpu_per_unit: Optional[int] = None,
                 memory_per_unit: Optional[int] = None,
                 num_of_units: Optional[int] = None):
        OceanNpHeadroom._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_per_unit=cpu_per_unit,
            gpu_per_unit=gpu_per_unit,
            memory_per_unit=memory_per_unit,
            num_of_units=num_of_units,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_per_unit: Optional[int] = None,
             gpu_per_unit: Optional[int] = None,
             memory_per_unit: Optional[int] = None,
             num_of_units: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cpu_per_unit is not None:
            _setter("cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            _setter("gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            _setter("memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            _setter("num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "cpu_per_unit")

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "gpu_per_unit")

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "memory_per_unit")

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[int]:
        return pulumi.get(self, "num_of_units")


@pulumi.output_type
class OceanNpHealth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gracePeriod":
            suggest = "grace_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpHealth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpHealth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpHealth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grace_period: Optional[int] = None):
        OceanNpHealth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grace_period=grace_period,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grace_period: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if grace_period is not None:
            _setter("grace_period", grace_period)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        return pulumi.get(self, "grace_period")


@pulumi.output_type
class OceanNpScheduling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shutdownHours":
            suggest = "shutdown_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpScheduling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpScheduling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpScheduling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 shutdown_hours: Optional['outputs.OceanNpSchedulingShutdownHours'] = None):
        OceanNpScheduling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            shutdown_hours=shutdown_hours,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             shutdown_hours: Optional['outputs.OceanNpSchedulingShutdownHours'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if shutdown_hours is not None:
            _setter("shutdown_hours", shutdown_hours)

    @property
    @pulumi.getter(name="shutdownHours")
    def shutdown_hours(self) -> Optional['outputs.OceanNpSchedulingShutdownHours']:
        return pulumi.get(self, "shutdown_hours")


@pulumi.output_type
class OceanNpSchedulingShutdownHours(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeWindows":
            suggest = "time_windows"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpSchedulingShutdownHours. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpSchedulingShutdownHours.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpSchedulingShutdownHours.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_windows: Sequence[str],
                 is_enabled: Optional[bool] = None):
        OceanNpSchedulingShutdownHours._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            time_windows=time_windows,
            is_enabled=is_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             time_windows: Sequence[str],
             is_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("time_windows", time_windows)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Sequence[str]:
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")


@pulumi.output_type
class OceanNpTaint(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: str):
        OceanNpTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: str,
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("effect", effect)
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanNpVirtualNodeGroupFilters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeSeries":
            suggest = "exclude_series"
        elif key == "maxMemoryGib":
            suggest = "max_memory_gib"
        elif key == "maxVcpu":
            suggest = "max_vcpu"
        elif key == "minMemoryGib":
            suggest = "min_memory_gib"
        elif key == "minVcpu":
            suggest = "min_vcpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpVirtualNodeGroupFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpVirtualNodeGroupFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpVirtualNodeGroupFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 architectures: Optional[Sequence[str]] = None,
                 exclude_series: Optional[Sequence[str]] = None,
                 max_memory_gib: Optional[float] = None,
                 max_vcpu: Optional[int] = None,
                 min_memory_gib: Optional[float] = None,
                 min_vcpu: Optional[int] = None,
                 series: Optional[Sequence[str]] = None):
        OceanNpVirtualNodeGroupFilters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            architectures=architectures,
            exclude_series=exclude_series,
            max_memory_gib=max_memory_gib,
            max_vcpu=max_vcpu,
            min_memory_gib=min_memory_gib,
            min_vcpu=min_vcpu,
            series=series,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             architectures: Optional[Sequence[str]] = None,
             exclude_series: Optional[Sequence[str]] = None,
             max_memory_gib: Optional[float] = None,
             max_vcpu: Optional[int] = None,
             min_memory_gib: Optional[float] = None,
             min_vcpu: Optional[int] = None,
             series: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if architectures is not None:
            _setter("architectures", architectures)
        if exclude_series is not None:
            _setter("exclude_series", exclude_series)
        if max_memory_gib is not None:
            _setter("max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            _setter("max_vcpu", max_vcpu)
        if min_memory_gib is not None:
            _setter("min_memory_gib", min_memory_gib)
        if min_vcpu is not None:
            _setter("min_vcpu", min_vcpu)
        if series is not None:
            _setter("series", series)

    @property
    @pulumi.getter
    def architectures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "architectures")

    @property
    @pulumi.getter(name="excludeSeries")
    def exclude_series(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclude_series")

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[float]:
        return pulumi.get(self, "max_memory_gib")

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[int]:
        return pulumi.get(self, "max_vcpu")

    @property
    @pulumi.getter(name="minMemoryGib")
    def min_memory_gib(self) -> Optional[float]:
        return pulumi.get(self, "min_memory_gib")

    @property
    @pulumi.getter(name="minVcpu")
    def min_vcpu(self) -> Optional[int]:
        return pulumi.get(self, "min_vcpu")

    @property
    @pulumi.getter
    def series(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "series")


@pulumi.output_type
class OceanNpVirtualNodeGroupHeadroom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuPerUnit":
            suggest = "cpu_per_unit"
        elif key == "gpuPerUnit":
            suggest = "gpu_per_unit"
        elif key == "memoryPerUnit":
            suggest = "memory_per_unit"
        elif key == "numOfUnits":
            suggest = "num_of_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanNpVirtualNodeGroupHeadroom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanNpVirtualNodeGroupHeadroom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanNpVirtualNodeGroupHeadroom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_per_unit: Optional[int] = None,
                 gpu_per_unit: Optional[int] = None,
                 memory_per_unit: Optional[int] = None,
                 num_of_units: Optional[int] = None):
        OceanNpVirtualNodeGroupHeadroom._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_per_unit=cpu_per_unit,
            gpu_per_unit=gpu_per_unit,
            memory_per_unit=memory_per_unit,
            num_of_units=num_of_units,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_per_unit: Optional[int] = None,
             gpu_per_unit: Optional[int] = None,
             memory_per_unit: Optional[int] = None,
             num_of_units: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cpu_per_unit is not None:
            _setter("cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            _setter("gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            _setter("memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            _setter("num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "cpu_per_unit")

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "gpu_per_unit")

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "memory_per_unit")

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[int]:
        return pulumi.get(self, "num_of_units")


@pulumi.output_type
class OceanNpVirtualNodeGroupTaint(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: str):
        OceanNpVirtualNodeGroupTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: str,
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("effect", effect)
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGb":
            suggest = "size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_gb: int,
                 type: Optional[str] = None):
        """
        :param int size_gb: The size of the OS disk in GB.
        :param str type: The type of load balancer. Supported value: `loadBalancer`
        """
        OceanOsDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            size_gb=size_gb,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             size_gb: int,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("size_gb", size_gb)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> int:
        """
        The size of the OS disk in GB.
        """
        return pulumi.get(self, "size_gb")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of load balancer. Supported value: `loadBalancer`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OceanStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackToOndemand":
            suggest = "fallback_to_ondemand"
        elif key == "spotPercentage":
            suggest = "spot_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_to_ondemand: Optional[bool] = None,
                 spot_percentage: Optional[int] = None):
        """
        :param bool fallback_to_ondemand: If no spot instance markets are available, enable Ocean to launch on-demand instances instead.
        :param int spot_percentage: Percentage of Spot VMs to maintain.
        """
        OceanStrategy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fallback_to_ondemand=fallback_to_ondemand,
            spot_percentage=spot_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fallback_to_ondemand: Optional[bool] = None,
             spot_percentage: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if fallback_to_ondemand is not None:
            _setter("fallback_to_ondemand", fallback_to_ondemand)
        if spot_percentage is not None:
            _setter("spot_percentage", spot_percentage)

    @property
    @pulumi.getter(name="fallbackToOndemand")
    def fallback_to_ondemand(self) -> Optional[bool]:
        """
        If no spot instance markets are available, enable Ocean to launch on-demand instances instead.
        """
        return pulumi.get(self, "fallback_to_ondemand")

    @property
    @pulumi.getter(name="spotPercentage")
    def spot_percentage(self) -> Optional[int]:
        """
        Percentage of Spot VMs to maintain.
        """
        return pulumi.get(self, "spot_percentage")


@pulumi.output_type
class OceanTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: Tag key.
        :param str value: Tag value.
        """
        OceanTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanVirtualNodeGroupAutoscale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoHeadroomPercentage":
            suggest = "auto_headroom_percentage"
        elif key == "autoscaleHeadrooms":
            suggest = "autoscale_headrooms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanVirtualNodeGroupAutoscale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanVirtualNodeGroupAutoscale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanVirtualNodeGroupAutoscale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_headroom_percentage: Optional[int] = None,
                 autoscale_headrooms: Optional[Sequence['outputs.OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom']] = None):
        """
        :param int auto_headroom_percentage: Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when `cluster.autoScaler.headroom.automatic.is_enabled` = true is set on the Ocean cluster.
        """
        OceanVirtualNodeGroupAutoscale._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_headroom_percentage=auto_headroom_percentage,
            autoscale_headrooms=autoscale_headrooms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_headroom_percentage: Optional[int] = None,
             autoscale_headrooms: Optional[Sequence['outputs.OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if auto_headroom_percentage is not None:
            _setter("auto_headroom_percentage", auto_headroom_percentage)
        if autoscale_headrooms is not None:
            _setter("autoscale_headrooms", autoscale_headrooms)

    @property
    @pulumi.getter(name="autoHeadroomPercentage")
    def auto_headroom_percentage(self) -> Optional[int]:
        """
        Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when `cluster.autoScaler.headroom.automatic.is_enabled` = true is set on the Ocean cluster.
        """
        return pulumi.get(self, "auto_headroom_percentage")

    @property
    @pulumi.getter(name="autoscaleHeadrooms")
    def autoscale_headrooms(self) -> Optional[Sequence['outputs.OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom']]:
        return pulumi.get(self, "autoscale_headrooms")


@pulumi.output_type
class OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numOfUnits":
            suggest = "num_of_units"
        elif key == "cpuPerUnit":
            suggest = "cpu_per_unit"
        elif key == "gpuPerUnit":
            suggest = "gpu_per_unit"
        elif key == "memoryPerUnit":
            suggest = "memory_per_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_of_units: int,
                 cpu_per_unit: Optional[int] = None,
                 gpu_per_unit: Optional[int] = None,
                 memory_per_unit: Optional[int] = None):
        """
        :param int num_of_units: The number of headroom units to maintain, where each unit has the defined CPU, memory and GPU.
        :param int cpu_per_unit: Configure the number of CPUs to allocate for the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param int gpu_per_unit: How many GPU cores should be allocated for headroom unit.
        :param int memory_per_unit: Configure the amount of memory (MiB) to allocate the headroom.
        """
        OceanVirtualNodeGroupAutoscaleAutoscaleHeadroom._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            num_of_units=num_of_units,
            cpu_per_unit=cpu_per_unit,
            gpu_per_unit=gpu_per_unit,
            memory_per_unit=memory_per_unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             num_of_units: int,
             cpu_per_unit: Optional[int] = None,
             gpu_per_unit: Optional[int] = None,
             memory_per_unit: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("num_of_units", num_of_units)
        if cpu_per_unit is not None:
            _setter("cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            _setter("gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            _setter("memory_per_unit", memory_per_unit)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> int:
        """
        The number of headroom units to maintain, where each unit has the defined CPU, memory and GPU.
        """
        return pulumi.get(self, "num_of_units")

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[int]:
        """
        Configure the number of CPUs to allocate for the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[int]:
        """
        How many GPU cores should be allocated for headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[int]:
        """
        Configure the amount of memory (MiB) to allocate the headroom.
        """
        return pulumi.get(self, "memory_per_unit")


@pulumi.output_type
class OceanVirtualNodeGroupLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        """
        :param str key: Tag Key for Vms in the cluster.
        :param str value: Tag Value for VMs in the cluster.
        """
        OceanVirtualNodeGroupLabel._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Tag Key for Vms in the cluster.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Tag Value for VMs in the cluster.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanVirtualNodeGroupLaunchSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPods":
            suggest = "max_pods"
        elif key == "osDisk":
            suggest = "os_disk"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanVirtualNodeGroupLaunchSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanVirtualNodeGroupLaunchSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanVirtualNodeGroupLaunchSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_pods: Optional[int] = None,
                 os_disk: Optional['outputs.OceanVirtualNodeGroupLaunchSpecificationOsDisk'] = None,
                 tags: Optional[Sequence['outputs.OceanVirtualNodeGroupLaunchSpecificationTag']] = None):
        """
        :param int max_pods: The maximum number of pods per node in an AKS cluster.
        :param 'OceanVirtualNodeGroupLaunchSpecificationOsDiskArgs' os_disk: Specify OS disk specification other than default.
        :param Sequence['OceanVirtualNodeGroupLaunchSpecificationTagArgs'] tags: Additional key-value pairs to be used to tag the VMs in the virtual node group.
        """
        OceanVirtualNodeGroupLaunchSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_pods=max_pods,
            os_disk=os_disk,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_pods: Optional[int] = None,
             os_disk: Optional['outputs.OceanVirtualNodeGroupLaunchSpecificationOsDisk'] = None,
             tags: Optional[Sequence['outputs.OceanVirtualNodeGroupLaunchSpecificationTag']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_pods is not None:
            _setter("max_pods", max_pods)
        if os_disk is not None:
            _setter("os_disk", os_disk)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[int]:
        """
        The maximum number of pods per node in an AKS cluster.
        """
        return pulumi.get(self, "max_pods")

    @property
    @pulumi.getter(name="osDisk")
    def os_disk(self) -> Optional['outputs.OceanVirtualNodeGroupLaunchSpecificationOsDisk']:
        """
        Specify OS disk specification other than default.
        """
        return pulumi.get(self, "os_disk")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.OceanVirtualNodeGroupLaunchSpecificationTag']]:
        """
        Additional key-value pairs to be used to tag the VMs in the virtual node group.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class OceanVirtualNodeGroupLaunchSpecificationOsDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGb":
            suggest = "size_gb"
        elif key == "utilizeEphemeralStorage":
            suggest = "utilize_ephemeral_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanVirtualNodeGroupLaunchSpecificationOsDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanVirtualNodeGroupLaunchSpecificationOsDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanVirtualNodeGroupLaunchSpecificationOsDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_gb: int,
                 type: Optional[str] = None,
                 utilize_ephemeral_storage: Optional[bool] = None):
        """
        :param int size_gb: The size of the OS disk in GB, Required if dataDisks is specified.
        :param str type: The type of the OS disk. Valid values: `"Standard_LRS"`, `"Premium_LRS"`, `"StandardSSD_LRS"`.
        :param bool utilize_ephemeral_storage: Flag to enable/disable the Ephemeral OS Disk utilization.
        """
        OceanVirtualNodeGroupLaunchSpecificationOsDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            size_gb=size_gb,
            type=type,
            utilize_ephemeral_storage=utilize_ephemeral_storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             size_gb: int,
             type: Optional[str] = None,
             utilize_ephemeral_storage: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("size_gb", size_gb)
        if type is not None:
            _setter("type", type)
        if utilize_ephemeral_storage is not None:
            _setter("utilize_ephemeral_storage", utilize_ephemeral_storage)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> int:
        """
        The size of the OS disk in GB, Required if dataDisks is specified.
        """
        return pulumi.get(self, "size_gb")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the OS disk. Valid values: `"Standard_LRS"`, `"Premium_LRS"`, `"StandardSSD_LRS"`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="utilizeEphemeralStorage")
    def utilize_ephemeral_storage(self) -> Optional[bool]:
        """
        Flag to enable/disable the Ephemeral OS Disk utilization.
        """
        return pulumi.get(self, "utilize_ephemeral_storage")


@pulumi.output_type
class OceanVirtualNodeGroupLaunchSpecificationTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: Tag Key for Vms in the cluster.
        :param str value: Tag Value for VMs in the cluster.
        """
        OceanVirtualNodeGroupLaunchSpecificationTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Tag Key for Vms in the cluster.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Tag Value for VMs in the cluster.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanVirtualNodeGroupResourceLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxInstanceCount":
            suggest = "max_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanVirtualNodeGroupResourceLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanVirtualNodeGroupResourceLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanVirtualNodeGroupResourceLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_instance_count: Optional[int] = None):
        """
        :param int max_instance_count: Option to set a maximum number of instances per virtual node group. If set, value must be greater than or equal to 0.
        """
        OceanVirtualNodeGroupResourceLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_instance_count=max_instance_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_instance_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_instance_count is not None:
            _setter("max_instance_count", max_instance_count)

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> Optional[int]:
        """
        Option to set a maximum number of instances per virtual node group. If set, value must be greater than or equal to 0.
        """
        return pulumi.get(self, "max_instance_count")


@pulumi.output_type
class OceanVirtualNodeGroupTaint(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: str):
        """
        :param str effect: The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`, `"PreferNoExecute"`.
        :param str key: Tag Key for Vms in the cluster.
        :param str value: Tag Value for VMs in the cluster.
        """
        OceanVirtualNodeGroupTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: str,
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("effect", effect)
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`, `"PreferNoExecute"`.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Tag Key for Vms in the cluster.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Tag Value for VMs in the cluster.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanVmSize(dict):
    def __init__(__self__, *,
                 whitelists: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] whitelists: VM types allowed in the Ocean cluster.
        """
        OceanVmSize._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            whitelists=whitelists,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             whitelists: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if whitelists is not None:
            _setter("whitelists", whitelists)

    @property
    @pulumi.getter
    def whitelists(self) -> Optional[Sequence[str]]:
        """
        VM types allowed in the Ocean cluster.
        """
        return pulumi.get(self, "whitelists")


