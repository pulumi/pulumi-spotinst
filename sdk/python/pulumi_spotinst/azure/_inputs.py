# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'OceanNpAutoscalerArgs',
    'OceanNpAutoscalerAutoscaleDownArgs',
    'OceanNpAutoscalerAutoscaleHeadroomArgs',
    'OceanNpAutoscalerAutoscaleHeadroomAutomaticArgs',
    'OceanNpAutoscalerResourceLimitsArgs',
    'OceanNpFiltersArgs',
    'OceanNpHeadroomArgs',
    'OceanNpHealthArgs',
    'OceanNpLinuxOsConfigArgs',
    'OceanNpLinuxOsConfigSysctlArgs',
    'OceanNpSchedulingArgs',
    'OceanNpSchedulingShutdownHoursArgs',
    'OceanNpSchedulingTaskArgs',
    'OceanNpSchedulingTaskParametersArgs',
    'OceanNpSchedulingTaskParametersParametersClusterRollArgs',
    'OceanNpTaintArgs',
    'OceanNpUpdatePolicyArgs',
    'OceanNpUpdatePolicyRollConfigArgs',
    'OceanNpVirtualNodeGroupFiltersArgs',
    'OceanNpVirtualNodeGroupHeadroomArgs',
    'OceanNpVirtualNodeGroupLinuxOsConfigArgs',
    'OceanNpVirtualNodeGroupLinuxOsConfigSysctlArgs',
    'OceanNpVirtualNodeGroupTaintArgs',
    'OceanNpVirtualNodeGroupUpdatePolicyArgs',
    'OceanNpVirtualNodeGroupUpdatePolicyRollConfigArgs',
]

@pulumi.input_type
class OceanNpAutoscalerArgs:
    def __init__(__self__, *,
                 autoscale_down: Optional[pulumi.Input['OceanNpAutoscalerAutoscaleDownArgs']] = None,
                 autoscale_headroom: Optional[pulumi.Input['OceanNpAutoscalerAutoscaleHeadroomArgs']] = None,
                 autoscale_is_enabled: Optional[pulumi.Input[bool]] = None,
                 resource_limits: Optional[pulumi.Input['OceanNpAutoscalerResourceLimitsArgs']] = None):
        """
        :param pulumi.Input['OceanNpAutoscalerAutoscaleDownArgs'] autoscale_down: Auto Scaling scale down operations.
        :param pulumi.Input['OceanNpAutoscalerAutoscaleHeadroomArgs'] autoscale_headroom: Spare resource capacity management enabling fast assignment of pods without waiting for new resources to launch.
        :param pulumi.Input[bool] autoscale_is_enabled: Enable the Ocean Kubernetes Autoscaler.
        :param pulumi.Input['OceanNpAutoscalerResourceLimitsArgs'] resource_limits: Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        if autoscale_down is not None:
            pulumi.set(__self__, "autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)
        if autoscale_is_enabled is not None:
            pulumi.set(__self__, "autoscale_is_enabled", autoscale_is_enabled)
        if resource_limits is not None:
            pulumi.set(__self__, "resource_limits", resource_limits)

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional[pulumi.Input['OceanNpAutoscalerAutoscaleDownArgs']]:
        """
        Auto Scaling scale down operations.
        """
        return pulumi.get(self, "autoscale_down")

    @autoscale_down.setter
    def autoscale_down(self, value: Optional[pulumi.Input['OceanNpAutoscalerAutoscaleDownArgs']]):
        pulumi.set(self, "autoscale_down", value)

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional[pulumi.Input['OceanNpAutoscalerAutoscaleHeadroomArgs']]:
        """
        Spare resource capacity management enabling fast assignment of pods without waiting for new resources to launch.
        """
        return pulumi.get(self, "autoscale_headroom")

    @autoscale_headroom.setter
    def autoscale_headroom(self, value: Optional[pulumi.Input['OceanNpAutoscalerAutoscaleHeadroomArgs']]):
        pulumi.set(self, "autoscale_headroom", value)

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the Ocean Kubernetes Autoscaler.
        """
        return pulumi.get(self, "autoscale_is_enabled")

    @autoscale_is_enabled.setter
    def autoscale_is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale_is_enabled", value)

    @property
    @pulumi.getter(name="resourceLimits")
    def resource_limits(self) -> Optional[pulumi.Input['OceanNpAutoscalerResourceLimitsArgs']]:
        """
        Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        return pulumi.get(self, "resource_limits")

    @resource_limits.setter
    def resource_limits(self, value: Optional[pulumi.Input['OceanNpAutoscalerResourceLimitsArgs']]):
        pulumi.set(self, "resource_limits", value)


@pulumi.input_type
class OceanNpAutoscalerAutoscaleDownArgs:
    def __init__(__self__, *,
                 max_scale_down_percentage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_scale_down_percentage: The maximum percentage allowed to scale down in a single scaling action.
        """
        if max_scale_down_percentage is not None:
            pulumi.set(__self__, "max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum percentage allowed to scale down in a single scaling action.
        """
        return pulumi.get(self, "max_scale_down_percentage")

    @max_scale_down_percentage.setter
    def max_scale_down_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_scale_down_percentage", value)


@pulumi.input_type
class OceanNpAutoscalerAutoscaleHeadroomArgs:
    def __init__(__self__, *,
                 automatic: Optional[pulumi.Input['OceanNpAutoscalerAutoscaleHeadroomAutomaticArgs']] = None):
        """
        :param pulumi.Input['OceanNpAutoscalerAutoscaleHeadroomAutomaticArgs'] automatic: [Automatic headroom](https://docs.spot.io/ocean/features/headroom?id=automatic-headroom) configuration.
        """
        if automatic is not None:
            pulumi.set(__self__, "automatic", automatic)

    @property
    @pulumi.getter
    def automatic(self) -> Optional[pulumi.Input['OceanNpAutoscalerAutoscaleHeadroomAutomaticArgs']]:
        """
        [Automatic headroom](https://docs.spot.io/ocean/features/headroom?id=automatic-headroom) configuration.
        """
        return pulumi.get(self, "automatic")

    @automatic.setter
    def automatic(self, value: Optional[pulumi.Input['OceanNpAutoscalerAutoscaleHeadroomAutomaticArgs']]):
        pulumi.set(self, "automatic", value)


@pulumi.input_type
class OceanNpAutoscalerAutoscaleHeadroomAutomaticArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 percentage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] is_enabled: Enable automatic headroom. When set to True, Ocean configures and optimizes headroom automatically.
        :param pulumi.Input[int] percentage: Optionally set a number between 0-100 to control the percentage of total cluster resources dedicated to headroom.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if percentage is not None:
            pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable automatic headroom. When set to True, Ocean configures and optimizes headroom automatically.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally set a number between 0-100 to control the percentage of total cluster resources dedicated to headroom.
        """
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "percentage", value)


@pulumi.input_type
class OceanNpAutoscalerResourceLimitsArgs:
    def __init__(__self__, *,
                 max_memory_gib: Optional[pulumi.Input[int]] = None,
                 max_vcpu: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_memory_gib: The maximum memory in GiB units that can be allocated to the cluster.
        :param pulumi.Input[int] max_vcpu: The maximum cpu in vCpu units that can be allocated to the cluster.
        """
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum memory in GiB units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_memory_gib")

    @max_memory_gib.setter
    def max_memory_gib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_memory_gib", value)

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum cpu in vCpu units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_vcpu")

    @max_vcpu.setter
    def max_vcpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_vcpu", value)


@pulumi.input_type
class OceanNpFiltersArgs:
    def __init__(__self__, *,
                 accelerated_networking: Optional[pulumi.Input[str]] = None,
                 architectures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 disk_performance: Optional[pulumi.Input[str]] = None,
                 exclude_series: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gpu_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_gpu: Optional[pulumi.Input[float]] = None,
                 max_memory_gib: Optional[pulumi.Input[float]] = None,
                 max_vcpu: Optional[pulumi.Input[int]] = None,
                 min_disk: Optional[pulumi.Input[int]] = None,
                 min_gpu: Optional[pulumi.Input[float]] = None,
                 min_memory_gib: Optional[pulumi.Input[float]] = None,
                 min_nics: Optional[pulumi.Input[int]] = None,
                 min_vcpu: Optional[pulumi.Input[int]] = None,
                 series: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vm_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] accelerated_networking: In case acceleratedNetworking is set to Enabled, accelerated networking applies only to the VM that enables it.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] architectures: The filtered vm sizes will support at least one of the architectures from this list. x86_64 includes both intel64 and amd64.
        :param pulumi.Input[str] disk_performance: The filtered vm sizes will support at least one of the classes from this list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_series: Vm sizes belonging to a series from the list will not be available for scaling
        :param pulumi.Input[Sequence[pulumi.Input[str]]] gpu_types: The filtered gpu types will belong to one of the gpu types from this list.
        :param pulumi.Input[float] max_gpu: Maximum number of GPUs available.
        :param pulumi.Input[float] max_memory_gib: Maximum amount of Memory (GiB).
        :param pulumi.Input[int] max_vcpu: Maximum number of vcpus available.
        :param pulumi.Input[int] min_disk: Minimum number of data disks available.
        :param pulumi.Input[float] min_gpu: Minimum number of GPUs available.
        :param pulumi.Input[float] min_memory_gib: Minimum amount of Memory (GiB).
        :param pulumi.Input[int] min_nics: Minimum number of network interfaces.
        :param pulumi.Input[int] min_vcpu: Minimum number of vcpus available.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] series: Vm sizes belonging to a series from the list will be available for scaling. We can specify include list and series can be specified with capital or small letters, with space, without space or with underscore '_' .  For example all of these "DSv2", "Ds v2", "ds_v2" refer to same DS_v2 series.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vm_types: The filtered vm types will belong to one of the vm types from this list.
        """
        if accelerated_networking is not None:
            pulumi.set(__self__, "accelerated_networking", accelerated_networking)
        if architectures is not None:
            pulumi.set(__self__, "architectures", architectures)
        if disk_performance is not None:
            pulumi.set(__self__, "disk_performance", disk_performance)
        if exclude_series is not None:
            pulumi.set(__self__, "exclude_series", exclude_series)
        if gpu_types is not None:
            pulumi.set(__self__, "gpu_types", gpu_types)
        if max_gpu is not None:
            pulumi.set(__self__, "max_gpu", max_gpu)
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)
        if min_disk is not None:
            pulumi.set(__self__, "min_disk", min_disk)
        if min_gpu is not None:
            pulumi.set(__self__, "min_gpu", min_gpu)
        if min_memory_gib is not None:
            pulumi.set(__self__, "min_memory_gib", min_memory_gib)
        if min_nics is not None:
            pulumi.set(__self__, "min_nics", min_nics)
        if min_vcpu is not None:
            pulumi.set(__self__, "min_vcpu", min_vcpu)
        if series is not None:
            pulumi.set(__self__, "series", series)
        if vm_types is not None:
            pulumi.set(__self__, "vm_types", vm_types)

    @property
    @pulumi.getter(name="acceleratedNetworking")
    def accelerated_networking(self) -> Optional[pulumi.Input[str]]:
        """
        In case acceleratedNetworking is set to Enabled, accelerated networking applies only to the VM that enables it.
        """
        return pulumi.get(self, "accelerated_networking")

    @accelerated_networking.setter
    def accelerated_networking(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "accelerated_networking", value)

    @property
    @pulumi.getter
    def architectures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered vm sizes will support at least one of the architectures from this list. x86_64 includes both intel64 and amd64.
        """
        return pulumi.get(self, "architectures")

    @architectures.setter
    def architectures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "architectures", value)

    @property
    @pulumi.getter(name="diskPerformance")
    def disk_performance(self) -> Optional[pulumi.Input[str]]:
        """
        The filtered vm sizes will support at least one of the classes from this list.
        """
        return pulumi.get(self, "disk_performance")

    @disk_performance.setter
    def disk_performance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_performance", value)

    @property
    @pulumi.getter(name="excludeSeries")
    def exclude_series(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Vm sizes belonging to a series from the list will not be available for scaling
        """
        return pulumi.get(self, "exclude_series")

    @exclude_series.setter
    def exclude_series(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_series", value)

    @property
    @pulumi.getter(name="gpuTypes")
    def gpu_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered gpu types will belong to one of the gpu types from this list.
        """
        return pulumi.get(self, "gpu_types")

    @gpu_types.setter
    def gpu_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "gpu_types", value)

    @property
    @pulumi.getter(name="maxGpu")
    def max_gpu(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum number of GPUs available.
        """
        return pulumi.get(self, "max_gpu")

    @max_gpu.setter
    def max_gpu(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_gpu", value)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum amount of Memory (GiB).
        """
        return pulumi.get(self, "max_memory_gib")

    @max_memory_gib.setter
    def max_memory_gib(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_memory_gib", value)

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of vcpus available.
        """
        return pulumi.get(self, "max_vcpu")

    @max_vcpu.setter
    def max_vcpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_vcpu", value)

    @property
    @pulumi.getter(name="minDisk")
    def min_disk(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of data disks available.
        """
        return pulumi.get(self, "min_disk")

    @min_disk.setter
    def min_disk(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_disk", value)

    @property
    @pulumi.getter(name="minGpu")
    def min_gpu(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum number of GPUs available.
        """
        return pulumi.get(self, "min_gpu")

    @min_gpu.setter
    def min_gpu(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_gpu", value)

    @property
    @pulumi.getter(name="minMemoryGib")
    def min_memory_gib(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum amount of Memory (GiB).
        """
        return pulumi.get(self, "min_memory_gib")

    @min_memory_gib.setter
    def min_memory_gib(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_memory_gib", value)

    @property
    @pulumi.getter(name="minNics")
    def min_nics(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of network interfaces.
        """
        return pulumi.get(self, "min_nics")

    @min_nics.setter
    def min_nics(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_nics", value)

    @property
    @pulumi.getter(name="minVcpu")
    def min_vcpu(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of vcpus available.
        """
        return pulumi.get(self, "min_vcpu")

    @min_vcpu.setter
    def min_vcpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_vcpu", value)

    @property
    @pulumi.getter
    def series(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Vm sizes belonging to a series from the list will be available for scaling. We can specify include list and series can be specified with capital or small letters, with space, without space or with underscore '_' .  For example all of these "DSv2", "Ds v2", "ds_v2" refer to same DS_v2 series.
        """
        return pulumi.get(self, "series")

    @series.setter
    def series(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "series", value)

    @property
    @pulumi.getter(name="vmTypes")
    def vm_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered vm types will belong to one of the vm types from this list.
        """
        return pulumi.get(self, "vm_types")

    @vm_types.setter
    def vm_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vm_types", value)


@pulumi.input_type
class OceanNpHeadroomArgs:
    def __init__(__self__, *,
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 gpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None,
                 num_of_units: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] cpu_per_unit: Configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[int] gpu_per_unit: Amount of GPU to allocate for headroom unit.
        :param pulumi.Input[int] memory_per_unit: Configure the amount of memory (MiB) to allocate the headroom.
        :param pulumi.Input[int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Amount of GPU to allocate for headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @gpu_per_unit.setter
    def gpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Configure the amount of memory (MiB) to allocate the headroom.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[pulumi.Input[int]]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_of_units", value)


@pulumi.input_type
class OceanNpHealthArgs:
    def __init__(__self__, *,
                 grace_period: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] grace_period: The amount of time to wait, in seconds, from the moment the instance has launched until monitoring of its health checks begins.
        """
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time to wait, in seconds, from the moment the instance has launched until monitoring of its health checks begins.
        """
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "grace_period", value)


@pulumi.input_type
class OceanNpLinuxOsConfigArgs:
    def __init__(__self__, *,
                 sysctls: Optional[pulumi.Input[Sequence[pulumi.Input['OceanNpLinuxOsConfigSysctlArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OceanNpLinuxOsConfigSysctlArgs']]] sysctls: System Controls
        """
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanNpLinuxOsConfigSysctlArgs']]]]:
        """
        System Controls
        """
        return pulumi.get(self, "sysctls")

    @sysctls.setter
    def sysctls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanNpLinuxOsConfigSysctlArgs']]]]):
        pulumi.set(self, "sysctls", value)


@pulumi.input_type
class OceanNpLinuxOsConfigSysctlArgs:
    def __init__(__self__, *,
                 vm_max_map_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] vm_max_map_count: Maximum number of memory map areas a process may have. Can be configured only if OS type is Linux.
        """
        if vm_max_map_count is not None:
            pulumi.set(__self__, "vm_max_map_count", vm_max_map_count)

    @property
    @pulumi.getter(name="vmMaxMapCount")
    def vm_max_map_count(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of memory map areas a process may have. Can be configured only if OS type is Linux.
        """
        return pulumi.get(self, "vm_max_map_count")

    @vm_max_map_count.setter
    def vm_max_map_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vm_max_map_count", value)


@pulumi.input_type
class OceanNpSchedulingArgs:
    def __init__(__self__, *,
                 shutdown_hours: Optional[pulumi.Input['OceanNpSchedulingShutdownHoursArgs']] = None,
                 tasks: Optional[pulumi.Input[Sequence[pulumi.Input['OceanNpSchedulingTaskArgs']]]] = None):
        if shutdown_hours is not None:
            pulumi.set(__self__, "shutdown_hours", shutdown_hours)
        if tasks is not None:
            pulumi.set(__self__, "tasks", tasks)

    @property
    @pulumi.getter(name="shutdownHours")
    def shutdown_hours(self) -> Optional[pulumi.Input['OceanNpSchedulingShutdownHoursArgs']]:
        return pulumi.get(self, "shutdown_hours")

    @shutdown_hours.setter
    def shutdown_hours(self, value: Optional[pulumi.Input['OceanNpSchedulingShutdownHoursArgs']]):
        pulumi.set(self, "shutdown_hours", value)

    @property
    @pulumi.getter
    def tasks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanNpSchedulingTaskArgs']]]]:
        return pulumi.get(self, "tasks")

    @tasks.setter
    def tasks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanNpSchedulingTaskArgs']]]]):
        pulumi.set(self, "tasks", value)


@pulumi.input_type
class OceanNpSchedulingShutdownHoursArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 time_windows: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] is_enabled: Enable automatic headroom. When set to True, Ocean configures and optimizes headroom automatically.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable automatic headroom. When set to True, Ocean configures and optimizes headroom automatically.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "time_windows", value)


@pulumi.input_type
class OceanNpSchedulingTaskArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[str],
                 is_enabled: pulumi.Input[bool],
                 task_type: pulumi.Input[str],
                 parameters: Optional[pulumi.Input['OceanNpSchedulingTaskParametersArgs']] = None):
        """
        :param pulumi.Input[bool] is_enabled: Enable automatic headroom. When set to True, Ocean configures and optimizes headroom automatically.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "task_type", task_type)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Enable automatic headroom. When set to True, Ocean configures and optimizes headroom automatically.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_type", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input['OceanNpSchedulingTaskParametersArgs']]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input['OceanNpSchedulingTaskParametersArgs']]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class OceanNpSchedulingTaskParametersArgs:
    def __init__(__self__, *,
                 parameters_cluster_roll: Optional[pulumi.Input['OceanNpSchedulingTaskParametersParametersClusterRollArgs']] = None):
        if parameters_cluster_roll is not None:
            pulumi.set(__self__, "parameters_cluster_roll", parameters_cluster_roll)

    @property
    @pulumi.getter(name="parametersClusterRoll")
    def parameters_cluster_roll(self) -> Optional[pulumi.Input['OceanNpSchedulingTaskParametersParametersClusterRollArgs']]:
        return pulumi.get(self, "parameters_cluster_roll")

    @parameters_cluster_roll.setter
    def parameters_cluster_roll(self, value: Optional[pulumi.Input['OceanNpSchedulingTaskParametersParametersClusterRollArgs']]):
        pulumi.set(self, "parameters_cluster_roll", value)


@pulumi.input_type
class OceanNpSchedulingTaskParametersParametersClusterRollArgs:
    def __init__(__self__, *,
                 batch_min_healthy_percentage: Optional[pulumi.Input[int]] = None,
                 batch_size_percentage: Optional[pulumi.Input[int]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 respect_pdb: Optional[pulumi.Input[bool]] = None,
                 respect_restrict_scale_down: Optional[pulumi.Input[bool]] = None,
                 vng_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] batch_min_healthy_percentage: Indicates the threshold of minimum healthy nodes in single batch. If the amount of healthy nodes in single batch is under the threshold, the roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        :param pulumi.Input[int] batch_size_percentage: Value as a percent to set the size of a batch in a roll. Valid values are 0-100. In case of null as value, the default value in the backend will be 20%.
        :param pulumi.Input[str] comment: Add a comment description for the roll. The comment is limited to 256 chars and optional.
        :param pulumi.Input[bool] respect_pdb: During the roll, if the parameter is set to true we honor PDB during the nodes replacement.
        :param pulumi.Input[bool] respect_restrict_scale_down: During the roll, if the parameter is set to true we honor Restrict Scale Down label during the nodes replacement.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vng_ids: List of virtual node group identifiers to be rolled. Each identifier is a string. vngIds can be null, and cannot be used together with nodeNames and nodePoolNames.
        """
        if batch_min_healthy_percentage is not None:
            pulumi.set(__self__, "batch_min_healthy_percentage", batch_min_healthy_percentage)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if respect_pdb is not None:
            pulumi.set(__self__, "respect_pdb", respect_pdb)
        if respect_restrict_scale_down is not None:
            pulumi.set(__self__, "respect_restrict_scale_down", respect_restrict_scale_down)
        if vng_ids is not None:
            pulumi.set(__self__, "vng_ids", vng_ids)

    @property
    @pulumi.getter(name="batchMinHealthyPercentage")
    def batch_min_healthy_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates the threshold of minimum healthy nodes in single batch. If the amount of healthy nodes in single batch is under the threshold, the roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        """
        return pulumi.get(self, "batch_min_healthy_percentage")

    @batch_min_healthy_percentage.setter
    def batch_min_healthy_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_min_healthy_percentage", value)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Value as a percent to set the size of a batch in a roll. Valid values are 0-100. In case of null as value, the default value in the backend will be 20%.
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        Add a comment description for the roll. The comment is limited to 256 chars and optional.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="respectPdb")
    def respect_pdb(self) -> Optional[pulumi.Input[bool]]:
        """
        During the roll, if the parameter is set to true we honor PDB during the nodes replacement.
        """
        return pulumi.get(self, "respect_pdb")

    @respect_pdb.setter
    def respect_pdb(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "respect_pdb", value)

    @property
    @pulumi.getter(name="respectRestrictScaleDown")
    def respect_restrict_scale_down(self) -> Optional[pulumi.Input[bool]]:
        """
        During the roll, if the parameter is set to true we honor Restrict Scale Down label during the nodes replacement.
        """
        return pulumi.get(self, "respect_restrict_scale_down")

    @respect_restrict_scale_down.setter
    def respect_restrict_scale_down(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "respect_restrict_scale_down", value)

    @property
    @pulumi.getter(name="vngIds")
    def vng_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of virtual node group identifiers to be rolled. Each identifier is a string. vngIds can be null, and cannot be used together with nodeNames and nodePoolNames.
        """
        return pulumi.get(self, "vng_ids")

    @vng_ids.setter
    def vng_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vng_ids", value)


@pulumi.input_type
class OceanNpTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[str],
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] effect: Set taint effect.
        :param pulumi.Input[str] key: Set taint key. The following taint keys are not allowed: ["node.kubernetes.io/not-ready",  "node.kubernetes.io/unreachable", "node.kubernetes.io/unschedulable",  "node.kubernetes.io/memory-pressure",  "node.kubernetes.io/disk-pressure",  "node.kubernetes.io/network-unavailable",  "node.kubernetes.io/pid-pressure",  "node.kubernetes.io/out-of-service",  "node.cloudprovider.kubernetes.io/uninitialized",  "node.cloudprovider.kubernetes.io/shutdown", "kubernetes.azure.com/scalesetpriority"]
        :param pulumi.Input[str] value: Set taint value.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[str]:
        """
        Set taint effect.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Set taint key. The following taint keys are not allowed: ["node.kubernetes.io/not-ready",  "node.kubernetes.io/unreachable", "node.kubernetes.io/unschedulable",  "node.kubernetes.io/memory-pressure",  "node.kubernetes.io/disk-pressure",  "node.kubernetes.io/network-unavailable",  "node.kubernetes.io/pid-pressure",  "node.kubernetes.io/out-of-service",  "node.cloudprovider.kubernetes.io/uninitialized",  "node.cloudprovider.kubernetes.io/shutdown", "kubernetes.azure.com/scalesetpriority"]
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Set taint value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class OceanNpUpdatePolicyArgs:
    def __init__(__self__, *,
                 should_roll: pulumi.Input[bool],
                 conditioned_roll: Optional[pulumi.Input[bool]] = None,
                 roll_config: Optional[pulumi.Input['OceanNpUpdatePolicyRollConfigArgs']] = None):
        """
        :param pulumi.Input[bool] should_roll: If set to true along with the cluster update, roll will be triggered.
        :param pulumi.Input[bool] conditioned_roll: Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as availability_zones, max_pods_per_node, enable_node_public_ip, os_disk_size_gb, os_disk_type, os_sku, kubernetes_version, vnet_subnet_ids, pod_subnet_ids, labels, taints and tags).
        :param pulumi.Input['OceanNpUpdatePolicyRollConfigArgs'] roll_config: While used, you can control whether the group should perform a deployment after an update to the configuration.
        """
        pulumi.set(__self__, "should_roll", should_roll)
        if conditioned_roll is not None:
            pulumi.set(__self__, "conditioned_roll", conditioned_roll)
        if roll_config is not None:
            pulumi.set(__self__, "roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> pulumi.Input[bool]:
        """
        If set to true along with the cluster update, roll will be triggered.
        """
        return pulumi.get(self, "should_roll")

    @should_roll.setter
    def should_roll(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_roll", value)

    @property
    @pulumi.getter(name="conditionedRoll")
    def conditioned_roll(self) -> Optional[pulumi.Input[bool]]:
        """
        Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as availability_zones, max_pods_per_node, enable_node_public_ip, os_disk_size_gb, os_disk_type, os_sku, kubernetes_version, vnet_subnet_ids, pod_subnet_ids, labels, taints and tags).
        """
        return pulumi.get(self, "conditioned_roll")

    @conditioned_roll.setter
    def conditioned_roll(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "conditioned_roll", value)

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional[pulumi.Input['OceanNpUpdatePolicyRollConfigArgs']]:
        """
        While used, you can control whether the group should perform a deployment after an update to the configuration.
        """
        return pulumi.get(self, "roll_config")

    @roll_config.setter
    def roll_config(self, value: Optional[pulumi.Input['OceanNpUpdatePolicyRollConfigArgs']]):
        pulumi.set(self, "roll_config", value)


@pulumi.input_type
class OceanNpUpdatePolicyRollConfigArgs:
    def __init__(__self__, *,
                 batch_min_healthy_percentage: Optional[pulumi.Input[int]] = None,
                 batch_size_percentage: Optional[pulumi.Input[int]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 node_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 node_pool_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 respect_pdb: Optional[pulumi.Input[bool]] = None,
                 respect_restrict_scale_down: Optional[pulumi.Input[bool]] = None,
                 vng_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] batch_min_healthy_percentage: Indicates the threshold of minimum healthy nodes in single batch. If the amount of healthy nodes in single batch is under the threshold, the roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        :param pulumi.Input[int] batch_size_percentage: Value as a percent to set the size of a batch in a roll. Valid values are 0-100. In case of null as value, the default value in the backend will be 20%.
        :param pulumi.Input[str] comment: Add a comment description for the roll. The comment is limited to 256 chars and optional.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] node_names: List of node names to be rolled. Each identifier is a string. nodeNames can be null, and cannot be used together with nodePoolNames and vngIds.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] node_pool_names: List of node pools to be rolled. Each node pool name is a string. nodePoolNames can be null, and cannot be used together with nodeNames and vngIds.
        :param pulumi.Input[bool] respect_pdb: During the roll, if the parameter is set to true we honor PDB during the nodes replacement.
        :param pulumi.Input[bool] respect_restrict_scale_down: During the roll, if the parameter is set to true we honor Restrict Scale Down label during the nodes replacement.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vng_ids: List of virtual node group identifiers to be rolled. Each identifier is a string. vngIds can be null, and cannot be used together with nodeNames and nodePoolNames.
        """
        if batch_min_healthy_percentage is not None:
            pulumi.set(__self__, "batch_min_healthy_percentage", batch_min_healthy_percentage)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if node_names is not None:
            pulumi.set(__self__, "node_names", node_names)
        if node_pool_names is not None:
            pulumi.set(__self__, "node_pool_names", node_pool_names)
        if respect_pdb is not None:
            pulumi.set(__self__, "respect_pdb", respect_pdb)
        if respect_restrict_scale_down is not None:
            pulumi.set(__self__, "respect_restrict_scale_down", respect_restrict_scale_down)
        if vng_ids is not None:
            pulumi.set(__self__, "vng_ids", vng_ids)

    @property
    @pulumi.getter(name="batchMinHealthyPercentage")
    def batch_min_healthy_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates the threshold of minimum healthy nodes in single batch. If the amount of healthy nodes in single batch is under the threshold, the roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        """
        return pulumi.get(self, "batch_min_healthy_percentage")

    @batch_min_healthy_percentage.setter
    def batch_min_healthy_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_min_healthy_percentage", value)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Value as a percent to set the size of a batch in a roll. Valid values are 0-100. In case of null as value, the default value in the backend will be 20%.
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        Add a comment description for the roll. The comment is limited to 256 chars and optional.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="nodeNames")
    def node_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of node names to be rolled. Each identifier is a string. nodeNames can be null, and cannot be used together with nodePoolNames and vngIds.
        """
        return pulumi.get(self, "node_names")

    @node_names.setter
    def node_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "node_names", value)

    @property
    @pulumi.getter(name="nodePoolNames")
    def node_pool_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of node pools to be rolled. Each node pool name is a string. nodePoolNames can be null, and cannot be used together with nodeNames and vngIds.
        """
        return pulumi.get(self, "node_pool_names")

    @node_pool_names.setter
    def node_pool_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "node_pool_names", value)

    @property
    @pulumi.getter(name="respectPdb")
    def respect_pdb(self) -> Optional[pulumi.Input[bool]]:
        """
        During the roll, if the parameter is set to true we honor PDB during the nodes replacement.
        """
        return pulumi.get(self, "respect_pdb")

    @respect_pdb.setter
    def respect_pdb(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "respect_pdb", value)

    @property
    @pulumi.getter(name="respectRestrictScaleDown")
    def respect_restrict_scale_down(self) -> Optional[pulumi.Input[bool]]:
        """
        During the roll, if the parameter is set to true we honor Restrict Scale Down label during the nodes replacement.
        """
        return pulumi.get(self, "respect_restrict_scale_down")

    @respect_restrict_scale_down.setter
    def respect_restrict_scale_down(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "respect_restrict_scale_down", value)

    @property
    @pulumi.getter(name="vngIds")
    def vng_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of virtual node group identifiers to be rolled. Each identifier is a string. vngIds can be null, and cannot be used together with nodeNames and nodePoolNames.
        """
        return pulumi.get(self, "vng_ids")

    @vng_ids.setter
    def vng_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vng_ids", value)


@pulumi.input_type
class OceanNpVirtualNodeGroupFiltersArgs:
    def __init__(__self__, *,
                 accelerated_networking: Optional[pulumi.Input[str]] = None,
                 architectures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 disk_performance: Optional[pulumi.Input[str]] = None,
                 exclude_series: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gpu_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_gpu: Optional[pulumi.Input[float]] = None,
                 max_memory_gib: Optional[pulumi.Input[float]] = None,
                 max_vcpu: Optional[pulumi.Input[int]] = None,
                 min_disk: Optional[pulumi.Input[int]] = None,
                 min_gpu: Optional[pulumi.Input[float]] = None,
                 min_memory_gib: Optional[pulumi.Input[float]] = None,
                 min_nics: Optional[pulumi.Input[int]] = None,
                 min_vcpu: Optional[pulumi.Input[int]] = None,
                 series: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vm_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] accelerated_networking: In case acceleratedNetworking is set to Enabled, accelerated networking applies only to the VM that enables it.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] architectures: The filtered vm sizes will support at least one of the architectures from this list. x86_64 includes both intel64 and amd64.
        :param pulumi.Input[str] disk_performance: The filtered vm sizes will support at least one of the classes from this list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_series: Vm sizes belonging to a series from the list will not be available for scaling.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] gpu_types: The filtered gpu types will belong to one of the gpu types from this list.
        :param pulumi.Input[float] max_gpu: Maximum number of GPUs available.
        :param pulumi.Input[float] max_memory_gib: Maximum amount of Memory (GiB).
        :param pulumi.Input[int] max_vcpu: Maximum number of vcpus available.
        :param pulumi.Input[int] min_disk: Minimum number of data disks available.
        :param pulumi.Input[float] min_gpu: Minimum number of GPUs available.
        :param pulumi.Input[float] min_memory_gib: Minimum amount of Memory (GiB).
        :param pulumi.Input[int] min_nics: Minimum number of network interfaces.
        :param pulumi.Input[int] min_vcpu: Minimum number of vcpus available.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] series: Vm sizes belonging to a series from the list will be available for scaling.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vm_types: The filtered vm types will belong to one of the vm types from this list.
        """
        if accelerated_networking is not None:
            pulumi.set(__self__, "accelerated_networking", accelerated_networking)
        if architectures is not None:
            pulumi.set(__self__, "architectures", architectures)
        if disk_performance is not None:
            pulumi.set(__self__, "disk_performance", disk_performance)
        if exclude_series is not None:
            pulumi.set(__self__, "exclude_series", exclude_series)
        if gpu_types is not None:
            pulumi.set(__self__, "gpu_types", gpu_types)
        if max_gpu is not None:
            pulumi.set(__self__, "max_gpu", max_gpu)
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)
        if min_disk is not None:
            pulumi.set(__self__, "min_disk", min_disk)
        if min_gpu is not None:
            pulumi.set(__self__, "min_gpu", min_gpu)
        if min_memory_gib is not None:
            pulumi.set(__self__, "min_memory_gib", min_memory_gib)
        if min_nics is not None:
            pulumi.set(__self__, "min_nics", min_nics)
        if min_vcpu is not None:
            pulumi.set(__self__, "min_vcpu", min_vcpu)
        if series is not None:
            pulumi.set(__self__, "series", series)
        if vm_types is not None:
            pulumi.set(__self__, "vm_types", vm_types)

    @property
    @pulumi.getter(name="acceleratedNetworking")
    def accelerated_networking(self) -> Optional[pulumi.Input[str]]:
        """
        In case acceleratedNetworking is set to Enabled, accelerated networking applies only to the VM that enables it.
        """
        return pulumi.get(self, "accelerated_networking")

    @accelerated_networking.setter
    def accelerated_networking(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "accelerated_networking", value)

    @property
    @pulumi.getter
    def architectures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered vm sizes will support at least one of the architectures from this list. x86_64 includes both intel64 and amd64.
        """
        return pulumi.get(self, "architectures")

    @architectures.setter
    def architectures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "architectures", value)

    @property
    @pulumi.getter(name="diskPerformance")
    def disk_performance(self) -> Optional[pulumi.Input[str]]:
        """
        The filtered vm sizes will support at least one of the classes from this list.
        """
        return pulumi.get(self, "disk_performance")

    @disk_performance.setter
    def disk_performance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_performance", value)

    @property
    @pulumi.getter(name="excludeSeries")
    def exclude_series(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Vm sizes belonging to a series from the list will not be available for scaling.
        """
        return pulumi.get(self, "exclude_series")

    @exclude_series.setter
    def exclude_series(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_series", value)

    @property
    @pulumi.getter(name="gpuTypes")
    def gpu_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered gpu types will belong to one of the gpu types from this list.
        """
        return pulumi.get(self, "gpu_types")

    @gpu_types.setter
    def gpu_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "gpu_types", value)

    @property
    @pulumi.getter(name="maxGpu")
    def max_gpu(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum number of GPUs available.
        """
        return pulumi.get(self, "max_gpu")

    @max_gpu.setter
    def max_gpu(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_gpu", value)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum amount of Memory (GiB).
        """
        return pulumi.get(self, "max_memory_gib")

    @max_memory_gib.setter
    def max_memory_gib(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_memory_gib", value)

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of vcpus available.
        """
        return pulumi.get(self, "max_vcpu")

    @max_vcpu.setter
    def max_vcpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_vcpu", value)

    @property
    @pulumi.getter(name="minDisk")
    def min_disk(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of data disks available.
        """
        return pulumi.get(self, "min_disk")

    @min_disk.setter
    def min_disk(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_disk", value)

    @property
    @pulumi.getter(name="minGpu")
    def min_gpu(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum number of GPUs available.
        """
        return pulumi.get(self, "min_gpu")

    @min_gpu.setter
    def min_gpu(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_gpu", value)

    @property
    @pulumi.getter(name="minMemoryGib")
    def min_memory_gib(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum amount of Memory (GiB).
        """
        return pulumi.get(self, "min_memory_gib")

    @min_memory_gib.setter
    def min_memory_gib(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_memory_gib", value)

    @property
    @pulumi.getter(name="minNics")
    def min_nics(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of network interfaces.
        """
        return pulumi.get(self, "min_nics")

    @min_nics.setter
    def min_nics(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_nics", value)

    @property
    @pulumi.getter(name="minVcpu")
    def min_vcpu(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of vcpus available.
        """
        return pulumi.get(self, "min_vcpu")

    @min_vcpu.setter
    def min_vcpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_vcpu", value)

    @property
    @pulumi.getter
    def series(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Vm sizes belonging to a series from the list will be available for scaling.
        """
        return pulumi.get(self, "series")

    @series.setter
    def series(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "series", value)

    @property
    @pulumi.getter(name="vmTypes")
    def vm_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered vm types will belong to one of the vm types from this list.
        """
        return pulumi.get(self, "vm_types")

    @vm_types.setter
    def vm_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vm_types", value)


@pulumi.input_type
class OceanNpVirtualNodeGroupHeadroomArgs:
    def __init__(__self__, *,
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 gpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None,
                 num_of_units: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] cpu_per_unit: Configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[int] gpu_per_unit: Amount of GPU to allocate for headroom unit.
        :param pulumi.Input[int] memory_per_unit: Configure the amount of memory (MiB) to allocate the headroom.
        :param pulumi.Input[int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Amount of GPU to allocate for headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @gpu_per_unit.setter
    def gpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Configure the amount of memory (MiB) to allocate the headroom.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[pulumi.Input[int]]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_of_units", value)


@pulumi.input_type
class OceanNpVirtualNodeGroupLinuxOsConfigArgs:
    def __init__(__self__, *,
                 sysctls: Optional[pulumi.Input[Sequence[pulumi.Input['OceanNpVirtualNodeGroupLinuxOsConfigSysctlArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OceanNpVirtualNodeGroupLinuxOsConfigSysctlArgs']]] sysctls: System Controls
        """
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanNpVirtualNodeGroupLinuxOsConfigSysctlArgs']]]]:
        """
        System Controls
        """
        return pulumi.get(self, "sysctls")

    @sysctls.setter
    def sysctls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanNpVirtualNodeGroupLinuxOsConfigSysctlArgs']]]]):
        pulumi.set(self, "sysctls", value)


@pulumi.input_type
class OceanNpVirtualNodeGroupLinuxOsConfigSysctlArgs:
    def __init__(__self__, *,
                 vm_max_map_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] vm_max_map_count: Maximum number of memory map areas a process may have. Can be configured only if OS type is Linux.
        """
        if vm_max_map_count is not None:
            pulumi.set(__self__, "vm_max_map_count", vm_max_map_count)

    @property
    @pulumi.getter(name="vmMaxMapCount")
    def vm_max_map_count(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of memory map areas a process may have. Can be configured only if OS type is Linux.
        """
        return pulumi.get(self, "vm_max_map_count")

    @vm_max_map_count.setter
    def vm_max_map_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vm_max_map_count", value)


@pulumi.input_type
class OceanNpVirtualNodeGroupTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[str],
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] effect: Set taint effect.
        :param pulumi.Input[str] key: Set taint key. The following are not allowed: "kubernetes.azure.com/scalesetpriority".
        :param pulumi.Input[str] value: Set taint value.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[str]:
        """
        Set taint effect.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Set taint key. The following are not allowed: "kubernetes.azure.com/scalesetpriority".
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Set taint value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class OceanNpVirtualNodeGroupUpdatePolicyArgs:
    def __init__(__self__, *,
                 should_roll: pulumi.Input[bool],
                 conditioned_roll: Optional[pulumi.Input[bool]] = None,
                 roll_config: Optional[pulumi.Input['OceanNpVirtualNodeGroupUpdatePolicyRollConfigArgs']] = None):
        """
        :param pulumi.Input[bool] should_roll: If set to true along with the vng update, roll will be triggered.
        :param pulumi.Input[bool] conditioned_roll: Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as availability_zones, max_pods_per_node, enable_node_public_ip, os_disk_size_gb, os_disk_type, os_sku, kubernetes_version, vnet_subnet_ids, pod_subnet_ids, labels, taints and tags).
        :param pulumi.Input['OceanNpVirtualNodeGroupUpdatePolicyRollConfigArgs'] roll_config: While used, you can control whether the group should perform a deployment after an update to the configuration.
        """
        pulumi.set(__self__, "should_roll", should_roll)
        if conditioned_roll is not None:
            pulumi.set(__self__, "conditioned_roll", conditioned_roll)
        if roll_config is not None:
            pulumi.set(__self__, "roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> pulumi.Input[bool]:
        """
        If set to true along with the vng update, roll will be triggered.
        """
        return pulumi.get(self, "should_roll")

    @should_roll.setter
    def should_roll(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_roll", value)

    @property
    @pulumi.getter(name="conditionedRoll")
    def conditioned_roll(self) -> Optional[pulumi.Input[bool]]:
        """
        Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as availability_zones, max_pods_per_node, enable_node_public_ip, os_disk_size_gb, os_disk_type, os_sku, kubernetes_version, vnet_subnet_ids, pod_subnet_ids, labels, taints and tags).
        """
        return pulumi.get(self, "conditioned_roll")

    @conditioned_roll.setter
    def conditioned_roll(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "conditioned_roll", value)

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional[pulumi.Input['OceanNpVirtualNodeGroupUpdatePolicyRollConfigArgs']]:
        """
        While used, you can control whether the group should perform a deployment after an update to the configuration.
        """
        return pulumi.get(self, "roll_config")

    @roll_config.setter
    def roll_config(self, value: Optional[pulumi.Input['OceanNpVirtualNodeGroupUpdatePolicyRollConfigArgs']]):
        pulumi.set(self, "roll_config", value)


@pulumi.input_type
class OceanNpVirtualNodeGroupUpdatePolicyRollConfigArgs:
    def __init__(__self__, *,
                 batch_min_healthy_percentage: Optional[pulumi.Input[int]] = None,
                 batch_size_percentage: Optional[pulumi.Input[int]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 node_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 node_pool_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 respect_pdb: Optional[pulumi.Input[bool]] = None,
                 respect_restrict_scale_down: Optional[pulumi.Input[bool]] = None,
                 vng_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] batch_min_healthy_percentage: Indicates the threshold of minimum healthy nodes in single batch. If the amount of healthy nodes in single batch is under the threshold, the roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        :param pulumi.Input[int] batch_size_percentage: Value as a percent to set the size of a batch in a roll. Valid values are 0-100. In case of null as value, the default value in the backend will be 20%.
        :param pulumi.Input[str] comment: Add a comment description for the roll. The comment is limited to 256 chars and optional.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] node_names: List of node names to be rolled. Each identifier is a string. nodeNames can be null, and cannot be used together with nodePoolNames and vngIds.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] node_pool_names: List of node pools to be rolled. Each node pool name is a string. nodePoolNames can be null, and cannot be used together with nodeNames and vngIds.
        :param pulumi.Input[bool] respect_pdb: During the roll, if the parameter is set to true we honor PDB during the nodes replacement.
        :param pulumi.Input[bool] respect_restrict_scale_down: During the roll, if the parameter is set to true we honor Restrict Scale Down label during the nodes replacement.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vng_ids: List of virtual node group identifiers to be rolled. Each identifier is a string. vngIds can be null, and cannot be used together with nodeNames and nodePoolNames.
        """
        if batch_min_healthy_percentage is not None:
            pulumi.set(__self__, "batch_min_healthy_percentage", batch_min_healthy_percentage)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if node_names is not None:
            pulumi.set(__self__, "node_names", node_names)
        if node_pool_names is not None:
            pulumi.set(__self__, "node_pool_names", node_pool_names)
        if respect_pdb is not None:
            pulumi.set(__self__, "respect_pdb", respect_pdb)
        if respect_restrict_scale_down is not None:
            pulumi.set(__self__, "respect_restrict_scale_down", respect_restrict_scale_down)
        if vng_ids is not None:
            pulumi.set(__self__, "vng_ids", vng_ids)

    @property
    @pulumi.getter(name="batchMinHealthyPercentage")
    def batch_min_healthy_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates the threshold of minimum healthy nodes in single batch. If the amount of healthy nodes in single batch is under the threshold, the roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        """
        return pulumi.get(self, "batch_min_healthy_percentage")

    @batch_min_healthy_percentage.setter
    def batch_min_healthy_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_min_healthy_percentage", value)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Value as a percent to set the size of a batch in a roll. Valid values are 0-100. In case of null as value, the default value in the backend will be 20%.
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        Add a comment description for the roll. The comment is limited to 256 chars and optional.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="nodeNames")
    def node_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of node names to be rolled. Each identifier is a string. nodeNames can be null, and cannot be used together with nodePoolNames and vngIds.
        """
        return pulumi.get(self, "node_names")

    @node_names.setter
    def node_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "node_names", value)

    @property
    @pulumi.getter(name="nodePoolNames")
    def node_pool_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of node pools to be rolled. Each node pool name is a string. nodePoolNames can be null, and cannot be used together with nodeNames and vngIds.
        """
        return pulumi.get(self, "node_pool_names")

    @node_pool_names.setter
    def node_pool_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "node_pool_names", value)

    @property
    @pulumi.getter(name="respectPdb")
    def respect_pdb(self) -> Optional[pulumi.Input[bool]]:
        """
        During the roll, if the parameter is set to true we honor PDB during the nodes replacement.
        """
        return pulumi.get(self, "respect_pdb")

    @respect_pdb.setter
    def respect_pdb(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "respect_pdb", value)

    @property
    @pulumi.getter(name="respectRestrictScaleDown")
    def respect_restrict_scale_down(self) -> Optional[pulumi.Input[bool]]:
        """
        During the roll, if the parameter is set to true we honor Restrict Scale Down label during the nodes replacement.
        """
        return pulumi.get(self, "respect_restrict_scale_down")

    @respect_restrict_scale_down.setter
    def respect_restrict_scale_down(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "respect_restrict_scale_down", value)

    @property
    @pulumi.getter(name="vngIds")
    def vng_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of virtual node group identifiers to be rolled. Each identifier is a string. vngIds can be null, and cannot be used together with nodeNames and nodePoolNames.
        """
        return pulumi.get(self, "vng_ids")

    @vng_ids.setter
    def vng_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vng_ids", value)


