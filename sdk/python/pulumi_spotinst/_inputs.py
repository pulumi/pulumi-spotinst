# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'DataIntegrationS3Args',
    'DataIntegrationS3ArgsDict',
    'ElastigroupAzureV3ExtensionArgs',
    'ElastigroupAzureV3ExtensionArgsDict',
    'ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVaultArgs',
    'ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVaultArgsDict',
    'ElastigroupAzureV3ImageArgs',
    'ElastigroupAzureV3ImageArgsDict',
    'ElastigroupAzureV3ImageCustomArgs',
    'ElastigroupAzureV3ImageCustomArgsDict',
    'ElastigroupAzureV3ImageGalleryImageArgs',
    'ElastigroupAzureV3ImageGalleryImageArgsDict',
    'ElastigroupAzureV3ImageMarketplaceArgs',
    'ElastigroupAzureV3ImageMarketplaceArgsDict',
    'ElastigroupAzureV3LoginArgs',
    'ElastigroupAzureV3LoginArgsDict',
    'ElastigroupAzureV3ManagedServiceIdentityArgs',
    'ElastigroupAzureV3ManagedServiceIdentityArgsDict',
    'ElastigroupAzureV3NetworkArgs',
    'ElastigroupAzureV3NetworkArgsDict',
    'ElastigroupAzureV3NetworkNetworkInterfaceArgs',
    'ElastigroupAzureV3NetworkNetworkInterfaceArgsDict',
    'ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfigArgs',
    'ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfigArgsDict',
    'ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroupArgs',
    'ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroupArgsDict',
    'ElastigroupAzureV3ScalingDownPolicyArgs',
    'ElastigroupAzureV3ScalingDownPolicyArgsDict',
    'ElastigroupAzureV3ScalingDownPolicyActionArgs',
    'ElastigroupAzureV3ScalingDownPolicyActionArgsDict',
    'ElastigroupAzureV3ScalingDownPolicyDimensionArgs',
    'ElastigroupAzureV3ScalingDownPolicyDimensionArgsDict',
    'ElastigroupAzureV3ScalingUpPolicyArgs',
    'ElastigroupAzureV3ScalingUpPolicyArgsDict',
    'ElastigroupAzureV3ScalingUpPolicyActionArgs',
    'ElastigroupAzureV3ScalingUpPolicyActionArgsDict',
    'ElastigroupAzureV3ScalingUpPolicyDimensionArgs',
    'ElastigroupAzureV3ScalingUpPolicyDimensionArgsDict',
    'ElastigroupAzureV3TagArgs',
    'ElastigroupAzureV3TagArgsDict',
    'ElastigroupAzureV3VmSizesArgs',
    'ElastigroupAzureV3VmSizesArgsDict',
    'HealthCheckCheckArgs',
    'HealthCheckCheckArgsDict',
    'OceanRightSizingRuleAttachWorkloadArgs',
    'OceanRightSizingRuleAttachWorkloadArgsDict',
    'OceanRightSizingRuleAttachWorkloadNamespaceArgs',
    'OceanRightSizingRuleAttachWorkloadNamespaceArgsDict',
    'OceanRightSizingRuleAttachWorkloadNamespaceLabelArgs',
    'OceanRightSizingRuleAttachWorkloadNamespaceLabelArgsDict',
    'OceanRightSizingRuleAttachWorkloadNamespaceWorkloadArgs',
    'OceanRightSizingRuleAttachWorkloadNamespaceWorkloadArgsDict',
    'OceanRightSizingRuleDetachWorkloadArgs',
    'OceanRightSizingRuleDetachWorkloadArgsDict',
    'OceanRightSizingRuleDetachWorkloadNamespaceArgs',
    'OceanRightSizingRuleDetachWorkloadNamespaceArgsDict',
    'OceanRightSizingRuleDetachWorkloadNamespaceLabelArgs',
    'OceanRightSizingRuleDetachWorkloadNamespaceLabelArgsDict',
    'OceanRightSizingRuleDetachWorkloadNamespaceWorkloadArgs',
    'OceanRightSizingRuleDetachWorkloadNamespaceWorkloadArgsDict',
    'OceanRightSizingRuleRecommendationApplicationBoundaryArgs',
    'OceanRightSizingRuleRecommendationApplicationBoundaryArgsDict',
    'OceanRightSizingRuleRecommendationApplicationIntervalArgs',
    'OceanRightSizingRuleRecommendationApplicationIntervalArgsDict',
    'OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseArgs',
    'OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseArgsDict',
    'OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBaseArgs',
    'OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBaseArgsDict',
    'OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBaseArgs',
    'OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBaseArgsDict',
    'OceanRightSizingRuleRecommendationApplicationMinThresholdArgs',
    'OceanRightSizingRuleRecommendationApplicationMinThresholdArgsDict',
    'OceanRightSizingRuleRecommendationApplicationOverheadValueArgs',
    'OceanRightSizingRuleRecommendationApplicationOverheadValueArgsDict',
    'StatefulNodeAzureAttachDataDiskArgs',
    'StatefulNodeAzureAttachDataDiskArgsDict',
    'StatefulNodeAzureBootDiagnosticArgs',
    'StatefulNodeAzureBootDiagnosticArgsDict',
    'StatefulNodeAzureDataDiskArgs',
    'StatefulNodeAzureDataDiskArgsDict',
    'StatefulNodeAzureDeleteArgs',
    'StatefulNodeAzureDeleteArgsDict',
    'StatefulNodeAzureDetachDataDiskArgs',
    'StatefulNodeAzureDetachDataDiskArgsDict',
    'StatefulNodeAzureExtensionArgs',
    'StatefulNodeAzureExtensionArgsDict',
    'StatefulNodeAzureHealthArgs',
    'StatefulNodeAzureHealthArgsDict',
    'StatefulNodeAzureImageArgs',
    'StatefulNodeAzureImageArgsDict',
    'StatefulNodeAzureImageCustomImageArgs',
    'StatefulNodeAzureImageCustomImageArgsDict',
    'StatefulNodeAzureImageGalleryArgs',
    'StatefulNodeAzureImageGalleryArgsDict',
    'StatefulNodeAzureImageMarketplaceImageArgs',
    'StatefulNodeAzureImageMarketplaceImageArgsDict',
    'StatefulNodeAzureImportVmArgs',
    'StatefulNodeAzureImportVmArgsDict',
    'StatefulNodeAzureLoadBalancerArgs',
    'StatefulNodeAzureLoadBalancerArgsDict',
    'StatefulNodeAzureLoginArgs',
    'StatefulNodeAzureLoginArgsDict',
    'StatefulNodeAzureManagedServiceIdentityArgs',
    'StatefulNodeAzureManagedServiceIdentityArgsDict',
    'StatefulNodeAzureNetworkArgs',
    'StatefulNodeAzureNetworkArgsDict',
    'StatefulNodeAzureNetworkNetworkInterfaceArgs',
    'StatefulNodeAzureNetworkNetworkInterfaceArgsDict',
    'StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfigurationArgs',
    'StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfigurationArgsDict',
    'StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroupArgs',
    'StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroupArgsDict',
    'StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroupArgs',
    'StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroupArgsDict',
    'StatefulNodeAzureNetworkNetworkInterfacePublicIpArgs',
    'StatefulNodeAzureNetworkNetworkInterfacePublicIpArgsDict',
    'StatefulNodeAzureOsDiskArgs',
    'StatefulNodeAzureOsDiskArgsDict',
    'StatefulNodeAzureProximityPlacementGroupArgs',
    'StatefulNodeAzureProximityPlacementGroupArgsDict',
    'StatefulNodeAzureSchedulingTaskArgs',
    'StatefulNodeAzureSchedulingTaskArgsDict',
    'StatefulNodeAzureSecretArgs',
    'StatefulNodeAzureSecretArgsDict',
    'StatefulNodeAzureSecretSourceVaultArgs',
    'StatefulNodeAzureSecretSourceVaultArgsDict',
    'StatefulNodeAzureSecretVaultCertificateArgs',
    'StatefulNodeAzureSecretVaultCertificateArgsDict',
    'StatefulNodeAzureSecurityArgs',
    'StatefulNodeAzureSecurityArgsDict',
    'StatefulNodeAzureSignalArgs',
    'StatefulNodeAzureSignalArgsDict',
    'StatefulNodeAzureStrategyArgs',
    'StatefulNodeAzureStrategyArgsDict',
    'StatefulNodeAzureStrategyCapacityReservationArgs',
    'StatefulNodeAzureStrategyCapacityReservationArgsDict',
    'StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroupArgs',
    'StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroupArgsDict',
    'StatefulNodeAzureStrategyRevertToSpotArgs',
    'StatefulNodeAzureStrategyRevertToSpotArgsDict',
    'StatefulNodeAzureTagArgs',
    'StatefulNodeAzureTagArgsDict',
    'StatefulNodeAzureUpdateStateArgs',
    'StatefulNodeAzureUpdateStateArgsDict',
    'StatefulNodeAzureVmSizesArgs',
    'StatefulNodeAzureVmSizesArgsDict',
]

MYPY = False

if not MYPY:
    class DataIntegrationS3ArgsDict(TypedDict):
        bucket_name: pulumi.Input[str]
        subdir: NotRequired[pulumi.Input[str]]
        """
        The subdirectory in which your files will be stored within the bucket. Adds the prefix subdir/ to new objects' keys. Can't be null or contain '/'.
        """
elif False:
    DataIntegrationS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataIntegrationS3Args:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 subdir: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subdir: The subdirectory in which your files will be stored within the bucket. Adds the prefix subdir/ to new objects' keys. Can't be null or contain '/'.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        if subdir is not None:
            pulumi.set(__self__, "subdir", subdir)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter
    def subdir(self) -> Optional[pulumi.Input[str]]:
        """
        The subdirectory in which your files will be stored within the bucket. Adds the prefix subdir/ to new objects' keys. Can't be null or contain '/'.
        """
        return pulumi.get(self, "subdir")

    @subdir.setter
    def subdir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subdir", value)


if not MYPY:
    class ElastigroupAzureV3ExtensionArgsDict(TypedDict):
        api_version: pulumi.Input[str]
        minor_version_auto_upgrade: pulumi.Input[bool]
        name: pulumi.Input[str]
        publisher: pulumi.Input[str]
        type: pulumi.Input[str]
        enable_automatic_upgrade: NotRequired[pulumi.Input[bool]]
        protected_settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        protected_settings_from_key_vault: NotRequired[pulumi.Input['ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVaultArgsDict']]
        public_settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    ElastigroupAzureV3ExtensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3ExtensionArgs:
    def __init__(__self__, *,
                 api_version: pulumi.Input[str],
                 minor_version_auto_upgrade: pulumi.Input[bool],
                 name: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 type: pulumi.Input[str],
                 enable_automatic_upgrade: Optional[pulumi.Input[bool]] = None,
                 protected_settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 protected_settings_from_key_vault: Optional[pulumi.Input['ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVaultArgs']] = None,
                 public_settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "minor_version_auto_upgrade", minor_version_auto_upgrade)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "type", type)
        if enable_automatic_upgrade is not None:
            pulumi.set(__self__, "enable_automatic_upgrade", enable_automatic_upgrade)
        if protected_settings is not None:
            pulumi.set(__self__, "protected_settings", protected_settings)
        if protected_settings_from_key_vault is not None:
            pulumi.set(__self__, "protected_settings_from_key_vault", protected_settings_from_key_vault)
        if public_settings is not None:
            pulumi.set(__self__, "public_settings", public_settings)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> pulumi.Input[str]:
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="minorVersionAutoUpgrade")
    def minor_version_auto_upgrade(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "minor_version_auto_upgrade")

    @minor_version_auto_upgrade.setter
    def minor_version_auto_upgrade(self, value: pulumi.Input[bool]):
        pulumi.set(self, "minor_version_auto_upgrade", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="enableAutomaticUpgrade")
    def enable_automatic_upgrade(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_automatic_upgrade")

    @enable_automatic_upgrade.setter
    def enable_automatic_upgrade(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_automatic_upgrade", value)

    @property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "protected_settings")

    @protected_settings.setter
    def protected_settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "protected_settings", value)

    @property
    @pulumi.getter(name="protectedSettingsFromKeyVault")
    def protected_settings_from_key_vault(self) -> Optional[pulumi.Input['ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVaultArgs']]:
        return pulumi.get(self, "protected_settings_from_key_vault")

    @protected_settings_from_key_vault.setter
    def protected_settings_from_key_vault(self, value: Optional[pulumi.Input['ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVaultArgs']]):
        pulumi.set(self, "protected_settings_from_key_vault", value)

    @property
    @pulumi.getter(name="publicSettings")
    def public_settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "public_settings")

    @public_settings.setter
    def public_settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "public_settings", value)


if not MYPY:
    class ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVaultArgsDict(TypedDict):
        secret_url: pulumi.Input[str]
        source_vault: pulumi.Input[str]
elif False:
    ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3ExtensionProtectedSettingsFromKeyVaultArgs:
    def __init__(__self__, *,
                 secret_url: pulumi.Input[str],
                 source_vault: pulumi.Input[str]):
        pulumi.set(__self__, "secret_url", secret_url)
        pulumi.set(__self__, "source_vault", source_vault)

    @property
    @pulumi.getter(name="secretUrl")
    def secret_url(self) -> pulumi.Input[str]:
        return pulumi.get(self, "secret_url")

    @secret_url.setter
    def secret_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_url", value)

    @property
    @pulumi.getter(name="sourceVault")
    def source_vault(self) -> pulumi.Input[str]:
        return pulumi.get(self, "source_vault")

    @source_vault.setter
    def source_vault(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_vault", value)


if not MYPY:
    class ElastigroupAzureV3ImageArgsDict(TypedDict):
        customs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ImageCustomArgsDict']]]]
        gallery_images: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ImageGalleryImageArgsDict']]]]
        marketplaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ImageMarketplaceArgsDict']]]]
elif False:
    ElastigroupAzureV3ImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3ImageArgs:
    def __init__(__self__, *,
                 customs: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ImageCustomArgs']]]] = None,
                 gallery_images: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ImageGalleryImageArgs']]]] = None,
                 marketplaces: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ImageMarketplaceArgs']]]] = None):
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if gallery_images is not None:
            pulumi.set(__self__, "gallery_images", gallery_images)
        if marketplaces is not None:
            pulumi.set(__self__, "marketplaces", marketplaces)

    @property
    @pulumi.getter
    def customs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ImageCustomArgs']]]]:
        return pulumi.get(self, "customs")

    @customs.setter
    def customs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ImageCustomArgs']]]]):
        pulumi.set(self, "customs", value)

    @property
    @pulumi.getter(name="galleryImages")
    def gallery_images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ImageGalleryImageArgs']]]]:
        return pulumi.get(self, "gallery_images")

    @gallery_images.setter
    def gallery_images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ImageGalleryImageArgs']]]]):
        pulumi.set(self, "gallery_images", value)

    @property
    @pulumi.getter
    def marketplaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ImageMarketplaceArgs']]]]:
        return pulumi.get(self, "marketplaces")

    @marketplaces.setter
    def marketplaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ImageMarketplaceArgs']]]]):
        pulumi.set(self, "marketplaces", value)


if not MYPY:
    class ElastigroupAzureV3ImageCustomArgsDict(TypedDict):
        image_name: pulumi.Input[str]
        resource_group_name: pulumi.Input[str]
elif False:
    ElastigroupAzureV3ImageCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3ImageCustomArgs:
    def __init__(__self__, *,
                 image_name: pulumi.Input[str],
                 resource_group_name: pulumi.Input[str]):
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_group_name", value)


if not MYPY:
    class ElastigroupAzureV3ImageGalleryImageArgsDict(TypedDict):
        gallery_name: pulumi.Input[str]
        image_name: pulumi.Input[str]
        resource_group_name: pulumi.Input[str]
        version: pulumi.Input[str]
        spot_account_id: NotRequired[pulumi.Input[str]]
elif False:
    ElastigroupAzureV3ImageGalleryImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3ImageGalleryImageArgs:
    def __init__(__self__, *,
                 gallery_name: pulumi.Input[str],
                 image_name: pulumi.Input[str],
                 resource_group_name: pulumi.Input[str],
                 version: pulumi.Input[str],
                 spot_account_id: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "gallery_name", gallery_name)
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "version", version)
        if spot_account_id is not None:
            pulumi.set(__self__, "spot_account_id", spot_account_id)

    @property
    @pulumi.getter(name="galleryName")
    def gallery_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "gallery_name")

    @gallery_name.setter
    def gallery_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "gallery_name", value)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="spotAccountId")
    def spot_account_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "spot_account_id")

    @spot_account_id.setter
    def spot_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spot_account_id", value)


if not MYPY:
    class ElastigroupAzureV3ImageMarketplaceArgsDict(TypedDict):
        offer: pulumi.Input[str]
        publisher: pulumi.Input[str]
        sku: pulumi.Input[str]
        version: pulumi.Input[str]
elif False:
    ElastigroupAzureV3ImageMarketplaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3ImageMarketplaceArgs:
    def __init__(__self__, *,
                 offer: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 sku: pulumi.Input[str],
                 version: pulumi.Input[str]):
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def offer(self) -> pulumi.Input[str]:
        return pulumi.get(self, "offer")

    @offer.setter
    def offer(self, value: pulumi.Input[str]):
        pulumi.set(self, "offer", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def sku(self) -> pulumi.Input[str]:
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: pulumi.Input[str]):
        pulumi.set(self, "sku", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ElastigroupAzureV3LoginArgsDict(TypedDict):
        user_name: pulumi.Input[str]
        password: NotRequired[pulumi.Input[str]]
        ssh_public_key: NotRequired[pulumi.Input[str]]
elif False:
    ElastigroupAzureV3LoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3LoginArgs:
    def __init__(__self__, *,
                 user_name: pulumi.Input[str],
                 password: Optional[pulumi.Input[str]] = None,
                 ssh_public_key: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "user_name", user_name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if ssh_public_key is not None:
            pulumi.set(__self__, "ssh_public_key", ssh_public_key)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="sshPublicKey")
    def ssh_public_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ssh_public_key")

    @ssh_public_key.setter
    def ssh_public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_public_key", value)


if not MYPY:
    class ElastigroupAzureV3ManagedServiceIdentityArgsDict(TypedDict):
        name: pulumi.Input[str]
        resource_group_name: pulumi.Input[str]
elif False:
    ElastigroupAzureV3ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 resource_group_name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_group_name", value)


if not MYPY:
    class ElastigroupAzureV3NetworkArgsDict(TypedDict):
        network_interfaces: pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3NetworkNetworkInterfaceArgsDict']]]
        resource_group_name: pulumi.Input[str]
        virtual_network_name: pulumi.Input[str]
elif False:
    ElastigroupAzureV3NetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3NetworkArgs:
    def __init__(__self__, *,
                 network_interfaces: pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3NetworkNetworkInterfaceArgs']]],
                 resource_group_name: pulumi.Input[str],
                 virtual_network_name: pulumi.Input[str]):
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "virtual_network_name", virtual_network_name)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3NetworkNetworkInterfaceArgs']]]:
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3NetworkNetworkInterfaceArgs']]]):
        pulumi.set(self, "network_interfaces", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter(name="virtualNetworkName")
    def virtual_network_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "virtual_network_name")

    @virtual_network_name.setter
    def virtual_network_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_network_name", value)


if not MYPY:
    class ElastigroupAzureV3NetworkNetworkInterfaceArgsDict(TypedDict):
        assign_public_ip: pulumi.Input[bool]
        is_primary: pulumi.Input[bool]
        subnet_name: pulumi.Input[str]
        additional_ip_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfigArgsDict']]]]
        application_security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroupArgsDict']]]]
elif False:
    ElastigroupAzureV3NetworkNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3NetworkNetworkInterfaceArgs:
    def __init__(__self__, *,
                 assign_public_ip: pulumi.Input[bool],
                 is_primary: pulumi.Input[bool],
                 subnet_name: pulumi.Input[str],
                 additional_ip_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfigArgs']]]] = None,
                 application_security_groups: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroupArgs']]]] = None):
        pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        pulumi.set(__self__, "is_primary", is_primary)
        pulumi.set(__self__, "subnet_name", subnet_name)
        if additional_ip_configs is not None:
            pulumi.set(__self__, "additional_ip_configs", additional_ip_configs)
        if application_security_groups is not None:
            pulumi.set(__self__, "application_security_groups", application_security_groups)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: pulumi.Input[bool]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "is_primary")

    @is_primary.setter
    def is_primary(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_primary", value)

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "subnet_name")

    @subnet_name.setter
    def subnet_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_name", value)

    @property
    @pulumi.getter(name="additionalIpConfigs")
    def additional_ip_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfigArgs']]]]:
        return pulumi.get(self, "additional_ip_configs")

    @additional_ip_configs.setter
    def additional_ip_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfigArgs']]]]):
        pulumi.set(self, "additional_ip_configs", value)

    @property
    @pulumi.getter(name="applicationSecurityGroups")
    def application_security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroupArgs']]]]:
        return pulumi.get(self, "application_security_groups")

    @application_security_groups.setter
    def application_security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroupArgs']]]]):
        pulumi.set(self, "application_security_groups", value)


if not MYPY:
    class ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfigArgsDict(TypedDict):
        name: pulumi.Input[str]
        private_ip_version: NotRequired[pulumi.Input[str]]
elif False:
    ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfigArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 private_ip_version: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "name", name)
        if private_ip_version is not None:
            pulumi.set(__self__, "private_ip_version", private_ip_version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateIpVersion")
    def private_ip_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_ip_version")

    @private_ip_version.setter
    def private_ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip_version", value)


if not MYPY:
    class ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroupArgsDict(TypedDict):
        name: pulumi.Input[str]
        resource_group_name: pulumi.Input[str]
elif False:
    ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 resource_group_name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_group_name", value)


if not MYPY:
    class ElastigroupAzureV3ScalingDownPolicyArgsDict(TypedDict):
        action: pulumi.Input['ElastigroupAzureV3ScalingDownPolicyActionArgsDict']
        cooldown: pulumi.Input[int]
        evaluation_periods: pulumi.Input[int]
        metric_name: pulumi.Input[str]
        namespace: pulumi.Input[str]
        operator: pulumi.Input[str]
        period: pulumi.Input[int]
        policy_name: pulumi.Input[str]
        statistic: pulumi.Input[str]
        threshold: pulumi.Input[float]
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ScalingDownPolicyDimensionArgsDict']]]]
        is_enabled: NotRequired[pulumi.Input[bool]]
        source: NotRequired[pulumi.Input[str]]
        unit: NotRequired[pulumi.Input[str]]
elif False:
    ElastigroupAzureV3ScalingDownPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3ScalingDownPolicyArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['ElastigroupAzureV3ScalingDownPolicyActionArgs'],
                 cooldown: pulumi.Input[int],
                 evaluation_periods: pulumi.Input[int],
                 metric_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 period: pulumi.Input[int],
                 policy_name: pulumi.Input[str],
                 statistic: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ScalingDownPolicyDimensionArgs']]]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 unit: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "cooldown", cooldown)
        pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "statistic", statistic)
        pulumi.set(__self__, "threshold", threshold)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['ElastigroupAzureV3ScalingDownPolicyActionArgs']:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['ElastigroupAzureV3ScalingDownPolicyActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def cooldown(self) -> pulumi.Input[int]:
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: pulumi.Input[int]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> pulumi.Input[int]:
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: pulumi.Input[int]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def period(self) -> pulumi.Input[int]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[int]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_name", value)

    @property
    @pulumi.getter
    def statistic(self) -> pulumi.Input[str]:
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: pulumi.Input[str]):
        pulumi.set(self, "statistic", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ScalingDownPolicyDimensionArgs']]]]:
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ScalingDownPolicyDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ElastigroupAzureV3ScalingDownPolicyActionArgsDict(TypedDict):
        adjustment: NotRequired[pulumi.Input[str]]
        maximum: NotRequired[pulumi.Input[str]]
        minimum: NotRequired[pulumi.Input[str]]
        target: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    ElastigroupAzureV3ScalingDownPolicyActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3ScalingDownPolicyActionArgs:
    def __init__(__self__, *,
                 adjustment: Optional[pulumi.Input[str]] = None,
                 maximum: Optional[pulumi.Input[str]] = None,
                 minimum: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ElastigroupAzureV3ScalingDownPolicyDimensionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    ElastigroupAzureV3ScalingDownPolicyDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3ScalingDownPolicyDimensionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ElastigroupAzureV3ScalingUpPolicyArgsDict(TypedDict):
        action: pulumi.Input['ElastigroupAzureV3ScalingUpPolicyActionArgsDict']
        cooldown: pulumi.Input[int]
        evaluation_periods: pulumi.Input[int]
        metric_name: pulumi.Input[str]
        namespace: pulumi.Input[str]
        operator: pulumi.Input[str]
        period: pulumi.Input[int]
        policy_name: pulumi.Input[str]
        statistic: pulumi.Input[str]
        threshold: pulumi.Input[float]
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ScalingUpPolicyDimensionArgsDict']]]]
        is_enabled: NotRequired[pulumi.Input[bool]]
        source: NotRequired[pulumi.Input[str]]
        unit: NotRequired[pulumi.Input[str]]
elif False:
    ElastigroupAzureV3ScalingUpPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3ScalingUpPolicyArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['ElastigroupAzureV3ScalingUpPolicyActionArgs'],
                 cooldown: pulumi.Input[int],
                 evaluation_periods: pulumi.Input[int],
                 metric_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 period: pulumi.Input[int],
                 policy_name: pulumi.Input[str],
                 statistic: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ScalingUpPolicyDimensionArgs']]]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 unit: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "cooldown", cooldown)
        pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "statistic", statistic)
        pulumi.set(__self__, "threshold", threshold)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['ElastigroupAzureV3ScalingUpPolicyActionArgs']:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['ElastigroupAzureV3ScalingUpPolicyActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def cooldown(self) -> pulumi.Input[int]:
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: pulumi.Input[int]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> pulumi.Input[int]:
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: pulumi.Input[int]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def period(self) -> pulumi.Input[int]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[int]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_name", value)

    @property
    @pulumi.getter
    def statistic(self) -> pulumi.Input[str]:
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: pulumi.Input[str]):
        pulumi.set(self, "statistic", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ScalingUpPolicyDimensionArgs']]]]:
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupAzureV3ScalingUpPolicyDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ElastigroupAzureV3ScalingUpPolicyActionArgsDict(TypedDict):
        adjustment: NotRequired[pulumi.Input[str]]
        maximum: NotRequired[pulumi.Input[str]]
        minimum: NotRequired[pulumi.Input[str]]
        target: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    ElastigroupAzureV3ScalingUpPolicyActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3ScalingUpPolicyActionArgs:
    def __init__(__self__, *,
                 adjustment: Optional[pulumi.Input[str]] = None,
                 maximum: Optional[pulumi.Input[str]] = None,
                 minimum: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ElastigroupAzureV3ScalingUpPolicyDimensionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    ElastigroupAzureV3ScalingUpPolicyDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3ScalingUpPolicyDimensionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ElastigroupAzureV3TagArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    ElastigroupAzureV3TagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3TagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ElastigroupAzureV3VmSizesArgsDict(TypedDict):
        od_sizes: pulumi.Input[Sequence[pulumi.Input[str]]]
        spot_sizes: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    ElastigroupAzureV3VmSizesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupAzureV3VmSizesArgs:
    def __init__(__self__, *,
                 od_sizes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 spot_sizes: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "od_sizes", od_sizes)
        pulumi.set(__self__, "spot_sizes", spot_sizes)

    @property
    @pulumi.getter(name="odSizes")
    def od_sizes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "od_sizes")

    @od_sizes.setter
    def od_sizes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "od_sizes", value)

    @property
    @pulumi.getter(name="spotSizes")
    def spot_sizes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "spot_sizes")

    @spot_sizes.setter
    def spot_sizes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "spot_sizes", value)


if not MYPY:
    class HealthCheckCheckArgsDict(TypedDict):
        healthy: pulumi.Input[int]
        """
        The number of consecutive successful health checks that must occur before declaring an instance healthy.
        """
        interval: pulumi.Input[int]
        """
        The amount of time (in seconds) between each health check (minimum: 10).
        """
        port: pulumi.Input[int]
        """
        The port to use to connect with the instance.
        """
        protocol: pulumi.Input[str]
        """
        The protocol to use to connect with the instance. Valid values: http, https.
        """
        unhealthy: pulumi.Input[int]
        """
        The number of consecutive failed health checks that must occur before declaring an instance unhealthy.
        """
        end_point: NotRequired[pulumi.Input[str]]
        endpoint: NotRequired[pulumi.Input[str]]
        """
        The destination for the request.
        """
        time_out: NotRequired[pulumi.Input[int]]
        timeout: NotRequired[pulumi.Input[int]]
        """
        the amount of time (in seconds) to wait when receiving a response from the health check.
        """
elif False:
    HealthCheckCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HealthCheckCheckArgs:
    def __init__(__self__, *,
                 healthy: pulumi.Input[int],
                 interval: pulumi.Input[int],
                 port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 unhealthy: pulumi.Input[int],
                 end_point: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 time_out: Optional[pulumi.Input[int]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] healthy: The number of consecutive successful health checks that must occur before declaring an instance healthy.
        :param pulumi.Input[int] interval: The amount of time (in seconds) between each health check (minimum: 10).
        :param pulumi.Input[int] port: The port to use to connect with the instance.
        :param pulumi.Input[str] protocol: The protocol to use to connect with the instance. Valid values: http, https.
        :param pulumi.Input[int] unhealthy: The number of consecutive failed health checks that must occur before declaring an instance unhealthy.
        :param pulumi.Input[str] endpoint: The destination for the request.
        :param pulumi.Input[int] timeout: the amount of time (in seconds) to wait when receiving a response from the health check.
        """
        pulumi.set(__self__, "healthy", healthy)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "unhealthy", unhealthy)
        if end_point is not None:
            pulumi.set(__self__, "end_point", end_point)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if time_out is not None:
            pulumi.set(__self__, "time_out", time_out)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def healthy(self) -> pulumi.Input[int]:
        """
        The number of consecutive successful health checks that must occur before declaring an instance healthy.
        """
        return pulumi.get(self, "healthy")

    @healthy.setter
    def healthy(self, value: pulumi.Input[int]):
        pulumi.set(self, "healthy", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[int]:
        """
        The amount of time (in seconds) between each health check (minimum: 10).
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port to use to connect with the instance.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol to use to connect with the instance. Valid values: http, https.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def unhealthy(self) -> pulumi.Input[int]:
        """
        The number of consecutive failed health checks that must occur before declaring an instance unhealthy.
        """
        return pulumi.get(self, "unhealthy")

    @unhealthy.setter
    def unhealthy(self, value: pulumi.Input[int]):
        pulumi.set(self, "unhealthy", value)

    @property
    @pulumi.getter(name="endPoint")
    def end_point(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "end_point")

    @end_point.setter
    def end_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_point", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The destination for the request.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="timeOut")
    def time_out(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "time_out")

    @time_out.setter
    def time_out(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_out", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        the amount of time (in seconds) to wait when receiving a response from the health check.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class OceanRightSizingRuleAttachWorkloadArgsDict(TypedDict):
        namespaces: pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleAttachWorkloadNamespaceArgsDict']]]
elif False:
    OceanRightSizingRuleAttachWorkloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanRightSizingRuleAttachWorkloadArgs:
    def __init__(__self__, *,
                 namespaces: pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleAttachWorkloadNamespaceArgs']]]):
        pulumi.set(__self__, "namespaces", namespaces)

    @property
    @pulumi.getter
    def namespaces(self) -> pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleAttachWorkloadNamespaceArgs']]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleAttachWorkloadNamespaceArgs']]]):
        pulumi.set(self, "namespaces", value)


if not MYPY:
    class OceanRightSizingRuleAttachWorkloadNamespaceArgsDict(TypedDict):
        namespace_name: pulumi.Input[str]
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleAttachWorkloadNamespaceLabelArgsDict']]]]
        workloads: NotRequired[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleAttachWorkloadNamespaceWorkloadArgsDict']]]]
elif False:
    OceanRightSizingRuleAttachWorkloadNamespaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanRightSizingRuleAttachWorkloadNamespaceArgs:
    def __init__(__self__, *,
                 namespace_name: pulumi.Input[str],
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleAttachWorkloadNamespaceLabelArgs']]]] = None,
                 workloads: Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleAttachWorkloadNamespaceWorkloadArgs']]]] = None):
        pulumi.set(__self__, "namespace_name", namespace_name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if workloads is not None:
            pulumi.set(__self__, "workloads", workloads)

    @property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace_name")

    @namespace_name.setter
    def namespace_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace_name", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleAttachWorkloadNamespaceLabelArgs']]]]:
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleAttachWorkloadNamespaceLabelArgs']]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def workloads(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleAttachWorkloadNamespaceWorkloadArgs']]]]:
        return pulumi.get(self, "workloads")

    @workloads.setter
    def workloads(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleAttachWorkloadNamespaceWorkloadArgs']]]]):
        pulumi.set(self, "workloads", value)


if not MYPY:
    class OceanRightSizingRuleAttachWorkloadNamespaceLabelArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    OceanRightSizingRuleAttachWorkloadNamespaceLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanRightSizingRuleAttachWorkloadNamespaceLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OceanRightSizingRuleAttachWorkloadNamespaceWorkloadArgsDict(TypedDict):
        workload_type: pulumi.Input[str]
        regex_name: NotRequired[pulumi.Input[str]]
        workload_name: NotRequired[pulumi.Input[str]]
elif False:
    OceanRightSizingRuleAttachWorkloadNamespaceWorkloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanRightSizingRuleAttachWorkloadNamespaceWorkloadArgs:
    def __init__(__self__, *,
                 workload_type: pulumi.Input[str],
                 regex_name: Optional[pulumi.Input[str]] = None,
                 workload_name: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "workload_type", workload_type)
        if regex_name is not None:
            pulumi.set(__self__, "regex_name", regex_name)
        if workload_name is not None:
            pulumi.set(__self__, "workload_name", workload_name)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "workload_type", value)

    @property
    @pulumi.getter(name="regexName")
    def regex_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "regex_name")

    @regex_name.setter
    def regex_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex_name", value)

    @property
    @pulumi.getter(name="workloadName")
    def workload_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "workload_name")

    @workload_name.setter
    def workload_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_name", value)


if not MYPY:
    class OceanRightSizingRuleDetachWorkloadArgsDict(TypedDict):
        namespaces: pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleDetachWorkloadNamespaceArgsDict']]]
elif False:
    OceanRightSizingRuleDetachWorkloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanRightSizingRuleDetachWorkloadArgs:
    def __init__(__self__, *,
                 namespaces: pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleDetachWorkloadNamespaceArgs']]]):
        pulumi.set(__self__, "namespaces", namespaces)

    @property
    @pulumi.getter
    def namespaces(self) -> pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleDetachWorkloadNamespaceArgs']]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleDetachWorkloadNamespaceArgs']]]):
        pulumi.set(self, "namespaces", value)


if not MYPY:
    class OceanRightSizingRuleDetachWorkloadNamespaceArgsDict(TypedDict):
        namespace_name: pulumi.Input[str]
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleDetachWorkloadNamespaceLabelArgsDict']]]]
        workloads: NotRequired[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleDetachWorkloadNamespaceWorkloadArgsDict']]]]
elif False:
    OceanRightSizingRuleDetachWorkloadNamespaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanRightSizingRuleDetachWorkloadNamespaceArgs:
    def __init__(__self__, *,
                 namespace_name: pulumi.Input[str],
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleDetachWorkloadNamespaceLabelArgs']]]] = None,
                 workloads: Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleDetachWorkloadNamespaceWorkloadArgs']]]] = None):
        pulumi.set(__self__, "namespace_name", namespace_name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if workloads is not None:
            pulumi.set(__self__, "workloads", workloads)

    @property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace_name")

    @namespace_name.setter
    def namespace_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace_name", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleDetachWorkloadNamespaceLabelArgs']]]]:
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleDetachWorkloadNamespaceLabelArgs']]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def workloads(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleDetachWorkloadNamespaceWorkloadArgs']]]]:
        return pulumi.get(self, "workloads")

    @workloads.setter
    def workloads(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleDetachWorkloadNamespaceWorkloadArgs']]]]):
        pulumi.set(self, "workloads", value)


if not MYPY:
    class OceanRightSizingRuleDetachWorkloadNamespaceLabelArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    OceanRightSizingRuleDetachWorkloadNamespaceLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanRightSizingRuleDetachWorkloadNamespaceLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OceanRightSizingRuleDetachWorkloadNamespaceWorkloadArgsDict(TypedDict):
        workload_type: pulumi.Input[str]
        regex_name: NotRequired[pulumi.Input[str]]
        workload_name: NotRequired[pulumi.Input[str]]
elif False:
    OceanRightSizingRuleDetachWorkloadNamespaceWorkloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanRightSizingRuleDetachWorkloadNamespaceWorkloadArgs:
    def __init__(__self__, *,
                 workload_type: pulumi.Input[str],
                 regex_name: Optional[pulumi.Input[str]] = None,
                 workload_name: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "workload_type", workload_type)
        if regex_name is not None:
            pulumi.set(__self__, "regex_name", regex_name)
        if workload_name is not None:
            pulumi.set(__self__, "workload_name", workload_name)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "workload_type", value)

    @property
    @pulumi.getter(name="regexName")
    def regex_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "regex_name")

    @regex_name.setter
    def regex_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex_name", value)

    @property
    @pulumi.getter(name="workloadName")
    def workload_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "workload_name")

    @workload_name.setter
    def workload_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_name", value)


if not MYPY:
    class OceanRightSizingRuleRecommendationApplicationBoundaryArgsDict(TypedDict):
        cpu_max: NotRequired[pulumi.Input[float]]
        cpu_min: NotRequired[pulumi.Input[float]]
        memory_max: NotRequired[pulumi.Input[int]]
        memory_min: NotRequired[pulumi.Input[int]]
elif False:
    OceanRightSizingRuleRecommendationApplicationBoundaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanRightSizingRuleRecommendationApplicationBoundaryArgs:
    def __init__(__self__, *,
                 cpu_max: Optional[pulumi.Input[float]] = None,
                 cpu_min: Optional[pulumi.Input[float]] = None,
                 memory_max: Optional[pulumi.Input[int]] = None,
                 memory_min: Optional[pulumi.Input[int]] = None):
        if cpu_max is not None:
            pulumi.set(__self__, "cpu_max", cpu_max)
        if cpu_min is not None:
            pulumi.set(__self__, "cpu_min", cpu_min)
        if memory_max is not None:
            pulumi.set(__self__, "memory_max", memory_max)
        if memory_min is not None:
            pulumi.set(__self__, "memory_min", memory_min)

    @property
    @pulumi.getter(name="cpuMax")
    def cpu_max(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_max")

    @cpu_max.setter
    def cpu_max(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_max", value)

    @property
    @pulumi.getter(name="cpuMin")
    def cpu_min(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_min")

    @cpu_min.setter
    def cpu_min(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_min", value)

    @property
    @pulumi.getter(name="memoryMax")
    def memory_max(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "memory_max")

    @memory_max.setter
    def memory_max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_max", value)

    @property
    @pulumi.getter(name="memoryMin")
    def memory_min(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "memory_min")

    @memory_min.setter
    def memory_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_min", value)


if not MYPY:
    class OceanRightSizingRuleRecommendationApplicationIntervalArgsDict(TypedDict):
        repetition_basis: pulumi.Input[str]
        monthly_repetition_bases: NotRequired[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseArgsDict']]]]
        weekly_repetition_bases: NotRequired[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBaseArgsDict']]]]
elif False:
    OceanRightSizingRuleRecommendationApplicationIntervalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanRightSizingRuleRecommendationApplicationIntervalArgs:
    def __init__(__self__, *,
                 repetition_basis: pulumi.Input[str],
                 monthly_repetition_bases: Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseArgs']]]] = None,
                 weekly_repetition_bases: Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBaseArgs']]]] = None):
        pulumi.set(__self__, "repetition_basis", repetition_basis)
        if monthly_repetition_bases is not None:
            pulumi.set(__self__, "monthly_repetition_bases", monthly_repetition_bases)
        if weekly_repetition_bases is not None:
            pulumi.set(__self__, "weekly_repetition_bases", weekly_repetition_bases)

    @property
    @pulumi.getter(name="repetitionBasis")
    def repetition_basis(self) -> pulumi.Input[str]:
        return pulumi.get(self, "repetition_basis")

    @repetition_basis.setter
    def repetition_basis(self, value: pulumi.Input[str]):
        pulumi.set(self, "repetition_basis", value)

    @property
    @pulumi.getter(name="monthlyRepetitionBases")
    def monthly_repetition_bases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseArgs']]]]:
        return pulumi.get(self, "monthly_repetition_bases")

    @monthly_repetition_bases.setter
    def monthly_repetition_bases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseArgs']]]]):
        pulumi.set(self, "monthly_repetition_bases", value)

    @property
    @pulumi.getter(name="weeklyRepetitionBases")
    def weekly_repetition_bases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBaseArgs']]]]:
        return pulumi.get(self, "weekly_repetition_bases")

    @weekly_repetition_bases.setter
    def weekly_repetition_bases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBaseArgs']]]]):
        pulumi.set(self, "weekly_repetition_bases", value)


if not MYPY:
    class OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseArgsDict(TypedDict):
        interval_months: pulumi.Input[Sequence[pulumi.Input[int]]]
        week_of_the_months: pulumi.Input[Sequence[pulumi.Input[str]]]
        weekly_repetition_bases: NotRequired[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBaseArgsDict']]]]
elif False:
    OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseArgs:
    def __init__(__self__, *,
                 interval_months: pulumi.Input[Sequence[pulumi.Input[int]]],
                 week_of_the_months: pulumi.Input[Sequence[pulumi.Input[str]]],
                 weekly_repetition_bases: Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBaseArgs']]]] = None):
        pulumi.set(__self__, "interval_months", interval_months)
        pulumi.set(__self__, "week_of_the_months", week_of_the_months)
        if weekly_repetition_bases is not None:
            pulumi.set(__self__, "weekly_repetition_bases", weekly_repetition_bases)

    @property
    @pulumi.getter(name="intervalMonths")
    def interval_months(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        return pulumi.get(self, "interval_months")

    @interval_months.setter
    def interval_months(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "interval_months", value)

    @property
    @pulumi.getter(name="weekOfTheMonths")
    def week_of_the_months(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "week_of_the_months")

    @week_of_the_months.setter
    def week_of_the_months(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "week_of_the_months", value)

    @property
    @pulumi.getter(name="weeklyRepetitionBases")
    def weekly_repetition_bases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBaseArgs']]]]:
        return pulumi.get(self, "weekly_repetition_bases")

    @weekly_repetition_bases.setter
    def weekly_repetition_bases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBaseArgs']]]]):
        pulumi.set(self, "weekly_repetition_bases", value)


if not MYPY:
    class OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBaseArgsDict(TypedDict):
        interval_days: pulumi.Input[Sequence[pulumi.Input[str]]]
        interval_hours_end_time: pulumi.Input[str]
        interval_hours_start_time: pulumi.Input[str]
elif False:
    OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBaseArgs:
    def __init__(__self__, *,
                 interval_days: pulumi.Input[Sequence[pulumi.Input[str]]],
                 interval_hours_end_time: pulumi.Input[str],
                 interval_hours_start_time: pulumi.Input[str]):
        pulumi.set(__self__, "interval_days", interval_days)
        pulumi.set(__self__, "interval_hours_end_time", interval_hours_end_time)
        pulumi.set(__self__, "interval_hours_start_time", interval_hours_start_time)

    @property
    @pulumi.getter(name="intervalDays")
    def interval_days(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "interval_days")

    @interval_days.setter
    def interval_days(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "interval_days", value)

    @property
    @pulumi.getter(name="intervalHoursEndTime")
    def interval_hours_end_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "interval_hours_end_time")

    @interval_hours_end_time.setter
    def interval_hours_end_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval_hours_end_time", value)

    @property
    @pulumi.getter(name="intervalHoursStartTime")
    def interval_hours_start_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "interval_hours_start_time")

    @interval_hours_start_time.setter
    def interval_hours_start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval_hours_start_time", value)


if not MYPY:
    class OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBaseArgsDict(TypedDict):
        interval_days: pulumi.Input[Sequence[pulumi.Input[str]]]
        interval_hours_end_time: pulumi.Input[str]
        interval_hours_start_time: pulumi.Input[str]
elif False:
    OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBaseArgs:
    def __init__(__self__, *,
                 interval_days: pulumi.Input[Sequence[pulumi.Input[str]]],
                 interval_hours_end_time: pulumi.Input[str],
                 interval_hours_start_time: pulumi.Input[str]):
        pulumi.set(__self__, "interval_days", interval_days)
        pulumi.set(__self__, "interval_hours_end_time", interval_hours_end_time)
        pulumi.set(__self__, "interval_hours_start_time", interval_hours_start_time)

    @property
    @pulumi.getter(name="intervalDays")
    def interval_days(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "interval_days")

    @interval_days.setter
    def interval_days(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "interval_days", value)

    @property
    @pulumi.getter(name="intervalHoursEndTime")
    def interval_hours_end_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "interval_hours_end_time")

    @interval_hours_end_time.setter
    def interval_hours_end_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval_hours_end_time", value)

    @property
    @pulumi.getter(name="intervalHoursStartTime")
    def interval_hours_start_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "interval_hours_start_time")

    @interval_hours_start_time.setter
    def interval_hours_start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval_hours_start_time", value)


if not MYPY:
    class OceanRightSizingRuleRecommendationApplicationMinThresholdArgsDict(TypedDict):
        cpu_percentage: NotRequired[pulumi.Input[float]]
        memory_percentage: NotRequired[pulumi.Input[float]]
elif False:
    OceanRightSizingRuleRecommendationApplicationMinThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanRightSizingRuleRecommendationApplicationMinThresholdArgs:
    def __init__(__self__, *,
                 cpu_percentage: Optional[pulumi.Input[float]] = None,
                 memory_percentage: Optional[pulumi.Input[float]] = None):
        if cpu_percentage is not None:
            pulumi.set(__self__, "cpu_percentage", cpu_percentage)
        if memory_percentage is not None:
            pulumi.set(__self__, "memory_percentage", memory_percentage)

    @property
    @pulumi.getter(name="cpuPercentage")
    def cpu_percentage(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_percentage")

    @cpu_percentage.setter
    def cpu_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_percentage", value)

    @property
    @pulumi.getter(name="memoryPercentage")
    def memory_percentage(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_percentage")

    @memory_percentage.setter
    def memory_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_percentage", value)


if not MYPY:
    class OceanRightSizingRuleRecommendationApplicationOverheadValueArgsDict(TypedDict):
        cpu_percentage: NotRequired[pulumi.Input[float]]
        memory_percentage: NotRequired[pulumi.Input[float]]
elif False:
    OceanRightSizingRuleRecommendationApplicationOverheadValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanRightSizingRuleRecommendationApplicationOverheadValueArgs:
    def __init__(__self__, *,
                 cpu_percentage: Optional[pulumi.Input[float]] = None,
                 memory_percentage: Optional[pulumi.Input[float]] = None):
        if cpu_percentage is not None:
            pulumi.set(__self__, "cpu_percentage", cpu_percentage)
        if memory_percentage is not None:
            pulumi.set(__self__, "memory_percentage", memory_percentage)

    @property
    @pulumi.getter(name="cpuPercentage")
    def cpu_percentage(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_percentage")

    @cpu_percentage.setter
    def cpu_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_percentage", value)

    @property
    @pulumi.getter(name="memoryPercentage")
    def memory_percentage(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_percentage")

    @memory_percentage.setter
    def memory_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_percentage", value)


if not MYPY:
    class StatefulNodeAzureAttachDataDiskArgsDict(TypedDict):
        data_disk_name: pulumi.Input[str]
        data_disk_resource_group_name: pulumi.Input[str]
        size_gb: pulumi.Input[int]
        storage_account_type: pulumi.Input[str]
        lun: NotRequired[pulumi.Input[int]]
        zone: NotRequired[pulumi.Input[str]]
elif False:
    StatefulNodeAzureAttachDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureAttachDataDiskArgs:
    def __init__(__self__, *,
                 data_disk_name: pulumi.Input[str],
                 data_disk_resource_group_name: pulumi.Input[str],
                 size_gb: pulumi.Input[int],
                 storage_account_type: pulumi.Input[str],
                 lun: Optional[pulumi.Input[int]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "data_disk_name", data_disk_name)
        pulumi.set(__self__, "data_disk_resource_group_name", data_disk_resource_group_name)
        pulumi.set(__self__, "size_gb", size_gb)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if lun is not None:
            pulumi.set(__self__, "lun", lun)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="dataDiskName")
    def data_disk_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "data_disk_name")

    @data_disk_name.setter
    def data_disk_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_disk_name", value)

    @property
    @pulumi.getter(name="dataDiskResourceGroupName")
    def data_disk_resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "data_disk_resource_group_name")

    @data_disk_resource_group_name.setter
    def data_disk_resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_disk_resource_group_name", value)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> pulumi.Input[int]:
        return pulumi.get(self, "size_gb")

    @size_gb.setter
    def size_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_gb", value)

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "storage_account_type")

    @storage_account_type.setter
    def storage_account_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_type", value)

    @property
    @pulumi.getter
    def lun(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "lun")

    @lun.setter
    def lun(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lun", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class StatefulNodeAzureBootDiagnosticArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[bool]]
        storage_url: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    StatefulNodeAzureBootDiagnosticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureBootDiagnosticArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 storage_url: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if storage_url is not None:
            pulumi.set(__self__, "storage_url", storage_url)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="storageUrl")
    def storage_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "storage_url")

    @storage_url.setter
    def storage_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_url", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class StatefulNodeAzureDataDiskArgsDict(TypedDict):
        lun: pulumi.Input[int]
        size_gb: pulumi.Input[int]
        type: pulumi.Input[str]
elif False:
    StatefulNodeAzureDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureDataDiskArgs:
    def __init__(__self__, *,
                 lun: pulumi.Input[int],
                 size_gb: pulumi.Input[int],
                 type: pulumi.Input[str]):
        pulumi.set(__self__, "lun", lun)
        pulumi.set(__self__, "size_gb", size_gb)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def lun(self) -> pulumi.Input[int]:
        return pulumi.get(self, "lun")

    @lun.setter
    def lun(self, value: pulumi.Input[int]):
        pulumi.set(self, "lun", value)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> pulumi.Input[int]:
        return pulumi.get(self, "size_gb")

    @size_gb.setter
    def size_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_gb", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class StatefulNodeAzureDeleteArgsDict(TypedDict):
        disk_should_deallocate: pulumi.Input[bool]
        network_should_deallocate: pulumi.Input[bool]
        public_ip_should_deallocate: pulumi.Input[bool]
        should_terminate_vm: pulumi.Input[bool]
        snapshot_should_deallocate: pulumi.Input[bool]
        disk_ttl_in_hours: NotRequired[pulumi.Input[int]]
        network_ttl_in_hours: NotRequired[pulumi.Input[int]]
        public_ip_ttl_in_hours: NotRequired[pulumi.Input[int]]
        should_deregister_from_lb: NotRequired[pulumi.Input[bool]]
        snapshot_ttl_in_hours: NotRequired[pulumi.Input[int]]
elif False:
    StatefulNodeAzureDeleteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureDeleteArgs:
    def __init__(__self__, *,
                 disk_should_deallocate: pulumi.Input[bool],
                 network_should_deallocate: pulumi.Input[bool],
                 public_ip_should_deallocate: pulumi.Input[bool],
                 should_terminate_vm: pulumi.Input[bool],
                 snapshot_should_deallocate: pulumi.Input[bool],
                 disk_ttl_in_hours: Optional[pulumi.Input[int]] = None,
                 network_ttl_in_hours: Optional[pulumi.Input[int]] = None,
                 public_ip_ttl_in_hours: Optional[pulumi.Input[int]] = None,
                 should_deregister_from_lb: Optional[pulumi.Input[bool]] = None,
                 snapshot_ttl_in_hours: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "disk_should_deallocate", disk_should_deallocate)
        pulumi.set(__self__, "network_should_deallocate", network_should_deallocate)
        pulumi.set(__self__, "public_ip_should_deallocate", public_ip_should_deallocate)
        pulumi.set(__self__, "should_terminate_vm", should_terminate_vm)
        pulumi.set(__self__, "snapshot_should_deallocate", snapshot_should_deallocate)
        if disk_ttl_in_hours is not None:
            pulumi.set(__self__, "disk_ttl_in_hours", disk_ttl_in_hours)
        if network_ttl_in_hours is not None:
            pulumi.set(__self__, "network_ttl_in_hours", network_ttl_in_hours)
        if public_ip_ttl_in_hours is not None:
            pulumi.set(__self__, "public_ip_ttl_in_hours", public_ip_ttl_in_hours)
        if should_deregister_from_lb is not None:
            pulumi.set(__self__, "should_deregister_from_lb", should_deregister_from_lb)
        if snapshot_ttl_in_hours is not None:
            pulumi.set(__self__, "snapshot_ttl_in_hours", snapshot_ttl_in_hours)

    @property
    @pulumi.getter(name="diskShouldDeallocate")
    def disk_should_deallocate(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "disk_should_deallocate")

    @disk_should_deallocate.setter
    def disk_should_deallocate(self, value: pulumi.Input[bool]):
        pulumi.set(self, "disk_should_deallocate", value)

    @property
    @pulumi.getter(name="networkShouldDeallocate")
    def network_should_deallocate(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "network_should_deallocate")

    @network_should_deallocate.setter
    def network_should_deallocate(self, value: pulumi.Input[bool]):
        pulumi.set(self, "network_should_deallocate", value)

    @property
    @pulumi.getter(name="publicIpShouldDeallocate")
    def public_ip_should_deallocate(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "public_ip_should_deallocate")

    @public_ip_should_deallocate.setter
    def public_ip_should_deallocate(self, value: pulumi.Input[bool]):
        pulumi.set(self, "public_ip_should_deallocate", value)

    @property
    @pulumi.getter(name="shouldTerminateVm")
    def should_terminate_vm(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "should_terminate_vm")

    @should_terminate_vm.setter
    def should_terminate_vm(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_terminate_vm", value)

    @property
    @pulumi.getter(name="snapshotShouldDeallocate")
    def snapshot_should_deallocate(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "snapshot_should_deallocate")

    @snapshot_should_deallocate.setter
    def snapshot_should_deallocate(self, value: pulumi.Input[bool]):
        pulumi.set(self, "snapshot_should_deallocate", value)

    @property
    @pulumi.getter(name="diskTtlInHours")
    def disk_ttl_in_hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "disk_ttl_in_hours")

    @disk_ttl_in_hours.setter
    def disk_ttl_in_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_ttl_in_hours", value)

    @property
    @pulumi.getter(name="networkTtlInHours")
    def network_ttl_in_hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "network_ttl_in_hours")

    @network_ttl_in_hours.setter
    def network_ttl_in_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "network_ttl_in_hours", value)

    @property
    @pulumi.getter(name="publicIpTtlInHours")
    def public_ip_ttl_in_hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "public_ip_ttl_in_hours")

    @public_ip_ttl_in_hours.setter
    def public_ip_ttl_in_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "public_ip_ttl_in_hours", value)

    @property
    @pulumi.getter(name="shouldDeregisterFromLb")
    def should_deregister_from_lb(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_deregister_from_lb")

    @should_deregister_from_lb.setter
    def should_deregister_from_lb(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_deregister_from_lb", value)

    @property
    @pulumi.getter(name="snapshotTtlInHours")
    def snapshot_ttl_in_hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "snapshot_ttl_in_hours")

    @snapshot_ttl_in_hours.setter
    def snapshot_ttl_in_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "snapshot_ttl_in_hours", value)


if not MYPY:
    class StatefulNodeAzureDetachDataDiskArgsDict(TypedDict):
        data_disk_name: pulumi.Input[str]
        data_disk_resource_group_name: pulumi.Input[str]
        should_deallocate: pulumi.Input[bool]
        ttl_in_hours: NotRequired[pulumi.Input[int]]
elif False:
    StatefulNodeAzureDetachDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureDetachDataDiskArgs:
    def __init__(__self__, *,
                 data_disk_name: pulumi.Input[str],
                 data_disk_resource_group_name: pulumi.Input[str],
                 should_deallocate: pulumi.Input[bool],
                 ttl_in_hours: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "data_disk_name", data_disk_name)
        pulumi.set(__self__, "data_disk_resource_group_name", data_disk_resource_group_name)
        pulumi.set(__self__, "should_deallocate", should_deallocate)
        if ttl_in_hours is not None:
            pulumi.set(__self__, "ttl_in_hours", ttl_in_hours)

    @property
    @pulumi.getter(name="dataDiskName")
    def data_disk_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "data_disk_name")

    @data_disk_name.setter
    def data_disk_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_disk_name", value)

    @property
    @pulumi.getter(name="dataDiskResourceGroupName")
    def data_disk_resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "data_disk_resource_group_name")

    @data_disk_resource_group_name.setter
    def data_disk_resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_disk_resource_group_name", value)

    @property
    @pulumi.getter(name="shouldDeallocate")
    def should_deallocate(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "should_deallocate")

    @should_deallocate.setter
    def should_deallocate(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_deallocate", value)

    @property
    @pulumi.getter(name="ttlInHours")
    def ttl_in_hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ttl_in_hours")

    @ttl_in_hours.setter
    def ttl_in_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl_in_hours", value)


if not MYPY:
    class StatefulNodeAzureExtensionArgsDict(TypedDict):
        api_version: pulumi.Input[str]
        minor_version_auto_upgrade: pulumi.Input[bool]
        name: pulumi.Input[str]
        publisher: pulumi.Input[str]
        type: pulumi.Input[str]
        protected_settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        public_settings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    StatefulNodeAzureExtensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureExtensionArgs:
    def __init__(__self__, *,
                 api_version: pulumi.Input[str],
                 minor_version_auto_upgrade: pulumi.Input[bool],
                 name: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 type: pulumi.Input[str],
                 protected_settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 public_settings: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "minor_version_auto_upgrade", minor_version_auto_upgrade)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "type", type)
        if protected_settings is not None:
            pulumi.set(__self__, "protected_settings", protected_settings)
        if public_settings is not None:
            pulumi.set(__self__, "public_settings", public_settings)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> pulumi.Input[str]:
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="minorVersionAutoUpgrade")
    def minor_version_auto_upgrade(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "minor_version_auto_upgrade")

    @minor_version_auto_upgrade.setter
    def minor_version_auto_upgrade(self, value: pulumi.Input[bool]):
        pulumi.set(self, "minor_version_auto_upgrade", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "protected_settings")

    @protected_settings.setter
    def protected_settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "protected_settings", value)

    @property
    @pulumi.getter(name="publicSettings")
    def public_settings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "public_settings")

    @public_settings.setter
    def public_settings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "public_settings", value)


if not MYPY:
    class StatefulNodeAzureHealthArgsDict(TypedDict):
        auto_healing: pulumi.Input[bool]
        health_check_types: pulumi.Input[Sequence[pulumi.Input[str]]]
        grace_period: NotRequired[pulumi.Input[int]]
        unhealthy_duration: NotRequired[pulumi.Input[int]]
elif False:
    StatefulNodeAzureHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureHealthArgs:
    def __init__(__self__, *,
                 auto_healing: pulumi.Input[bool],
                 health_check_types: pulumi.Input[Sequence[pulumi.Input[str]]],
                 grace_period: Optional[pulumi.Input[int]] = None,
                 unhealthy_duration: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "auto_healing", auto_healing)
        pulumi.set(__self__, "health_check_types", health_check_types)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if unhealthy_duration is not None:
            pulumi.set(__self__, "unhealthy_duration", unhealthy_duration)

    @property
    @pulumi.getter(name="autoHealing")
    def auto_healing(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "auto_healing")

    @auto_healing.setter
    def auto_healing(self, value: pulumi.Input[bool]):
        pulumi.set(self, "auto_healing", value)

    @property
    @pulumi.getter(name="healthCheckTypes")
    def health_check_types(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "health_check_types")

    @health_check_types.setter
    def health_check_types(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "health_check_types", value)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "grace_period", value)

    @property
    @pulumi.getter(name="unhealthyDuration")
    def unhealthy_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "unhealthy_duration")

    @unhealthy_duration.setter
    def unhealthy_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unhealthy_duration", value)


if not MYPY:
    class StatefulNodeAzureImageArgsDict(TypedDict):
        custom_images: NotRequired[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImageCustomImageArgsDict']]]]
        galleries: NotRequired[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImageGalleryArgsDict']]]]
        marketplace_images: NotRequired[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImageMarketplaceImageArgsDict']]]]
elif False:
    StatefulNodeAzureImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureImageArgs:
    def __init__(__self__, *,
                 custom_images: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImageCustomImageArgs']]]] = None,
                 galleries: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImageGalleryArgs']]]] = None,
                 marketplace_images: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImageMarketplaceImageArgs']]]] = None):
        if custom_images is not None:
            pulumi.set(__self__, "custom_images", custom_images)
        if galleries is not None:
            pulumi.set(__self__, "galleries", galleries)
        if marketplace_images is not None:
            pulumi.set(__self__, "marketplace_images", marketplace_images)

    @property
    @pulumi.getter(name="customImages")
    def custom_images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImageCustomImageArgs']]]]:
        return pulumi.get(self, "custom_images")

    @custom_images.setter
    def custom_images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImageCustomImageArgs']]]]):
        pulumi.set(self, "custom_images", value)

    @property
    @pulumi.getter
    def galleries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImageGalleryArgs']]]]:
        return pulumi.get(self, "galleries")

    @galleries.setter
    def galleries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImageGalleryArgs']]]]):
        pulumi.set(self, "galleries", value)

    @property
    @pulumi.getter(name="marketplaceImages")
    def marketplace_images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImageMarketplaceImageArgs']]]]:
        return pulumi.get(self, "marketplace_images")

    @marketplace_images.setter
    def marketplace_images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImageMarketplaceImageArgs']]]]):
        pulumi.set(self, "marketplace_images", value)


if not MYPY:
    class StatefulNodeAzureImageCustomImageArgsDict(TypedDict):
        custom_image_resource_group_name: pulumi.Input[str]
        name: pulumi.Input[str]
elif False:
    StatefulNodeAzureImageCustomImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureImageCustomImageArgs:
    def __init__(__self__, *,
                 custom_image_resource_group_name: pulumi.Input[str],
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "custom_image_resource_group_name", custom_image_resource_group_name)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="customImageResourceGroupName")
    def custom_image_resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "custom_image_resource_group_name")

    @custom_image_resource_group_name.setter
    def custom_image_resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "custom_image_resource_group_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class StatefulNodeAzureImageGalleryArgsDict(TypedDict):
        gallery_name: pulumi.Input[str]
        gallery_resource_group_name: pulumi.Input[str]
        image_name: pulumi.Input[str]
        version_name: pulumi.Input[str]
        spot_account_id: NotRequired[pulumi.Input[str]]
elif False:
    StatefulNodeAzureImageGalleryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureImageGalleryArgs:
    def __init__(__self__, *,
                 gallery_name: pulumi.Input[str],
                 gallery_resource_group_name: pulumi.Input[str],
                 image_name: pulumi.Input[str],
                 version_name: pulumi.Input[str],
                 spot_account_id: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "gallery_name", gallery_name)
        pulumi.set(__self__, "gallery_resource_group_name", gallery_resource_group_name)
        pulumi.set(__self__, "image_name", image_name)
        pulumi.set(__self__, "version_name", version_name)
        if spot_account_id is not None:
            pulumi.set(__self__, "spot_account_id", spot_account_id)

    @property
    @pulumi.getter(name="galleryName")
    def gallery_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "gallery_name")

    @gallery_name.setter
    def gallery_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "gallery_name", value)

    @property
    @pulumi.getter(name="galleryResourceGroupName")
    def gallery_resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "gallery_resource_group_name")

    @gallery_resource_group_name.setter
    def gallery_resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "gallery_resource_group_name", value)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter(name="versionName")
    def version_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "version_name")

    @version_name.setter
    def version_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "version_name", value)

    @property
    @pulumi.getter(name="spotAccountId")
    def spot_account_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "spot_account_id")

    @spot_account_id.setter
    def spot_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spot_account_id", value)


if not MYPY:
    class StatefulNodeAzureImageMarketplaceImageArgsDict(TypedDict):
        offer: pulumi.Input[str]
        publisher: pulumi.Input[str]
        sku: pulumi.Input[str]
        version: pulumi.Input[str]
elif False:
    StatefulNodeAzureImageMarketplaceImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureImageMarketplaceImageArgs:
    def __init__(__self__, *,
                 offer: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 sku: pulumi.Input[str],
                 version: pulumi.Input[str]):
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def offer(self) -> pulumi.Input[str]:
        return pulumi.get(self, "offer")

    @offer.setter
    def offer(self, value: pulumi.Input[str]):
        pulumi.set(self, "offer", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def sku(self) -> pulumi.Input[str]:
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: pulumi.Input[str]):
        pulumi.set(self, "sku", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class StatefulNodeAzureImportVmArgsDict(TypedDict):
        original_vm_name: pulumi.Input[str]
        resource_group_name: pulumi.Input[str]
        draining_timeout: NotRequired[pulumi.Input[int]]
        resources_retention_time: NotRequired[pulumi.Input[int]]
elif False:
    StatefulNodeAzureImportVmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureImportVmArgs:
    def __init__(__self__, *,
                 original_vm_name: pulumi.Input[str],
                 resource_group_name: pulumi.Input[str],
                 draining_timeout: Optional[pulumi.Input[int]] = None,
                 resources_retention_time: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "original_vm_name", original_vm_name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        if draining_timeout is not None:
            pulumi.set(__self__, "draining_timeout", draining_timeout)
        if resources_retention_time is not None:
            pulumi.set(__self__, "resources_retention_time", resources_retention_time)

    @property
    @pulumi.getter(name="originalVmName")
    def original_vm_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "original_vm_name")

    @original_vm_name.setter
    def original_vm_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "original_vm_name", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter(name="drainingTimeout")
    def draining_timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "draining_timeout")

    @draining_timeout.setter
    def draining_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "draining_timeout", value)

    @property
    @pulumi.getter(name="resourcesRetentionTime")
    def resources_retention_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "resources_retention_time")

    @resources_retention_time.setter
    def resources_retention_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "resources_retention_time", value)


if not MYPY:
    class StatefulNodeAzureLoadBalancerArgsDict(TypedDict):
        backend_pool_names: pulumi.Input[Sequence[pulumi.Input[str]]]
        name: pulumi.Input[str]
        resource_group_name: pulumi.Input[str]
        type: pulumi.Input[str]
        sku: NotRequired[pulumi.Input[str]]
elif False:
    StatefulNodeAzureLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureLoadBalancerArgs:
    def __init__(__self__, *,
                 backend_pool_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: pulumi.Input[str],
                 resource_group_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 sku: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "backend_pool_names", backend_pool_names)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "type", type)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)

    @property
    @pulumi.getter(name="backendPoolNames")
    def backend_pool_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "backend_pool_names")

    @backend_pool_names.setter
    def backend_pool_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "backend_pool_names", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def sku(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sku", value)


if not MYPY:
    class StatefulNodeAzureLoginArgsDict(TypedDict):
        user_name: pulumi.Input[str]
        password: NotRequired[pulumi.Input[str]]
        ssh_public_key: NotRequired[pulumi.Input[str]]
elif False:
    StatefulNodeAzureLoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureLoginArgs:
    def __init__(__self__, *,
                 user_name: pulumi.Input[str],
                 password: Optional[pulumi.Input[str]] = None,
                 ssh_public_key: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "user_name", user_name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if ssh_public_key is not None:
            pulumi.set(__self__, "ssh_public_key", ssh_public_key)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="sshPublicKey")
    def ssh_public_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ssh_public_key")

    @ssh_public_key.setter
    def ssh_public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_public_key", value)


if not MYPY:
    class StatefulNodeAzureManagedServiceIdentityArgsDict(TypedDict):
        name: pulumi.Input[str]
        resource_group_name: pulumi.Input[str]
elif False:
    StatefulNodeAzureManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 resource_group_name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_group_name", value)


if not MYPY:
    class StatefulNodeAzureNetworkArgsDict(TypedDict):
        network_interfaces: pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfaceArgsDict']]]
        network_resource_group_name: pulumi.Input[str]
        virtual_network_name: pulumi.Input[str]
elif False:
    StatefulNodeAzureNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureNetworkArgs:
    def __init__(__self__, *,
                 network_interfaces: pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfaceArgs']]],
                 network_resource_group_name: pulumi.Input[str],
                 virtual_network_name: pulumi.Input[str]):
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "network_resource_group_name", network_resource_group_name)
        pulumi.set(__self__, "virtual_network_name", virtual_network_name)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfaceArgs']]]:
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfaceArgs']]]):
        pulumi.set(self, "network_interfaces", value)

    @property
    @pulumi.getter(name="networkResourceGroupName")
    def network_resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "network_resource_group_name")

    @network_resource_group_name.setter
    def network_resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_resource_group_name", value)

    @property
    @pulumi.getter(name="virtualNetworkName")
    def virtual_network_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "virtual_network_name")

    @virtual_network_name.setter
    def virtual_network_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_network_name", value)


if not MYPY:
    class StatefulNodeAzureNetworkNetworkInterfaceArgsDict(TypedDict):
        is_primary: pulumi.Input[bool]
        subnet_name: pulumi.Input[str]
        additional_ip_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfigurationArgsDict']]]]
        application_security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroupArgsDict']]]]
        assign_public_ip: NotRequired[pulumi.Input[bool]]
        enable_ip_forwarding: NotRequired[pulumi.Input[bool]]
        network_security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroupArgsDict']]]]
        private_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        public_ip_sku: NotRequired[pulumi.Input[str]]
        public_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfacePublicIpArgsDict']]]]
elif False:
    StatefulNodeAzureNetworkNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureNetworkNetworkInterfaceArgs:
    def __init__(__self__, *,
                 is_primary: pulumi.Input[bool],
                 subnet_name: pulumi.Input[str],
                 additional_ip_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfigurationArgs']]]] = None,
                 application_security_groups: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroupArgs']]]] = None,
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 enable_ip_forwarding: Optional[pulumi.Input[bool]] = None,
                 network_security_groups: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroupArgs']]]] = None,
                 private_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 public_ip_sku: Optional[pulumi.Input[str]] = None,
                 public_ips: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfacePublicIpArgs']]]] = None):
        pulumi.set(__self__, "is_primary", is_primary)
        pulumi.set(__self__, "subnet_name", subnet_name)
        if additional_ip_configurations is not None:
            pulumi.set(__self__, "additional_ip_configurations", additional_ip_configurations)
        if application_security_groups is not None:
            pulumi.set(__self__, "application_security_groups", application_security_groups)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if enable_ip_forwarding is not None:
            pulumi.set(__self__, "enable_ip_forwarding", enable_ip_forwarding)
        if network_security_groups is not None:
            pulumi.set(__self__, "network_security_groups", network_security_groups)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if public_ip_sku is not None:
            pulumi.set(__self__, "public_ip_sku", public_ip_sku)
        if public_ips is not None:
            pulumi.set(__self__, "public_ips", public_ips)

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "is_primary")

    @is_primary.setter
    def is_primary(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_primary", value)

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "subnet_name")

    @subnet_name.setter
    def subnet_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_name", value)

    @property
    @pulumi.getter(name="additionalIpConfigurations")
    def additional_ip_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfigurationArgs']]]]:
        return pulumi.get(self, "additional_ip_configurations")

    @additional_ip_configurations.setter
    def additional_ip_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfigurationArgs']]]]):
        pulumi.set(self, "additional_ip_configurations", value)

    @property
    @pulumi.getter(name="applicationSecurityGroups")
    def application_security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroupArgs']]]]:
        return pulumi.get(self, "application_security_groups")

    @application_security_groups.setter
    def application_security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroupArgs']]]]):
        pulumi.set(self, "application_security_groups", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="enableIpForwarding")
    def enable_ip_forwarding(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_ip_forwarding")

    @enable_ip_forwarding.setter
    def enable_ip_forwarding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ip_forwarding", value)

    @property
    @pulumi.getter(name="networkSecurityGroups")
    def network_security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroupArgs']]]]:
        return pulumi.get(self, "network_security_groups")

    @network_security_groups.setter
    def network_security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroupArgs']]]]):
        pulumi.set(self, "network_security_groups", value)

    @property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "private_ip_addresses")

    @private_ip_addresses.setter
    def private_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "private_ip_addresses", value)

    @property
    @pulumi.getter(name="publicIpSku")
    def public_ip_sku(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "public_ip_sku")

    @public_ip_sku.setter
    def public_ip_sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_ip_sku", value)

    @property
    @pulumi.getter(name="publicIps")
    def public_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfacePublicIpArgs']]]]:
        return pulumi.get(self, "public_ips")

    @public_ips.setter
    def public_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureNetworkNetworkInterfacePublicIpArgs']]]]):
        pulumi.set(self, "public_ips", value)


if not MYPY:
    class StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfigurationArgsDict(TypedDict):
        name: pulumi.Input[str]
        private_ip_address_version: pulumi.Input[str]
elif False:
    StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfigurationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 private_ip_address_version: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_ip_address_version", private_ip_address_version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateIpAddressVersion")
    def private_ip_address_version(self) -> pulumi.Input[str]:
        return pulumi.get(self, "private_ip_address_version")

    @private_ip_address_version.setter
    def private_ip_address_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_ip_address_version", value)


if not MYPY:
    class StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroupArgsDict(TypedDict):
        name: pulumi.Input[str]
        network_resource_group_name: pulumi.Input[str]
elif False:
    StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 network_resource_group_name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_resource_group_name", network_resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="networkResourceGroupName")
    def network_resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "network_resource_group_name")

    @network_resource_group_name.setter
    def network_resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_resource_group_name", value)


if not MYPY:
    class StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroupArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        network_resource_group_name: NotRequired[pulumi.Input[str]]
elif False:
    StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroupArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 network_resource_group_name: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_resource_group_name is not None:
            pulumi.set(__self__, "network_resource_group_name", network_resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="networkResourceGroupName")
    def network_resource_group_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network_resource_group_name")

    @network_resource_group_name.setter
    def network_resource_group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_resource_group_name", value)


if not MYPY:
    class StatefulNodeAzureNetworkNetworkInterfacePublicIpArgsDict(TypedDict):
        name: pulumi.Input[str]
        network_resource_group_name: pulumi.Input[str]
elif False:
    StatefulNodeAzureNetworkNetworkInterfacePublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureNetworkNetworkInterfacePublicIpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 network_resource_group_name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_resource_group_name", network_resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="networkResourceGroupName")
    def network_resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "network_resource_group_name")

    @network_resource_group_name.setter
    def network_resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_resource_group_name", value)


if not MYPY:
    class StatefulNodeAzureOsDiskArgsDict(TypedDict):
        type: pulumi.Input[str]
        caching: NotRequired[pulumi.Input[str]]
        size_gb: NotRequired[pulumi.Input[int]]
elif False:
    StatefulNodeAzureOsDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureOsDiskArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 caching: Optional[pulumi.Input[str]] = None,
                 size_gb: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "type", type)
        if caching is not None:
            pulumi.set(__self__, "caching", caching)
        if size_gb is not None:
            pulumi.set(__self__, "size_gb", size_gb)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def caching(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "caching")

    @caching.setter
    def caching(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "caching", value)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "size_gb")

    @size_gb.setter
    def size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_gb", value)


if not MYPY:
    class StatefulNodeAzureProximityPlacementGroupArgsDict(TypedDict):
        name: pulumi.Input[str]
        resource_group_name: pulumi.Input[str]
elif False:
    StatefulNodeAzureProximityPlacementGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureProximityPlacementGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 resource_group_name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_group_name", value)


if not MYPY:
    class StatefulNodeAzureSchedulingTaskArgsDict(TypedDict):
        cron_expression: pulumi.Input[str]
        is_enabled: pulumi.Input[bool]
        type: pulumi.Input[str]
elif False:
    StatefulNodeAzureSchedulingTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureSchedulingTaskArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[str],
                 is_enabled: pulumi.Input[bool],
                 type: pulumi.Input[str]):
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class StatefulNodeAzureSecretArgsDict(TypedDict):
        source_vaults: pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSecretSourceVaultArgsDict']]]
        vault_certificates: pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSecretVaultCertificateArgsDict']]]
elif False:
    StatefulNodeAzureSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureSecretArgs:
    def __init__(__self__, *,
                 source_vaults: pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSecretSourceVaultArgs']]],
                 vault_certificates: pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSecretVaultCertificateArgs']]]):
        pulumi.set(__self__, "source_vaults", source_vaults)
        pulumi.set(__self__, "vault_certificates", vault_certificates)

    @property
    @pulumi.getter(name="sourceVaults")
    def source_vaults(self) -> pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSecretSourceVaultArgs']]]:
        return pulumi.get(self, "source_vaults")

    @source_vaults.setter
    def source_vaults(self, value: pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSecretSourceVaultArgs']]]):
        pulumi.set(self, "source_vaults", value)

    @property
    @pulumi.getter(name="vaultCertificates")
    def vault_certificates(self) -> pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSecretVaultCertificateArgs']]]:
        return pulumi.get(self, "vault_certificates")

    @vault_certificates.setter
    def vault_certificates(self, value: pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSecretVaultCertificateArgs']]]):
        pulumi.set(self, "vault_certificates", value)


if not MYPY:
    class StatefulNodeAzureSecretSourceVaultArgsDict(TypedDict):
        name: pulumi.Input[str]
        resource_group_name: pulumi.Input[str]
elif False:
    StatefulNodeAzureSecretSourceVaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureSecretSourceVaultArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 resource_group_name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_group_name", value)


if not MYPY:
    class StatefulNodeAzureSecretVaultCertificateArgsDict(TypedDict):
        certificate_store: NotRequired[pulumi.Input[str]]
        certificate_url: NotRequired[pulumi.Input[str]]
elif False:
    StatefulNodeAzureSecretVaultCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureSecretVaultCertificateArgs:
    def __init__(__self__, *,
                 certificate_store: Optional[pulumi.Input[str]] = None,
                 certificate_url: Optional[pulumi.Input[str]] = None):
        if certificate_store is not None:
            pulumi.set(__self__, "certificate_store", certificate_store)
        if certificate_url is not None:
            pulumi.set(__self__, "certificate_url", certificate_url)

    @property
    @pulumi.getter(name="certificateStore")
    def certificate_store(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "certificate_store")

    @certificate_store.setter
    def certificate_store(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_store", value)

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "certificate_url")

    @certificate_url.setter
    def certificate_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_url", value)


if not MYPY:
    class StatefulNodeAzureSecurityArgsDict(TypedDict):
        confidential_os_disk_encryption: NotRequired[pulumi.Input[bool]]
        encryption_at_host: NotRequired[pulumi.Input[bool]]
        secure_boot_enabled: NotRequired[pulumi.Input[bool]]
        security_type: NotRequired[pulumi.Input[str]]
        vtpm_enabled: NotRequired[pulumi.Input[bool]]
elif False:
    StatefulNodeAzureSecurityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureSecurityArgs:
    def __init__(__self__, *,
                 confidential_os_disk_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_at_host: Optional[pulumi.Input[bool]] = None,
                 secure_boot_enabled: Optional[pulumi.Input[bool]] = None,
                 security_type: Optional[pulumi.Input[str]] = None,
                 vtpm_enabled: Optional[pulumi.Input[bool]] = None):
        if confidential_os_disk_encryption is not None:
            pulumi.set(__self__, "confidential_os_disk_encryption", confidential_os_disk_encryption)
        if encryption_at_host is not None:
            pulumi.set(__self__, "encryption_at_host", encryption_at_host)
        if secure_boot_enabled is not None:
            pulumi.set(__self__, "secure_boot_enabled", secure_boot_enabled)
        if security_type is not None:
            pulumi.set(__self__, "security_type", security_type)
        if vtpm_enabled is not None:
            pulumi.set(__self__, "vtpm_enabled", vtpm_enabled)

    @property
    @pulumi.getter(name="confidentialOsDiskEncryption")
    def confidential_os_disk_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "confidential_os_disk_encryption")

    @confidential_os_disk_encryption.setter
    def confidential_os_disk_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "confidential_os_disk_encryption", value)

    @property
    @pulumi.getter(name="encryptionAtHost")
    def encryption_at_host(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encryption_at_host")

    @encryption_at_host.setter
    def encryption_at_host(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encryption_at_host", value)

    @property
    @pulumi.getter(name="secureBootEnabled")
    def secure_boot_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure_boot_enabled")

    @secure_boot_enabled.setter
    def secure_boot_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure_boot_enabled", value)

    @property
    @pulumi.getter(name="securityType")
    def security_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "security_type")

    @security_type.setter
    def security_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_type", value)

    @property
    @pulumi.getter(name="vtpmEnabled")
    def vtpm_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "vtpm_enabled")

    @vtpm_enabled.setter
    def vtpm_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vtpm_enabled", value)


if not MYPY:
    class StatefulNodeAzureSignalArgsDict(TypedDict):
        timeout: pulumi.Input[int]
        type: pulumi.Input[str]
elif False:
    StatefulNodeAzureSignalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureSignalArgs:
    def __init__(__self__, *,
                 timeout: pulumi.Input[int],
                 type: pulumi.Input[str]):
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def timeout(self) -> pulumi.Input[int]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: pulumi.Input[int]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class StatefulNodeAzureStrategyArgsDict(TypedDict):
        fallback_to_on_demand: pulumi.Input[bool]
        availability_vs_cost: NotRequired[pulumi.Input[int]]
        capacity_reservations: NotRequired[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureStrategyCapacityReservationArgsDict']]]]
        draining_timeout: NotRequired[pulumi.Input[int]]
        od_windows: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        optimization_windows: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        preferred_life_cycle: NotRequired[pulumi.Input[str]]
        revert_to_spot: NotRequired[pulumi.Input['StatefulNodeAzureStrategyRevertToSpotArgsDict']]
        vm_admins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    StatefulNodeAzureStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureStrategyArgs:
    def __init__(__self__, *,
                 fallback_to_on_demand: pulumi.Input[bool],
                 availability_vs_cost: Optional[pulumi.Input[int]] = None,
                 capacity_reservations: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureStrategyCapacityReservationArgs']]]] = None,
                 draining_timeout: Optional[pulumi.Input[int]] = None,
                 od_windows: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 optimization_windows: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preferred_life_cycle: Optional[pulumi.Input[str]] = None,
                 revert_to_spot: Optional[pulumi.Input['StatefulNodeAzureStrategyRevertToSpotArgs']] = None,
                 vm_admins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "fallback_to_on_demand", fallback_to_on_demand)
        if availability_vs_cost is not None:
            pulumi.set(__self__, "availability_vs_cost", availability_vs_cost)
        if capacity_reservations is not None:
            pulumi.set(__self__, "capacity_reservations", capacity_reservations)
        if draining_timeout is not None:
            pulumi.set(__self__, "draining_timeout", draining_timeout)
        if od_windows is not None:
            pulumi.set(__self__, "od_windows", od_windows)
        if optimization_windows is not None:
            pulumi.set(__self__, "optimization_windows", optimization_windows)
        if preferred_life_cycle is not None:
            pulumi.set(__self__, "preferred_life_cycle", preferred_life_cycle)
        if revert_to_spot is not None:
            pulumi.set(__self__, "revert_to_spot", revert_to_spot)
        if vm_admins is not None:
            pulumi.set(__self__, "vm_admins", vm_admins)

    @property
    @pulumi.getter(name="fallbackToOnDemand")
    def fallback_to_on_demand(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "fallback_to_on_demand")

    @fallback_to_on_demand.setter
    def fallback_to_on_demand(self, value: pulumi.Input[bool]):
        pulumi.set(self, "fallback_to_on_demand", value)

    @property
    @pulumi.getter(name="availabilityVsCost")
    def availability_vs_cost(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "availability_vs_cost")

    @availability_vs_cost.setter
    def availability_vs_cost(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "availability_vs_cost", value)

    @property
    @pulumi.getter(name="capacityReservations")
    def capacity_reservations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureStrategyCapacityReservationArgs']]]]:
        return pulumi.get(self, "capacity_reservations")

    @capacity_reservations.setter
    def capacity_reservations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureStrategyCapacityReservationArgs']]]]):
        pulumi.set(self, "capacity_reservations", value)

    @property
    @pulumi.getter(name="drainingTimeout")
    def draining_timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "draining_timeout")

    @draining_timeout.setter
    def draining_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "draining_timeout", value)

    @property
    @pulumi.getter(name="odWindows")
    def od_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "od_windows")

    @od_windows.setter
    def od_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "od_windows", value)

    @property
    @pulumi.getter(name="optimizationWindows")
    def optimization_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "optimization_windows")

    @optimization_windows.setter
    def optimization_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "optimization_windows", value)

    @property
    @pulumi.getter(name="preferredLifeCycle")
    def preferred_life_cycle(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "preferred_life_cycle")

    @preferred_life_cycle.setter
    def preferred_life_cycle(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preferred_life_cycle", value)

    @property
    @pulumi.getter(name="revertToSpot")
    def revert_to_spot(self) -> Optional[pulumi.Input['StatefulNodeAzureStrategyRevertToSpotArgs']]:
        return pulumi.get(self, "revert_to_spot")

    @revert_to_spot.setter
    def revert_to_spot(self, value: Optional[pulumi.Input['StatefulNodeAzureStrategyRevertToSpotArgs']]):
        pulumi.set(self, "revert_to_spot", value)

    @property
    @pulumi.getter(name="vmAdmins")
    def vm_admins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "vm_admins")

    @vm_admins.setter
    def vm_admins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vm_admins", value)


if not MYPY:
    class StatefulNodeAzureStrategyCapacityReservationArgsDict(TypedDict):
        should_utilize: pulumi.Input[bool]
        utilization_strategy: pulumi.Input[str]
        capacity_reservation_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroupArgsDict']]]]
elif False:
    StatefulNodeAzureStrategyCapacityReservationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureStrategyCapacityReservationArgs:
    def __init__(__self__, *,
                 should_utilize: pulumi.Input[bool],
                 utilization_strategy: pulumi.Input[str],
                 capacity_reservation_groups: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroupArgs']]]] = None):
        pulumi.set(__self__, "should_utilize", should_utilize)
        pulumi.set(__self__, "utilization_strategy", utilization_strategy)
        if capacity_reservation_groups is not None:
            pulumi.set(__self__, "capacity_reservation_groups", capacity_reservation_groups)

    @property
    @pulumi.getter(name="shouldUtilize")
    def should_utilize(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "should_utilize")

    @should_utilize.setter
    def should_utilize(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_utilize", value)

    @property
    @pulumi.getter(name="utilizationStrategy")
    def utilization_strategy(self) -> pulumi.Input[str]:
        return pulumi.get(self, "utilization_strategy")

    @utilization_strategy.setter
    def utilization_strategy(self, value: pulumi.Input[str]):
        pulumi.set(self, "utilization_strategy", value)

    @property
    @pulumi.getter(name="capacityReservationGroups")
    def capacity_reservation_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroupArgs']]]]:
        return pulumi.get(self, "capacity_reservation_groups")

    @capacity_reservation_groups.setter
    def capacity_reservation_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroupArgs']]]]):
        pulumi.set(self, "capacity_reservation_groups", value)


if not MYPY:
    class StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroupArgsDict(TypedDict):
        crg_name: pulumi.Input[str]
        crg_resource_group_name: pulumi.Input[str]
        crg_should_prioritize: NotRequired[pulumi.Input[bool]]
elif False:
    StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroupArgs:
    def __init__(__self__, *,
                 crg_name: pulumi.Input[str],
                 crg_resource_group_name: pulumi.Input[str],
                 crg_should_prioritize: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "crg_name", crg_name)
        pulumi.set(__self__, "crg_resource_group_name", crg_resource_group_name)
        if crg_should_prioritize is not None:
            pulumi.set(__self__, "crg_should_prioritize", crg_should_prioritize)

    @property
    @pulumi.getter(name="crgName")
    def crg_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "crg_name")

    @crg_name.setter
    def crg_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "crg_name", value)

    @property
    @pulumi.getter(name="crgResourceGroupName")
    def crg_resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "crg_resource_group_name")

    @crg_resource_group_name.setter
    def crg_resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "crg_resource_group_name", value)

    @property
    @pulumi.getter(name="crgShouldPrioritize")
    def crg_should_prioritize(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "crg_should_prioritize")

    @crg_should_prioritize.setter
    def crg_should_prioritize(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "crg_should_prioritize", value)


if not MYPY:
    class StatefulNodeAzureStrategyRevertToSpotArgsDict(TypedDict):
        perform_at: pulumi.Input[str]
elif False:
    StatefulNodeAzureStrategyRevertToSpotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureStrategyRevertToSpotArgs:
    def __init__(__self__, *,
                 perform_at: pulumi.Input[str]):
        pulumi.set(__self__, "perform_at", perform_at)

    @property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> pulumi.Input[str]:
        return pulumi.get(self, "perform_at")

    @perform_at.setter
    def perform_at(self, value: pulumi.Input[str]):
        pulumi.set(self, "perform_at", value)


if not MYPY:
    class StatefulNodeAzureTagArgsDict(TypedDict):
        tag_key: pulumi.Input[str]
        tag_value: NotRequired[pulumi.Input[str]]
elif False:
    StatefulNodeAzureTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureTagArgs:
    def __init__(__self__, *,
                 tag_key: pulumi.Input[str],
                 tag_value: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class StatefulNodeAzureUpdateStateArgsDict(TypedDict):
        state: pulumi.Input[str]
elif False:
    StatefulNodeAzureUpdateStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureUpdateStateArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[str]):
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[str]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[str]):
        pulumi.set(self, "state", value)


if not MYPY:
    class StatefulNodeAzureVmSizesArgsDict(TypedDict):
        od_sizes: pulumi.Input[Sequence[pulumi.Input[str]]]
        spot_sizes: pulumi.Input[Sequence[pulumi.Input[str]]]
        preferred_spot_sizes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    StatefulNodeAzureVmSizesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatefulNodeAzureVmSizesArgs:
    def __init__(__self__, *,
                 od_sizes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 spot_sizes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 preferred_spot_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "od_sizes", od_sizes)
        pulumi.set(__self__, "spot_sizes", spot_sizes)
        if preferred_spot_sizes is not None:
            pulumi.set(__self__, "preferred_spot_sizes", preferred_spot_sizes)

    @property
    @pulumi.getter(name="odSizes")
    def od_sizes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "od_sizes")

    @od_sizes.setter
    def od_sizes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "od_sizes", value)

    @property
    @pulumi.getter(name="spotSizes")
    def spot_sizes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "spot_sizes")

    @spot_sizes.setter
    def spot_sizes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "spot_sizes", value)

    @property
    @pulumi.getter(name="preferredSpotSizes")
    def preferred_spot_sizes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "preferred_spot_sizes")

    @preferred_spot_sizes.setter
    def preferred_spot_sizes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "preferred_spot_sizes", value)


