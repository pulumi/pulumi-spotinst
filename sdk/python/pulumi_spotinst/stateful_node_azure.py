# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['StatefulNodeAzureArgs', 'StatefulNodeAzure']

@pulumi.input_type
class StatefulNodeAzureArgs:
    def __init__(__self__, *,
                 od_sizes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 os: pulumi.Input[str],
                 region: pulumi.Input[str],
                 resource_group_name: pulumi.Input[str],
                 should_persist_data_disks: pulumi.Input[bool],
                 should_persist_network: pulumi.Input[bool],
                 should_persist_os_disk: pulumi.Input[bool],
                 spot_sizes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 strategy: pulumi.Input['StatefulNodeAzureStrategyArgs'],
                 attach_data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureAttachDataDiskArgs']]]] = None,
                 boot_diagnostics: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureBootDiagnosticArgs']]]] = None,
                 custom_data: Optional[pulumi.Input[str]] = None,
                 data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDataDiskArgs']]]] = None,
                 data_disks_persistence_mode: Optional[pulumi.Input[str]] = None,
                 deletes: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDeleteArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 detach_data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDetachDataDiskArgs']]]] = None,
                 extensions: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureExtensionArgs']]]] = None,
                 health: Optional[pulumi.Input['StatefulNodeAzureHealthArgs']] = None,
                 image: Optional[pulumi.Input['StatefulNodeAzureImageArgs']] = None,
                 import_vms: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImportVmArgs']]]] = None,
                 load_balancers: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureLoadBalancerArgs']]]] = None,
                 login: Optional[pulumi.Input['StatefulNodeAzureLoginArgs']] = None,
                 managed_service_identities: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureManagedServiceIdentityArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input['StatefulNodeAzureNetworkArgs']] = None,
                 os_disk: Optional[pulumi.Input['StatefulNodeAzureOsDiskArgs']] = None,
                 os_disk_persistence_mode: Optional[pulumi.Input[str]] = None,
                 preferred_spot_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preferred_zone: Optional[pulumi.Input[str]] = None,
                 scheduling_tasks: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSchedulingTaskArgs']]]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSecretArgs']]]] = None,
                 security: Optional[pulumi.Input['StatefulNodeAzureSecurityArgs']] = None,
                 should_persist_vm: Optional[pulumi.Input[bool]] = None,
                 shutdown_script: Optional[pulumi.Input[str]] = None,
                 signals: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSignalArgs']]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureTagArgs']]]] = None,
                 update_states: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureUpdateStateArgs']]]] = None,
                 user_data: Optional[pulumi.Input[str]] = None,
                 vm_name: Optional[pulumi.Input[str]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The set of arguments for constructing a StatefulNodeAzure resource.
        """
        StatefulNodeAzureArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            od_sizes=od_sizes,
            os=os,
            region=region,
            resource_group_name=resource_group_name,
            should_persist_data_disks=should_persist_data_disks,
            should_persist_network=should_persist_network,
            should_persist_os_disk=should_persist_os_disk,
            spot_sizes=spot_sizes,
            strategy=strategy,
            attach_data_disks=attach_data_disks,
            boot_diagnostics=boot_diagnostics,
            custom_data=custom_data,
            data_disks=data_disks,
            data_disks_persistence_mode=data_disks_persistence_mode,
            deletes=deletes,
            description=description,
            detach_data_disks=detach_data_disks,
            extensions=extensions,
            health=health,
            image=image,
            import_vms=import_vms,
            load_balancers=load_balancers,
            login=login,
            managed_service_identities=managed_service_identities,
            name=name,
            network=network,
            os_disk=os_disk,
            os_disk_persistence_mode=os_disk_persistence_mode,
            preferred_spot_sizes=preferred_spot_sizes,
            preferred_zone=preferred_zone,
            scheduling_tasks=scheduling_tasks,
            secrets=secrets,
            security=security,
            should_persist_vm=should_persist_vm,
            shutdown_script=shutdown_script,
            signals=signals,
            tags=tags,
            update_states=update_states,
            user_data=user_data,
            vm_name=vm_name,
            zones=zones,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             od_sizes: pulumi.Input[Sequence[pulumi.Input[str]]],
             os: pulumi.Input[str],
             region: pulumi.Input[str],
             resource_group_name: pulumi.Input[str],
             should_persist_data_disks: pulumi.Input[bool],
             should_persist_network: pulumi.Input[bool],
             should_persist_os_disk: pulumi.Input[bool],
             spot_sizes: pulumi.Input[Sequence[pulumi.Input[str]]],
             strategy: pulumi.Input['StatefulNodeAzureStrategyArgs'],
             attach_data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureAttachDataDiskArgs']]]] = None,
             boot_diagnostics: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureBootDiagnosticArgs']]]] = None,
             custom_data: Optional[pulumi.Input[str]] = None,
             data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDataDiskArgs']]]] = None,
             data_disks_persistence_mode: Optional[pulumi.Input[str]] = None,
             deletes: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDeleteArgs']]]] = None,
             description: Optional[pulumi.Input[str]] = None,
             detach_data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDetachDataDiskArgs']]]] = None,
             extensions: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureExtensionArgs']]]] = None,
             health: Optional[pulumi.Input['StatefulNodeAzureHealthArgs']] = None,
             image: Optional[pulumi.Input['StatefulNodeAzureImageArgs']] = None,
             import_vms: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImportVmArgs']]]] = None,
             load_balancers: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureLoadBalancerArgs']]]] = None,
             login: Optional[pulumi.Input['StatefulNodeAzureLoginArgs']] = None,
             managed_service_identities: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureManagedServiceIdentityArgs']]]] = None,
             name: Optional[pulumi.Input[str]] = None,
             network: Optional[pulumi.Input['StatefulNodeAzureNetworkArgs']] = None,
             os_disk: Optional[pulumi.Input['StatefulNodeAzureOsDiskArgs']] = None,
             os_disk_persistence_mode: Optional[pulumi.Input[str]] = None,
             preferred_spot_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             preferred_zone: Optional[pulumi.Input[str]] = None,
             scheduling_tasks: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSchedulingTaskArgs']]]] = None,
             secrets: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSecretArgs']]]] = None,
             security: Optional[pulumi.Input['StatefulNodeAzureSecurityArgs']] = None,
             should_persist_vm: Optional[pulumi.Input[bool]] = None,
             shutdown_script: Optional[pulumi.Input[str]] = None,
             signals: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSignalArgs']]]] = None,
             tags: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureTagArgs']]]] = None,
             update_states: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureUpdateStateArgs']]]] = None,
             user_data: Optional[pulumi.Input[str]] = None,
             vm_name: Optional[pulumi.Input[str]] = None,
             zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("od_sizes", od_sizes)
        _setter("os", os)
        _setter("region", region)
        _setter("resource_group_name", resource_group_name)
        _setter("should_persist_data_disks", should_persist_data_disks)
        _setter("should_persist_network", should_persist_network)
        _setter("should_persist_os_disk", should_persist_os_disk)
        _setter("spot_sizes", spot_sizes)
        _setter("strategy", strategy)
        if attach_data_disks is not None:
            _setter("attach_data_disks", attach_data_disks)
        if boot_diagnostics is not None:
            _setter("boot_diagnostics", boot_diagnostics)
        if custom_data is not None:
            _setter("custom_data", custom_data)
        if data_disks is not None:
            _setter("data_disks", data_disks)
        if data_disks_persistence_mode is not None:
            _setter("data_disks_persistence_mode", data_disks_persistence_mode)
        if deletes is not None:
            _setter("deletes", deletes)
        if description is not None:
            _setter("description", description)
        if detach_data_disks is not None:
            _setter("detach_data_disks", detach_data_disks)
        if extensions is not None:
            _setter("extensions", extensions)
        if health is not None:
            _setter("health", health)
        if image is not None:
            _setter("image", image)
        if import_vms is not None:
            _setter("import_vms", import_vms)
        if load_balancers is not None:
            _setter("load_balancers", load_balancers)
        if login is not None:
            _setter("login", login)
        if managed_service_identities is not None:
            _setter("managed_service_identities", managed_service_identities)
        if name is not None:
            _setter("name", name)
        if network is not None:
            _setter("network", network)
        if os_disk is not None:
            _setter("os_disk", os_disk)
        if os_disk_persistence_mode is not None:
            _setter("os_disk_persistence_mode", os_disk_persistence_mode)
        if preferred_spot_sizes is not None:
            _setter("preferred_spot_sizes", preferred_spot_sizes)
        if preferred_zone is not None:
            _setter("preferred_zone", preferred_zone)
        if scheduling_tasks is not None:
            _setter("scheduling_tasks", scheduling_tasks)
        if secrets is not None:
            _setter("secrets", secrets)
        if security is not None:
            _setter("security", security)
        if should_persist_vm is not None:
            _setter("should_persist_vm", should_persist_vm)
        if shutdown_script is not None:
            _setter("shutdown_script", shutdown_script)
        if signals is not None:
            _setter("signals", signals)
        if tags is not None:
            _setter("tags", tags)
        if update_states is not None:
            _setter("update_states", update_states)
        if user_data is not None:
            _setter("user_data", user_data)
        if vm_name is not None:
            _setter("vm_name", vm_name)
        if zones is not None:
            _setter("zones", zones)

    @property
    @pulumi.getter(name="odSizes")
    def od_sizes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "od_sizes")

    @od_sizes.setter
    def od_sizes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "od_sizes", value)

    @property
    @pulumi.getter
    def os(self) -> pulumi.Input[str]:
        return pulumi.get(self, "os")

    @os.setter
    def os(self, value: pulumi.Input[str]):
        pulumi.set(self, "os", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter(name="shouldPersistDataDisks")
    def should_persist_data_disks(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "should_persist_data_disks")

    @should_persist_data_disks.setter
    def should_persist_data_disks(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_persist_data_disks", value)

    @property
    @pulumi.getter(name="shouldPersistNetwork")
    def should_persist_network(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "should_persist_network")

    @should_persist_network.setter
    def should_persist_network(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_persist_network", value)

    @property
    @pulumi.getter(name="shouldPersistOsDisk")
    def should_persist_os_disk(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "should_persist_os_disk")

    @should_persist_os_disk.setter
    def should_persist_os_disk(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_persist_os_disk", value)

    @property
    @pulumi.getter(name="spotSizes")
    def spot_sizes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "spot_sizes")

    @spot_sizes.setter
    def spot_sizes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "spot_sizes", value)

    @property
    @pulumi.getter
    def strategy(self) -> pulumi.Input['StatefulNodeAzureStrategyArgs']:
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: pulumi.Input['StatefulNodeAzureStrategyArgs']):
        pulumi.set(self, "strategy", value)

    @property
    @pulumi.getter(name="attachDataDisks")
    def attach_data_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureAttachDataDiskArgs']]]]:
        return pulumi.get(self, "attach_data_disks")

    @attach_data_disks.setter
    def attach_data_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureAttachDataDiskArgs']]]]):
        pulumi.set(self, "attach_data_disks", value)

    @property
    @pulumi.getter(name="bootDiagnostics")
    def boot_diagnostics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureBootDiagnosticArgs']]]]:
        return pulumi.get(self, "boot_diagnostics")

    @boot_diagnostics.setter
    def boot_diagnostics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureBootDiagnosticArgs']]]]):
        pulumi.set(self, "boot_diagnostics", value)

    @property
    @pulumi.getter(name="customData")
    def custom_data(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "custom_data")

    @custom_data.setter
    def custom_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_data", value)

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDataDiskArgs']]]]:
        return pulumi.get(self, "data_disks")

    @data_disks.setter
    def data_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDataDiskArgs']]]]):
        pulumi.set(self, "data_disks", value)

    @property
    @pulumi.getter(name="dataDisksPersistenceMode")
    def data_disks_persistence_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "data_disks_persistence_mode")

    @data_disks_persistence_mode.setter
    def data_disks_persistence_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_disks_persistence_mode", value)

    @property
    @pulumi.getter
    def deletes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDeleteArgs']]]]:
        return pulumi.get(self, "deletes")

    @deletes.setter
    def deletes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDeleteArgs']]]]):
        pulumi.set(self, "deletes", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="detachDataDisks")
    def detach_data_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDetachDataDiskArgs']]]]:
        return pulumi.get(self, "detach_data_disks")

    @detach_data_disks.setter
    def detach_data_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDetachDataDiskArgs']]]]):
        pulumi.set(self, "detach_data_disks", value)

    @property
    @pulumi.getter
    def extensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureExtensionArgs']]]]:
        return pulumi.get(self, "extensions")

    @extensions.setter
    def extensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureExtensionArgs']]]]):
        pulumi.set(self, "extensions", value)

    @property
    @pulumi.getter
    def health(self) -> Optional[pulumi.Input['StatefulNodeAzureHealthArgs']]:
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: Optional[pulumi.Input['StatefulNodeAzureHealthArgs']]):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['StatefulNodeAzureImageArgs']]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['StatefulNodeAzureImageArgs']]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="importVms")
    def import_vms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImportVmArgs']]]]:
        return pulumi.get(self, "import_vms")

    @import_vms.setter
    def import_vms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImportVmArgs']]]]):
        pulumi.set(self, "import_vms", value)

    @property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureLoadBalancerArgs']]]]:
        return pulumi.get(self, "load_balancers")

    @load_balancers.setter
    def load_balancers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureLoadBalancerArgs']]]]):
        pulumi.set(self, "load_balancers", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['StatefulNodeAzureLoginArgs']]:
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['StatefulNodeAzureLoginArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter(name="managedServiceIdentities")
    def managed_service_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureManagedServiceIdentityArgs']]]]:
        return pulumi.get(self, "managed_service_identities")

    @managed_service_identities.setter
    def managed_service_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureManagedServiceIdentityArgs']]]]):
        pulumi.set(self, "managed_service_identities", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input['StatefulNodeAzureNetworkArgs']]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input['StatefulNodeAzureNetworkArgs']]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="osDisk")
    def os_disk(self) -> Optional[pulumi.Input['StatefulNodeAzureOsDiskArgs']]:
        return pulumi.get(self, "os_disk")

    @os_disk.setter
    def os_disk(self, value: Optional[pulumi.Input['StatefulNodeAzureOsDiskArgs']]):
        pulumi.set(self, "os_disk", value)

    @property
    @pulumi.getter(name="osDiskPersistenceMode")
    def os_disk_persistence_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "os_disk_persistence_mode")

    @os_disk_persistence_mode.setter
    def os_disk_persistence_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_disk_persistence_mode", value)

    @property
    @pulumi.getter(name="preferredSpotSizes")
    def preferred_spot_sizes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "preferred_spot_sizes")

    @preferred_spot_sizes.setter
    def preferred_spot_sizes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "preferred_spot_sizes", value)

    @property
    @pulumi.getter(name="preferredZone")
    def preferred_zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "preferred_zone")

    @preferred_zone.setter
    def preferred_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preferred_zone", value)

    @property
    @pulumi.getter(name="schedulingTasks")
    def scheduling_tasks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSchedulingTaskArgs']]]]:
        return pulumi.get(self, "scheduling_tasks")

    @scheduling_tasks.setter
    def scheduling_tasks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSchedulingTaskArgs']]]]):
        pulumi.set(self, "scheduling_tasks", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSecretArgs']]]]:
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSecretArgs']]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter
    def security(self) -> Optional[pulumi.Input['StatefulNodeAzureSecurityArgs']]:
        return pulumi.get(self, "security")

    @security.setter
    def security(self, value: Optional[pulumi.Input['StatefulNodeAzureSecurityArgs']]):
        pulumi.set(self, "security", value)

    @property
    @pulumi.getter(name="shouldPersistVm")
    def should_persist_vm(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_persist_vm")

    @should_persist_vm.setter
    def should_persist_vm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_persist_vm", value)

    @property
    @pulumi.getter(name="shutdownScript")
    def shutdown_script(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shutdown_script")

    @shutdown_script.setter
    def shutdown_script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shutdown_script", value)

    @property
    @pulumi.getter
    def signals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSignalArgs']]]]:
        return pulumi.get(self, "signals")

    @signals.setter
    def signals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSignalArgs']]]]):
        pulumi.set(self, "signals", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureTagArgs']]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="updateStates")
    def update_states(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureUpdateStateArgs']]]]:
        return pulumi.get(self, "update_states")

    @update_states.setter
    def update_states(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureUpdateStateArgs']]]]):
        pulumi.set(self, "update_states", value)

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data", value)

    @property
    @pulumi.getter(name="vmName")
    def vm_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vm_name")

    @vm_name.setter
    def vm_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_name", value)

    @property
    @pulumi.getter
    def zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "zones", value)


@pulumi.input_type
class _StatefulNodeAzureState:
    def __init__(__self__, *,
                 attach_data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureAttachDataDiskArgs']]]] = None,
                 boot_diagnostics: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureBootDiagnosticArgs']]]] = None,
                 custom_data: Optional[pulumi.Input[str]] = None,
                 data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDataDiskArgs']]]] = None,
                 data_disks_persistence_mode: Optional[pulumi.Input[str]] = None,
                 deletes: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDeleteArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 detach_data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDetachDataDiskArgs']]]] = None,
                 extensions: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureExtensionArgs']]]] = None,
                 health: Optional[pulumi.Input['StatefulNodeAzureHealthArgs']] = None,
                 image: Optional[pulumi.Input['StatefulNodeAzureImageArgs']] = None,
                 import_vms: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImportVmArgs']]]] = None,
                 load_balancers: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureLoadBalancerArgs']]]] = None,
                 login: Optional[pulumi.Input['StatefulNodeAzureLoginArgs']] = None,
                 managed_service_identities: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureManagedServiceIdentityArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input['StatefulNodeAzureNetworkArgs']] = None,
                 od_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 os: Optional[pulumi.Input[str]] = None,
                 os_disk: Optional[pulumi.Input['StatefulNodeAzureOsDiskArgs']] = None,
                 os_disk_persistence_mode: Optional[pulumi.Input[str]] = None,
                 preferred_spot_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preferred_zone: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 resource_group_name: Optional[pulumi.Input[str]] = None,
                 scheduling_tasks: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSchedulingTaskArgs']]]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSecretArgs']]]] = None,
                 security: Optional[pulumi.Input['StatefulNodeAzureSecurityArgs']] = None,
                 should_persist_data_disks: Optional[pulumi.Input[bool]] = None,
                 should_persist_network: Optional[pulumi.Input[bool]] = None,
                 should_persist_os_disk: Optional[pulumi.Input[bool]] = None,
                 should_persist_vm: Optional[pulumi.Input[bool]] = None,
                 shutdown_script: Optional[pulumi.Input[str]] = None,
                 signals: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSignalArgs']]]] = None,
                 spot_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 strategy: Optional[pulumi.Input['StatefulNodeAzureStrategyArgs']] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureTagArgs']]]] = None,
                 update_states: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureUpdateStateArgs']]]] = None,
                 user_data: Optional[pulumi.Input[str]] = None,
                 vm_name: Optional[pulumi.Input[str]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Input properties used for looking up and filtering StatefulNodeAzure resources.
        """
        _StatefulNodeAzureState._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attach_data_disks=attach_data_disks,
            boot_diagnostics=boot_diagnostics,
            custom_data=custom_data,
            data_disks=data_disks,
            data_disks_persistence_mode=data_disks_persistence_mode,
            deletes=deletes,
            description=description,
            detach_data_disks=detach_data_disks,
            extensions=extensions,
            health=health,
            image=image,
            import_vms=import_vms,
            load_balancers=load_balancers,
            login=login,
            managed_service_identities=managed_service_identities,
            name=name,
            network=network,
            od_sizes=od_sizes,
            os=os,
            os_disk=os_disk,
            os_disk_persistence_mode=os_disk_persistence_mode,
            preferred_spot_sizes=preferred_spot_sizes,
            preferred_zone=preferred_zone,
            region=region,
            resource_group_name=resource_group_name,
            scheduling_tasks=scheduling_tasks,
            secrets=secrets,
            security=security,
            should_persist_data_disks=should_persist_data_disks,
            should_persist_network=should_persist_network,
            should_persist_os_disk=should_persist_os_disk,
            should_persist_vm=should_persist_vm,
            shutdown_script=shutdown_script,
            signals=signals,
            spot_sizes=spot_sizes,
            strategy=strategy,
            tags=tags,
            update_states=update_states,
            user_data=user_data,
            vm_name=vm_name,
            zones=zones,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attach_data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureAttachDataDiskArgs']]]] = None,
             boot_diagnostics: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureBootDiagnosticArgs']]]] = None,
             custom_data: Optional[pulumi.Input[str]] = None,
             data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDataDiskArgs']]]] = None,
             data_disks_persistence_mode: Optional[pulumi.Input[str]] = None,
             deletes: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDeleteArgs']]]] = None,
             description: Optional[pulumi.Input[str]] = None,
             detach_data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDetachDataDiskArgs']]]] = None,
             extensions: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureExtensionArgs']]]] = None,
             health: Optional[pulumi.Input['StatefulNodeAzureHealthArgs']] = None,
             image: Optional[pulumi.Input['StatefulNodeAzureImageArgs']] = None,
             import_vms: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImportVmArgs']]]] = None,
             load_balancers: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureLoadBalancerArgs']]]] = None,
             login: Optional[pulumi.Input['StatefulNodeAzureLoginArgs']] = None,
             managed_service_identities: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureManagedServiceIdentityArgs']]]] = None,
             name: Optional[pulumi.Input[str]] = None,
             network: Optional[pulumi.Input['StatefulNodeAzureNetworkArgs']] = None,
             od_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             os: Optional[pulumi.Input[str]] = None,
             os_disk: Optional[pulumi.Input['StatefulNodeAzureOsDiskArgs']] = None,
             os_disk_persistence_mode: Optional[pulumi.Input[str]] = None,
             preferred_spot_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             preferred_zone: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             resource_group_name: Optional[pulumi.Input[str]] = None,
             scheduling_tasks: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSchedulingTaskArgs']]]] = None,
             secrets: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSecretArgs']]]] = None,
             security: Optional[pulumi.Input['StatefulNodeAzureSecurityArgs']] = None,
             should_persist_data_disks: Optional[pulumi.Input[bool]] = None,
             should_persist_network: Optional[pulumi.Input[bool]] = None,
             should_persist_os_disk: Optional[pulumi.Input[bool]] = None,
             should_persist_vm: Optional[pulumi.Input[bool]] = None,
             shutdown_script: Optional[pulumi.Input[str]] = None,
             signals: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSignalArgs']]]] = None,
             spot_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             strategy: Optional[pulumi.Input['StatefulNodeAzureStrategyArgs']] = None,
             tags: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureTagArgs']]]] = None,
             update_states: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureUpdateStateArgs']]]] = None,
             user_data: Optional[pulumi.Input[str]] = None,
             vm_name: Optional[pulumi.Input[str]] = None,
             zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attach_data_disks is not None:
            _setter("attach_data_disks", attach_data_disks)
        if boot_diagnostics is not None:
            _setter("boot_diagnostics", boot_diagnostics)
        if custom_data is not None:
            _setter("custom_data", custom_data)
        if data_disks is not None:
            _setter("data_disks", data_disks)
        if data_disks_persistence_mode is not None:
            _setter("data_disks_persistence_mode", data_disks_persistence_mode)
        if deletes is not None:
            _setter("deletes", deletes)
        if description is not None:
            _setter("description", description)
        if detach_data_disks is not None:
            _setter("detach_data_disks", detach_data_disks)
        if extensions is not None:
            _setter("extensions", extensions)
        if health is not None:
            _setter("health", health)
        if image is not None:
            _setter("image", image)
        if import_vms is not None:
            _setter("import_vms", import_vms)
        if load_balancers is not None:
            _setter("load_balancers", load_balancers)
        if login is not None:
            _setter("login", login)
        if managed_service_identities is not None:
            _setter("managed_service_identities", managed_service_identities)
        if name is not None:
            _setter("name", name)
        if network is not None:
            _setter("network", network)
        if od_sizes is not None:
            _setter("od_sizes", od_sizes)
        if os is not None:
            _setter("os", os)
        if os_disk is not None:
            _setter("os_disk", os_disk)
        if os_disk_persistence_mode is not None:
            _setter("os_disk_persistence_mode", os_disk_persistence_mode)
        if preferred_spot_sizes is not None:
            _setter("preferred_spot_sizes", preferred_spot_sizes)
        if preferred_zone is not None:
            _setter("preferred_zone", preferred_zone)
        if region is not None:
            _setter("region", region)
        if resource_group_name is not None:
            _setter("resource_group_name", resource_group_name)
        if scheduling_tasks is not None:
            _setter("scheduling_tasks", scheduling_tasks)
        if secrets is not None:
            _setter("secrets", secrets)
        if security is not None:
            _setter("security", security)
        if should_persist_data_disks is not None:
            _setter("should_persist_data_disks", should_persist_data_disks)
        if should_persist_network is not None:
            _setter("should_persist_network", should_persist_network)
        if should_persist_os_disk is not None:
            _setter("should_persist_os_disk", should_persist_os_disk)
        if should_persist_vm is not None:
            _setter("should_persist_vm", should_persist_vm)
        if shutdown_script is not None:
            _setter("shutdown_script", shutdown_script)
        if signals is not None:
            _setter("signals", signals)
        if spot_sizes is not None:
            _setter("spot_sizes", spot_sizes)
        if strategy is not None:
            _setter("strategy", strategy)
        if tags is not None:
            _setter("tags", tags)
        if update_states is not None:
            _setter("update_states", update_states)
        if user_data is not None:
            _setter("user_data", user_data)
        if vm_name is not None:
            _setter("vm_name", vm_name)
        if zones is not None:
            _setter("zones", zones)

    @property
    @pulumi.getter(name="attachDataDisks")
    def attach_data_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureAttachDataDiskArgs']]]]:
        return pulumi.get(self, "attach_data_disks")

    @attach_data_disks.setter
    def attach_data_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureAttachDataDiskArgs']]]]):
        pulumi.set(self, "attach_data_disks", value)

    @property
    @pulumi.getter(name="bootDiagnostics")
    def boot_diagnostics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureBootDiagnosticArgs']]]]:
        return pulumi.get(self, "boot_diagnostics")

    @boot_diagnostics.setter
    def boot_diagnostics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureBootDiagnosticArgs']]]]):
        pulumi.set(self, "boot_diagnostics", value)

    @property
    @pulumi.getter(name="customData")
    def custom_data(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "custom_data")

    @custom_data.setter
    def custom_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_data", value)

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDataDiskArgs']]]]:
        return pulumi.get(self, "data_disks")

    @data_disks.setter
    def data_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDataDiskArgs']]]]):
        pulumi.set(self, "data_disks", value)

    @property
    @pulumi.getter(name="dataDisksPersistenceMode")
    def data_disks_persistence_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "data_disks_persistence_mode")

    @data_disks_persistence_mode.setter
    def data_disks_persistence_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_disks_persistence_mode", value)

    @property
    @pulumi.getter
    def deletes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDeleteArgs']]]]:
        return pulumi.get(self, "deletes")

    @deletes.setter
    def deletes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDeleteArgs']]]]):
        pulumi.set(self, "deletes", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="detachDataDisks")
    def detach_data_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDetachDataDiskArgs']]]]:
        return pulumi.get(self, "detach_data_disks")

    @detach_data_disks.setter
    def detach_data_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureDetachDataDiskArgs']]]]):
        pulumi.set(self, "detach_data_disks", value)

    @property
    @pulumi.getter
    def extensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureExtensionArgs']]]]:
        return pulumi.get(self, "extensions")

    @extensions.setter
    def extensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureExtensionArgs']]]]):
        pulumi.set(self, "extensions", value)

    @property
    @pulumi.getter
    def health(self) -> Optional[pulumi.Input['StatefulNodeAzureHealthArgs']]:
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: Optional[pulumi.Input['StatefulNodeAzureHealthArgs']]):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['StatefulNodeAzureImageArgs']]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['StatefulNodeAzureImageArgs']]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="importVms")
    def import_vms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImportVmArgs']]]]:
        return pulumi.get(self, "import_vms")

    @import_vms.setter
    def import_vms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureImportVmArgs']]]]):
        pulumi.set(self, "import_vms", value)

    @property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureLoadBalancerArgs']]]]:
        return pulumi.get(self, "load_balancers")

    @load_balancers.setter
    def load_balancers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureLoadBalancerArgs']]]]):
        pulumi.set(self, "load_balancers", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['StatefulNodeAzureLoginArgs']]:
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['StatefulNodeAzureLoginArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter(name="managedServiceIdentities")
    def managed_service_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureManagedServiceIdentityArgs']]]]:
        return pulumi.get(self, "managed_service_identities")

    @managed_service_identities.setter
    def managed_service_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureManagedServiceIdentityArgs']]]]):
        pulumi.set(self, "managed_service_identities", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input['StatefulNodeAzureNetworkArgs']]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input['StatefulNodeAzureNetworkArgs']]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="odSizes")
    def od_sizes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "od_sizes")

    @od_sizes.setter
    def od_sizes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "od_sizes", value)

    @property
    @pulumi.getter
    def os(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "os")

    @os.setter
    def os(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os", value)

    @property
    @pulumi.getter(name="osDisk")
    def os_disk(self) -> Optional[pulumi.Input['StatefulNodeAzureOsDiskArgs']]:
        return pulumi.get(self, "os_disk")

    @os_disk.setter
    def os_disk(self, value: Optional[pulumi.Input['StatefulNodeAzureOsDiskArgs']]):
        pulumi.set(self, "os_disk", value)

    @property
    @pulumi.getter(name="osDiskPersistenceMode")
    def os_disk_persistence_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "os_disk_persistence_mode")

    @os_disk_persistence_mode.setter
    def os_disk_persistence_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_disk_persistence_mode", value)

    @property
    @pulumi.getter(name="preferredSpotSizes")
    def preferred_spot_sizes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "preferred_spot_sizes")

    @preferred_spot_sizes.setter
    def preferred_spot_sizes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "preferred_spot_sizes", value)

    @property
    @pulumi.getter(name="preferredZone")
    def preferred_zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "preferred_zone")

    @preferred_zone.setter
    def preferred_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preferred_zone", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter(name="schedulingTasks")
    def scheduling_tasks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSchedulingTaskArgs']]]]:
        return pulumi.get(self, "scheduling_tasks")

    @scheduling_tasks.setter
    def scheduling_tasks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSchedulingTaskArgs']]]]):
        pulumi.set(self, "scheduling_tasks", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSecretArgs']]]]:
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSecretArgs']]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter
    def security(self) -> Optional[pulumi.Input['StatefulNodeAzureSecurityArgs']]:
        return pulumi.get(self, "security")

    @security.setter
    def security(self, value: Optional[pulumi.Input['StatefulNodeAzureSecurityArgs']]):
        pulumi.set(self, "security", value)

    @property
    @pulumi.getter(name="shouldPersistDataDisks")
    def should_persist_data_disks(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_persist_data_disks")

    @should_persist_data_disks.setter
    def should_persist_data_disks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_persist_data_disks", value)

    @property
    @pulumi.getter(name="shouldPersistNetwork")
    def should_persist_network(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_persist_network")

    @should_persist_network.setter
    def should_persist_network(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_persist_network", value)

    @property
    @pulumi.getter(name="shouldPersistOsDisk")
    def should_persist_os_disk(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_persist_os_disk")

    @should_persist_os_disk.setter
    def should_persist_os_disk(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_persist_os_disk", value)

    @property
    @pulumi.getter(name="shouldPersistVm")
    def should_persist_vm(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_persist_vm")

    @should_persist_vm.setter
    def should_persist_vm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_persist_vm", value)

    @property
    @pulumi.getter(name="shutdownScript")
    def shutdown_script(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shutdown_script")

    @shutdown_script.setter
    def shutdown_script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shutdown_script", value)

    @property
    @pulumi.getter
    def signals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSignalArgs']]]]:
        return pulumi.get(self, "signals")

    @signals.setter
    def signals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureSignalArgs']]]]):
        pulumi.set(self, "signals", value)

    @property
    @pulumi.getter(name="spotSizes")
    def spot_sizes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "spot_sizes")

    @spot_sizes.setter
    def spot_sizes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "spot_sizes", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input['StatefulNodeAzureStrategyArgs']]:
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input['StatefulNodeAzureStrategyArgs']]):
        pulumi.set(self, "strategy", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureTagArgs']]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="updateStates")
    def update_states(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureUpdateStateArgs']]]]:
        return pulumi.get(self, "update_states")

    @update_states.setter
    def update_states(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatefulNodeAzureUpdateStateArgs']]]]):
        pulumi.set(self, "update_states", value)

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data", value)

    @property
    @pulumi.getter(name="vmName")
    def vm_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vm_name")

    @vm_name.setter
    def vm_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_name", value)

    @property
    @pulumi.getter
    def zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "zones", value)


class StatefulNodeAzure(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 attach_data_disks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureAttachDataDiskArgs']]]]] = None,
                 boot_diagnostics: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureBootDiagnosticArgs']]]]] = None,
                 custom_data: Optional[pulumi.Input[str]] = None,
                 data_disks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureDataDiskArgs']]]]] = None,
                 data_disks_persistence_mode: Optional[pulumi.Input[str]] = None,
                 deletes: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureDeleteArgs']]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 detach_data_disks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureDetachDataDiskArgs']]]]] = None,
                 extensions: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureExtensionArgs']]]]] = None,
                 health: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureHealthArgs']]] = None,
                 image: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureImageArgs']]] = None,
                 import_vms: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureImportVmArgs']]]]] = None,
                 load_balancers: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureLoadBalancerArgs']]]]] = None,
                 login: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureLoginArgs']]] = None,
                 managed_service_identities: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureManagedServiceIdentityArgs']]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureNetworkArgs']]] = None,
                 od_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 os: Optional[pulumi.Input[str]] = None,
                 os_disk: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureOsDiskArgs']]] = None,
                 os_disk_persistence_mode: Optional[pulumi.Input[str]] = None,
                 preferred_spot_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preferred_zone: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 resource_group_name: Optional[pulumi.Input[str]] = None,
                 scheduling_tasks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureSchedulingTaskArgs']]]]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureSecretArgs']]]]] = None,
                 security: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureSecurityArgs']]] = None,
                 should_persist_data_disks: Optional[pulumi.Input[bool]] = None,
                 should_persist_network: Optional[pulumi.Input[bool]] = None,
                 should_persist_os_disk: Optional[pulumi.Input[bool]] = None,
                 should_persist_vm: Optional[pulumi.Input[bool]] = None,
                 shutdown_script: Optional[pulumi.Input[str]] = None,
                 signals: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureSignalArgs']]]]] = None,
                 spot_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 strategy: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureStrategyArgs']]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureTagArgs']]]]] = None,
                 update_states: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureUpdateStateArgs']]]]] = None,
                 user_data: Optional[pulumi.Input[str]] = None,
                 vm_name: Optional[pulumi.Input[str]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 __props__=None):
        """
        Provides a Spotinst stateful node Azure resource.

        ## Strategy

        * `strategy` - (Required) Strategy for stateful node.
          * `draining_timeout` - (Optional, Default `120`) Time (in seconds) to allow the VM be drained from incoming TCP connections and detached from MLB before terminating it during a scale down operation.
          * `fallback_to_on_demand` - (Required) In case of no spots available, Stateful Node will launch an On-demand instance instead.
          * `optimization_windows` - (Optional) Valid format: "ddd:hh:mm-ddd:hh:mm (day:hour(0-23):minute(0-59))", not empty if revertToSpot.performAt = timeWindow.
          * `preferred_life_cycle` - (Optional, Enum `"od", "spot"`, Default `"spot"`) The desired type of VM.
          * `revert_to_spot` - (Optional) Hold settings for strategy correction - replacing On-Demand for Spot VMs.
            * `perform_at` - (Required, Enum `"timeWindow", "never", "always"`, Default `"always"`) Settings for maintenance strategy.
          * `capacity_reservation` - (Optional) On-demand Capacity Reservation group enables you to reserve Compute capacity in an Azure region or an Availability Zone for any duration of time. [CRG can only be created on the Azure end.](https://learn.microsoft.com/en-us/azure/virtual-machines/capacity-reservation-create)
            * `should_utilize` - (Required) Determines whether capacity reservations should be utilized.
            * `utilization_strategy` - (Required, Enum `"utilizeOverSpot", "utilizeOverOD"`) The priority requested for using CRG. This value will determine if CRG is used ahead of spot VMs or On-demand VMs. (`"utilizeOverOD"`- If picked, we will use CRG only in case On demand should be launched. `"utilizeOverSpot"`- CRG will be preferred over Spot. Only after CRG is fully used, spot VMs can be used.)
            * `capacity_reservation_groups` - (Optional) List of the desired CRGs to use under the associated Azure subscription. When null we will utilize any available reservation that matches the launch specification.
              * `crg_name` - (Required) The name of the CRG.
              * `crg_resource_group_name` - (Required) Azure resource group name
              * `crg_should_prioritize` - The desired CRG to utilize ahead of other CRGs in the subscription.

        <a id="compute"></a>
        ## Compute

        * `os` - (Required, Enum `"Linux", "Windows"`) Type of operating system.
        * `od_sizes` - (Required) Available On-Demand sizes.
        * `spot_sizes` - (Required) Available Spot-VM sizes.
        * `preferred_spot_sizes` - (Optional) Prioritize Spot VM sizes when launching Spot VMs for the group. If set, must be a sublist of compute.vmSizes.spotSizes.
        * `zones` - (Optional, Enum `"1", "2", "3"`) List of Azure Availability Zones in the defined region. If not defined, Virtual machines will be launched regionally.
        * `preferred_zone` - (Optional, Enum `"1", "2", "3"`) The AZ to prioritize when launching VMs. If no markets are available in the Preferred AZ, VMs are launched in the non-preferred AZ. Must be a sublist of compute.zones.
        * `custom_data` - (Optional) This value will hold the YAML in base64 and will be executed upon VM launch.
        * `shutdown_script` - (Optional) Shutdown script for the stateful node. Value should be passed as a string encoded at Base64 only.
        * `user_data` - (Optional) Define a set of scripts or other metadata that's inserted to an Azure virtual machine at provision time. (Base64 encoded)
        * `vm_name` - (Optional) Set a VM name that will be persisted throughout the entire node lifecycle.

        <a id="boot_diagnostics"></a>
        ## Boot Diagnostics

        * `boot_diagnostics`
          * `is_enabled` - (Optional) Allows you to enable and disable the configuration of boot diagnostics at launch.
          * `storage_url` - (Optional) The storage URI that is used if a type is unmanaged. The storage URI must follow the blob storage URI format ("https://.blob.core.windows.net/"). StorageUri is required if the type is unmanaged. StorageUri must be null in case the boot diagnostics type is managed.
          * `type` - (Optional, Enum `"managed", "unmanaged"`) Defines the storage type on VM launch in Azure.

        <a id="data_disks"></a>
        ## Data Disks

        * `data_disk` - (Optional) The definitions of data disks that will be created and attached to the stateful node's VM.
          * `size_gb` - (Required) The size of the data disk in GB, required if dataDisks is specified.
          * `lun` - (Required) The LUN of the data disk.
          * `type` - (Required, Enum `"Standard_LRS", "Premium_LRS", "StandardSSD_LRS", "UltraSSD_LRS"`) The type of the data disk.

        <a id="extensions"></a>
        ## Extensions

        * `extension` - (Optional) An object for an azure extension.
          * `name` - (Required) Required on compute.launchSpecification.extensions object.
          * `type` - (Required) Required on compute.launchSpecification.extensions object.
          * `publisher` - (Required) Required on compute.launchSpecification.extensions object.
          * `api_version` - (Required) The API version of the extension. Required if extension specified.
          * `minor_version_auto_upgrade` - (Required) Required on compute.launchSpecification.extensions object.
          * `protected_settings` - (Optional) Object for protected settings.
          * `public_settings` - (Optional) Object for public settings.

        <a id="image"></a>
        ## Image

        * `image`
          * `marketplace_image` - (Optional) Select an image from Azure's Marketplace image catalogue. Required if the custom image or gallery image are not specified.
            * `publisher` - (Required) Image publisher.
            * `offer` - (Required) Image offer.
            * `sku` - (Required) Image Stock Keeping Unit, which is the specific version of the image.
            * `version` - (Required, Default `"latest"`) Image's version. if version not provided we use "latest".
          * `gallery_image` - (Optional) Gallery image definitions. Required if custom image or marketplace image are not specified.
            * `gallery_resource_group_name` - (Required) The resource group name for gallery image.
            * `gallery_name` - (Required) Name of the gallery.
            * `image_name` - (Required) Name of the gallery image.
            * `version_name` - (Required) Image's version. Can be in the format x.x.x or 'latest'.
          * `custom_image` - (Optional) Custom image definitions. Required if marketplace image or gallery image are not specified.
            * `custom_image_resource_group_name` - (Required) The resource group name for custom image.
            * `name` - (Required) The name of the custom image.

        <a id="load balancer"></a>
        ## Load Balancer

        * `load_balancer` - (Optional) Add a load balancer. For Azure Gateway, each Backend Pool is a separate load balancer.
          * `type` - (Required, Enum `"loadBalancer", "applicationGateway"`) The type of load balancer.
          * `resource_group_name` - (Required) The Resource Group name of the Load Balancer.
          * `name` - (Required) Name of the Application Gateway/Load Balancer.
          * `sku` - (Optional)
            * if type is `"LoadBalancer"` then possible values are `Standard", "Basic`.
            * If ApplicationGateway then possible values are
              `Standard_Large, Standard_Medium, Standard_Small, Standard_v2", WAF_Large, WAF_Medium", WAF_v2"`.
          * `backend_pool_names` - (Optional) Name of the Backend Pool to register the Stateful Node VMs to. Each Backend Pool is a separate load balancer. Required if Type is APPLICATION_GATEWAY.

        <a id="login"></a>
        ## Login

        * `login` - (Required) Set admin access for accessing your VMs. Password/SSH is required for Linux.
          * `user_name` - (Required) username for admin access to VMs.
          * `ssh_public_key` - (Optional) SSH for admin access to Linux VMs. Optional for Linux.
          * `password` - (Optional) Password for admin access to Windows VMs. Required for Windows.

        <a id="managed_service_identities"></a>
        ## Managed Service Identities

        * `managed_service_identities` - (Optional) Add a user-assigned managed identity to the Stateful Node's VM.
          * `name` - (Required) name of the managed identity.
          * `resource_group_name` - (Required) The Resource Group that the user-assigned managed identity resides in.

        <a id="network"></a>
        ## Network

        * `network` - (Required) Define the Virtual Network and Subnet for your Stateful Node.
          * `network_resource_group_name` - (Required) Vnet Resource Group Name.
          * `virtual_network_name` - (Required) Virtual Network.
          * `network_interface` - (Required) Define a network interface
            * `is_primary` - (Required) Defines whether the network interface is primary or not.
            * `subnet_name` - (Required) Subnet name.
            * `assign_public_ip` - (Optional) Assign public IP.
            * `public_ip_sku` - (Optional) Required if assignPublicIp=true values=[Standard/Basic].
            * `network_security_group` - (Optional) Network Security Group.
              * `network_resource_group_name` - (Required) Requires valid security group name.
              * `name` - (Required) Requires valid resource group name.
            * `enable_ip_forwarding` - (Optional) Enable IP Forwarding.
            * `private_ip_addresses` - (Optional) A list with unique items that every item is a valid IP.
            * `additional_ip_configurations` - (Optional) Additional configuration of network interface.
              * `name` - (Required) Configuration name.
              * `private_ip_address_version` - (Required, Enum `"IPv4", "IPv6"` Default `"IPv4"`) Version of the private IP address.
            * `public_ips` - (Optional) Defined a pool of Public Ips (from Azure), that will be associated to the network interface. We will associate one public ip per instance until the pool is exhausted, in which case, we will create a new one.
              * `resource_group_name` - (Required) The resource group of the public ip.
              * `name` - (Required) - The name of the public ip.
            * `application_security_groups` - (Optional) Network Security Group.
              * `resource_group_name` - (Required) Requires valid security group name.
              * `name` - (Required) Requires valid resource group name.

        <a id="os_disk"></a>
        ## OS Disk

        * `os_disk` - (Optional) Specify OS disk specification other than default.
          * `size_gb` - (Optional, Default `"30"`) The size of the data disk in GB.
          * `type` - (Required, Enum `"Standard_LRS", "Premium_LRS", "StandardSSD_LRS"`) The type of the OS disk.

        <a id="secret"></a>
        ## Secret

        * `secret` - (Optional) Set of certificates that should be installed on the VM.
          * `source_vault` - (Required) The key vault reference, contains the required certificates.
            * `name` - (Required) The name of the key vault.
            * `resource_group_name` - (Required) The resource group name of the key vault.
          * `vault_certificates` - (Required) The required certificate references.
            * `certificate_url` - (Optional) The URL of the certificate under the key vault.
            * `certificate_store` - (Required) The certificate store directory the VM. The directory is created in the LocalMachine account.
              * This field is required only when using Windows OS type
              * This field must be null when the OS type is Linux

        <a id="secutiry"></a>
        ## Security

        * `security` - (Optional) Specifies the Security related profile settings for the virtual machine.
            * `secure_boot_enabled` - (Optional) Specifies whether secure boot should be enabled on the virtual machine.
            * `security_type` - (Optional) Enum: `"Standard", "TrustedLaunch"` Security type refers to the different security features of a virtual machine. Security features like Trusted launch virtual machines help to improve the security of Azure generation 2 virtual machines.
            * `vtpm_enabled` - (Optional) Specifies whether vTPM should be enabled on the virtual machine.

        <a id="tag"></a>
        ## Tag

        * `tag` - (Optional) Unique Key-Value pair for all Stateful Node Resources.
          * `tag_key` - (Optional) Tag Key for Stateful Node Resources.
          * `tag_value` - (Optional) Tag Value for Stateful Node Resources.

        <a id="health"></a>
        ## Health

        * `health` - (Optional) Set the auto healing preferences for unhealthy VMs.
          * `health_check_types` - (Optional, Enum `"vmState", "applicationGateway"`) Healthcheck to use to validate VM health.
          * `unhealthy_duration` - (Optional) Amount of time to be unhealthy before a replacement is triggered.
          * `auto_healing` - (Required) Enable Autohealing of unhealthy VMs.
          * `grace_period` - (Optional) Period of time to wait for VM to reach healthiness before monitoring for unhealthiness.

        <a id="persistence"></a>
        ## Persistence

        * `should_persist_os_disk` - (Required) Should persist os disk.
        * `os_disk_persistence_mode` - (Optional, Enum `"reattach", "onLaunch"`)
        * `should_persist_data_disks` - (Required) Should persist data disks.
        * `data_disks_persistence_mode` - (Optional, Enum `"reattach", "onLaunch"`)
        * `should_persist_network` - (Required) Should persist network.

        <a id="scheduling_tasks"></a>
        ## Scheduling Tasks

        * `scheduling_task` - (Optional) Scheduling settings object for stateful node.
          * `is_enabled` - (Required) Is scheduled task enabled for stateful node.
          * `type` - (Required, Enum `"pause", "resume", "recycle") The type of the scheduled task
          * `cron_expression` (Required) A expression which describes when to execute the scheduled task (UTC).

        <a id="signals"></a>
        ## Signals

        * `signal` - (Optional) A signal object defined for the stateful node.
          * `type` - (Required, Enum `"vmReady", "vmReadyToShutdown"`) The type of the signal defined for the stateful node.
          * `timeout` - (Required, Default `"1800"`) The timeout in seconds to hold the vm until a signal is sent. If no signal is sent the vm will be replaced (vmReady) or we will terminate the vm (vmReadyToShutdown) after the timeout.

        ***

        <a id="attach_data_disk"></a>
        ## Attach Data Disk

        * `attach_data_disk` - (Optional) Create a new data disk and attach it to the stateful node.
          * `data_disk_name` - (Required) The name of the created data disk.
          * `data_disk_resource_group_name` - (Required) The resource group name in which the data disk will be created.
          * `storage_account_type` - (Required, Enum `"Standard_LRS", "Premium_LRS", "StandardSSD_LRS", "UltraSSD_LRS"`) The type of the data disk.
          * `size_gb` - (Required) The size of the data disk in GB, Required if dataDisks is specified.
          * `zone` - (Optional, Enum `"1", "2", "3"`) The Availability Zone in which the data disk will be created. If not defined, the data disk will be created regionally.
          * `lun` - (Optional, Default `"orginal"`) The LUN of the data disk. If not defined, the LUN will be set in order.

        <a id="detach_data_disk"></a>
        ## Detach Data Disk

        * `detach_data_disk` - (Optional) Detach a data disk from a stateful node.
          * `data_disk_name` - (Required) The name of the detached data disk.
          * `data_disk_resource_group_name` - (Required) The resource group name in which the data disk exists.
          * `should_deallocate` - (Required) Indicates whether to delete the data disk in addition to detach.
          * `ttl_in_hours` - (Required, Default `"0"`) Hours to keep the disk alive before deletion.

        <a id="update_state"></a>
        ## Update State

        * `update_state` - (Optional) Update the stateful node state.
          * `state` - (Required, Enum `"pause", "resume", "recycle"`) New state for the stateful node.

        <a id="import_vm"></a>
        ## Import VM

        * `import_vm` - (Optional) Import an Azure VM and create a stateful node by providing a node configuration.
          * `resource_group_name` - (Required) Name of the Resource Group for Stateful Node.
          * `original_vm_name` - (Required) Azure Import Stateful Node Name.
          * `draining_timeout` - (Optional) Hours to keep resources alive.
          * `resources_retention_time` - (Optional) Hours to keep resources alive.

        <a id="delete"></a>
        ## Deallocation Config

        * `delete` - (Required) Specify deallocation parameters for stateful node deletion.
            * `should_terminate_vm` - (Required) Indicates whether to delete the stateful node's VM.
            * `network_should_deallocate` - (Required) Indicates whether to delete the stateful node's network resources.
            * `network_ttl_in_hours` - (Optional, Default: 96) Hours to keep the network resource alive before deletion.
            * `disk_should_deallocate` - (Required) Indicates whether to delete the stateful node's disk resources.
            * `disk_ttl_in_hours` - (Optional, Default: 96) Hours to keep the disk resource alive before deletion.
            * `snapshot_should_deallocate` - (Required) Indicates whether to delete the stateful node's snapshot resources.
            * `snapshot_ttl_in_hours` - (Optional, Default: 96) Hours to keep the snapshots alive before deletion.
            * `public_ip_should_deallocate` - (Required) Indicates whether to delete the stateful node's public ip resources.
            * `public_ip_ttl_in_hours` - (Optional, Default: 96) Hours to keep the public ip alive before deletion.

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: StatefulNodeAzureArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Provides a Spotinst stateful node Azure resource.

        ## Strategy

        * `strategy` - (Required) Strategy for stateful node.
          * `draining_timeout` - (Optional, Default `120`) Time (in seconds) to allow the VM be drained from incoming TCP connections and detached from MLB before terminating it during a scale down operation.
          * `fallback_to_on_demand` - (Required) In case of no spots available, Stateful Node will launch an On-demand instance instead.
          * `optimization_windows` - (Optional) Valid format: "ddd:hh:mm-ddd:hh:mm (day:hour(0-23):minute(0-59))", not empty if revertToSpot.performAt = timeWindow.
          * `preferred_life_cycle` - (Optional, Enum `"od", "spot"`, Default `"spot"`) The desired type of VM.
          * `revert_to_spot` - (Optional) Hold settings for strategy correction - replacing On-Demand for Spot VMs.
            * `perform_at` - (Required, Enum `"timeWindow", "never", "always"`, Default `"always"`) Settings for maintenance strategy.
          * `capacity_reservation` - (Optional) On-demand Capacity Reservation group enables you to reserve Compute capacity in an Azure region or an Availability Zone for any duration of time. [CRG can only be created on the Azure end.](https://learn.microsoft.com/en-us/azure/virtual-machines/capacity-reservation-create)
            * `should_utilize` - (Required) Determines whether capacity reservations should be utilized.
            * `utilization_strategy` - (Required, Enum `"utilizeOverSpot", "utilizeOverOD"`) The priority requested for using CRG. This value will determine if CRG is used ahead of spot VMs or On-demand VMs. (`"utilizeOverOD"`- If picked, we will use CRG only in case On demand should be launched. `"utilizeOverSpot"`- CRG will be preferred over Spot. Only after CRG is fully used, spot VMs can be used.)
            * `capacity_reservation_groups` - (Optional) List of the desired CRGs to use under the associated Azure subscription. When null we will utilize any available reservation that matches the launch specification.
              * `crg_name` - (Required) The name of the CRG.
              * `crg_resource_group_name` - (Required) Azure resource group name
              * `crg_should_prioritize` - The desired CRG to utilize ahead of other CRGs in the subscription.

        <a id="compute"></a>
        ## Compute

        * `os` - (Required, Enum `"Linux", "Windows"`) Type of operating system.
        * `od_sizes` - (Required) Available On-Demand sizes.
        * `spot_sizes` - (Required) Available Spot-VM sizes.
        * `preferred_spot_sizes` - (Optional) Prioritize Spot VM sizes when launching Spot VMs for the group. If set, must be a sublist of compute.vmSizes.spotSizes.
        * `zones` - (Optional, Enum `"1", "2", "3"`) List of Azure Availability Zones in the defined region. If not defined, Virtual machines will be launched regionally.
        * `preferred_zone` - (Optional, Enum `"1", "2", "3"`) The AZ to prioritize when launching VMs. If no markets are available in the Preferred AZ, VMs are launched in the non-preferred AZ. Must be a sublist of compute.zones.
        * `custom_data` - (Optional) This value will hold the YAML in base64 and will be executed upon VM launch.
        * `shutdown_script` - (Optional) Shutdown script for the stateful node. Value should be passed as a string encoded at Base64 only.
        * `user_data` - (Optional) Define a set of scripts or other metadata that's inserted to an Azure virtual machine at provision time. (Base64 encoded)
        * `vm_name` - (Optional) Set a VM name that will be persisted throughout the entire node lifecycle.

        <a id="boot_diagnostics"></a>
        ## Boot Diagnostics

        * `boot_diagnostics`
          * `is_enabled` - (Optional) Allows you to enable and disable the configuration of boot diagnostics at launch.
          * `storage_url` - (Optional) The storage URI that is used if a type is unmanaged. The storage URI must follow the blob storage URI format ("https://.blob.core.windows.net/"). StorageUri is required if the type is unmanaged. StorageUri must be null in case the boot diagnostics type is managed.
          * `type` - (Optional, Enum `"managed", "unmanaged"`) Defines the storage type on VM launch in Azure.

        <a id="data_disks"></a>
        ## Data Disks

        * `data_disk` - (Optional) The definitions of data disks that will be created and attached to the stateful node's VM.
          * `size_gb` - (Required) The size of the data disk in GB, required if dataDisks is specified.
          * `lun` - (Required) The LUN of the data disk.
          * `type` - (Required, Enum `"Standard_LRS", "Premium_LRS", "StandardSSD_LRS", "UltraSSD_LRS"`) The type of the data disk.

        <a id="extensions"></a>
        ## Extensions

        * `extension` - (Optional) An object for an azure extension.
          * `name` - (Required) Required on compute.launchSpecification.extensions object.
          * `type` - (Required) Required on compute.launchSpecification.extensions object.
          * `publisher` - (Required) Required on compute.launchSpecification.extensions object.
          * `api_version` - (Required) The API version of the extension. Required if extension specified.
          * `minor_version_auto_upgrade` - (Required) Required on compute.launchSpecification.extensions object.
          * `protected_settings` - (Optional) Object for protected settings.
          * `public_settings` - (Optional) Object for public settings.

        <a id="image"></a>
        ## Image

        * `image`
          * `marketplace_image` - (Optional) Select an image from Azure's Marketplace image catalogue. Required if the custom image or gallery image are not specified.
            * `publisher` - (Required) Image publisher.
            * `offer` - (Required) Image offer.
            * `sku` - (Required) Image Stock Keeping Unit, which is the specific version of the image.
            * `version` - (Required, Default `"latest"`) Image's version. if version not provided we use "latest".
          * `gallery_image` - (Optional) Gallery image definitions. Required if custom image or marketplace image are not specified.
            * `gallery_resource_group_name` - (Required) The resource group name for gallery image.
            * `gallery_name` - (Required) Name of the gallery.
            * `image_name` - (Required) Name of the gallery image.
            * `version_name` - (Required) Image's version. Can be in the format x.x.x or 'latest'.
          * `custom_image` - (Optional) Custom image definitions. Required if marketplace image or gallery image are not specified.
            * `custom_image_resource_group_name` - (Required) The resource group name for custom image.
            * `name` - (Required) The name of the custom image.

        <a id="load balancer"></a>
        ## Load Balancer

        * `load_balancer` - (Optional) Add a load balancer. For Azure Gateway, each Backend Pool is a separate load balancer.
          * `type` - (Required, Enum `"loadBalancer", "applicationGateway"`) The type of load balancer.
          * `resource_group_name` - (Required) The Resource Group name of the Load Balancer.
          * `name` - (Required) Name of the Application Gateway/Load Balancer.
          * `sku` - (Optional)
            * if type is `"LoadBalancer"` then possible values are `Standard", "Basic`.
            * If ApplicationGateway then possible values are
              `Standard_Large, Standard_Medium, Standard_Small, Standard_v2", WAF_Large, WAF_Medium", WAF_v2"`.
          * `backend_pool_names` - (Optional) Name of the Backend Pool to register the Stateful Node VMs to. Each Backend Pool is a separate load balancer. Required if Type is APPLICATION_GATEWAY.

        <a id="login"></a>
        ## Login

        * `login` - (Required) Set admin access for accessing your VMs. Password/SSH is required for Linux.
          * `user_name` - (Required) username for admin access to VMs.
          * `ssh_public_key` - (Optional) SSH for admin access to Linux VMs. Optional for Linux.
          * `password` - (Optional) Password for admin access to Windows VMs. Required for Windows.

        <a id="managed_service_identities"></a>
        ## Managed Service Identities

        * `managed_service_identities` - (Optional) Add a user-assigned managed identity to the Stateful Node's VM.
          * `name` - (Required) name of the managed identity.
          * `resource_group_name` - (Required) The Resource Group that the user-assigned managed identity resides in.

        <a id="network"></a>
        ## Network

        * `network` - (Required) Define the Virtual Network and Subnet for your Stateful Node.
          * `network_resource_group_name` - (Required) Vnet Resource Group Name.
          * `virtual_network_name` - (Required) Virtual Network.
          * `network_interface` - (Required) Define a network interface
            * `is_primary` - (Required) Defines whether the network interface is primary or not.
            * `subnet_name` - (Required) Subnet name.
            * `assign_public_ip` - (Optional) Assign public IP.
            * `public_ip_sku` - (Optional) Required if assignPublicIp=true values=[Standard/Basic].
            * `network_security_group` - (Optional) Network Security Group.
              * `network_resource_group_name` - (Required) Requires valid security group name.
              * `name` - (Required) Requires valid resource group name.
            * `enable_ip_forwarding` - (Optional) Enable IP Forwarding.
            * `private_ip_addresses` - (Optional) A list with unique items that every item is a valid IP.
            * `additional_ip_configurations` - (Optional) Additional configuration of network interface.
              * `name` - (Required) Configuration name.
              * `private_ip_address_version` - (Required, Enum `"IPv4", "IPv6"` Default `"IPv4"`) Version of the private IP address.
            * `public_ips` - (Optional) Defined a pool of Public Ips (from Azure), that will be associated to the network interface. We will associate one public ip per instance until the pool is exhausted, in which case, we will create a new one.
              * `resource_group_name` - (Required) The resource group of the public ip.
              * `name` - (Required) - The name of the public ip.
            * `application_security_groups` - (Optional) Network Security Group.
              * `resource_group_name` - (Required) Requires valid security group name.
              * `name` - (Required) Requires valid resource group name.

        <a id="os_disk"></a>
        ## OS Disk

        * `os_disk` - (Optional) Specify OS disk specification other than default.
          * `size_gb` - (Optional, Default `"30"`) The size of the data disk in GB.
          * `type` - (Required, Enum `"Standard_LRS", "Premium_LRS", "StandardSSD_LRS"`) The type of the OS disk.

        <a id="secret"></a>
        ## Secret

        * `secret` - (Optional) Set of certificates that should be installed on the VM.
          * `source_vault` - (Required) The key vault reference, contains the required certificates.
            * `name` - (Required) The name of the key vault.
            * `resource_group_name` - (Required) The resource group name of the key vault.
          * `vault_certificates` - (Required) The required certificate references.
            * `certificate_url` - (Optional) The URL of the certificate under the key vault.
            * `certificate_store` - (Required) The certificate store directory the VM. The directory is created in the LocalMachine account.
              * This field is required only when using Windows OS type
              * This field must be null when the OS type is Linux

        <a id="secutiry"></a>
        ## Security

        * `security` - (Optional) Specifies the Security related profile settings for the virtual machine.
            * `secure_boot_enabled` - (Optional) Specifies whether secure boot should be enabled on the virtual machine.
            * `security_type` - (Optional) Enum: `"Standard", "TrustedLaunch"` Security type refers to the different security features of a virtual machine. Security features like Trusted launch virtual machines help to improve the security of Azure generation 2 virtual machines.
            * `vtpm_enabled` - (Optional) Specifies whether vTPM should be enabled on the virtual machine.

        <a id="tag"></a>
        ## Tag

        * `tag` - (Optional) Unique Key-Value pair for all Stateful Node Resources.
          * `tag_key` - (Optional) Tag Key for Stateful Node Resources.
          * `tag_value` - (Optional) Tag Value for Stateful Node Resources.

        <a id="health"></a>
        ## Health

        * `health` - (Optional) Set the auto healing preferences for unhealthy VMs.
          * `health_check_types` - (Optional, Enum `"vmState", "applicationGateway"`) Healthcheck to use to validate VM health.
          * `unhealthy_duration` - (Optional) Amount of time to be unhealthy before a replacement is triggered.
          * `auto_healing` - (Required) Enable Autohealing of unhealthy VMs.
          * `grace_period` - (Optional) Period of time to wait for VM to reach healthiness before monitoring for unhealthiness.

        <a id="persistence"></a>
        ## Persistence

        * `should_persist_os_disk` - (Required) Should persist os disk.
        * `os_disk_persistence_mode` - (Optional, Enum `"reattach", "onLaunch"`)
        * `should_persist_data_disks` - (Required) Should persist data disks.
        * `data_disks_persistence_mode` - (Optional, Enum `"reattach", "onLaunch"`)
        * `should_persist_network` - (Required) Should persist network.

        <a id="scheduling_tasks"></a>
        ## Scheduling Tasks

        * `scheduling_task` - (Optional) Scheduling settings object for stateful node.
          * `is_enabled` - (Required) Is scheduled task enabled for stateful node.
          * `type` - (Required, Enum `"pause", "resume", "recycle") The type of the scheduled task
          * `cron_expression` (Required) A expression which describes when to execute the scheduled task (UTC).

        <a id="signals"></a>
        ## Signals

        * `signal` - (Optional) A signal object defined for the stateful node.
          * `type` - (Required, Enum `"vmReady", "vmReadyToShutdown"`) The type of the signal defined for the stateful node.
          * `timeout` - (Required, Default `"1800"`) The timeout in seconds to hold the vm until a signal is sent. If no signal is sent the vm will be replaced (vmReady) or we will terminate the vm (vmReadyToShutdown) after the timeout.

        ***

        <a id="attach_data_disk"></a>
        ## Attach Data Disk

        * `attach_data_disk` - (Optional) Create a new data disk and attach it to the stateful node.
          * `data_disk_name` - (Required) The name of the created data disk.
          * `data_disk_resource_group_name` - (Required) The resource group name in which the data disk will be created.
          * `storage_account_type` - (Required, Enum `"Standard_LRS", "Premium_LRS", "StandardSSD_LRS", "UltraSSD_LRS"`) The type of the data disk.
          * `size_gb` - (Required) The size of the data disk in GB, Required if dataDisks is specified.
          * `zone` - (Optional, Enum `"1", "2", "3"`) The Availability Zone in which the data disk will be created. If not defined, the data disk will be created regionally.
          * `lun` - (Optional, Default `"orginal"`) The LUN of the data disk. If not defined, the LUN will be set in order.

        <a id="detach_data_disk"></a>
        ## Detach Data Disk

        * `detach_data_disk` - (Optional) Detach a data disk from a stateful node.
          * `data_disk_name` - (Required) The name of the detached data disk.
          * `data_disk_resource_group_name` - (Required) The resource group name in which the data disk exists.
          * `should_deallocate` - (Required) Indicates whether to delete the data disk in addition to detach.
          * `ttl_in_hours` - (Required, Default `"0"`) Hours to keep the disk alive before deletion.

        <a id="update_state"></a>
        ## Update State

        * `update_state` - (Optional) Update the stateful node state.
          * `state` - (Required, Enum `"pause", "resume", "recycle"`) New state for the stateful node.

        <a id="import_vm"></a>
        ## Import VM

        * `import_vm` - (Optional) Import an Azure VM and create a stateful node by providing a node configuration.
          * `resource_group_name` - (Required) Name of the Resource Group for Stateful Node.
          * `original_vm_name` - (Required) Azure Import Stateful Node Name.
          * `draining_timeout` - (Optional) Hours to keep resources alive.
          * `resources_retention_time` - (Optional) Hours to keep resources alive.

        <a id="delete"></a>
        ## Deallocation Config

        * `delete` - (Required) Specify deallocation parameters for stateful node deletion.
            * `should_terminate_vm` - (Required) Indicates whether to delete the stateful node's VM.
            * `network_should_deallocate` - (Required) Indicates whether to delete the stateful node's network resources.
            * `network_ttl_in_hours` - (Optional, Default: 96) Hours to keep the network resource alive before deletion.
            * `disk_should_deallocate` - (Required) Indicates whether to delete the stateful node's disk resources.
            * `disk_ttl_in_hours` - (Optional, Default: 96) Hours to keep the disk resource alive before deletion.
            * `snapshot_should_deallocate` - (Required) Indicates whether to delete the stateful node's snapshot resources.
            * `snapshot_ttl_in_hours` - (Optional, Default: 96) Hours to keep the snapshots alive before deletion.
            * `public_ip_should_deallocate` - (Required) Indicates whether to delete the stateful node's public ip resources.
            * `public_ip_ttl_in_hours` - (Optional, Default: 96) Hours to keep the public ip alive before deletion.

        :param str resource_name: The name of the resource.
        :param StatefulNodeAzureArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(StatefulNodeAzureArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            kwargs = kwargs or {}
            def _setter(key, value):
                kwargs[key] = value
            StatefulNodeAzureArgs._configure(_setter, **kwargs)
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 attach_data_disks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureAttachDataDiskArgs']]]]] = None,
                 boot_diagnostics: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureBootDiagnosticArgs']]]]] = None,
                 custom_data: Optional[pulumi.Input[str]] = None,
                 data_disks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureDataDiskArgs']]]]] = None,
                 data_disks_persistence_mode: Optional[pulumi.Input[str]] = None,
                 deletes: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureDeleteArgs']]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 detach_data_disks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureDetachDataDiskArgs']]]]] = None,
                 extensions: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureExtensionArgs']]]]] = None,
                 health: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureHealthArgs']]] = None,
                 image: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureImageArgs']]] = None,
                 import_vms: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureImportVmArgs']]]]] = None,
                 load_balancers: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureLoadBalancerArgs']]]]] = None,
                 login: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureLoginArgs']]] = None,
                 managed_service_identities: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureManagedServiceIdentityArgs']]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureNetworkArgs']]] = None,
                 od_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 os: Optional[pulumi.Input[str]] = None,
                 os_disk: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureOsDiskArgs']]] = None,
                 os_disk_persistence_mode: Optional[pulumi.Input[str]] = None,
                 preferred_spot_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preferred_zone: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 resource_group_name: Optional[pulumi.Input[str]] = None,
                 scheduling_tasks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureSchedulingTaskArgs']]]]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureSecretArgs']]]]] = None,
                 security: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureSecurityArgs']]] = None,
                 should_persist_data_disks: Optional[pulumi.Input[bool]] = None,
                 should_persist_network: Optional[pulumi.Input[bool]] = None,
                 should_persist_os_disk: Optional[pulumi.Input[bool]] = None,
                 should_persist_vm: Optional[pulumi.Input[bool]] = None,
                 shutdown_script: Optional[pulumi.Input[str]] = None,
                 signals: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureSignalArgs']]]]] = None,
                 spot_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 strategy: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureStrategyArgs']]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureTagArgs']]]]] = None,
                 update_states: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureUpdateStateArgs']]]]] = None,
                 user_data: Optional[pulumi.Input[str]] = None,
                 vm_name: Optional[pulumi.Input[str]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = StatefulNodeAzureArgs.__new__(StatefulNodeAzureArgs)

            __props__.__dict__["attach_data_disks"] = attach_data_disks
            __props__.__dict__["boot_diagnostics"] = boot_diagnostics
            __props__.__dict__["custom_data"] = custom_data
            __props__.__dict__["data_disks"] = data_disks
            __props__.__dict__["data_disks_persistence_mode"] = data_disks_persistence_mode
            __props__.__dict__["deletes"] = deletes
            __props__.__dict__["description"] = description
            __props__.__dict__["detach_data_disks"] = detach_data_disks
            __props__.__dict__["extensions"] = extensions
            if health is not None and not isinstance(health, StatefulNodeAzureHealthArgs):
                health = health or {}
                def _setter(key, value):
                    health[key] = value
                StatefulNodeAzureHealthArgs._configure(_setter, **health)
            __props__.__dict__["health"] = health
            if image is not None and not isinstance(image, StatefulNodeAzureImageArgs):
                image = image or {}
                def _setter(key, value):
                    image[key] = value
                StatefulNodeAzureImageArgs._configure(_setter, **image)
            __props__.__dict__["image"] = image
            __props__.__dict__["import_vms"] = import_vms
            __props__.__dict__["load_balancers"] = load_balancers
            if login is not None and not isinstance(login, StatefulNodeAzureLoginArgs):
                login = login or {}
                def _setter(key, value):
                    login[key] = value
                StatefulNodeAzureLoginArgs._configure(_setter, **login)
            __props__.__dict__["login"] = login
            __props__.__dict__["managed_service_identities"] = managed_service_identities
            __props__.__dict__["name"] = name
            if network is not None and not isinstance(network, StatefulNodeAzureNetworkArgs):
                network = network or {}
                def _setter(key, value):
                    network[key] = value
                StatefulNodeAzureNetworkArgs._configure(_setter, **network)
            __props__.__dict__["network"] = network
            if od_sizes is None and not opts.urn:
                raise TypeError("Missing required property 'od_sizes'")
            __props__.__dict__["od_sizes"] = od_sizes
            if os is None and not opts.urn:
                raise TypeError("Missing required property 'os'")
            __props__.__dict__["os"] = os
            if os_disk is not None and not isinstance(os_disk, StatefulNodeAzureOsDiskArgs):
                os_disk = os_disk or {}
                def _setter(key, value):
                    os_disk[key] = value
                StatefulNodeAzureOsDiskArgs._configure(_setter, **os_disk)
            __props__.__dict__["os_disk"] = os_disk
            __props__.__dict__["os_disk_persistence_mode"] = os_disk_persistence_mode
            __props__.__dict__["preferred_spot_sizes"] = preferred_spot_sizes
            __props__.__dict__["preferred_zone"] = preferred_zone
            if region is None and not opts.urn:
                raise TypeError("Missing required property 'region'")
            __props__.__dict__["region"] = region
            if resource_group_name is None and not opts.urn:
                raise TypeError("Missing required property 'resource_group_name'")
            __props__.__dict__["resource_group_name"] = resource_group_name
            __props__.__dict__["scheduling_tasks"] = scheduling_tasks
            __props__.__dict__["secrets"] = secrets
            if security is not None and not isinstance(security, StatefulNodeAzureSecurityArgs):
                security = security or {}
                def _setter(key, value):
                    security[key] = value
                StatefulNodeAzureSecurityArgs._configure(_setter, **security)
            __props__.__dict__["security"] = security
            if should_persist_data_disks is None and not opts.urn:
                raise TypeError("Missing required property 'should_persist_data_disks'")
            __props__.__dict__["should_persist_data_disks"] = should_persist_data_disks
            if should_persist_network is None and not opts.urn:
                raise TypeError("Missing required property 'should_persist_network'")
            __props__.__dict__["should_persist_network"] = should_persist_network
            if should_persist_os_disk is None and not opts.urn:
                raise TypeError("Missing required property 'should_persist_os_disk'")
            __props__.__dict__["should_persist_os_disk"] = should_persist_os_disk
            __props__.__dict__["should_persist_vm"] = should_persist_vm
            __props__.__dict__["shutdown_script"] = shutdown_script
            __props__.__dict__["signals"] = signals
            if spot_sizes is None and not opts.urn:
                raise TypeError("Missing required property 'spot_sizes'")
            __props__.__dict__["spot_sizes"] = spot_sizes
            if strategy is not None and not isinstance(strategy, StatefulNodeAzureStrategyArgs):
                strategy = strategy or {}
                def _setter(key, value):
                    strategy[key] = value
                StatefulNodeAzureStrategyArgs._configure(_setter, **strategy)
            if strategy is None and not opts.urn:
                raise TypeError("Missing required property 'strategy'")
            __props__.__dict__["strategy"] = strategy
            __props__.__dict__["tags"] = tags
            __props__.__dict__["update_states"] = update_states
            __props__.__dict__["user_data"] = user_data
            __props__.__dict__["vm_name"] = vm_name
            __props__.__dict__["zones"] = zones
        super(StatefulNodeAzure, __self__).__init__(
            'spotinst:index/statefulNodeAzure:StatefulNodeAzure',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            attach_data_disks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureAttachDataDiskArgs']]]]] = None,
            boot_diagnostics: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureBootDiagnosticArgs']]]]] = None,
            custom_data: Optional[pulumi.Input[str]] = None,
            data_disks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureDataDiskArgs']]]]] = None,
            data_disks_persistence_mode: Optional[pulumi.Input[str]] = None,
            deletes: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureDeleteArgs']]]]] = None,
            description: Optional[pulumi.Input[str]] = None,
            detach_data_disks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureDetachDataDiskArgs']]]]] = None,
            extensions: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureExtensionArgs']]]]] = None,
            health: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureHealthArgs']]] = None,
            image: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureImageArgs']]] = None,
            import_vms: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureImportVmArgs']]]]] = None,
            load_balancers: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureLoadBalancerArgs']]]]] = None,
            login: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureLoginArgs']]] = None,
            managed_service_identities: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureManagedServiceIdentityArgs']]]]] = None,
            name: Optional[pulumi.Input[str]] = None,
            network: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureNetworkArgs']]] = None,
            od_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            os: Optional[pulumi.Input[str]] = None,
            os_disk: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureOsDiskArgs']]] = None,
            os_disk_persistence_mode: Optional[pulumi.Input[str]] = None,
            preferred_spot_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            preferred_zone: Optional[pulumi.Input[str]] = None,
            region: Optional[pulumi.Input[str]] = None,
            resource_group_name: Optional[pulumi.Input[str]] = None,
            scheduling_tasks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureSchedulingTaskArgs']]]]] = None,
            secrets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureSecretArgs']]]]] = None,
            security: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureSecurityArgs']]] = None,
            should_persist_data_disks: Optional[pulumi.Input[bool]] = None,
            should_persist_network: Optional[pulumi.Input[bool]] = None,
            should_persist_os_disk: Optional[pulumi.Input[bool]] = None,
            should_persist_vm: Optional[pulumi.Input[bool]] = None,
            shutdown_script: Optional[pulumi.Input[str]] = None,
            signals: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureSignalArgs']]]]] = None,
            spot_sizes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            strategy: Optional[pulumi.Input[pulumi.InputType['StatefulNodeAzureStrategyArgs']]] = None,
            tags: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureTagArgs']]]]] = None,
            update_states: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['StatefulNodeAzureUpdateStateArgs']]]]] = None,
            user_data: Optional[pulumi.Input[str]] = None,
            vm_name: Optional[pulumi.Input[str]] = None,
            zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None) -> 'StatefulNodeAzure':
        """
        Get an existing StatefulNodeAzure resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _StatefulNodeAzureState.__new__(_StatefulNodeAzureState)

        __props__.__dict__["attach_data_disks"] = attach_data_disks
        __props__.__dict__["boot_diagnostics"] = boot_diagnostics
        __props__.__dict__["custom_data"] = custom_data
        __props__.__dict__["data_disks"] = data_disks
        __props__.__dict__["data_disks_persistence_mode"] = data_disks_persistence_mode
        __props__.__dict__["deletes"] = deletes
        __props__.__dict__["description"] = description
        __props__.__dict__["detach_data_disks"] = detach_data_disks
        __props__.__dict__["extensions"] = extensions
        __props__.__dict__["health"] = health
        __props__.__dict__["image"] = image
        __props__.__dict__["import_vms"] = import_vms
        __props__.__dict__["load_balancers"] = load_balancers
        __props__.__dict__["login"] = login
        __props__.__dict__["managed_service_identities"] = managed_service_identities
        __props__.__dict__["name"] = name
        __props__.__dict__["network"] = network
        __props__.__dict__["od_sizes"] = od_sizes
        __props__.__dict__["os"] = os
        __props__.__dict__["os_disk"] = os_disk
        __props__.__dict__["os_disk_persistence_mode"] = os_disk_persistence_mode
        __props__.__dict__["preferred_spot_sizes"] = preferred_spot_sizes
        __props__.__dict__["preferred_zone"] = preferred_zone
        __props__.__dict__["region"] = region
        __props__.__dict__["resource_group_name"] = resource_group_name
        __props__.__dict__["scheduling_tasks"] = scheduling_tasks
        __props__.__dict__["secrets"] = secrets
        __props__.__dict__["security"] = security
        __props__.__dict__["should_persist_data_disks"] = should_persist_data_disks
        __props__.__dict__["should_persist_network"] = should_persist_network
        __props__.__dict__["should_persist_os_disk"] = should_persist_os_disk
        __props__.__dict__["should_persist_vm"] = should_persist_vm
        __props__.__dict__["shutdown_script"] = shutdown_script
        __props__.__dict__["signals"] = signals
        __props__.__dict__["spot_sizes"] = spot_sizes
        __props__.__dict__["strategy"] = strategy
        __props__.__dict__["tags"] = tags
        __props__.__dict__["update_states"] = update_states
        __props__.__dict__["user_data"] = user_data
        __props__.__dict__["vm_name"] = vm_name
        __props__.__dict__["zones"] = zones
        return StatefulNodeAzure(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="attachDataDisks")
    def attach_data_disks(self) -> pulumi.Output[Optional[Sequence['outputs.StatefulNodeAzureAttachDataDisk']]]:
        return pulumi.get(self, "attach_data_disks")

    @property
    @pulumi.getter(name="bootDiagnostics")
    def boot_diagnostics(self) -> pulumi.Output[Sequence['outputs.StatefulNodeAzureBootDiagnostic']]:
        return pulumi.get(self, "boot_diagnostics")

    @property
    @pulumi.getter(name="customData")
    def custom_data(self) -> pulumi.Output[str]:
        return pulumi.get(self, "custom_data")

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> pulumi.Output[Optional[Sequence['outputs.StatefulNodeAzureDataDisk']]]:
        return pulumi.get(self, "data_disks")

    @property
    @pulumi.getter(name="dataDisksPersistenceMode")
    def data_disks_persistence_mode(self) -> pulumi.Output[str]:
        return pulumi.get(self, "data_disks_persistence_mode")

    @property
    @pulumi.getter
    def deletes(self) -> pulumi.Output[Optional[Sequence['outputs.StatefulNodeAzureDelete']]]:
        return pulumi.get(self, "deletes")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="detachDataDisks")
    def detach_data_disks(self) -> pulumi.Output[Optional[Sequence['outputs.StatefulNodeAzureDetachDataDisk']]]:
        return pulumi.get(self, "detach_data_disks")

    @property
    @pulumi.getter
    def extensions(self) -> pulumi.Output[Sequence['outputs.StatefulNodeAzureExtension']]:
        return pulumi.get(self, "extensions")

    @property
    @pulumi.getter
    def health(self) -> pulumi.Output['outputs.StatefulNodeAzureHealth']:
        return pulumi.get(self, "health")

    @property
    @pulumi.getter
    def image(self) -> pulumi.Output[Optional['outputs.StatefulNodeAzureImage']]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="importVms")
    def import_vms(self) -> pulumi.Output[Optional[Sequence['outputs.StatefulNodeAzureImportVm']]]:
        return pulumi.get(self, "import_vms")

    @property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> pulumi.Output[Sequence['outputs.StatefulNodeAzureLoadBalancer']]:
        return pulumi.get(self, "load_balancers")

    @property
    @pulumi.getter
    def login(self) -> pulumi.Output[Optional['outputs.StatefulNodeAzureLogin']]:
        return pulumi.get(self, "login")

    @property
    @pulumi.getter(name="managedServiceIdentities")
    def managed_service_identities(self) -> pulumi.Output[Sequence['outputs.StatefulNodeAzureManagedServiceIdentity']]:
        return pulumi.get(self, "managed_service_identities")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def network(self) -> pulumi.Output[Optional['outputs.StatefulNodeAzureNetwork']]:
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="odSizes")
    def od_sizes(self) -> pulumi.Output[Sequence[str]]:
        return pulumi.get(self, "od_sizes")

    @property
    @pulumi.getter
    def os(self) -> pulumi.Output[str]:
        return pulumi.get(self, "os")

    @property
    @pulumi.getter(name="osDisk")
    def os_disk(self) -> pulumi.Output[Optional['outputs.StatefulNodeAzureOsDisk']]:
        return pulumi.get(self, "os_disk")

    @property
    @pulumi.getter(name="osDiskPersistenceMode")
    def os_disk_persistence_mode(self) -> pulumi.Output[str]:
        return pulumi.get(self, "os_disk_persistence_mode")

    @property
    @pulumi.getter(name="preferredSpotSizes")
    def preferred_spot_sizes(self) -> pulumi.Output[Sequence[str]]:
        return pulumi.get(self, "preferred_spot_sizes")

    @property
    @pulumi.getter(name="preferredZone")
    def preferred_zone(self) -> pulumi.Output[str]:
        return pulumi.get(self, "preferred_zone")

    @property
    @pulumi.getter
    def region(self) -> pulumi.Output[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> pulumi.Output[str]:
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="schedulingTasks")
    def scheduling_tasks(self) -> pulumi.Output[Sequence['outputs.StatefulNodeAzureSchedulingTask']]:
        return pulumi.get(self, "scheduling_tasks")

    @property
    @pulumi.getter
    def secrets(self) -> pulumi.Output[Optional[Sequence['outputs.StatefulNodeAzureSecret']]]:
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter
    def security(self) -> pulumi.Output[Optional['outputs.StatefulNodeAzureSecurity']]:
        return pulumi.get(self, "security")

    @property
    @pulumi.getter(name="shouldPersistDataDisks")
    def should_persist_data_disks(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "should_persist_data_disks")

    @property
    @pulumi.getter(name="shouldPersistNetwork")
    def should_persist_network(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "should_persist_network")

    @property
    @pulumi.getter(name="shouldPersistOsDisk")
    def should_persist_os_disk(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "should_persist_os_disk")

    @property
    @pulumi.getter(name="shouldPersistVm")
    def should_persist_vm(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "should_persist_vm")

    @property
    @pulumi.getter(name="shutdownScript")
    def shutdown_script(self) -> pulumi.Output[str]:
        return pulumi.get(self, "shutdown_script")

    @property
    @pulumi.getter
    def signals(self) -> pulumi.Output[Sequence['outputs.StatefulNodeAzureSignal']]:
        return pulumi.get(self, "signals")

    @property
    @pulumi.getter(name="spotSizes")
    def spot_sizes(self) -> pulumi.Output[Sequence[str]]:
        return pulumi.get(self, "spot_sizes")

    @property
    @pulumi.getter
    def strategy(self) -> pulumi.Output['outputs.StatefulNodeAzureStrategy']:
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter
    def tags(self) -> pulumi.Output[Sequence['outputs.StatefulNodeAzureTag']]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="updateStates")
    def update_states(self) -> pulumi.Output[Optional[Sequence['outputs.StatefulNodeAzureUpdateState']]]:
        return pulumi.get(self, "update_states")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> pulumi.Output[str]:
        return pulumi.get(self, "user_data")

    @property
    @pulumi.getter(name="vmName")
    def vm_name(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "vm_name")

    @property
    @pulumi.getter
    def zones(self) -> pulumi.Output[Optional[Sequence[str]]]:
        return pulumi.get(self, "zones")

