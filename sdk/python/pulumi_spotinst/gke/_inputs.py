# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ElastigroupBackendServiceArgs',
    'ElastigroupBackendServiceArgsDict',
    'ElastigroupBackendServiceNamedPortArgs',
    'ElastigroupBackendServiceNamedPortArgsDict',
    'ElastigroupDiskArgs',
    'ElastigroupDiskArgsDict',
    'ElastigroupDiskInitializeParamArgs',
    'ElastigroupDiskInitializeParamArgsDict',
    'ElastigroupGpuArgs',
    'ElastigroupGpuArgsDict',
    'ElastigroupInstanceTypesCustomArgs',
    'ElastigroupInstanceTypesCustomArgsDict',
    'ElastigroupIntegrationDockerSwarmArgs',
    'ElastigroupIntegrationDockerSwarmArgsDict',
    'ElastigroupIntegrationGkeArgs',
    'ElastigroupIntegrationGkeArgsDict',
    'ElastigroupIntegrationGkeAutoscaleDownArgs',
    'ElastigroupIntegrationGkeAutoscaleDownArgsDict',
    'ElastigroupIntegrationGkeAutoscaleHeadroomArgs',
    'ElastigroupIntegrationGkeAutoscaleHeadroomArgsDict',
    'ElastigroupIntegrationGkeAutoscaleLabelArgs',
    'ElastigroupIntegrationGkeAutoscaleLabelArgsDict',
    'ElastigroupLabelArgs',
    'ElastigroupLabelArgsDict',
    'ElastigroupMetadataArgs',
    'ElastigroupMetadataArgsDict',
    'ElastigroupNetworkInterfaceArgs',
    'ElastigroupNetworkInterfaceArgsDict',
    'ElastigroupNetworkInterfaceAccessConfigArgs',
    'ElastigroupNetworkInterfaceAccessConfigArgsDict',
    'ElastigroupNetworkInterfaceAliasIpRangeArgs',
    'ElastigroupNetworkInterfaceAliasIpRangeArgsDict',
    'ElastigroupRevertToPreemptibleArgs',
    'ElastigroupRevertToPreemptibleArgsDict',
    'ElastigroupScalingDownPolicyArgs',
    'ElastigroupScalingDownPolicyArgsDict',
    'ElastigroupScalingDownPolicyDimensionArgs',
    'ElastigroupScalingDownPolicyDimensionArgsDict',
    'ElastigroupScalingUpPolicyArgs',
    'ElastigroupScalingUpPolicyArgsDict',
    'ElastigroupScalingUpPolicyDimensionArgs',
    'ElastigroupScalingUpPolicyDimensionArgsDict',
    'ElastigroupShieldedInstanceConfigArgs',
    'ElastigroupShieldedInstanceConfigArgsDict',
    'OceanImportAutoUpdateArgs',
    'OceanImportAutoUpdateArgsDict',
    'OceanImportAutoscalerArgs',
    'OceanImportAutoscalerArgsDict',
    'OceanImportAutoscalerDownArgs',
    'OceanImportAutoscalerDownArgsDict',
    'OceanImportAutoscalerHeadroomArgs',
    'OceanImportAutoscalerHeadroomArgsDict',
    'OceanImportAutoscalerResourceLimitsArgs',
    'OceanImportAutoscalerResourceLimitsArgsDict',
    'OceanImportBackendServiceArgs',
    'OceanImportBackendServiceArgsDict',
    'OceanImportBackendServiceNamedPortArgs',
    'OceanImportBackendServiceNamedPortArgsDict',
    'OceanImportFiltersArgs',
    'OceanImportFiltersArgsDict',
    'OceanImportScheduledTaskArgs',
    'OceanImportScheduledTaskArgsDict',
    'OceanImportScheduledTaskShutdownHoursArgs',
    'OceanImportScheduledTaskShutdownHoursArgsDict',
    'OceanImportScheduledTaskTaskArgs',
    'OceanImportScheduledTaskTaskArgsDict',
    'OceanImportScheduledTaskTaskTaskParametersArgs',
    'OceanImportScheduledTaskTaskTaskParametersArgsDict',
    'OceanImportScheduledTaskTaskTaskParametersClusterRollArgs',
    'OceanImportScheduledTaskTaskTaskParametersClusterRollArgsDict',
    'OceanImportShieldedInstanceConfigArgs',
    'OceanImportShieldedInstanceConfigArgsDict',
    'OceanImportStrategyArgs',
    'OceanImportStrategyArgsDict',
    'OceanImportUpdatePolicyArgs',
    'OceanImportUpdatePolicyArgsDict',
    'OceanImportUpdatePolicyRollConfigArgs',
    'OceanImportUpdatePolicyRollConfigArgsDict',
    'OceanLaunchSpecAutoscaleHeadroomArgs',
    'OceanLaunchSpecAutoscaleHeadroomArgsDict',
    'OceanLaunchSpecAutoscaleHeadroomsAutomaticArgs',
    'OceanLaunchSpecAutoscaleHeadroomsAutomaticArgsDict',
    'OceanLaunchSpecCreateOptionsArgs',
    'OceanLaunchSpecCreateOptionsArgsDict',
    'OceanLaunchSpecLabelArgs',
    'OceanLaunchSpecLabelArgsDict',
    'OceanLaunchSpecMetadataArgs',
    'OceanLaunchSpecMetadataArgsDict',
    'OceanLaunchSpecNetworkInterfaceArgs',
    'OceanLaunchSpecNetworkInterfaceArgsDict',
    'OceanLaunchSpecNetworkInterfaceAccessConfigArgs',
    'OceanLaunchSpecNetworkInterfaceAccessConfigArgsDict',
    'OceanLaunchSpecNetworkInterfaceAliasIpRangeArgs',
    'OceanLaunchSpecNetworkInterfaceAliasIpRangeArgsDict',
    'OceanLaunchSpecResourceLimitsArgs',
    'OceanLaunchSpecResourceLimitsArgsDict',
    'OceanLaunchSpecSchedulingTaskArgs',
    'OceanLaunchSpecSchedulingTaskArgsDict',
    'OceanLaunchSpecSchedulingTaskTaskHeadroomArgs',
    'OceanLaunchSpecSchedulingTaskTaskHeadroomArgsDict',
    'OceanLaunchSpecShieldedInstanceConfigArgs',
    'OceanLaunchSpecShieldedInstanceConfigArgsDict',
    'OceanLaunchSpecStorageArgs',
    'OceanLaunchSpecStorageArgsDict',
    'OceanLaunchSpecStrategyArgs',
    'OceanLaunchSpecStrategyArgsDict',
    'OceanLaunchSpecTaintArgs',
    'OceanLaunchSpecTaintArgsDict',
    'OceanLaunchSpecUpdatePolicyArgs',
    'OceanLaunchSpecUpdatePolicyArgsDict',
    'OceanLaunchSpecUpdatePolicyRollConfigArgs',
    'OceanLaunchSpecUpdatePolicyRollConfigArgsDict',
]

MYPY = False

if not MYPY:
    class ElastigroupBackendServiceArgsDict(TypedDict):
        service_name: pulumi.Input[builtins.str]
        location_type: NotRequired[pulumi.Input[builtins.str]]
        named_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupBackendServiceNamedPortArgsDict']]]]
        scheme: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ElastigroupBackendServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupBackendServiceArgs:
    def __init__(__self__, *,
                 service_name: pulumi.Input[builtins.str],
                 location_type: Optional[pulumi.Input[builtins.str]] = None,
                 named_ports: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupBackendServiceNamedPortArgs']]]] = None,
                 scheme: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "service_name", service_name)
        if location_type is not None:
            pulumi.set(__self__, "location_type", location_type)
        if named_ports is not None:
            pulumi.set(__self__, "named_ports", named_ports)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="locationType")
    def location_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "location_type")

    @location_type.setter
    def location_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "location_type", value)

    @property
    @pulumi.getter(name="namedPorts")
    def named_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupBackendServiceNamedPortArgs']]]]:
        return pulumi.get(self, "named_ports")

    @named_ports.setter
    def named_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupBackendServiceNamedPortArgs']]]]):
        pulumi.set(self, "named_ports", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class ElastigroupBackendServiceNamedPortArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        ports: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    ElastigroupBackendServiceNamedPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupBackendServiceNamedPortArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 ports: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class ElastigroupDiskArgsDict(TypedDict):
        auto_delete: NotRequired[pulumi.Input[builtins.bool]]
        boot: NotRequired[pulumi.Input[builtins.bool]]
        device_name: NotRequired[pulumi.Input[builtins.str]]
        initialize_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupDiskInitializeParamArgsDict']]]]
        interface: NotRequired[pulumi.Input[builtins.str]]
        mode: NotRequired[pulumi.Input[builtins.str]]
        source: NotRequired[pulumi.Input[builtins.str]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ElastigroupDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupDiskArgs:
    def __init__(__self__, *,
                 auto_delete: Optional[pulumi.Input[builtins.bool]] = None,
                 boot: Optional[pulumi.Input[builtins.bool]] = None,
                 device_name: Optional[pulumi.Input[builtins.str]] = None,
                 initialize_params: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupDiskInitializeParamArgs']]]] = None,
                 interface: Optional[pulumi.Input[builtins.str]] = None,
                 mode: Optional[pulumi.Input[builtins.str]] = None,
                 source: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if boot is not None:
            pulumi.set(__self__, "boot", boot)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "auto_delete")

    @auto_delete.setter
    def auto_delete(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "auto_delete", value)

    @property
    @pulumi.getter
    def boot(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "boot")

    @boot.setter
    def boot(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "boot", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupDiskInitializeParamArgs']]]]:
        return pulumi.get(self, "initialize_params")

    @initialize_params.setter
    def initialize_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupDiskInitializeParamArgs']]]]):
        pulumi.set(self, "initialize_params", value)

    @property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "interface", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ElastigroupDiskInitializeParamArgsDict(TypedDict):
        source_image: pulumi.Input[builtins.str]
        disk_size_gb: NotRequired[pulumi.Input[builtins.str]]
        disk_type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ElastigroupDiskInitializeParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupDiskInitializeParamArgs:
    def __init__(__self__, *,
                 source_image: pulumi.Input[builtins.str],
                 disk_size_gb: Optional[pulumi.Input[builtins.str]] = None,
                 disk_type: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "source_image", source_image)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)

    @property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "source_image")

    @source_image.setter
    def source_image(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source_image", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "disk_type", value)


if not MYPY:
    class ElastigroupGpuArgsDict(TypedDict):
        count: pulumi.Input[builtins.int]
        type: pulumi.Input[builtins.str]
elif False:
    ElastigroupGpuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupGpuArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[builtins.int],
                 type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ElastigroupInstanceTypesCustomArgsDict(TypedDict):
        memory_gib: pulumi.Input[builtins.int]
        vcpu: pulumi.Input[builtins.int]
elif False:
    ElastigroupInstanceTypesCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupInstanceTypesCustomArgs:
    def __init__(__self__, *,
                 memory_gib: pulumi.Input[builtins.int],
                 vcpu: pulumi.Input[builtins.int]):
        pulumi.set(__self__, "memory_gib", memory_gib)
        pulumi.set(__self__, "vcpu", vcpu)

    @property
    @pulumi.getter(name="memoryGib")
    def memory_gib(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "memory_gib")

    @memory_gib.setter
    def memory_gib(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "memory_gib", value)

    @property
    @pulumi.getter
    def vcpu(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "vcpu")

    @vcpu.setter
    def vcpu(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "vcpu", value)


if not MYPY:
    class ElastigroupIntegrationDockerSwarmArgsDict(TypedDict):
        master_host: pulumi.Input[builtins.str]
        master_port: pulumi.Input[builtins.int]
elif False:
    ElastigroupIntegrationDockerSwarmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationDockerSwarmArgs:
    def __init__(__self__, *,
                 master_host: pulumi.Input[builtins.str],
                 master_port: pulumi.Input[builtins.int]):
        pulumi.set(__self__, "master_host", master_host)
        pulumi.set(__self__, "master_port", master_port)

    @property
    @pulumi.getter(name="masterHost")
    def master_host(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "master_host")

    @master_host.setter
    def master_host(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "master_host", value)

    @property
    @pulumi.getter(name="masterPort")
    def master_port(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "master_port")

    @master_port.setter
    def master_port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "master_port", value)


if not MYPY:
    class ElastigroupIntegrationGkeArgsDict(TypedDict):
        auto_update: NotRequired[pulumi.Input[builtins.bool]]
        autoscale_cooldown: NotRequired[pulumi.Input[builtins.int]]
        """
        The amount of time, in seconds, after a scaling activity completes before any further trigger-related scaling activities can start.
        """
        autoscale_down: NotRequired[pulumi.Input['ElastigroupIntegrationGkeAutoscaleDownArgsDict']]
        """
        Enabling scale down.
        """
        autoscale_headroom: NotRequired[pulumi.Input['ElastigroupIntegrationGkeAutoscaleHeadroomArgsDict']]
        """
        Headroom for the cluster.
        """
        autoscale_is_auto_config: NotRequired[pulumi.Input[builtins.bool]]
        autoscale_is_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether the auto scaling feature is enabled.
        """
        autoscale_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationGkeAutoscaleLabelArgsDict']]]]
        """
        Labels to assign to the resource.
        """
        cluster_id: NotRequired[pulumi.Input[builtins.str]]
        location: NotRequired[pulumi.Input[builtins.str]]
        """
        The location of your GKE cluster.
        """
elif False:
    ElastigroupIntegrationGkeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationGkeArgs:
    def __init__(__self__, *,
                 auto_update: Optional[pulumi.Input[builtins.bool]] = None,
                 autoscale_cooldown: Optional[pulumi.Input[builtins.int]] = None,
                 autoscale_down: Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleDownArgs']] = None,
                 autoscale_headroom: Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleHeadroomArgs']] = None,
                 autoscale_is_auto_config: Optional[pulumi.Input[builtins.bool]] = None,
                 autoscale_is_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 autoscale_labels: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationGkeAutoscaleLabelArgs']]]] = None,
                 cluster_id: Optional[pulumi.Input[builtins.str]] = None,
                 location: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] autoscale_cooldown: The amount of time, in seconds, after a scaling activity completes before any further trigger-related scaling activities can start.
        :param pulumi.Input['ElastigroupIntegrationGkeAutoscaleDownArgs'] autoscale_down: Enabling scale down.
        :param pulumi.Input['ElastigroupIntegrationGkeAutoscaleHeadroomArgs'] autoscale_headroom: Headroom for the cluster.
        :param pulumi.Input[builtins.bool] autoscale_is_enabled: Specifies whether the auto scaling feature is enabled.
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationGkeAutoscaleLabelArgs']]] autoscale_labels: Labels to assign to the resource.
        :param pulumi.Input[builtins.str] location: The location of your GKE cluster.
        """
        if auto_update is not None:
            pulumi.set(__self__, "auto_update", auto_update)
        if autoscale_cooldown is not None:
            pulumi.set(__self__, "autoscale_cooldown", autoscale_cooldown)
        if autoscale_down is not None:
            pulumi.set(__self__, "autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)
        if autoscale_is_auto_config is not None:
            pulumi.set(__self__, "autoscale_is_auto_config", autoscale_is_auto_config)
        if autoscale_is_enabled is not None:
            pulumi.set(__self__, "autoscale_is_enabled", autoscale_is_enabled)
        if autoscale_labels is not None:
            pulumi.set(__self__, "autoscale_labels", autoscale_labels)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if location is not None:
            pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter(name="autoUpdate")
    def auto_update(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "auto_update")

    @auto_update.setter
    def auto_update(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "auto_update", value)

    @property
    @pulumi.getter(name="autoscaleCooldown")
    def autoscale_cooldown(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The amount of time, in seconds, after a scaling activity completes before any further trigger-related scaling activities can start.
        """
        return pulumi.get(self, "autoscale_cooldown")

    @autoscale_cooldown.setter
    def autoscale_cooldown(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "autoscale_cooldown", value)

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleDownArgs']]:
        """
        Enabling scale down.
        """
        return pulumi.get(self, "autoscale_down")

    @autoscale_down.setter
    def autoscale_down(self, value: Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleDownArgs']]):
        pulumi.set(self, "autoscale_down", value)

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleHeadroomArgs']]:
        """
        Headroom for the cluster.
        """
        return pulumi.get(self, "autoscale_headroom")

    @autoscale_headroom.setter
    def autoscale_headroom(self, value: Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleHeadroomArgs']]):
        pulumi.set(self, "autoscale_headroom", value)

    @property
    @pulumi.getter(name="autoscaleIsAutoConfig")
    def autoscale_is_auto_config(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "autoscale_is_auto_config")

    @autoscale_is_auto_config.setter
    def autoscale_is_auto_config(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "autoscale_is_auto_config", value)

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether the auto scaling feature is enabled.
        """
        return pulumi.get(self, "autoscale_is_enabled")

    @autoscale_is_enabled.setter
    def autoscale_is_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "autoscale_is_enabled", value)

    @property
    @pulumi.getter(name="autoscaleLabels")
    def autoscale_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationGkeAutoscaleLabelArgs']]]]:
        """
        Labels to assign to the resource.
        """
        return pulumi.get(self, "autoscale_labels")

    @autoscale_labels.setter
    def autoscale_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationGkeAutoscaleLabelArgs']]]]):
        pulumi.set(self, "autoscale_labels", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The location of your GKE cluster.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "location", value)


if not MYPY:
    class ElastigroupIntegrationGkeAutoscaleDownArgsDict(TypedDict):
        evaluation_periods: NotRequired[pulumi.Input[builtins.int]]
        """
        Amount of cooldown evaluation periods for scale down.
        """
elif False:
    ElastigroupIntegrationGkeAutoscaleDownArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationGkeAutoscaleDownArgs:
    def __init__(__self__, *,
                 evaluation_periods: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] evaluation_periods: Amount of cooldown evaluation periods for scale down.
        """
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Amount of cooldown evaluation periods for scale down.
        """
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "evaluation_periods", value)


if not MYPY:
    class ElastigroupIntegrationGkeAutoscaleHeadroomArgsDict(TypedDict):
        cpu_per_unit: NotRequired[pulumi.Input[builtins.int]]
        """
        Cpu units for compute.
        """
        memory_per_unit: NotRequired[pulumi.Input[builtins.int]]
        """
        RAM units for compute.
        """
        num_of_units: NotRequired[pulumi.Input[builtins.int]]
        """
        Amount of units for compute.
        """
elif False:
    ElastigroupIntegrationGkeAutoscaleHeadroomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationGkeAutoscaleHeadroomArgs:
    def __init__(__self__, *,
                 cpu_per_unit: Optional[pulumi.Input[builtins.int]] = None,
                 memory_per_unit: Optional[pulumi.Input[builtins.int]] = None,
                 num_of_units: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] cpu_per_unit: Cpu units for compute.
        :param pulumi.Input[builtins.int] memory_per_unit: RAM units for compute.
        :param pulumi.Input[builtins.int] num_of_units: Amount of units for compute.
        """
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Cpu units for compute.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        RAM units for compute.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "memory_per_unit", value)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Amount of units for compute.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "num_of_units", value)


if not MYPY:
    class ElastigroupIntegrationGkeAutoscaleLabelArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
elif False:
    ElastigroupIntegrationGkeAutoscaleLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationGkeAutoscaleLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ElastigroupLabelArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
elif False:
    ElastigroupLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ElastigroupMetadataArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
elif False:
    ElastigroupMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupMetadataArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ElastigroupNetworkInterfaceArgsDict(TypedDict):
        network: pulumi.Input[builtins.str]
        access_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAccessConfigArgsDict']]]]
        alias_ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAliasIpRangeArgsDict']]]]
elif False:
    ElastigroupNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupNetworkInterfaceArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[builtins.str],
                 access_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAccessConfigArgs']]]] = None,
                 alias_ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAliasIpRangeArgs']]]] = None):
        pulumi.set(__self__, "network", network)
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if alias_ip_ranges is not None:
            pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAccessConfigArgs']]]]:
        return pulumi.get(self, "access_configs")

    @access_configs.setter
    def access_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAccessConfigArgs']]]]):
        pulumi.set(self, "access_configs", value)

    @property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAliasIpRangeArgs']]]]:
        return pulumi.get(self, "alias_ip_ranges")

    @alias_ip_ranges.setter
    def alias_ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAliasIpRangeArgs']]]]):
        pulumi.set(self, "alias_ip_ranges", value)


if not MYPY:
    class ElastigroupNetworkInterfaceAccessConfigArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ElastigroupNetworkInterfaceAccessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupNetworkInterfaceAccessConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ElastigroupNetworkInterfaceAliasIpRangeArgsDict(TypedDict):
        ip_cidr_range: pulumi.Input[builtins.str]
        subnetwork_range_name: pulumi.Input[builtins.str]
elif False:
    ElastigroupNetworkInterfaceAliasIpRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupNetworkInterfaceAliasIpRangeArgs:
    def __init__(__self__, *,
                 ip_cidr_range: pulumi.Input[builtins.str],
                 subnetwork_range_name: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "ip_cidr_range")

    @ip_cidr_range.setter
    def ip_cidr_range(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ip_cidr_range", value)

    @property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "subnetwork_range_name")

    @subnetwork_range_name.setter
    def subnetwork_range_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subnetwork_range_name", value)


if not MYPY:
    class ElastigroupRevertToPreemptibleArgsDict(TypedDict):
        perform_at: pulumi.Input[builtins.str]
elif False:
    ElastigroupRevertToPreemptibleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupRevertToPreemptibleArgs:
    def __init__(__self__, *,
                 perform_at: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "perform_at", perform_at)

    @property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "perform_at")

    @perform_at.setter
    def perform_at(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "perform_at", value)


if not MYPY:
    class ElastigroupScalingDownPolicyArgsDict(TypedDict):
        metric_name: pulumi.Input[builtins.str]
        namespace: pulumi.Input[builtins.str]
        policy_name: pulumi.Input[builtins.str]
        threshold: pulumi.Input[builtins.float]
        unit: pulumi.Input[builtins.str]
        action_type: NotRequired[pulumi.Input[builtins.str]]
        adjustment: NotRequired[pulumi.Input[builtins.int]]
        cooldown: NotRequired[pulumi.Input[builtins.int]]
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgsDict']]]]
        evaluation_periods: NotRequired[pulumi.Input[builtins.int]]
        """
        Amount of cooldown evaluation periods for scale down.
        """
        operator: NotRequired[pulumi.Input[builtins.str]]
        period: NotRequired[pulumi.Input[builtins.int]]
        source: NotRequired[pulumi.Input[builtins.str]]
        statistic: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ElastigroupScalingDownPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupScalingDownPolicyArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[builtins.str],
                 namespace: pulumi.Input[builtins.str],
                 policy_name: pulumi.Input[builtins.str],
                 threshold: pulumi.Input[builtins.float],
                 unit: pulumi.Input[builtins.str],
                 action_type: Optional[pulumi.Input[builtins.str]] = None,
                 adjustment: Optional[pulumi.Input[builtins.int]] = None,
                 cooldown: Optional[pulumi.Input[builtins.int]] = None,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgs']]]] = None,
                 evaluation_periods: Optional[pulumi.Input[builtins.int]] = None,
                 operator: Optional[pulumi.Input[builtins.str]] = None,
                 period: Optional[pulumi.Input[builtins.int]] = None,
                 source: Optional[pulumi.Input[builtins.str]] = None,
                 statistic: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] evaluation_periods: Amount of cooldown evaluation periods for scale down.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "policy_name", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[builtins.float]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgs']]]]:
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Amount of cooldown evaluation periods for scale down.
        """
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "statistic", value)


if not MYPY:
    class ElastigroupScalingDownPolicyDimensionArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        value: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ElastigroupScalingDownPolicyDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupScalingDownPolicyDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ElastigroupScalingUpPolicyArgsDict(TypedDict):
        metric_name: pulumi.Input[builtins.str]
        namespace: pulumi.Input[builtins.str]
        policy_name: pulumi.Input[builtins.str]
        threshold: pulumi.Input[builtins.float]
        unit: pulumi.Input[builtins.str]
        action_type: NotRequired[pulumi.Input[builtins.str]]
        adjustment: NotRequired[pulumi.Input[builtins.int]]
        cooldown: NotRequired[pulumi.Input[builtins.int]]
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgsDict']]]]
        evaluation_periods: NotRequired[pulumi.Input[builtins.int]]
        """
        Amount of cooldown evaluation periods for scale down.
        """
        operator: NotRequired[pulumi.Input[builtins.str]]
        period: NotRequired[pulumi.Input[builtins.int]]
        source: NotRequired[pulumi.Input[builtins.str]]
        statistic: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ElastigroupScalingUpPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupScalingUpPolicyArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[builtins.str],
                 namespace: pulumi.Input[builtins.str],
                 policy_name: pulumi.Input[builtins.str],
                 threshold: pulumi.Input[builtins.float],
                 unit: pulumi.Input[builtins.str],
                 action_type: Optional[pulumi.Input[builtins.str]] = None,
                 adjustment: Optional[pulumi.Input[builtins.int]] = None,
                 cooldown: Optional[pulumi.Input[builtins.int]] = None,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgs']]]] = None,
                 evaluation_periods: Optional[pulumi.Input[builtins.int]] = None,
                 operator: Optional[pulumi.Input[builtins.str]] = None,
                 period: Optional[pulumi.Input[builtins.int]] = None,
                 source: Optional[pulumi.Input[builtins.str]] = None,
                 statistic: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] evaluation_periods: Amount of cooldown evaluation periods for scale down.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "policy_name", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[builtins.float]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgs']]]]:
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Amount of cooldown evaluation periods for scale down.
        """
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "statistic", value)


if not MYPY:
    class ElastigroupScalingUpPolicyDimensionArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        value: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ElastigroupScalingUpPolicyDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupScalingUpPolicyDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ElastigroupShieldedInstanceConfigArgsDict(TypedDict):
        enable_integrity_monitoring: NotRequired[pulumi.Input[builtins.bool]]
        enable_secure_boot: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    ElastigroupShieldedInstanceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupShieldedInstanceConfigArgs:
    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_secure_boot: Optional[pulumi.Input[builtins.bool]] = None):
        if enable_integrity_monitoring is not None:
            pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)

    @property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enable_integrity_monitoring")

    @enable_integrity_monitoring.setter
    def enable_integrity_monitoring(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_integrity_monitoring", value)

    @property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enable_secure_boot")

    @enable_secure_boot.setter
    def enable_secure_boot(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_secure_boot", value)


if not MYPY:
    class OceanImportAutoUpdateArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable the Ocean Kubernetes AutoUpdate.
        """
elif False:
    OceanImportAutoUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportAutoUpdateArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] is_enabled: Enable the Ocean Kubernetes AutoUpdate.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable the Ocean Kubernetes AutoUpdate.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class OceanImportAutoscalerArgsDict(TypedDict):
        auto_headroom_percentage: NotRequired[pulumi.Input[builtins.int]]
        """
        Optionally set the auto headroom percentage, set a number between 0-200 to control the headroom % from the cluster. Relevant when isAutoConfig=true.
        """
        cooldown: NotRequired[pulumi.Input[builtins.int]]
        """
        Cooldown period between scaling actions.
        """
        down: NotRequired[pulumi.Input['OceanImportAutoscalerDownArgsDict']]
        """
        Auto Scaling scale down operations.
        """
        enable_automatic_and_manual_headroom: NotRequired[pulumi.Input[builtins.bool]]
        """
        enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
        """
        headroom: NotRequired[pulumi.Input['OceanImportAutoscalerHeadroomArgsDict']]
        """
        Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
        """
        is_auto_config: NotRequired[pulumi.Input[builtins.bool]]
        """
        Automatically configure and optimize headroom resources.
        """
        is_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable the Ocean Kubernetes Autoscaler.
        """
        resource_limits: NotRequired[pulumi.Input['OceanImportAutoscalerResourceLimitsArgsDict']]
        """
        Optionally set upper and lower bounds on the resource usage of the cluster.
        """
elif False:
    OceanImportAutoscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportAutoscalerArgs:
    def __init__(__self__, *,
                 auto_headroom_percentage: Optional[pulumi.Input[builtins.int]] = None,
                 cooldown: Optional[pulumi.Input[builtins.int]] = None,
                 down: Optional[pulumi.Input['OceanImportAutoscalerDownArgs']] = None,
                 enable_automatic_and_manual_headroom: Optional[pulumi.Input[builtins.bool]] = None,
                 headroom: Optional[pulumi.Input['OceanImportAutoscalerHeadroomArgs']] = None,
                 is_auto_config: Optional[pulumi.Input[builtins.bool]] = None,
                 is_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 resource_limits: Optional[pulumi.Input['OceanImportAutoscalerResourceLimitsArgs']] = None):
        """
        :param pulumi.Input[builtins.int] auto_headroom_percentage: Optionally set the auto headroom percentage, set a number between 0-200 to control the headroom % from the cluster. Relevant when isAutoConfig=true.
        :param pulumi.Input[builtins.int] cooldown: Cooldown period between scaling actions.
        :param pulumi.Input['OceanImportAutoscalerDownArgs'] down: Auto Scaling scale down operations.
        :param pulumi.Input[builtins.bool] enable_automatic_and_manual_headroom: enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
        :param pulumi.Input['OceanImportAutoscalerHeadroomArgs'] headroom: Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
        :param pulumi.Input[builtins.bool] is_auto_config: Automatically configure and optimize headroom resources.
        :param pulumi.Input[builtins.bool] is_enabled: Enable the Ocean Kubernetes Autoscaler.
        :param pulumi.Input['OceanImportAutoscalerResourceLimitsArgs'] resource_limits: Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        if auto_headroom_percentage is not None:
            pulumi.set(__self__, "auto_headroom_percentage", auto_headroom_percentage)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if down is not None:
            pulumi.set(__self__, "down", down)
        if enable_automatic_and_manual_headroom is not None:
            pulumi.set(__self__, "enable_automatic_and_manual_headroom", enable_automatic_and_manual_headroom)
        if headroom is not None:
            pulumi.set(__self__, "headroom", headroom)
        if is_auto_config is not None:
            pulumi.set(__self__, "is_auto_config", is_auto_config)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if resource_limits is not None:
            pulumi.set(__self__, "resource_limits", resource_limits)

    @property
    @pulumi.getter(name="autoHeadroomPercentage")
    def auto_headroom_percentage(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optionally set the auto headroom percentage, set a number between 0-200 to control the headroom % from the cluster. Relevant when isAutoConfig=true.
        """
        return pulumi.get(self, "auto_headroom_percentage")

    @auto_headroom_percentage.setter
    def auto_headroom_percentage(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "auto_headroom_percentage", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Cooldown period between scaling actions.
        """
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def down(self) -> Optional[pulumi.Input['OceanImportAutoscalerDownArgs']]:
        """
        Auto Scaling scale down operations.
        """
        return pulumi.get(self, "down")

    @down.setter
    def down(self, value: Optional[pulumi.Input['OceanImportAutoscalerDownArgs']]):
        pulumi.set(self, "down", value)

    @property
    @pulumi.getter(name="enableAutomaticAndManualHeadroom")
    def enable_automatic_and_manual_headroom(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
        """
        return pulumi.get(self, "enable_automatic_and_manual_headroom")

    @enable_automatic_and_manual_headroom.setter
    def enable_automatic_and_manual_headroom(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_automatic_and_manual_headroom", value)

    @property
    @pulumi.getter
    def headroom(self) -> Optional[pulumi.Input['OceanImportAutoscalerHeadroomArgs']]:
        """
        Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
        """
        return pulumi.get(self, "headroom")

    @headroom.setter
    def headroom(self, value: Optional[pulumi.Input['OceanImportAutoscalerHeadroomArgs']]):
        pulumi.set(self, "headroom", value)

    @property
    @pulumi.getter(name="isAutoConfig")
    def is_auto_config(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Automatically configure and optimize headroom resources.
        """
        return pulumi.get(self, "is_auto_config")

    @is_auto_config.setter
    def is_auto_config(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_auto_config", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable the Ocean Kubernetes Autoscaler.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="resourceLimits")
    def resource_limits(self) -> Optional[pulumi.Input['OceanImportAutoscalerResourceLimitsArgs']]:
        """
        Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        return pulumi.get(self, "resource_limits")

    @resource_limits.setter
    def resource_limits(self, value: Optional[pulumi.Input['OceanImportAutoscalerResourceLimitsArgs']]):
        pulumi.set(self, "resource_limits", value)


if not MYPY:
    class OceanImportAutoscalerDownArgsDict(TypedDict):
        evaluation_periods: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of evaluation periods that should accumulate before a scale down action takes place.
        """
        is_aggressive_scale_down_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        When set to 'true', the Aggressive Scale Down feature is enabled.
        """
        max_scale_down_percentage: NotRequired[pulumi.Input[builtins.float]]
        """
        Would represent the maximum % to scale-down. Number between 1-100.
        """
elif False:
    OceanImportAutoscalerDownArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportAutoscalerDownArgs:
    def __init__(__self__, *,
                 evaluation_periods: Optional[pulumi.Input[builtins.int]] = None,
                 is_aggressive_scale_down_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 max_scale_down_percentage: Optional[pulumi.Input[builtins.float]] = None):
        """
        :param pulumi.Input[builtins.int] evaluation_periods: The number of evaluation periods that should accumulate before a scale down action takes place.
        :param pulumi.Input[builtins.bool] is_aggressive_scale_down_enabled: When set to 'true', the Aggressive Scale Down feature is enabled.
        :param pulumi.Input[builtins.float] max_scale_down_percentage: Would represent the maximum % to scale-down. Number between 1-100.
        """
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if is_aggressive_scale_down_enabled is not None:
            pulumi.set(__self__, "is_aggressive_scale_down_enabled", is_aggressive_scale_down_enabled)
        if max_scale_down_percentage is not None:
            pulumi.set(__self__, "max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of evaluation periods that should accumulate before a scale down action takes place.
        """
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter(name="isAggressiveScaleDownEnabled")
    def is_aggressive_scale_down_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When set to 'true', the Aggressive Scale Down feature is enabled.
        """
        return pulumi.get(self, "is_aggressive_scale_down_enabled")

    @is_aggressive_scale_down_enabled.setter
    def is_aggressive_scale_down_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_aggressive_scale_down_enabled", value)

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Would represent the maximum % to scale-down. Number between 1-100.
        """
        return pulumi.get(self, "max_scale_down_percentage")

    @max_scale_down_percentage.setter
    def max_scale_down_percentage(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "max_scale_down_percentage", value)


if not MYPY:
    class OceanImportAutoscalerHeadroomArgsDict(TypedDict):
        cpu_per_unit: NotRequired[pulumi.Input[builtins.int]]
        """
        Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        gpu_per_unit: NotRequired[pulumi.Input[builtins.int]]
        """
        How much GPU allocate for headroom unit.
        """
        memory_per_unit: NotRequired[pulumi.Input[builtins.int]]
        """
        Optionally configure the amount of memory (MiB) to allocate the headroom.
        """
        num_of_units: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
elif False:
    OceanImportAutoscalerHeadroomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportAutoscalerHeadroomArgs:
    def __init__(__self__, *,
                 cpu_per_unit: Optional[pulumi.Input[builtins.int]] = None,
                 gpu_per_unit: Optional[pulumi.Input[builtins.int]] = None,
                 memory_per_unit: Optional[pulumi.Input[builtins.int]] = None,
                 num_of_units: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] cpu_per_unit: Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[builtins.int] gpu_per_unit: How much GPU allocate for headroom unit.
        :param pulumi.Input[builtins.int] memory_per_unit: Optionally configure the amount of memory (MiB) to allocate the headroom.
        :param pulumi.Input[builtins.int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        How much GPU allocate for headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @gpu_per_unit.setter
    def gpu_per_unit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "gpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optionally configure the amount of memory (MiB) to allocate the headroom.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "memory_per_unit", value)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "num_of_units", value)


if not MYPY:
    class OceanImportAutoscalerResourceLimitsArgsDict(TypedDict):
        max_memory_gib: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum memory in GiB units that can be allocated to the cluster.
        """
        max_vcpu: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum cpu in vCpu units that can be allocated to the cluster.
        """
elif False:
    OceanImportAutoscalerResourceLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportAutoscalerResourceLimitsArgs:
    def __init__(__self__, *,
                 max_memory_gib: Optional[pulumi.Input[builtins.int]] = None,
                 max_vcpu: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] max_memory_gib: The maximum memory in GiB units that can be allocated to the cluster.
        :param pulumi.Input[builtins.int] max_vcpu: The maximum cpu in vCpu units that can be allocated to the cluster.
        """
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum memory in GiB units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_memory_gib")

    @max_memory_gib.setter
    def max_memory_gib(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_memory_gib", value)

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum cpu in vCpu units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_vcpu")

    @max_vcpu.setter
    def max_vcpu(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_vcpu", value)


if not MYPY:
    class OceanImportBackendServiceArgsDict(TypedDict):
        service_name: pulumi.Input[builtins.str]
        """
        The name of the backend service.
        """
        location_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Sets which location the backend services will be active. Valid values: `regional`, `global`.
        """
        named_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['OceanImportBackendServiceNamedPortArgsDict']]]]
        scheme: NotRequired[pulumi.Input[builtins.str]]
        """
        Use when `location_type` is `regional`. Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: `INTERNAL`, `EXTERNAL`.
        """
elif False:
    OceanImportBackendServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportBackendServiceArgs:
    def __init__(__self__, *,
                 service_name: pulumi.Input[builtins.str],
                 location_type: Optional[pulumi.Input[builtins.str]] = None,
                 named_ports: Optional[pulumi.Input[Sequence[pulumi.Input['OceanImportBackendServiceNamedPortArgs']]]] = None,
                 scheme: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] service_name: The name of the backend service.
        :param pulumi.Input[builtins.str] location_type: Sets which location the backend services will be active. Valid values: `regional`, `global`.
        :param pulumi.Input[builtins.str] scheme: Use when `location_type` is `regional`. Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: `INTERNAL`, `EXTERNAL`.
        """
        pulumi.set(__self__, "service_name", service_name)
        if location_type is not None:
            pulumi.set(__self__, "location_type", location_type)
        if named_ports is not None:
            pulumi.set(__self__, "named_ports", named_ports)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the backend service.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="locationType")
    def location_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Sets which location the backend services will be active. Valid values: `regional`, `global`.
        """
        return pulumi.get(self, "location_type")

    @location_type.setter
    def location_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "location_type", value)

    @property
    @pulumi.getter(name="namedPorts")
    def named_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanImportBackendServiceNamedPortArgs']]]]:
        return pulumi.get(self, "named_ports")

    @named_ports.setter
    def named_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanImportBackendServiceNamedPortArgs']]]]):
        pulumi.set(self, "named_ports", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Use when `location_type` is `regional`. Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: `INTERNAL`, `EXTERNAL`.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class OceanImportBackendServiceNamedPortArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        ports: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        A list of ports.
        """
elif False:
    OceanImportBackendServiceNamedPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportBackendServiceNamedPortArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 ports: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] ports: A list of ports.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        A list of ports.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class OceanImportFiltersArgsDict(TypedDict):
        exclude_families: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
        """
        include_families: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
        """
        max_memory_gib: NotRequired[pulumi.Input[builtins.float]]
        """
        Maximum amount of Memory (GiB).
        """
        max_vcpu: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of vcpus available.
        """
        min_memory_gib: NotRequired[pulumi.Input[builtins.float]]
        """
        Minimum amount of Memory (GiB).
        """
        min_vcpu: NotRequired[pulumi.Input[builtins.int]]
        """
        Minimum number of vcpus available.
        """
elif False:
    OceanImportFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportFiltersArgs:
    def __init__(__self__, *,
                 exclude_families: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 include_families: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 max_memory_gib: Optional[pulumi.Input[builtins.float]] = None,
                 max_vcpu: Optional[pulumi.Input[builtins.int]] = None,
                 min_memory_gib: Optional[pulumi.Input[builtins.float]] = None,
                 min_vcpu: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] exclude_families: Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] include_families: Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
        :param pulumi.Input[builtins.float] max_memory_gib: Maximum amount of Memory (GiB).
        :param pulumi.Input[builtins.int] max_vcpu: Maximum number of vcpus available.
        :param pulumi.Input[builtins.float] min_memory_gib: Minimum amount of Memory (GiB).
        :param pulumi.Input[builtins.int] min_vcpu: Minimum number of vcpus available.
        """
        if exclude_families is not None:
            pulumi.set(__self__, "exclude_families", exclude_families)
        if include_families is not None:
            pulumi.set(__self__, "include_families", include_families)
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)
        if min_memory_gib is not None:
            pulumi.set(__self__, "min_memory_gib", min_memory_gib)
        if min_vcpu is not None:
            pulumi.set(__self__, "min_vcpu", min_vcpu)

    @property
    @pulumi.getter(name="excludeFamilies")
    def exclude_families(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
        """
        return pulumi.get(self, "exclude_families")

    @exclude_families.setter
    def exclude_families(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "exclude_families", value)

    @property
    @pulumi.getter(name="includeFamilies")
    def include_families(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
        """
        return pulumi.get(self, "include_families")

    @include_families.setter
    def include_families(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "include_families", value)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Maximum amount of Memory (GiB).
        """
        return pulumi.get(self, "max_memory_gib")

    @max_memory_gib.setter
    def max_memory_gib(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "max_memory_gib", value)

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of vcpus available.
        """
        return pulumi.get(self, "max_vcpu")

    @max_vcpu.setter
    def max_vcpu(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_vcpu", value)

    @property
    @pulumi.getter(name="minMemoryGib")
    def min_memory_gib(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Minimum amount of Memory (GiB).
        """
        return pulumi.get(self, "min_memory_gib")

    @min_memory_gib.setter
    def min_memory_gib(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "min_memory_gib", value)

    @property
    @pulumi.getter(name="minVcpu")
    def min_vcpu(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minimum number of vcpus available.
        """
        return pulumi.get(self, "min_vcpu")

    @min_vcpu.setter
    def min_vcpu(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_vcpu", value)


if not MYPY:
    class OceanImportScheduledTaskArgsDict(TypedDict):
        shutdown_hours: NotRequired[pulumi.Input['OceanImportScheduledTaskShutdownHoursArgsDict']]
        """
        Set shutdown hours for cluster object.
        """
        tasks: NotRequired[pulumi.Input[Sequence[pulumi.Input['OceanImportScheduledTaskTaskArgsDict']]]]
        """
        The scheduling tasks for the cluster.
        """
elif False:
    OceanImportScheduledTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportScheduledTaskArgs:
    def __init__(__self__, *,
                 shutdown_hours: Optional[pulumi.Input['OceanImportScheduledTaskShutdownHoursArgs']] = None,
                 tasks: Optional[pulumi.Input[Sequence[pulumi.Input['OceanImportScheduledTaskTaskArgs']]]] = None):
        """
        :param pulumi.Input['OceanImportScheduledTaskShutdownHoursArgs'] shutdown_hours: Set shutdown hours for cluster object.
        :param pulumi.Input[Sequence[pulumi.Input['OceanImportScheduledTaskTaskArgs']]] tasks: The scheduling tasks for the cluster.
        """
        if shutdown_hours is not None:
            pulumi.set(__self__, "shutdown_hours", shutdown_hours)
        if tasks is not None:
            pulumi.set(__self__, "tasks", tasks)

    @property
    @pulumi.getter(name="shutdownHours")
    def shutdown_hours(self) -> Optional[pulumi.Input['OceanImportScheduledTaskShutdownHoursArgs']]:
        """
        Set shutdown hours for cluster object.
        """
        return pulumi.get(self, "shutdown_hours")

    @shutdown_hours.setter
    def shutdown_hours(self, value: Optional[pulumi.Input['OceanImportScheduledTaskShutdownHoursArgs']]):
        pulumi.set(self, "shutdown_hours", value)

    @property
    @pulumi.getter
    def tasks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanImportScheduledTaskTaskArgs']]]]:
        """
        The scheduling tasks for the cluster.
        """
        return pulumi.get(self, "tasks")

    @tasks.setter
    def tasks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanImportScheduledTaskTaskArgs']]]]):
        pulumi.set(self, "tasks", value)


if not MYPY:
    class OceanImportScheduledTaskShutdownHoursArgsDict(TypedDict):
        time_windows: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Set time windows for shutdown hours. specify a list of 'timeWindows' with at least one time window Each string is in the format of - ddd:hh:mm-ddd:hh:mm ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59. Time windows should not overlap. required on cluster.scheduling.isEnabled = `true`. API Times are in UTC
        Example: Fri:15:30-Wed:14:30
        """
        is_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag to enable / disable the shutdown hours.
        Example: `true`
        """
elif False:
    OceanImportScheduledTaskShutdownHoursArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportScheduledTaskShutdownHoursArgs:
    def __init__(__self__, *,
                 time_windows: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 is_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] time_windows: Set time windows for shutdown hours. specify a list of 'timeWindows' with at least one time window Each string is in the format of - ddd:hh:mm-ddd:hh:mm ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59. Time windows should not overlap. required on cluster.scheduling.isEnabled = `true`. API Times are in UTC
               Example: Fri:15:30-Wed:14:30
        :param pulumi.Input[builtins.bool] is_enabled: Flag to enable / disable the shutdown hours.
               Example: `true`
        """
        pulumi.set(__self__, "time_windows", time_windows)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Set time windows for shutdown hours. specify a list of 'timeWindows' with at least one time window Each string is in the format of - ddd:hh:mm-ddd:hh:mm ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59. Time windows should not overlap. required on cluster.scheduling.isEnabled = `true`. API Times are in UTC
        Example: Fri:15:30-Wed:14:30
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to enable / disable the shutdown hours.
        Example: `true`
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class OceanImportScheduledTaskTaskArgsDict(TypedDict):
        cron_expression: pulumi.Input[builtins.str]
        """
        A valid cron expression. For example : " * * * * * ".The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of ‘frequency’ or ‘cronExpression’ should be used at a time. Required for cluster.scheduling.tasks object
        Example: 0 1 * * *
        """
        is_enabled: pulumi.Input[builtins.bool]
        """
        Describes whether the task is enabled. When true the task should run when false it should not run. Required for cluster.scheduling.tasks object.
        """
        task_type: pulumi.Input[builtins.str]
        """
        Valid values: "clusterRoll". Required for cluster.scheduling.tasks object.
        """
        task_parameters: NotRequired[pulumi.Input['OceanImportScheduledTaskTaskTaskParametersArgsDict']]
        """
        The scheduling parameters for the cluster.
        """
elif False:
    OceanImportScheduledTaskTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportScheduledTaskTaskArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[builtins.str],
                 is_enabled: pulumi.Input[builtins.bool],
                 task_type: pulumi.Input[builtins.str],
                 task_parameters: Optional[pulumi.Input['OceanImportScheduledTaskTaskTaskParametersArgs']] = None):
        """
        :param pulumi.Input[builtins.str] cron_expression: A valid cron expression. For example : " * * * * * ".The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of ‘frequency’ or ‘cronExpression’ should be used at a time. Required for cluster.scheduling.tasks object
               Example: 0 1 * * *
        :param pulumi.Input[builtins.bool] is_enabled: Describes whether the task is enabled. When true the task should run when false it should not run. Required for cluster.scheduling.tasks object.
        :param pulumi.Input[builtins.str] task_type: Valid values: "clusterRoll". Required for cluster.scheduling.tasks object.
        :param pulumi.Input['OceanImportScheduledTaskTaskTaskParametersArgs'] task_parameters: The scheduling parameters for the cluster.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "task_type", task_type)
        if task_parameters is not None:
            pulumi.set(__self__, "task_parameters", task_parameters)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[builtins.str]:
        """
        A valid cron expression. For example : " * * * * * ".The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of ‘frequency’ or ‘cronExpression’ should be used at a time. Required for cluster.scheduling.tasks object
        Example: 0 1 * * *
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Describes whether the task is enabled. When true the task should run when false it should not run. Required for cluster.scheduling.tasks object.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input[builtins.str]:
        """
        Valid values: "clusterRoll". Required for cluster.scheduling.tasks object.
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "task_type", value)

    @property
    @pulumi.getter(name="taskParameters")
    def task_parameters(self) -> Optional[pulumi.Input['OceanImportScheduledTaskTaskTaskParametersArgs']]:
        """
        The scheduling parameters for the cluster.
        """
        return pulumi.get(self, "task_parameters")

    @task_parameters.setter
    def task_parameters(self, value: Optional[pulumi.Input['OceanImportScheduledTaskTaskTaskParametersArgs']]):
        pulumi.set(self, "task_parameters", value)


if not MYPY:
    class OceanImportScheduledTaskTaskTaskParametersArgsDict(TypedDict):
        cluster_roll: NotRequired[pulumi.Input['OceanImportScheduledTaskTaskTaskParametersClusterRollArgsDict']]
        """
        The cluster roll parameters for the cluster.
        """
elif False:
    OceanImportScheduledTaskTaskTaskParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportScheduledTaskTaskTaskParametersArgs:
    def __init__(__self__, *,
                 cluster_roll: Optional[pulumi.Input['OceanImportScheduledTaskTaskTaskParametersClusterRollArgs']] = None):
        """
        :param pulumi.Input['OceanImportScheduledTaskTaskTaskParametersClusterRollArgs'] cluster_roll: The cluster roll parameters for the cluster.
        """
        if cluster_roll is not None:
            pulumi.set(__self__, "cluster_roll", cluster_roll)

    @property
    @pulumi.getter(name="clusterRoll")
    def cluster_roll(self) -> Optional[pulumi.Input['OceanImportScheduledTaskTaskTaskParametersClusterRollArgs']]:
        """
        The cluster roll parameters for the cluster.
        """
        return pulumi.get(self, "cluster_roll")

    @cluster_roll.setter
    def cluster_roll(self, value: Optional[pulumi.Input['OceanImportScheduledTaskTaskTaskParametersClusterRollArgs']]):
        pulumi.set(self, "cluster_roll", value)


if not MYPY:
    class OceanImportScheduledTaskTaskTaskParametersClusterRollArgsDict(TypedDict):
        batch_min_healthy_percentage: NotRequired[pulumi.Input[builtins.int]]
        """
        Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        """
        batch_size_percentage: NotRequired[pulumi.Input[builtins.int]]
        """
        Value as a percent to set the size of a batch in a roll. Valid values are 0-100.
        """
        comment: NotRequired[pulumi.Input[builtins.str]]
        """
        Add a comment description for the roll. The comment is limited to 256 chars.
        """
        respect_pdb: NotRequired[pulumi.Input[builtins.bool]]
        """
        During the roll, if the parameter is set to true we honor PDB during the instance replacement.
        """
elif False:
    OceanImportScheduledTaskTaskTaskParametersClusterRollArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportScheduledTaskTaskTaskParametersClusterRollArgs:
    def __init__(__self__, *,
                 batch_min_healthy_percentage: Optional[pulumi.Input[builtins.int]] = None,
                 batch_size_percentage: Optional[pulumi.Input[builtins.int]] = None,
                 comment: Optional[pulumi.Input[builtins.str]] = None,
                 respect_pdb: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] batch_min_healthy_percentage: Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        :param pulumi.Input[builtins.int] batch_size_percentage: Value as a percent to set the size of a batch in a roll. Valid values are 0-100.
        :param pulumi.Input[builtins.str] comment: Add a comment description for the roll. The comment is limited to 256 chars.
        :param pulumi.Input[builtins.bool] respect_pdb: During the roll, if the parameter is set to true we honor PDB during the instance replacement.
        """
        if batch_min_healthy_percentage is not None:
            pulumi.set(__self__, "batch_min_healthy_percentage", batch_min_healthy_percentage)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if respect_pdb is not None:
            pulumi.set(__self__, "respect_pdb", respect_pdb)

    @property
    @pulumi.getter(name="batchMinHealthyPercentage")
    def batch_min_healthy_percentage(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        """
        return pulumi.get(self, "batch_min_healthy_percentage")

    @batch_min_healthy_percentage.setter
    def batch_min_healthy_percentage(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "batch_min_healthy_percentage", value)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Value as a percent to set the size of a batch in a roll. Valid values are 0-100.
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Add a comment description for the roll. The comment is limited to 256 chars.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="respectPdb")
    def respect_pdb(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        During the roll, if the parameter is set to true we honor PDB during the instance replacement.
        """
        return pulumi.get(self, "respect_pdb")

    @respect_pdb.setter
    def respect_pdb(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "respect_pdb", value)


if not MYPY:
    class OceanImportShieldedInstanceConfigArgsDict(TypedDict):
        enable_integrity_monitoring: NotRequired[pulumi.Input[builtins.bool]]
        """
        Boolean. Enable the integrity monitoring parameter on the GCP instances.
        """
        enable_secure_boot: NotRequired[pulumi.Input[builtins.bool]]
        """
        Boolean. Enable the secure boot parameter on the GCP instances.
        """
elif False:
    OceanImportShieldedInstanceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportShieldedInstanceConfigArgs:
    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_secure_boot: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] enable_integrity_monitoring: Boolean. Enable the integrity monitoring parameter on the GCP instances.
        :param pulumi.Input[builtins.bool] enable_secure_boot: Boolean. Enable the secure boot parameter on the GCP instances.
        """
        if enable_integrity_monitoring is not None:
            pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)

    @property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Boolean. Enable the integrity monitoring parameter on the GCP instances.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @enable_integrity_monitoring.setter
    def enable_integrity_monitoring(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_integrity_monitoring", value)

    @property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Boolean. Enable the secure boot parameter on the GCP instances.
        """
        return pulumi.get(self, "enable_secure_boot")

    @enable_secure_boot.setter
    def enable_secure_boot(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_secure_boot", value)


if not MYPY:
    class OceanImportStrategyArgsDict(TypedDict):
        draining_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The draining timeout (in seconds) before terminating the instance. If no draining timeout is defined, the default draining timeout will be used.
        """
        preemptible_percentage: NotRequired[pulumi.Input[builtins.int]]
        """
        Defines the desired preemptible percentage for the cluster.
        """
        provisioning_model: NotRequired[pulumi.Input[builtins.str]]
        """
        Define the provisioning model of the launched instances. Valid values: `SPOT`, `PREEMPTIBLE`.
        """
        scaling_orientation: NotRequired[pulumi.Input[builtins.str]]
        """
        Valid Values: `"cost", "availability", "balanced"`. Set this value to control the approach that Ocean takes when launching nodes.
        """
        should_utilize_commitments: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable committed use discounts utilization.
        """
elif False:
    OceanImportStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportStrategyArgs:
    def __init__(__self__, *,
                 draining_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 preemptible_percentage: Optional[pulumi.Input[builtins.int]] = None,
                 provisioning_model: Optional[pulumi.Input[builtins.str]] = None,
                 scaling_orientation: Optional[pulumi.Input[builtins.str]] = None,
                 should_utilize_commitments: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] draining_timeout: The draining timeout (in seconds) before terminating the instance. If no draining timeout is defined, the default draining timeout will be used.
        :param pulumi.Input[builtins.int] preemptible_percentage: Defines the desired preemptible percentage for the cluster.
        :param pulumi.Input[builtins.str] provisioning_model: Define the provisioning model of the launched instances. Valid values: `SPOT`, `PREEMPTIBLE`.
        :param pulumi.Input[builtins.str] scaling_orientation: Valid Values: `"cost", "availability", "balanced"`. Set this value to control the approach that Ocean takes when launching nodes.
        :param pulumi.Input[builtins.bool] should_utilize_commitments: Enable committed use discounts utilization.
        """
        if draining_timeout is not None:
            pulumi.set(__self__, "draining_timeout", draining_timeout)
        if preemptible_percentage is not None:
            pulumi.set(__self__, "preemptible_percentage", preemptible_percentage)
        if provisioning_model is not None:
            pulumi.set(__self__, "provisioning_model", provisioning_model)
        if scaling_orientation is not None:
            pulumi.set(__self__, "scaling_orientation", scaling_orientation)
        if should_utilize_commitments is not None:
            pulumi.set(__self__, "should_utilize_commitments", should_utilize_commitments)

    @property
    @pulumi.getter(name="drainingTimeout")
    def draining_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The draining timeout (in seconds) before terminating the instance. If no draining timeout is defined, the default draining timeout will be used.
        """
        return pulumi.get(self, "draining_timeout")

    @draining_timeout.setter
    def draining_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "draining_timeout", value)

    @property
    @pulumi.getter(name="preemptiblePercentage")
    def preemptible_percentage(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Defines the desired preemptible percentage for the cluster.
        """
        return pulumi.get(self, "preemptible_percentage")

    @preemptible_percentage.setter
    def preemptible_percentage(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "preemptible_percentage", value)

    @property
    @pulumi.getter(name="provisioningModel")
    def provisioning_model(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Define the provisioning model of the launched instances. Valid values: `SPOT`, `PREEMPTIBLE`.
        """
        return pulumi.get(self, "provisioning_model")

    @provisioning_model.setter
    def provisioning_model(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "provisioning_model", value)

    @property
    @pulumi.getter(name="scalingOrientation")
    def scaling_orientation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Valid Values: `"cost", "availability", "balanced"`. Set this value to control the approach that Ocean takes when launching nodes.
        """
        return pulumi.get(self, "scaling_orientation")

    @scaling_orientation.setter
    def scaling_orientation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scaling_orientation", value)

    @property
    @pulumi.getter(name="shouldUtilizeCommitments")
    def should_utilize_commitments(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable committed use discounts utilization.
        """
        return pulumi.get(self, "should_utilize_commitments")

    @should_utilize_commitments.setter
    def should_utilize_commitments(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "should_utilize_commitments", value)


if not MYPY:
    class OceanImportUpdatePolicyArgsDict(TypedDict):
        should_roll: pulumi.Input[builtins.bool]
        """
        Enables the roll.
        """
        conditioned_roll: NotRequired[pulumi.Input[builtins.bool]]
        """
        Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
        """
        roll_config: NotRequired[pulumi.Input['OceanImportUpdatePolicyRollConfigArgsDict']]
        """
        Holds the roll configuration.
        """
elif False:
    OceanImportUpdatePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportUpdatePolicyArgs:
    def __init__(__self__, *,
                 should_roll: pulumi.Input[builtins.bool],
                 conditioned_roll: Optional[pulumi.Input[builtins.bool]] = None,
                 roll_config: Optional[pulumi.Input['OceanImportUpdatePolicyRollConfigArgs']] = None):
        """
        :param pulumi.Input[builtins.bool] should_roll: Enables the roll.
        :param pulumi.Input[builtins.bool] conditioned_roll: Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
        :param pulumi.Input['OceanImportUpdatePolicyRollConfigArgs'] roll_config: Holds the roll configuration.
        """
        pulumi.set(__self__, "should_roll", should_roll)
        if conditioned_roll is not None:
            pulumi.set(__self__, "conditioned_roll", conditioned_roll)
        if roll_config is not None:
            pulumi.set(__self__, "roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> pulumi.Input[builtins.bool]:
        """
        Enables the roll.
        """
        return pulumi.get(self, "should_roll")

    @should_roll.setter
    def should_roll(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "should_roll", value)

    @property
    @pulumi.getter(name="conditionedRoll")
    def conditioned_roll(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Spot will perform a cluster Roll in accordance with a relevant modification of the cluster’s settings. When set to true , only specific changes in the cluster’s configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
        """
        return pulumi.get(self, "conditioned_roll")

    @conditioned_roll.setter
    def conditioned_roll(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "conditioned_roll", value)

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional[pulumi.Input['OceanImportUpdatePolicyRollConfigArgs']]:
        """
        Holds the roll configuration.
        """
        return pulumi.get(self, "roll_config")

    @roll_config.setter
    def roll_config(self, value: Optional[pulumi.Input['OceanImportUpdatePolicyRollConfigArgs']]):
        pulumi.set(self, "roll_config", value)


if not MYPY:
    class OceanImportUpdatePolicyRollConfigArgsDict(TypedDict):
        batch_size_percentage: pulumi.Input[builtins.int]
        """
        Sets the percentage of the instances to deploy in each batch.
        """
        batch_min_healthy_percentage: NotRequired[pulumi.Input[builtins.int]]
        """
        Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        """
        launch_spec_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of Virtual Node Group identifiers to be rolled.
        """
        respect_pdb: NotRequired[pulumi.Input[builtins.bool]]
        """
        Default: `false`. During the roll, if the parameter is set to `true` we honor PDB during the instance replacement.
        """
elif False:
    OceanImportUpdatePolicyRollConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanImportUpdatePolicyRollConfigArgs:
    def __init__(__self__, *,
                 batch_size_percentage: pulumi.Input[builtins.int],
                 batch_min_healthy_percentage: Optional[pulumi.Input[builtins.int]] = None,
                 launch_spec_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 respect_pdb: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.int] batch_size_percentage: Sets the percentage of the instances to deploy in each batch.
        :param pulumi.Input[builtins.int] batch_min_healthy_percentage: Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] launch_spec_ids: List of Virtual Node Group identifiers to be rolled.
        :param pulumi.Input[builtins.bool] respect_pdb: Default: `false`. During the roll, if the parameter is set to `true` we honor PDB during the instance replacement.
        """
        pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if batch_min_healthy_percentage is not None:
            pulumi.set(__self__, "batch_min_healthy_percentage", batch_min_healthy_percentage)
        if launch_spec_ids is not None:
            pulumi.set(__self__, "launch_spec_ids", launch_spec_ids)
        if respect_pdb is not None:
            pulumi.set(__self__, "respect_pdb", respect_pdb)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> pulumi.Input[builtins.int]:
        """
        Sets the percentage of the instances to deploy in each batch.
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter(name="batchMinHealthyPercentage")
    def batch_min_healthy_percentage(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        """
        return pulumi.get(self, "batch_min_healthy_percentage")

    @batch_min_healthy_percentage.setter
    def batch_min_healthy_percentage(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "batch_min_healthy_percentage", value)

    @property
    @pulumi.getter(name="launchSpecIds")
    def launch_spec_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of Virtual Node Group identifiers to be rolled.
        """
        return pulumi.get(self, "launch_spec_ids")

    @launch_spec_ids.setter
    def launch_spec_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "launch_spec_ids", value)

    @property
    @pulumi.getter(name="respectPdb")
    def respect_pdb(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Default: `false`. During the roll, if the parameter is set to `true` we honor PDB during the instance replacement.
        """
        return pulumi.get(self, "respect_pdb")

    @respect_pdb.setter
    def respect_pdb(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "respect_pdb", value)


if not MYPY:
    class OceanLaunchSpecAutoscaleHeadroomArgsDict(TypedDict):
        num_of_units: pulumi.Input[builtins.int]
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        cpu_per_unit: NotRequired[pulumi.Input[builtins.int]]
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        gpu_per_unit: NotRequired[pulumi.Input[builtins.int]]
        """
        Optionally configure the number of GPUS to allocate for each headroom unit.
        """
        memory_per_unit: NotRequired[pulumi.Input[builtins.int]]
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
elif False:
    OceanLaunchSpecAutoscaleHeadroomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecAutoscaleHeadroomArgs:
    def __init__(__self__, *,
                 num_of_units: pulumi.Input[builtins.int],
                 cpu_per_unit: Optional[pulumi.Input[builtins.int]] = None,
                 gpu_per_unit: Optional[pulumi.Input[builtins.int]] = None,
                 memory_per_unit: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        :param pulumi.Input[builtins.int] cpu_per_unit: Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[builtins.int] gpu_per_unit: Optionally configure the number of GPUS to allocate for each headroom unit.
        :param pulumi.Input[builtins.int] memory_per_unit: Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        pulumi.set(__self__, "num_of_units", num_of_units)
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> pulumi.Input[builtins.int]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "num_of_units", value)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optionally configure the number of GPUS to allocate for each headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @gpu_per_unit.setter
    def gpu_per_unit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "gpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "memory_per_unit", value)


if not MYPY:
    class OceanLaunchSpecAutoscaleHeadroomsAutomaticArgsDict(TypedDict):
        auto_headroom_percentage: NotRequired[pulumi.Input[builtins.int]]
        """
        Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.`is_enabled` = true is set on the Ocean cluster.
        """
elif False:
    OceanLaunchSpecAutoscaleHeadroomsAutomaticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecAutoscaleHeadroomsAutomaticArgs:
    def __init__(__self__, *,
                 auto_headroom_percentage: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] auto_headroom_percentage: Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.`is_enabled` = true is set on the Ocean cluster.
        """
        if auto_headroom_percentage is not None:
            pulumi.set(__self__, "auto_headroom_percentage", auto_headroom_percentage)

    @property
    @pulumi.getter(name="autoHeadroomPercentage")
    def auto_headroom_percentage(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.`is_enabled` = true is set on the Ocean cluster.
        """
        return pulumi.get(self, "auto_headroom_percentage")

    @auto_headroom_percentage.setter
    def auto_headroom_percentage(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "auto_headroom_percentage", value)


if not MYPY:
    class OceanLaunchSpecCreateOptionsArgsDict(TypedDict):
        initial_nodes: NotRequired[pulumi.Input[builtins.int]]
        """
        When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group.
        """
elif False:
    OceanLaunchSpecCreateOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecCreateOptionsArgs:
    def __init__(__self__, *,
                 initial_nodes: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] initial_nodes: When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group.
        """
        if initial_nodes is not None:
            pulumi.set(__self__, "initial_nodes", initial_nodes)

    @property
    @pulumi.getter(name="initialNodes")
    def initial_nodes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group.
        """
        return pulumi.get(self, "initial_nodes")

    @initial_nodes.setter
    def initial_nodes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "initial_nodes", value)


if not MYPY:
    class OceanLaunchSpecLabelArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[builtins.str]]
        """
        The label key.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        The label value.
        """
elif False:
    OceanLaunchSpecLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecLabelArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] key: The label key.
        :param pulumi.Input[builtins.str] value: The label value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The label key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The label value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OceanLaunchSpecMetadataArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[builtins.str]]
        """
        The metadata key.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        The metadata value.
        """
elif False:
    OceanLaunchSpecMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecMetadataArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] key: The metadata key.
        :param pulumi.Input[builtins.str] value: The metadata value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The metadata key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The metadata value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OceanLaunchSpecNetworkInterfaceArgsDict(TypedDict):
        network: pulumi.Input[builtins.str]
        """
        The name of the network.
        """
        access_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAccessConfigArgsDict']]]]
        """
        The network protocol of the VNG.
        """
        alias_ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAliasIpRangeArgsDict']]]]
        """
        use the imported node pool’s associated aliasIpRange to assign secondary IP addresses to the nodes. Cannot be changed after VNG creation.
        """
        project_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Use a network resource from a different project. Set the project identifier to use its network resource. This parameter is relevant only if the network resource is in a different project.
        """
elif False:
    OceanLaunchSpecNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecNetworkInterfaceArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[builtins.str],
                 access_configs: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAccessConfigArgs']]]] = None,
                 alias_ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAliasIpRangeArgs']]]] = None,
                 project_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] network: The name of the network.
        :param pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAccessConfigArgs']]] access_configs: The network protocol of the VNG.
        :param pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAliasIpRangeArgs']]] alias_ip_ranges: use the imported node pool’s associated aliasIpRange to assign secondary IP addresses to the nodes. Cannot be changed after VNG creation.
        :param pulumi.Input[builtins.str] project_id: Use a network resource from a different project. Set the project identifier to use its network resource. This parameter is relevant only if the network resource is in a different project.
        """
        pulumi.set(__self__, "network", network)
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if alias_ip_ranges is not None:
            pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[builtins.str]:
        """
        The name of the network.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAccessConfigArgs']]]]:
        """
        The network protocol of the VNG.
        """
        return pulumi.get(self, "access_configs")

    @access_configs.setter
    def access_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAccessConfigArgs']]]]):
        pulumi.set(self, "access_configs", value)

    @property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAliasIpRangeArgs']]]]:
        """
        use the imported node pool’s associated aliasIpRange to assign secondary IP addresses to the nodes. Cannot be changed after VNG creation.
        """
        return pulumi.get(self, "alias_ip_ranges")

    @alias_ip_ranges.setter
    def alias_ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAliasIpRangeArgs']]]]):
        pulumi.set(self, "alias_ip_ranges", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Use a network resource from a different project. Set the project identifier to use its network resource. This parameter is relevant only if the network resource is in a different project.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class OceanLaunchSpecNetworkInterfaceAccessConfigArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the access configuration.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of the access configuration.
        """
elif False:
    OceanLaunchSpecNetworkInterfaceAccessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecNetworkInterfaceAccessConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: The name of the access configuration.
        :param pulumi.Input[builtins.str] type: The type of the access configuration.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the access configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of the access configuration.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class OceanLaunchSpecNetworkInterfaceAliasIpRangeArgsDict(TypedDict):
        ip_cidr_range: pulumi.Input[builtins.str]
        """
        specify the IP address range in CIDR notation that can be used for the alias IP addresses associated with the imported node pool.
        """
        subnetwork_range_name: pulumi.Input[builtins.str]
        """
        specify the IP address range for the subnet secondary IP range.
        """
elif False:
    OceanLaunchSpecNetworkInterfaceAliasIpRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecNetworkInterfaceAliasIpRangeArgs:
    def __init__(__self__, *,
                 ip_cidr_range: pulumi.Input[builtins.str],
                 subnetwork_range_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] ip_cidr_range: specify the IP address range in CIDR notation that can be used for the alias IP addresses associated with the imported node pool.
        :param pulumi.Input[builtins.str] subnetwork_range_name: specify the IP address range for the subnet secondary IP range.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> pulumi.Input[builtins.str]:
        """
        specify the IP address range in CIDR notation that can be used for the alias IP addresses associated with the imported node pool.
        """
        return pulumi.get(self, "ip_cidr_range")

    @ip_cidr_range.setter
    def ip_cidr_range(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ip_cidr_range", value)

    @property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> pulumi.Input[builtins.str]:
        """
        specify the IP address range for the subnet secondary IP range.
        """
        return pulumi.get(self, "subnetwork_range_name")

    @subnetwork_range_name.setter
    def subnetwork_range_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subnetwork_range_name", value)


if not MYPY:
    class OceanLaunchSpecResourceLimitsArgsDict(TypedDict):
        max_instance_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Option to set a maximum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
        """
        min_instance_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Option to set a minimum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
        """
elif False:
    OceanLaunchSpecResourceLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecResourceLimitsArgs:
    def __init__(__self__, *,
                 max_instance_count: Optional[pulumi.Input[builtins.int]] = None,
                 min_instance_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] max_instance_count: Option to set a maximum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
        :param pulumi.Input[builtins.int] min_instance_count: Option to set a minimum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
        """
        if max_instance_count is not None:
            pulumi.set(__self__, "max_instance_count", max_instance_count)
        if min_instance_count is not None:
            pulumi.set(__self__, "min_instance_count", min_instance_count)

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Option to set a maximum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
        """
        return pulumi.get(self, "max_instance_count")

    @max_instance_count.setter
    def max_instance_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_instance_count", value)

    @property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Option to set a minimum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
        """
        return pulumi.get(self, "min_instance_count")

    @min_instance_count.setter
    def min_instance_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_instance_count", value)


if not MYPY:
    class OceanLaunchSpecSchedulingTaskArgsDict(TypedDict):
        cron_expression: pulumi.Input[builtins.str]
        """
        A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
        """
        is_enabled: pulumi.Input[builtins.bool]
        """
        Describes whether the task is enabled. When `true`, the task runs. When `false`, it does not run.
        """
        task_type: pulumi.Input[builtins.str]
        """
        The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
        """
        task_headrooms: NotRequired[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgsDict']]]]
        """
        The config of this scheduled task. Depends on the value of taskType.
        """
elif False:
    OceanLaunchSpecSchedulingTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecSchedulingTaskArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[builtins.str],
                 is_enabled: pulumi.Input[builtins.bool],
                 task_type: pulumi.Input[builtins.str],
                 task_headrooms: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] cron_expression: A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
        :param pulumi.Input[builtins.bool] is_enabled: Describes whether the task is enabled. When `true`, the task runs. When `false`, it does not run.
        :param pulumi.Input[builtins.str] task_type: The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
        :param pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]] task_headrooms: The config of this scheduled task. Depends on the value of taskType.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "task_type", task_type)
        if task_headrooms is not None:
            pulumi.set(__self__, "task_headrooms", task_headrooms)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[builtins.str]:
        """
        A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Describes whether the task is enabled. When `true`, the task runs. When `false`, it does not run.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input[builtins.str]:
        """
        The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "task_type", value)

    @property
    @pulumi.getter(name="taskHeadrooms")
    def task_headrooms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]]:
        """
        The config of this scheduled task. Depends on the value of taskType.
        """
        return pulumi.get(self, "task_headrooms")

    @task_headrooms.setter
    def task_headrooms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]]):
        pulumi.set(self, "task_headrooms", value)


if not MYPY:
    class OceanLaunchSpecSchedulingTaskTaskHeadroomArgsDict(TypedDict):
        num_of_units: pulumi.Input[builtins.int]
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        cpu_per_unit: NotRequired[pulumi.Input[builtins.int]]
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        gpu_per_unit: NotRequired[pulumi.Input[builtins.int]]
        """
        Optionally configure the number of GPUS to allocate for each headroom unit.
        """
        memory_per_unit: NotRequired[pulumi.Input[builtins.int]]
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
elif False:
    OceanLaunchSpecSchedulingTaskTaskHeadroomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecSchedulingTaskTaskHeadroomArgs:
    def __init__(__self__, *,
                 num_of_units: pulumi.Input[builtins.int],
                 cpu_per_unit: Optional[pulumi.Input[builtins.int]] = None,
                 gpu_per_unit: Optional[pulumi.Input[builtins.int]] = None,
                 memory_per_unit: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        :param pulumi.Input[builtins.int] cpu_per_unit: Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[builtins.int] gpu_per_unit: Optionally configure the number of GPUS to allocate for each headroom unit.
        :param pulumi.Input[builtins.int] memory_per_unit: Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        pulumi.set(__self__, "num_of_units", num_of_units)
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> pulumi.Input[builtins.int]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "num_of_units", value)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optionally configure the number of GPUS to allocate for each headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @gpu_per_unit.setter
    def gpu_per_unit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "gpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "memory_per_unit", value)


if not MYPY:
    class OceanLaunchSpecShieldedInstanceConfigArgsDict(TypedDict):
        enable_integrity_monitoring: NotRequired[pulumi.Input[builtins.bool]]
        """
        Boolean. Enable the integrity monitoring parameter on the GCP instances.
        """
        enable_secure_boot: NotRequired[pulumi.Input[builtins.bool]]
        """
        Boolean. Enable the secure boot parameter on the GCP instances.
        """
elif False:
    OceanLaunchSpecShieldedInstanceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecShieldedInstanceConfigArgs:
    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_secure_boot: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] enable_integrity_monitoring: Boolean. Enable the integrity monitoring parameter on the GCP instances.
        :param pulumi.Input[builtins.bool] enable_secure_boot: Boolean. Enable the secure boot parameter on the GCP instances.
        """
        if enable_integrity_monitoring is not None:
            pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)

    @property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Boolean. Enable the integrity monitoring parameter on the GCP instances.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @enable_integrity_monitoring.setter
    def enable_integrity_monitoring(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_integrity_monitoring", value)

    @property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Boolean. Enable the secure boot parameter on the GCP instances.
        """
        return pulumi.get(self, "enable_secure_boot")

    @enable_secure_boot.setter
    def enable_secure_boot(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_secure_boot", value)


if not MYPY:
    class OceanLaunchSpecStorageArgsDict(TypedDict):
        local_ssd_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Defines the number of local SSDs to be attached per node for this VNG.
        """
elif False:
    OceanLaunchSpecStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecStorageArgs:
    def __init__(__self__, *,
                 local_ssd_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] local_ssd_count: Defines the number of local SSDs to be attached per node for this VNG.
        """
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Defines the number of local SSDs to be attached per node for this VNG.
        """
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "local_ssd_count", value)


if not MYPY:
    class OceanLaunchSpecStrategyArgsDict(TypedDict):
        preemptible_percentage: NotRequired[pulumi.Input[builtins.int]]
        """
        Defines the desired preemptible percentage for this launch specification.
        """
        scaling_orientation: NotRequired[pulumi.Input[builtins.str]]
        """
        Valid Values: `"cost", "availability", "balanced"`. Set this value to control the approach that Ocean takes when launching nodes.
        """
elif False:
    OceanLaunchSpecStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecStrategyArgs:
    def __init__(__self__, *,
                 preemptible_percentage: Optional[pulumi.Input[builtins.int]] = None,
                 scaling_orientation: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] preemptible_percentage: Defines the desired preemptible percentage for this launch specification.
        :param pulumi.Input[builtins.str] scaling_orientation: Valid Values: `"cost", "availability", "balanced"`. Set this value to control the approach that Ocean takes when launching nodes.
        """
        if preemptible_percentage is not None:
            pulumi.set(__self__, "preemptible_percentage", preemptible_percentage)
        if scaling_orientation is not None:
            pulumi.set(__self__, "scaling_orientation", scaling_orientation)

    @property
    @pulumi.getter(name="preemptiblePercentage")
    def preemptible_percentage(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Defines the desired preemptible percentage for this launch specification.
        """
        return pulumi.get(self, "preemptible_percentage")

    @preemptible_percentage.setter
    def preemptible_percentage(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "preemptible_percentage", value)

    @property
    @pulumi.getter(name="scalingOrientation")
    def scaling_orientation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Valid Values: `"cost", "availability", "balanced"`. Set this value to control the approach that Ocean takes when launching nodes.
        """
        return pulumi.get(self, "scaling_orientation")

    @scaling_orientation.setter
    def scaling_orientation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scaling_orientation", value)


if not MYPY:
    class OceanLaunchSpecTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[builtins.str]]
        """
        The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
        """
        key: NotRequired[pulumi.Input[builtins.str]]
        """
        The taint key.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        The taint value.
        """
elif False:
    OceanLaunchSpecTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[builtins.str]] = None,
                 key: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] effect: The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
        :param pulumi.Input[builtins.str] key: The taint key.
        :param pulumi.Input[builtins.str] value: The taint value.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The taint key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The taint value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OceanLaunchSpecUpdatePolicyArgsDict(TypedDict):
        should_roll: pulumi.Input[builtins.bool]
        """
        Enables the roll.
        """
        roll_config: NotRequired[pulumi.Input['OceanLaunchSpecUpdatePolicyRollConfigArgsDict']]
        """
        Holds the roll configuration.
        """
elif False:
    OceanLaunchSpecUpdatePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecUpdatePolicyArgs:
    def __init__(__self__, *,
                 should_roll: pulumi.Input[builtins.bool],
                 roll_config: Optional[pulumi.Input['OceanLaunchSpecUpdatePolicyRollConfigArgs']] = None):
        """
        :param pulumi.Input[builtins.bool] should_roll: Enables the roll.
        :param pulumi.Input['OceanLaunchSpecUpdatePolicyRollConfigArgs'] roll_config: Holds the roll configuration.
        """
        pulumi.set(__self__, "should_roll", should_roll)
        if roll_config is not None:
            pulumi.set(__self__, "roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> pulumi.Input[builtins.bool]:
        """
        Enables the roll.
        """
        return pulumi.get(self, "should_roll")

    @should_roll.setter
    def should_roll(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "should_roll", value)

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional[pulumi.Input['OceanLaunchSpecUpdatePolicyRollConfigArgs']]:
        """
        Holds the roll configuration.
        """
        return pulumi.get(self, "roll_config")

    @roll_config.setter
    def roll_config(self, value: Optional[pulumi.Input['OceanLaunchSpecUpdatePolicyRollConfigArgs']]):
        pulumi.set(self, "roll_config", value)


if not MYPY:
    class OceanLaunchSpecUpdatePolicyRollConfigArgsDict(TypedDict):
        batch_size_percentage: pulumi.Input[builtins.int]
        """
        Sets the percentage of the instances to deploy in each batch.
        """
elif False:
    OceanLaunchSpecUpdatePolicyRollConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecUpdatePolicyRollConfigArgs:
    def __init__(__self__, *,
                 batch_size_percentage: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] batch_size_percentage: Sets the percentage of the instances to deploy in each batch.
        """
        pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> pulumi.Input[builtins.int]:
        """
        Sets the percentage of the instances to deploy in each batch.
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "batch_size_percentage", value)


