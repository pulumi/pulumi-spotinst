# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'ElastigroupBackendServiceArgs',
    'ElastigroupBackendServiceNamedPortArgs',
    'ElastigroupDiskArgs',
    'ElastigroupDiskInitializeParamArgs',
    'ElastigroupGpuArgs',
    'ElastigroupInstanceTypesCustomArgs',
    'ElastigroupIntegrationDockerSwarmArgs',
    'ElastigroupIntegrationGkeArgs',
    'ElastigroupIntegrationGkeAutoscaleDownArgs',
    'ElastigroupIntegrationGkeAutoscaleHeadroomArgs',
    'ElastigroupIntegrationGkeAutoscaleLabelArgs',
    'ElastigroupLabelArgs',
    'ElastigroupMetadataArgs',
    'ElastigroupNetworkInterfaceArgs',
    'ElastigroupNetworkInterfaceAccessConfigArgs',
    'ElastigroupNetworkInterfaceAliasIpRangeArgs',
    'ElastigroupScalingDownPolicyArgs',
    'ElastigroupScalingDownPolicyDimensionArgs',
    'ElastigroupScalingUpPolicyArgs',
    'ElastigroupScalingUpPolicyDimensionArgs',
    'OceanImportAutoscalerArgs',
    'OceanImportAutoscalerDownArgs',
    'OceanImportAutoscalerHeadroomArgs',
    'OceanImportAutoscalerResourceLimitsArgs',
    'OceanImportBackendServiceArgs',
    'OceanImportBackendServiceNamedPortArgs',
    'OceanImportScheduledTaskArgs',
    'OceanImportScheduledTaskShutdownHoursArgs',
    'OceanImportScheduledTaskTaskArgs',
    'OceanImportScheduledTaskTaskTaskParametersArgs',
    'OceanImportScheduledTaskTaskTaskParametersClusterRollArgs',
    'OceanImportShieldedInstanceConfigArgs',
    'OceanImportStrategyArgs',
    'OceanImportUpdatePolicyArgs',
    'OceanImportUpdatePolicyRollConfigArgs',
    'OceanLaunchSpecAutoscaleHeadroomArgs',
    'OceanLaunchSpecAutoscaleHeadroomsAutomaticArgs',
    'OceanLaunchSpecLabelArgs',
    'OceanLaunchSpecMetadataArgs',
    'OceanLaunchSpecNetworkInterfaceArgs',
    'OceanLaunchSpecNetworkInterfaceAccessConfigArgs',
    'OceanLaunchSpecNetworkInterfaceAliasIpRangeArgs',
    'OceanLaunchSpecResourceLimitsArgs',
    'OceanLaunchSpecSchedulingTaskArgs',
    'OceanLaunchSpecSchedulingTaskTaskHeadroomArgs',
    'OceanLaunchSpecShieldedInstanceConfigArgs',
    'OceanLaunchSpecStorageArgs',
    'OceanLaunchSpecStrategyArgs',
    'OceanLaunchSpecTaintArgs',
    'OceanLaunchSpecUpdatePolicyArgs',
    'OceanLaunchSpecUpdatePolicyRollConfigArgs',
]

@pulumi.input_type
class ElastigroupBackendServiceArgs:
    def __init__(__self__, *,
                 service_name: pulumi.Input[str],
                 location_type: Optional[pulumi.Input[str]] = None,
                 named_ports: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupBackendServiceNamedPortArgs']]]] = None,
                 scheme: Optional[pulumi.Input[str]] = None):
        ElastigroupBackendServiceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service_name=service_name,
            location_type=location_type,
            named_ports=named_ports,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service_name: pulumi.Input[str],
             location_type: Optional[pulumi.Input[str]] = None,
             named_ports: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupBackendServiceNamedPortArgs']]]] = None,
             scheme: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("service_name", service_name)
        if location_type is not None:
            _setter("location_type", location_type)
        if named_ports is not None:
            _setter("named_ports", named_ports)
        if scheme is not None:
            _setter("scheme", scheme)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="locationType")
    def location_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "location_type")

    @location_type.setter
    def location_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location_type", value)

    @property
    @pulumi.getter(name="namedPorts")
    def named_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupBackendServiceNamedPortArgs']]]]:
        return pulumi.get(self, "named_ports")

    @named_ports.setter
    def named_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupBackendServiceNamedPortArgs']]]]):
        pulumi.set(self, "named_ports", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)


@pulumi.input_type
class ElastigroupBackendServiceNamedPortArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 ports: pulumi.Input[Sequence[pulumi.Input[str]]]):
        ElastigroupBackendServiceNamedPortArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            ports=ports,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             ports: pulumi.Input[Sequence[pulumi.Input[str]]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("ports", ports)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ports", value)


@pulumi.input_type
class ElastigroupDiskArgs:
    def __init__(__self__, *,
                 auto_delete: Optional[pulumi.Input[bool]] = None,
                 boot: Optional[pulumi.Input[bool]] = None,
                 device_name: Optional[pulumi.Input[str]] = None,
                 initialize_params: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupDiskInitializeParamArgs']]]] = None,
                 interface: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        ElastigroupDiskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_delete=auto_delete,
            boot=boot,
            device_name=device_name,
            initialize_params=initialize_params,
            interface=interface,
            mode=mode,
            source=source,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_delete: Optional[pulumi.Input[bool]] = None,
             boot: Optional[pulumi.Input[bool]] = None,
             device_name: Optional[pulumi.Input[str]] = None,
             initialize_params: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupDiskInitializeParamArgs']]]] = None,
             interface: Optional[pulumi.Input[str]] = None,
             mode: Optional[pulumi.Input[str]] = None,
             source: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if auto_delete is not None:
            _setter("auto_delete", auto_delete)
        if boot is not None:
            _setter("boot", boot)
        if device_name is not None:
            _setter("device_name", device_name)
        if initialize_params is not None:
            _setter("initialize_params", initialize_params)
        if interface is not None:
            _setter("interface", interface)
        if mode is not None:
            _setter("mode", mode)
        if source is not None:
            _setter("source", source)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "auto_delete")

    @auto_delete.setter
    def auto_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_delete", value)

    @property
    @pulumi.getter
    def boot(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "boot")

    @boot.setter
    def boot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boot", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupDiskInitializeParamArgs']]]]:
        return pulumi.get(self, "initialize_params")

    @initialize_params.setter
    def initialize_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupDiskInitializeParamArgs']]]]):
        pulumi.set(self, "initialize_params", value)

    @property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ElastigroupDiskInitializeParamArgs:
    def __init__(__self__, *,
                 source_image: pulumi.Input[str],
                 disk_size_gb: Optional[pulumi.Input[str]] = None,
                 disk_type: Optional[pulumi.Input[str]] = None):
        ElastigroupDiskInitializeParamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_image=source_image,
            disk_size_gb=disk_size_gb,
            disk_type=disk_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_image: pulumi.Input[str],
             disk_size_gb: Optional[pulumi.Input[str]] = None,
             disk_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("source_image", source_image)
        if disk_size_gb is not None:
            _setter("disk_size_gb", disk_size_gb)
        if disk_type is not None:
            _setter("disk_type", disk_type)

    @property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> pulumi.Input[str]:
        return pulumi.get(self, "source_image")

    @source_image.setter
    def source_image(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_image", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_type", value)


@pulumi.input_type
class ElastigroupGpuArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 type: pulumi.Input[str]):
        ElastigroupGpuArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: pulumi.Input[int],
             type: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("count", count)
        _setter("type", type)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ElastigroupInstanceTypesCustomArgs:
    def __init__(__self__, *,
                 memory_gib: pulumi.Input[int],
                 vcpu: pulumi.Input[int]):
        ElastigroupInstanceTypesCustomArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            memory_gib=memory_gib,
            vcpu=vcpu,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             memory_gib: pulumi.Input[int],
             vcpu: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("memory_gib", memory_gib)
        _setter("vcpu", vcpu)

    @property
    @pulumi.getter(name="memoryGib")
    def memory_gib(self) -> pulumi.Input[int]:
        return pulumi.get(self, "memory_gib")

    @memory_gib.setter
    def memory_gib(self, value: pulumi.Input[int]):
        pulumi.set(self, "memory_gib", value)

    @property
    @pulumi.getter
    def vcpu(self) -> pulumi.Input[int]:
        return pulumi.get(self, "vcpu")

    @vcpu.setter
    def vcpu(self, value: pulumi.Input[int]):
        pulumi.set(self, "vcpu", value)


@pulumi.input_type
class ElastigroupIntegrationDockerSwarmArgs:
    def __init__(__self__, *,
                 master_host: pulumi.Input[str],
                 master_port: pulumi.Input[int]):
        ElastigroupIntegrationDockerSwarmArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            master_host=master_host,
            master_port=master_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             master_host: pulumi.Input[str],
             master_port: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("master_host", master_host)
        _setter("master_port", master_port)

    @property
    @pulumi.getter(name="masterHost")
    def master_host(self) -> pulumi.Input[str]:
        return pulumi.get(self, "master_host")

    @master_host.setter
    def master_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "master_host", value)

    @property
    @pulumi.getter(name="masterPort")
    def master_port(self) -> pulumi.Input[int]:
        return pulumi.get(self, "master_port")

    @master_port.setter
    def master_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "master_port", value)


@pulumi.input_type
class ElastigroupIntegrationGkeArgs:
    def __init__(__self__, *,
                 auto_update: Optional[pulumi.Input[bool]] = None,
                 autoscale_cooldown: Optional[pulumi.Input[int]] = None,
                 autoscale_down: Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleDownArgs']] = None,
                 autoscale_headroom: Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleHeadroomArgs']] = None,
                 autoscale_is_auto_config: Optional[pulumi.Input[bool]] = None,
                 autoscale_is_enabled: Optional[pulumi.Input[bool]] = None,
                 autoscale_labels: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationGkeAutoscaleLabelArgs']]]] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] autoscale_cooldown: The amount of time, in seconds, after a scaling activity completes before any further trigger-related scaling activities can start.
        :param pulumi.Input['ElastigroupIntegrationGkeAutoscaleDownArgs'] autoscale_down: Enabling scale down.
        :param pulumi.Input['ElastigroupIntegrationGkeAutoscaleHeadroomArgs'] autoscale_headroom: Headroom for the cluster.
        :param pulumi.Input[bool] autoscale_is_enabled: Specifies whether the auto scaling feature is enabled.
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationGkeAutoscaleLabelArgs']]] autoscale_labels: Labels to assign to the resource.
        :param pulumi.Input[str] cluster_id: The name of the GKE cluster you wish to import.
        :param pulumi.Input[str] location: The location of your GKE cluster.
        """
        ElastigroupIntegrationGkeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_update=auto_update,
            autoscale_cooldown=autoscale_cooldown,
            autoscale_down=autoscale_down,
            autoscale_headroom=autoscale_headroom,
            autoscale_is_auto_config=autoscale_is_auto_config,
            autoscale_is_enabled=autoscale_is_enabled,
            autoscale_labels=autoscale_labels,
            cluster_id=cluster_id,
            location=location,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_update: Optional[pulumi.Input[bool]] = None,
             autoscale_cooldown: Optional[pulumi.Input[int]] = None,
             autoscale_down: Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleDownArgs']] = None,
             autoscale_headroom: Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleHeadroomArgs']] = None,
             autoscale_is_auto_config: Optional[pulumi.Input[bool]] = None,
             autoscale_is_enabled: Optional[pulumi.Input[bool]] = None,
             autoscale_labels: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationGkeAutoscaleLabelArgs']]]] = None,
             cluster_id: Optional[pulumi.Input[str]] = None,
             location: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if auto_update is not None:
            _setter("auto_update", auto_update)
        if autoscale_cooldown is not None:
            _setter("autoscale_cooldown", autoscale_cooldown)
        if autoscale_down is not None:
            _setter("autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            _setter("autoscale_headroom", autoscale_headroom)
        if autoscale_is_auto_config is not None:
            _setter("autoscale_is_auto_config", autoscale_is_auto_config)
        if autoscale_is_enabled is not None:
            _setter("autoscale_is_enabled", autoscale_is_enabled)
        if autoscale_labels is not None:
            _setter("autoscale_labels", autoscale_labels)
        if cluster_id is not None:
            _setter("cluster_id", cluster_id)
        if location is not None:
            _setter("location", location)

    @property
    @pulumi.getter(name="autoUpdate")
    def auto_update(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "auto_update")

    @auto_update.setter
    def auto_update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_update", value)

    @property
    @pulumi.getter(name="autoscaleCooldown")
    def autoscale_cooldown(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, after a scaling activity completes before any further trigger-related scaling activities can start.
        """
        return pulumi.get(self, "autoscale_cooldown")

    @autoscale_cooldown.setter
    def autoscale_cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autoscale_cooldown", value)

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleDownArgs']]:
        """
        Enabling scale down.
        """
        return pulumi.get(self, "autoscale_down")

    @autoscale_down.setter
    def autoscale_down(self, value: Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleDownArgs']]):
        pulumi.set(self, "autoscale_down", value)

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleHeadroomArgs']]:
        """
        Headroom for the cluster.
        """
        return pulumi.get(self, "autoscale_headroom")

    @autoscale_headroom.setter
    def autoscale_headroom(self, value: Optional[pulumi.Input['ElastigroupIntegrationGkeAutoscaleHeadroomArgs']]):
        pulumi.set(self, "autoscale_headroom", value)

    @property
    @pulumi.getter(name="autoscaleIsAutoConfig")
    def autoscale_is_auto_config(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "autoscale_is_auto_config")

    @autoscale_is_auto_config.setter
    def autoscale_is_auto_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale_is_auto_config", value)

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the auto scaling feature is enabled.
        """
        return pulumi.get(self, "autoscale_is_enabled")

    @autoscale_is_enabled.setter
    def autoscale_is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale_is_enabled", value)

    @property
    @pulumi.getter(name="autoscaleLabels")
    def autoscale_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationGkeAutoscaleLabelArgs']]]]:
        """
        Labels to assign to the resource.
        """
        return pulumi.get(self, "autoscale_labels")

    @autoscale_labels.setter
    def autoscale_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationGkeAutoscaleLabelArgs']]]]):
        pulumi.set(self, "autoscale_labels", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the GKE cluster you wish to import.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        The location of your GKE cluster.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)


@pulumi.input_type
class ElastigroupIntegrationGkeAutoscaleDownArgs:
    def __init__(__self__, *,
                 evaluation_periods: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] evaluation_periods: Amount of cooldown evaluation periods for scale down.
        """
        ElastigroupIntegrationGkeAutoscaleDownArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            evaluation_periods=evaluation_periods,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             evaluation_periods: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if evaluation_periods is not None:
            _setter("evaluation_periods", evaluation_periods)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        """
        Amount of cooldown evaluation periods for scale down.
        """
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)


@pulumi.input_type
class ElastigroupIntegrationGkeAutoscaleHeadroomArgs:
    def __init__(__self__, *,
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None,
                 num_of_units: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] cpu_per_unit: Cpu units for compute.
        :param pulumi.Input[int] memory_per_unit: RAM units for compute.
        :param pulumi.Input[int] num_of_units: Amount of units for compute.
        """
        ElastigroupIntegrationGkeAutoscaleHeadroomArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_per_unit=cpu_per_unit,
            memory_per_unit=memory_per_unit,
            num_of_units=num_of_units,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_per_unit: Optional[pulumi.Input[int]] = None,
             memory_per_unit: Optional[pulumi.Input[int]] = None,
             num_of_units: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cpu_per_unit is not None:
            _setter("cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            _setter("memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            _setter("num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Cpu units for compute.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        RAM units for compute.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[pulumi.Input[int]]:
        """
        Amount of units for compute.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_of_units", value)


@pulumi.input_type
class ElastigroupIntegrationGkeAutoscaleLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        ElastigroupIntegrationGkeAutoscaleLabelArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ElastigroupLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        ElastigroupLabelArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ElastigroupMetadataArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        ElastigroupMetadataArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ElastigroupNetworkInterfaceArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[str],
                 access_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAccessConfigArgs']]]] = None,
                 alias_ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAliasIpRangeArgs']]]] = None):
        ElastigroupNetworkInterfaceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network=network,
            access_configs=access_configs,
            alias_ip_ranges=alias_ip_ranges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network: pulumi.Input[str],
             access_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAccessConfigArgs']]]] = None,
             alias_ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAliasIpRangeArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("network", network)
        if access_configs is not None:
            _setter("access_configs", access_configs)
        if alias_ip_ranges is not None:
            _setter("alias_ip_ranges", alias_ip_ranges)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[str]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[str]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAccessConfigArgs']]]]:
        return pulumi.get(self, "access_configs")

    @access_configs.setter
    def access_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAccessConfigArgs']]]]):
        pulumi.set(self, "access_configs", value)

    @property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAliasIpRangeArgs']]]]:
        return pulumi.get(self, "alias_ip_ranges")

    @alias_ip_ranges.setter
    def alias_ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupNetworkInterfaceAliasIpRangeArgs']]]]):
        pulumi.set(self, "alias_ip_ranges", value)


@pulumi.input_type
class ElastigroupNetworkInterfaceAccessConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        ElastigroupNetworkInterfaceAccessConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ElastigroupNetworkInterfaceAliasIpRangeArgs:
    def __init__(__self__, *,
                 ip_cidr_range: pulumi.Input[str],
                 subnetwork_range_name: pulumi.Input[str]):
        ElastigroupNetworkInterfaceAliasIpRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_cidr_range=ip_cidr_range,
            subnetwork_range_name=subnetwork_range_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_cidr_range: pulumi.Input[str],
             subnetwork_range_name: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ip_cidr_range", ip_cidr_range)
        _setter("subnetwork_range_name", subnetwork_range_name)

    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> pulumi.Input[str]:
        return pulumi.get(self, "ip_cidr_range")

    @ip_cidr_range.setter
    def ip_cidr_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_cidr_range", value)

    @property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "subnetwork_range_name")

    @subnetwork_range_name.setter
    def subnetwork_range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnetwork_range_name", value)


@pulumi.input_type
class ElastigroupScalingDownPolicyArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 policy_name: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 unit: pulumi.Input[str],
                 action_type: Optional[pulumi.Input[str]] = None,
                 adjustment: Optional[pulumi.Input[int]] = None,
                 cooldown: Optional[pulumi.Input[int]] = None,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgs']]]] = None,
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 statistic: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] evaluation_periods: Amount of cooldown evaluation periods for scale down.
        """
        ElastigroupScalingDownPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_name=metric_name,
            namespace=namespace,
            policy_name=policy_name,
            threshold=threshold,
            unit=unit,
            action_type=action_type,
            adjustment=adjustment,
            cooldown=cooldown,
            dimensions=dimensions,
            evaluation_periods=evaluation_periods,
            operator=operator,
            period=period,
            source=source,
            statistic=statistic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_name: pulumi.Input[str],
             namespace: pulumi.Input[str],
             policy_name: pulumi.Input[str],
             threshold: pulumi.Input[float],
             unit: pulumi.Input[str],
             action_type: Optional[pulumi.Input[str]] = None,
             adjustment: Optional[pulumi.Input[int]] = None,
             cooldown: Optional[pulumi.Input[int]] = None,
             dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgs']]]] = None,
             evaluation_periods: Optional[pulumi.Input[int]] = None,
             operator: Optional[pulumi.Input[str]] = None,
             period: Optional[pulumi.Input[int]] = None,
             source: Optional[pulumi.Input[str]] = None,
             statistic: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric_name", metric_name)
        _setter("namespace", namespace)
        _setter("policy_name", policy_name)
        _setter("threshold", threshold)
        _setter("unit", unit)
        if action_type is not None:
            _setter("action_type", action_type)
        if adjustment is not None:
            _setter("adjustment", adjustment)
        if cooldown is not None:
            _setter("cooldown", cooldown)
        if dimensions is not None:
            _setter("dimensions", dimensions)
        if evaluation_periods is not None:
            _setter("evaluation_periods", evaluation_periods)
        if operator is not None:
            _setter("operator", operator)
        if period is not None:
            _setter("period", period)
        if source is not None:
            _setter("source", source)
        if statistic is not None:
            _setter("statistic", statistic)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_name", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgs']]]]:
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        """
        Amount of cooldown evaluation periods for scale down.
        """
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statistic", value)


@pulumi.input_type
class ElastigroupScalingDownPolicyDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        ElastigroupScalingDownPolicyDimensionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ElastigroupScalingUpPolicyArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 policy_name: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 unit: pulumi.Input[str],
                 action_type: Optional[pulumi.Input[str]] = None,
                 adjustment: Optional[pulumi.Input[int]] = None,
                 cooldown: Optional[pulumi.Input[int]] = None,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgs']]]] = None,
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 statistic: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] evaluation_periods: Amount of cooldown evaluation periods for scale down.
        """
        ElastigroupScalingUpPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_name=metric_name,
            namespace=namespace,
            policy_name=policy_name,
            threshold=threshold,
            unit=unit,
            action_type=action_type,
            adjustment=adjustment,
            cooldown=cooldown,
            dimensions=dimensions,
            evaluation_periods=evaluation_periods,
            operator=operator,
            period=period,
            source=source,
            statistic=statistic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_name: pulumi.Input[str],
             namespace: pulumi.Input[str],
             policy_name: pulumi.Input[str],
             threshold: pulumi.Input[float],
             unit: pulumi.Input[str],
             action_type: Optional[pulumi.Input[str]] = None,
             adjustment: Optional[pulumi.Input[int]] = None,
             cooldown: Optional[pulumi.Input[int]] = None,
             dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgs']]]] = None,
             evaluation_periods: Optional[pulumi.Input[int]] = None,
             operator: Optional[pulumi.Input[str]] = None,
             period: Optional[pulumi.Input[int]] = None,
             source: Optional[pulumi.Input[str]] = None,
             statistic: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric_name", metric_name)
        _setter("namespace", namespace)
        _setter("policy_name", policy_name)
        _setter("threshold", threshold)
        _setter("unit", unit)
        if action_type is not None:
            _setter("action_type", action_type)
        if adjustment is not None:
            _setter("adjustment", adjustment)
        if cooldown is not None:
            _setter("cooldown", cooldown)
        if dimensions is not None:
            _setter("dimensions", dimensions)
        if evaluation_periods is not None:
            _setter("evaluation_periods", evaluation_periods)
        if operator is not None:
            _setter("operator", operator)
        if period is not None:
            _setter("period", period)
        if source is not None:
            _setter("source", source)
        if statistic is not None:
            _setter("statistic", statistic)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_name", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgs']]]]:
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        """
        Amount of cooldown evaluation periods for scale down.
        """
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statistic", value)


@pulumi.input_type
class ElastigroupScalingUpPolicyDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        ElastigroupScalingUpPolicyDimensionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class OceanImportAutoscalerArgs:
    def __init__(__self__, *,
                 auto_headroom_percentage: Optional[pulumi.Input[int]] = None,
                 cooldown: Optional[pulumi.Input[int]] = None,
                 down: Optional[pulumi.Input['OceanImportAutoscalerDownArgs']] = None,
                 enable_automatic_and_manual_headroom: Optional[pulumi.Input[bool]] = None,
                 headroom: Optional[pulumi.Input['OceanImportAutoscalerHeadroomArgs']] = None,
                 is_auto_config: Optional[pulumi.Input[bool]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 resource_limits: Optional[pulumi.Input['OceanImportAutoscalerResourceLimitsArgs']] = None):
        """
        :param pulumi.Input[int] auto_headroom_percentage: Optionally set the auto headroom percentage, set a number between 0-200 to control the headroom % from the cluster. Relevant when isAutoConfig=true.
        :param pulumi.Input[int] cooldown: Cooldown period between scaling actions.
        :param pulumi.Input['OceanImportAutoscalerDownArgs'] down: Auto Scaling scale down operations.
        :param pulumi.Input[bool] enable_automatic_and_manual_headroom: enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
        :param pulumi.Input['OceanImportAutoscalerHeadroomArgs'] headroom: Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
        :param pulumi.Input[bool] is_auto_config: Automatically configure and optimize headroom resources.
        :param pulumi.Input[bool] is_enabled: Enable the Ocean Kubernetes Autoscaler.
        :param pulumi.Input['OceanImportAutoscalerResourceLimitsArgs'] resource_limits: Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        OceanImportAutoscalerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_headroom_percentage=auto_headroom_percentage,
            cooldown=cooldown,
            down=down,
            enable_automatic_and_manual_headroom=enable_automatic_and_manual_headroom,
            headroom=headroom,
            is_auto_config=is_auto_config,
            is_enabled=is_enabled,
            resource_limits=resource_limits,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_headroom_percentage: Optional[pulumi.Input[int]] = None,
             cooldown: Optional[pulumi.Input[int]] = None,
             down: Optional[pulumi.Input['OceanImportAutoscalerDownArgs']] = None,
             enable_automatic_and_manual_headroom: Optional[pulumi.Input[bool]] = None,
             headroom: Optional[pulumi.Input['OceanImportAutoscalerHeadroomArgs']] = None,
             is_auto_config: Optional[pulumi.Input[bool]] = None,
             is_enabled: Optional[pulumi.Input[bool]] = None,
             resource_limits: Optional[pulumi.Input['OceanImportAutoscalerResourceLimitsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if auto_headroom_percentage is not None:
            _setter("auto_headroom_percentage", auto_headroom_percentage)
        if cooldown is not None:
            _setter("cooldown", cooldown)
        if down is not None:
            _setter("down", down)
        if enable_automatic_and_manual_headroom is not None:
            _setter("enable_automatic_and_manual_headroom", enable_automatic_and_manual_headroom)
        if headroom is not None:
            _setter("headroom", headroom)
        if is_auto_config is not None:
            _setter("is_auto_config", is_auto_config)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if resource_limits is not None:
            _setter("resource_limits", resource_limits)

    @property
    @pulumi.getter(name="autoHeadroomPercentage")
    def auto_headroom_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally set the auto headroom percentage, set a number between 0-200 to control the headroom % from the cluster. Relevant when isAutoConfig=true.
        """
        return pulumi.get(self, "auto_headroom_percentage")

    @auto_headroom_percentage.setter
    def auto_headroom_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auto_headroom_percentage", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[int]]:
        """
        Cooldown period between scaling actions.
        """
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def down(self) -> Optional[pulumi.Input['OceanImportAutoscalerDownArgs']]:
        """
        Auto Scaling scale down operations.
        """
        return pulumi.get(self, "down")

    @down.setter
    def down(self, value: Optional[pulumi.Input['OceanImportAutoscalerDownArgs']]):
        pulumi.set(self, "down", value)

    @property
    @pulumi.getter(name="enableAutomaticAndManualHeadroom")
    def enable_automatic_and_manual_headroom(self) -> Optional[pulumi.Input[bool]]:
        """
        enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
        """
        return pulumi.get(self, "enable_automatic_and_manual_headroom")

    @enable_automatic_and_manual_headroom.setter
    def enable_automatic_and_manual_headroom(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_automatic_and_manual_headroom", value)

    @property
    @pulumi.getter
    def headroom(self) -> Optional[pulumi.Input['OceanImportAutoscalerHeadroomArgs']]:
        """
        Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
        """
        return pulumi.get(self, "headroom")

    @headroom.setter
    def headroom(self, value: Optional[pulumi.Input['OceanImportAutoscalerHeadroomArgs']]):
        pulumi.set(self, "headroom", value)

    @property
    @pulumi.getter(name="isAutoConfig")
    def is_auto_config(self) -> Optional[pulumi.Input[bool]]:
        """
        Automatically configure and optimize headroom resources.
        """
        return pulumi.get(self, "is_auto_config")

    @is_auto_config.setter
    def is_auto_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_auto_config", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the Ocean Kubernetes Autoscaler.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="resourceLimits")
    def resource_limits(self) -> Optional[pulumi.Input['OceanImportAutoscalerResourceLimitsArgs']]:
        """
        Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        return pulumi.get(self, "resource_limits")

    @resource_limits.setter
    def resource_limits(self, value: Optional[pulumi.Input['OceanImportAutoscalerResourceLimitsArgs']]):
        pulumi.set(self, "resource_limits", value)


@pulumi.input_type
class OceanImportAutoscalerDownArgs:
    def __init__(__self__, *,
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 max_scale_down_percentage: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[int] evaluation_periods: The number of evaluation periods that should accumulate before a scale down action takes place.
        :param pulumi.Input[float] max_scale_down_percentage: Would represent the maximum % to scale-down. Number between 1-100.
        """
        OceanImportAutoscalerDownArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            evaluation_periods=evaluation_periods,
            max_scale_down_percentage=max_scale_down_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             evaluation_periods: Optional[pulumi.Input[int]] = None,
             max_scale_down_percentage: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if evaluation_periods is not None:
            _setter("evaluation_periods", evaluation_periods)
        if max_scale_down_percentage is not None:
            _setter("max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        """
        The number of evaluation periods that should accumulate before a scale down action takes place.
        """
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        Would represent the maximum % to scale-down. Number between 1-100.
        """
        return pulumi.get(self, "max_scale_down_percentage")

    @max_scale_down_percentage.setter
    def max_scale_down_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_scale_down_percentage", value)


@pulumi.input_type
class OceanImportAutoscalerHeadroomArgs:
    def __init__(__self__, *,
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 gpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None,
                 num_of_units: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] cpu_per_unit: Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[int] gpu_per_unit: How much GPU allocate for headroom unit.
        :param pulumi.Input[int] memory_per_unit: Optionally configure the amount of memory (MiB) to allocate the headroom.
        :param pulumi.Input[int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        OceanImportAutoscalerHeadroomArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_per_unit=cpu_per_unit,
            gpu_per_unit=gpu_per_unit,
            memory_per_unit=memory_per_unit,
            num_of_units=num_of_units,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_per_unit: Optional[pulumi.Input[int]] = None,
             gpu_per_unit: Optional[pulumi.Input[int]] = None,
             memory_per_unit: Optional[pulumi.Input[int]] = None,
             num_of_units: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cpu_per_unit is not None:
            _setter("cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            _setter("gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            _setter("memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            _setter("num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        How much GPU allocate for headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @gpu_per_unit.setter
    def gpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the amount of memory (MiB) to allocate the headroom.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[pulumi.Input[int]]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_of_units", value)


@pulumi.input_type
class OceanImportAutoscalerResourceLimitsArgs:
    def __init__(__self__, *,
                 max_memory_gib: Optional[pulumi.Input[int]] = None,
                 max_vcpu: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_memory_gib: The maximum memory in GiB units that can be allocated to the cluster.
               
               ```python
               import pulumi
               ```
               
               <a id="strategy"></a>
        :param pulumi.Input[int] max_vcpu: The maximum cpu in vCpu units that can be allocated to the cluster.
        """
        OceanImportAutoscalerResourceLimitsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_memory_gib=max_memory_gib,
            max_vcpu=max_vcpu,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_memory_gib: Optional[pulumi.Input[int]] = None,
             max_vcpu: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_memory_gib is not None:
            _setter("max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            _setter("max_vcpu", max_vcpu)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum memory in GiB units that can be allocated to the cluster.

        ```python
        import pulumi
        ```

        <a id="strategy"></a>
        """
        return pulumi.get(self, "max_memory_gib")

    @max_memory_gib.setter
    def max_memory_gib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_memory_gib", value)

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum cpu in vCpu units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_vcpu")

    @max_vcpu.setter
    def max_vcpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_vcpu", value)


@pulumi.input_type
class OceanImportBackendServiceArgs:
    def __init__(__self__, *,
                 service_name: pulumi.Input[str],
                 location_type: Optional[pulumi.Input[str]] = None,
                 named_ports: Optional[pulumi.Input[Sequence[pulumi.Input['OceanImportBackendServiceNamedPortArgs']]]] = None,
                 scheme: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_name: The name of the backend service.
        :param pulumi.Input[str] location_type: Sets which location the backend services will be active. Valid values: `regional`, `global`.
        :param pulumi.Input[str] scheme: Use when `location_type` is `regional`. Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: `INTERNAL`, `EXTERNAL`.
        """
        OceanImportBackendServiceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service_name=service_name,
            location_type=location_type,
            named_ports=named_ports,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service_name: pulumi.Input[str],
             location_type: Optional[pulumi.Input[str]] = None,
             named_ports: Optional[pulumi.Input[Sequence[pulumi.Input['OceanImportBackendServiceNamedPortArgs']]]] = None,
             scheme: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("service_name", service_name)
        if location_type is not None:
            _setter("location_type", location_type)
        if named_ports is not None:
            _setter("named_ports", named_ports)
        if scheme is not None:
            _setter("scheme", scheme)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[str]:
        """
        The name of the backend service.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="locationType")
    def location_type(self) -> Optional[pulumi.Input[str]]:
        """
        Sets which location the backend services will be active. Valid values: `regional`, `global`.
        """
        return pulumi.get(self, "location_type")

    @location_type.setter
    def location_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location_type", value)

    @property
    @pulumi.getter(name="namedPorts")
    def named_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanImportBackendServiceNamedPortArgs']]]]:
        return pulumi.get(self, "named_ports")

    @named_ports.setter
    def named_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanImportBackendServiceNamedPortArgs']]]]):
        pulumi.set(self, "named_ports", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Use when `location_type` is `regional`. Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: `INTERNAL`, `EXTERNAL`.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)


@pulumi.input_type
class OceanImportBackendServiceNamedPortArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 ports: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ports: A list of ports.
        """
        OceanImportBackendServiceNamedPortArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            ports=ports,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             ports: pulumi.Input[Sequence[pulumi.Input[str]]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("ports", ports)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of ports.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ports", value)


@pulumi.input_type
class OceanImportScheduledTaskArgs:
    def __init__(__self__, *,
                 shutdown_hours: Optional[pulumi.Input['OceanImportScheduledTaskShutdownHoursArgs']] = None,
                 tasks: Optional[pulumi.Input[Sequence[pulumi.Input['OceanImportScheduledTaskTaskArgs']]]] = None):
        """
        :param pulumi.Input['OceanImportScheduledTaskShutdownHoursArgs'] shutdown_hours: Set shutdown hours for cluster object.
        :param pulumi.Input[Sequence[pulumi.Input['OceanImportScheduledTaskTaskArgs']]] tasks: The scheduling tasks for the cluster.
        """
        OceanImportScheduledTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            shutdown_hours=shutdown_hours,
            tasks=tasks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             shutdown_hours: Optional[pulumi.Input['OceanImportScheduledTaskShutdownHoursArgs']] = None,
             tasks: Optional[pulumi.Input[Sequence[pulumi.Input['OceanImportScheduledTaskTaskArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if shutdown_hours is not None:
            _setter("shutdown_hours", shutdown_hours)
        if tasks is not None:
            _setter("tasks", tasks)

    @property
    @pulumi.getter(name="shutdownHours")
    def shutdown_hours(self) -> Optional[pulumi.Input['OceanImportScheduledTaskShutdownHoursArgs']]:
        """
        Set shutdown hours for cluster object.
        """
        return pulumi.get(self, "shutdown_hours")

    @shutdown_hours.setter
    def shutdown_hours(self, value: Optional[pulumi.Input['OceanImportScheduledTaskShutdownHoursArgs']]):
        pulumi.set(self, "shutdown_hours", value)

    @property
    @pulumi.getter
    def tasks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanImportScheduledTaskTaskArgs']]]]:
        """
        The scheduling tasks for the cluster.
        """
        return pulumi.get(self, "tasks")

    @tasks.setter
    def tasks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanImportScheduledTaskTaskArgs']]]]):
        pulumi.set(self, "tasks", value)


@pulumi.input_type
class OceanImportScheduledTaskShutdownHoursArgs:
    def __init__(__self__, *,
                 time_windows: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] time_windows: Set time windows for shutdown hours. specify a list of 'timeWindows' with at least one time window Each string is in the format of - ddd:hh:mm-ddd:hh:mm ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59. Time windows should not overlap. required on cluster.scheduling.isEnabled = True. API Times are in UTC
               Example: Fri:15:30-Wed:14:30
        :param pulumi.Input[bool] is_enabled: Enable the Ocean Kubernetes Autoscaler.
        """
        OceanImportScheduledTaskShutdownHoursArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            time_windows=time_windows,
            is_enabled=is_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             time_windows: pulumi.Input[Sequence[pulumi.Input[str]]],
             is_enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("time_windows", time_windows)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set time windows for shutdown hours. specify a list of 'timeWindows' with at least one time window Each string is in the format of - ddd:hh:mm-ddd:hh:mm ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59. Time windows should not overlap. required on cluster.scheduling.isEnabled = True. API Times are in UTC
        Example: Fri:15:30-Wed:14:30
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the Ocean Kubernetes Autoscaler.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


@pulumi.input_type
class OceanImportScheduledTaskTaskArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[str],
                 is_enabled: pulumi.Input[bool],
                 task_type: pulumi.Input[str],
                 task_parameters: Optional[pulumi.Input['OceanImportScheduledTaskTaskTaskParametersArgs']] = None):
        """
        :param pulumi.Input[str] cron_expression: A valid cron expression. For example : " * * * * * ".The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of frequency or cronExpression should be used at a time. Required for cluster.scheduling.tasks object
               Example: 0 1 * * *
        :param pulumi.Input[bool] is_enabled: Enable the Ocean Kubernetes Autoscaler.
        :param pulumi.Input[str] task_type: Valid values: "clusterRoll". Required for cluster.scheduling.tasks object.
        """
        OceanImportScheduledTaskTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cron_expression=cron_expression,
            is_enabled=is_enabled,
            task_type=task_type,
            task_parameters=task_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cron_expression: pulumi.Input[str],
             is_enabled: pulumi.Input[bool],
             task_type: pulumi.Input[str],
             task_parameters: Optional[pulumi.Input['OceanImportScheduledTaskTaskTaskParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cron_expression", cron_expression)
        _setter("is_enabled", is_enabled)
        _setter("task_type", task_type)
        if task_parameters is not None:
            _setter("task_parameters", task_parameters)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[str]:
        """
        A valid cron expression. For example : " * * * * * ".The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of frequency or cronExpression should be used at a time. Required for cluster.scheduling.tasks object
        Example: 0 1 * * *
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Enable the Ocean Kubernetes Autoscaler.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input[str]:
        """
        Valid values: "clusterRoll". Required for cluster.scheduling.tasks object.
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_type", value)

    @property
    @pulumi.getter(name="taskParameters")
    def task_parameters(self) -> Optional[pulumi.Input['OceanImportScheduledTaskTaskTaskParametersArgs']]:
        return pulumi.get(self, "task_parameters")

    @task_parameters.setter
    def task_parameters(self, value: Optional[pulumi.Input['OceanImportScheduledTaskTaskTaskParametersArgs']]):
        pulumi.set(self, "task_parameters", value)


@pulumi.input_type
class OceanImportScheduledTaskTaskTaskParametersArgs:
    def __init__(__self__, *,
                 cluster_roll: Optional[pulumi.Input['OceanImportScheduledTaskTaskTaskParametersClusterRollArgs']] = None):
        OceanImportScheduledTaskTaskTaskParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_roll=cluster_roll,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_roll: Optional[pulumi.Input['OceanImportScheduledTaskTaskTaskParametersClusterRollArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cluster_roll is not None:
            _setter("cluster_roll", cluster_roll)

    @property
    @pulumi.getter(name="clusterRoll")
    def cluster_roll(self) -> Optional[pulumi.Input['OceanImportScheduledTaskTaskTaskParametersClusterRollArgs']]:
        return pulumi.get(self, "cluster_roll")

    @cluster_roll.setter
    def cluster_roll(self, value: Optional[pulumi.Input['OceanImportScheduledTaskTaskTaskParametersClusterRollArgs']]):
        pulumi.set(self, "cluster_roll", value)


@pulumi.input_type
class OceanImportScheduledTaskTaskTaskParametersClusterRollArgs:
    def __init__(__self__, *,
                 batch_min_healthy_percentage: Optional[pulumi.Input[int]] = None,
                 batch_size_percentage: Optional[pulumi.Input[int]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 respect_pdb: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] batch_size_percentage: Value in % to set size of batch in roll. Valid values are 0-100
               Example: 20.
               
               ```python
               import pulumi
               ```
        """
        OceanImportScheduledTaskTaskTaskParametersClusterRollArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            batch_min_healthy_percentage=batch_min_healthy_percentage,
            batch_size_percentage=batch_size_percentage,
            comment=comment,
            respect_pdb=respect_pdb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             batch_min_healthy_percentage: Optional[pulumi.Input[int]] = None,
             batch_size_percentage: Optional[pulumi.Input[int]] = None,
             comment: Optional[pulumi.Input[str]] = None,
             respect_pdb: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if batch_min_healthy_percentage is not None:
            _setter("batch_min_healthy_percentage", batch_min_healthy_percentage)
        if batch_size_percentage is not None:
            _setter("batch_size_percentage", batch_size_percentage)
        if comment is not None:
            _setter("comment", comment)
        if respect_pdb is not None:
            _setter("respect_pdb", respect_pdb)

    @property
    @pulumi.getter(name="batchMinHealthyPercentage")
    def batch_min_healthy_percentage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_min_healthy_percentage")

    @batch_min_healthy_percentage.setter
    def batch_min_healthy_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_min_healthy_percentage", value)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Value in % to set size of batch in roll. Valid values are 0-100
        Example: 20.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="respectPdb")
    def respect_pdb(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "respect_pdb")

    @respect_pdb.setter
    def respect_pdb(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "respect_pdb", value)


@pulumi.input_type
class OceanImportShieldedInstanceConfigArgs:
    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[pulumi.Input[bool]] = None,
                 enable_secure_boot: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enable_integrity_monitoring: Boolean. Enable the integrity monitoring parameter on the GCP instances.
        :param pulumi.Input[bool] enable_secure_boot: Boolean. Enable the secure boot parameter on the GCP instances.
        """
        OceanImportShieldedInstanceConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_integrity_monitoring=enable_integrity_monitoring,
            enable_secure_boot=enable_secure_boot,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_integrity_monitoring: Optional[pulumi.Input[bool]] = None,
             enable_secure_boot: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enable_integrity_monitoring is not None:
            _setter("enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            _setter("enable_secure_boot", enable_secure_boot)

    @property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean. Enable the integrity monitoring parameter on the GCP instances.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @enable_integrity_monitoring.setter
    def enable_integrity_monitoring(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_integrity_monitoring", value)

    @property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean. Enable the secure boot parameter on the GCP instances.
        """
        return pulumi.get(self, "enable_secure_boot")

    @enable_secure_boot.setter
    def enable_secure_boot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_secure_boot", value)


@pulumi.input_type
class OceanImportStrategyArgs:
    def __init__(__self__, *,
                 draining_timeout: Optional[pulumi.Input[int]] = None,
                 preemptible_percentage: Optional[pulumi.Input[int]] = None,
                 provisioning_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] draining_timeout: The draining timeout (in seconds) before terminating the instance.
        """
        OceanImportStrategyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            draining_timeout=draining_timeout,
            preemptible_percentage=preemptible_percentage,
            provisioning_model=provisioning_model,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             draining_timeout: Optional[pulumi.Input[int]] = None,
             preemptible_percentage: Optional[pulumi.Input[int]] = None,
             provisioning_model: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if draining_timeout is not None:
            _setter("draining_timeout", draining_timeout)
        if preemptible_percentage is not None:
            _setter("preemptible_percentage", preemptible_percentage)
        if provisioning_model is not None:
            _setter("provisioning_model", provisioning_model)

    @property
    @pulumi.getter(name="drainingTimeout")
    def draining_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The draining timeout (in seconds) before terminating the instance.
        """
        return pulumi.get(self, "draining_timeout")

    @draining_timeout.setter
    def draining_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "draining_timeout", value)

    @property
    @pulumi.getter(name="preemptiblePercentage")
    def preemptible_percentage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "preemptible_percentage")

    @preemptible_percentage.setter
    def preemptible_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preemptible_percentage", value)

    @property
    @pulumi.getter(name="provisioningModel")
    def provisioning_model(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "provisioning_model")

    @provisioning_model.setter
    def provisioning_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provisioning_model", value)


@pulumi.input_type
class OceanImportUpdatePolicyArgs:
    def __init__(__self__, *,
                 should_roll: pulumi.Input[bool],
                 conditioned_roll: Optional[pulumi.Input[bool]] = None,
                 roll_config: Optional[pulumi.Input['OceanImportUpdatePolicyRollConfigArgs']] = None):
        OceanImportUpdatePolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            should_roll=should_roll,
            conditioned_roll=conditioned_roll,
            roll_config=roll_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             should_roll: pulumi.Input[bool],
             conditioned_roll: Optional[pulumi.Input[bool]] = None,
             roll_config: Optional[pulumi.Input['OceanImportUpdatePolicyRollConfigArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("should_roll", should_roll)
        if conditioned_roll is not None:
            _setter("conditioned_roll", conditioned_roll)
        if roll_config is not None:
            _setter("roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "should_roll")

    @should_roll.setter
    def should_roll(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_roll", value)

    @property
    @pulumi.getter(name="conditionedRoll")
    def conditioned_roll(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "conditioned_roll")

    @conditioned_roll.setter
    def conditioned_roll(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "conditioned_roll", value)

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional[pulumi.Input['OceanImportUpdatePolicyRollConfigArgs']]:
        return pulumi.get(self, "roll_config")

    @roll_config.setter
    def roll_config(self, value: Optional[pulumi.Input['OceanImportUpdatePolicyRollConfigArgs']]):
        pulumi.set(self, "roll_config", value)


@pulumi.input_type
class OceanImportUpdatePolicyRollConfigArgs:
    def __init__(__self__, *,
                 batch_size_percentage: pulumi.Input[int],
                 batch_min_healthy_percentage: Optional[pulumi.Input[int]] = None,
                 launch_spec_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 respect_pdb: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] batch_size_percentage: Value in % to set size of batch in roll. Valid values are 0-100
               Example: 20.
               
               ```python
               import pulumi
               ```
        """
        OceanImportUpdatePolicyRollConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            batch_size_percentage=batch_size_percentage,
            batch_min_healthy_percentage=batch_min_healthy_percentage,
            launch_spec_ids=launch_spec_ids,
            respect_pdb=respect_pdb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             batch_size_percentage: pulumi.Input[int],
             batch_min_healthy_percentage: Optional[pulumi.Input[int]] = None,
             launch_spec_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             respect_pdb: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("batch_size_percentage", batch_size_percentage)
        if batch_min_healthy_percentage is not None:
            _setter("batch_min_healthy_percentage", batch_min_healthy_percentage)
        if launch_spec_ids is not None:
            _setter("launch_spec_ids", launch_spec_ids)
        if respect_pdb is not None:
            _setter("respect_pdb", respect_pdb)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> pulumi.Input[int]:
        """
        Value in % to set size of batch in roll. Valid values are 0-100
        Example: 20.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: pulumi.Input[int]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter(name="batchMinHealthyPercentage")
    def batch_min_healthy_percentage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_min_healthy_percentage")

    @batch_min_healthy_percentage.setter
    def batch_min_healthy_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_min_healthy_percentage", value)

    @property
    @pulumi.getter(name="launchSpecIds")
    def launch_spec_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "launch_spec_ids")

    @launch_spec_ids.setter
    def launch_spec_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "launch_spec_ids", value)

    @property
    @pulumi.getter(name="respectPdb")
    def respect_pdb(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "respect_pdb")

    @respect_pdb.setter
    def respect_pdb(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "respect_pdb", value)


@pulumi.input_type
class OceanLaunchSpecAutoscaleHeadroomArgs:
    def __init__(__self__, *,
                 num_of_units: pulumi.Input[int],
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 gpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        :param pulumi.Input[int] cpu_per_unit: Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[int] gpu_per_unit: Optionally configure the number of GPUS to allocate for each headroom unit.
        :param pulumi.Input[int] memory_per_unit: Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        OceanLaunchSpecAutoscaleHeadroomArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            num_of_units=num_of_units,
            cpu_per_unit=cpu_per_unit,
            gpu_per_unit=gpu_per_unit,
            memory_per_unit=memory_per_unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             num_of_units: pulumi.Input[int],
             cpu_per_unit: Optional[pulumi.Input[int]] = None,
             gpu_per_unit: Optional[pulumi.Input[int]] = None,
             memory_per_unit: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("num_of_units", num_of_units)
        if cpu_per_unit is not None:
            _setter("cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            _setter("gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            _setter("memory_per_unit", memory_per_unit)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> pulumi.Input[int]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "num_of_units", value)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of GPUS to allocate for each headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @gpu_per_unit.setter
    def gpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)


@pulumi.input_type
class OceanLaunchSpecAutoscaleHeadroomsAutomaticArgs:
    def __init__(__self__, *,
                 auto_headroom_percentage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] auto_headroom_percentage: Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.`is_enabled` = true is set on the Ocean cluster.
        """
        OceanLaunchSpecAutoscaleHeadroomsAutomaticArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_headroom_percentage=auto_headroom_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_headroom_percentage: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if auto_headroom_percentage is not None:
            _setter("auto_headroom_percentage", auto_headroom_percentage)

    @property
    @pulumi.getter(name="autoHeadroomPercentage")
    def auto_headroom_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.`is_enabled` = true is set on the Ocean cluster.
        """
        return pulumi.get(self, "auto_headroom_percentage")

    @auto_headroom_percentage.setter
    def auto_headroom_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auto_headroom_percentage", value)


@pulumi.input_type
class OceanLaunchSpecLabelArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The label key.
        :param pulumi.Input[str] value: The label value.
        """
        OceanLaunchSpecLabelArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The label key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The label value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class OceanLaunchSpecMetadataArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The label key.
        :param pulumi.Input[str] value: The label value.
        """
        OceanLaunchSpecMetadataArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The label key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The label value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class OceanLaunchSpecNetworkInterfaceArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[str],
                 access_configs: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAccessConfigArgs']]]] = None,
                 alias_ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAliasIpRangeArgs']]]] = None,
                 project_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] network: The name of the network.
        :param pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAccessConfigArgs']]] access_configs: The network protocol of the VNG.
        :param pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAliasIpRangeArgs']]] alias_ip_ranges: use the imported node pools associated aliasIpRange to assign secondary IP addresses to the nodes. Cannot be changed after VNG creation.
        :param pulumi.Input[str] project_id: Use a network resource from a different project. Set the project identifier to use its network resource. This parameter is relevant only if the network resource is in a different project.
        """
        OceanLaunchSpecNetworkInterfaceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network=network,
            access_configs=access_configs,
            alias_ip_ranges=alias_ip_ranges,
            project_id=project_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network: pulumi.Input[str],
             access_configs: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAccessConfigArgs']]]] = None,
             alias_ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAliasIpRangeArgs']]]] = None,
             project_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("network", network)
        if access_configs is not None:
            _setter("access_configs", access_configs)
        if alias_ip_ranges is not None:
            _setter("alias_ip_ranges", alias_ip_ranges)
        if project_id is not None:
            _setter("project_id", project_id)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[str]:
        """
        The name of the network.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[str]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAccessConfigArgs']]]]:
        """
        The network protocol of the VNG.
        """
        return pulumi.get(self, "access_configs")

    @access_configs.setter
    def access_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAccessConfigArgs']]]]):
        pulumi.set(self, "access_configs", value)

    @property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAliasIpRangeArgs']]]]:
        """
        use the imported node pools associated aliasIpRange to assign secondary IP addresses to the nodes. Cannot be changed after VNG creation.
        """
        return pulumi.get(self, "alias_ip_ranges")

    @alias_ip_ranges.setter
    def alias_ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecNetworkInterfaceAliasIpRangeArgs']]]]):
        pulumi.set(self, "alias_ip_ranges", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        Use a network resource from a different project. Set the project identifier to use its network resource. This parameter is relevant only if the network resource is in a different project.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)


@pulumi.input_type
class OceanLaunchSpecNetworkInterfaceAccessConfigArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the access configuration.
        :param pulumi.Input[str] type: The type of the access configuration.
        """
        OceanLaunchSpecNetworkInterfaceAccessConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the access configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the access configuration.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class OceanLaunchSpecNetworkInterfaceAliasIpRangeArgs:
    def __init__(__self__, *,
                 ip_cidr_range: pulumi.Input[str],
                 subnetwork_range_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ip_cidr_range: specify the IP address range in CIDR notation that can be used for the alias IP addresses associated with the imported node pool.
        :param pulumi.Input[str] subnetwork_range_name: specify the IP address range for the subnet secondary IP range.
               
               <a id="update-policy"></a>
        """
        OceanLaunchSpecNetworkInterfaceAliasIpRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_cidr_range=ip_cidr_range,
            subnetwork_range_name=subnetwork_range_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_cidr_range: pulumi.Input[str],
             subnetwork_range_name: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ip_cidr_range", ip_cidr_range)
        _setter("subnetwork_range_name", subnetwork_range_name)

    @property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> pulumi.Input[str]:
        """
        specify the IP address range in CIDR notation that can be used for the alias IP addresses associated with the imported node pool.
        """
        return pulumi.get(self, "ip_cidr_range")

    @ip_cidr_range.setter
    def ip_cidr_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_cidr_range", value)

    @property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> pulumi.Input[str]:
        """
        specify the IP address range for the subnet secondary IP range.

        <a id="update-policy"></a>
        """
        return pulumi.get(self, "subnetwork_range_name")

    @subnetwork_range_name.setter
    def subnetwork_range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnetwork_range_name", value)


@pulumi.input_type
class OceanLaunchSpecResourceLimitsArgs:
    def __init__(__self__, *,
                 max_instance_count: Optional[pulumi.Input[int]] = None,
                 min_instance_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_instance_count: Option to set a maximum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
        :param pulumi.Input[int] min_instance_count: Option to set a minimum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
        """
        OceanLaunchSpecResourceLimitsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_instance_count=max_instance_count,
            min_instance_count=min_instance_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_instance_count: Optional[pulumi.Input[int]] = None,
             min_instance_count: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_instance_count is not None:
            _setter("max_instance_count", max_instance_count)
        if min_instance_count is not None:
            _setter("min_instance_count", min_instance_count)

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        Option to set a maximum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
        """
        return pulumi.get(self, "max_instance_count")

    @max_instance_count.setter
    def max_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_instance_count", value)

    @property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        Option to set a minimum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
        """
        return pulumi.get(self, "min_instance_count")

    @min_instance_count.setter
    def min_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_instance_count", value)


@pulumi.input_type
class OceanLaunchSpecSchedulingTaskArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[str],
                 is_enabled: pulumi.Input[bool],
                 task_type: pulumi.Input[str],
                 task_headrooms: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]] = None):
        """
        :param pulumi.Input[str] cron_expression: A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
        :param pulumi.Input[bool] is_enabled: Describes whether the task is enabled. When True, the task runs. When False, it does not run.
        :param pulumi.Input[str] task_type: The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
        :param pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]] task_headrooms: The config of this scheduled task. Depends on the value of taskType.
        """
        OceanLaunchSpecSchedulingTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cron_expression=cron_expression,
            is_enabled=is_enabled,
            task_type=task_type,
            task_headrooms=task_headrooms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cron_expression: pulumi.Input[str],
             is_enabled: pulumi.Input[bool],
             task_type: pulumi.Input[str],
             task_headrooms: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cron_expression", cron_expression)
        _setter("is_enabled", is_enabled)
        _setter("task_type", task_type)
        if task_headrooms is not None:
            _setter("task_headrooms", task_headrooms)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[str]:
        """
        A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Describes whether the task is enabled. When True, the task runs. When False, it does not run.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input[str]:
        """
        The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_type", value)

    @property
    @pulumi.getter(name="taskHeadrooms")
    def task_headrooms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]]:
        """
        The config of this scheduled task. Depends on the value of taskType.
        """
        return pulumi.get(self, "task_headrooms")

    @task_headrooms.setter
    def task_headrooms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]]):
        pulumi.set(self, "task_headrooms", value)


@pulumi.input_type
class OceanLaunchSpecSchedulingTaskTaskHeadroomArgs:
    def __init__(__self__, *,
                 num_of_units: pulumi.Input[int],
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 gpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        :param pulumi.Input[int] cpu_per_unit: Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[int] gpu_per_unit: Optionally configure the number of GPUS to allocate for each headroom unit.
        :param pulumi.Input[int] memory_per_unit: Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        OceanLaunchSpecSchedulingTaskTaskHeadroomArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            num_of_units=num_of_units,
            cpu_per_unit=cpu_per_unit,
            gpu_per_unit=gpu_per_unit,
            memory_per_unit=memory_per_unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             num_of_units: pulumi.Input[int],
             cpu_per_unit: Optional[pulumi.Input[int]] = None,
             gpu_per_unit: Optional[pulumi.Input[int]] = None,
             memory_per_unit: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("num_of_units", num_of_units)
        if cpu_per_unit is not None:
            _setter("cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            _setter("gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            _setter("memory_per_unit", memory_per_unit)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> pulumi.Input[int]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "num_of_units", value)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of GPUS to allocate for each headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @gpu_per_unit.setter
    def gpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)


@pulumi.input_type
class OceanLaunchSpecShieldedInstanceConfigArgs:
    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[pulumi.Input[bool]] = None,
                 enable_secure_boot: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enable_integrity_monitoring: Boolean. Enable the integrity monitoring parameter on the GCP instances.
        :param pulumi.Input[bool] enable_secure_boot: Boolean. Enable the secure boot parameter on the GCP instances.
        """
        OceanLaunchSpecShieldedInstanceConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_integrity_monitoring=enable_integrity_monitoring,
            enable_secure_boot=enable_secure_boot,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_integrity_monitoring: Optional[pulumi.Input[bool]] = None,
             enable_secure_boot: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enable_integrity_monitoring is not None:
            _setter("enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            _setter("enable_secure_boot", enable_secure_boot)

    @property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean. Enable the integrity monitoring parameter on the GCP instances.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @enable_integrity_monitoring.setter
    def enable_integrity_monitoring(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_integrity_monitoring", value)

    @property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean. Enable the secure boot parameter on the GCP instances.
        """
        return pulumi.get(self, "enable_secure_boot")

    @enable_secure_boot.setter
    def enable_secure_boot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_secure_boot", value)


@pulumi.input_type
class OceanLaunchSpecStorageArgs:
    def __init__(__self__, *,
                 local_ssd_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] local_ssd_count: Defines the number of local SSDs to be attached per node for this VNG.
        """
        OceanLaunchSpecStorageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            local_ssd_count=local_ssd_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             local_ssd_count: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if local_ssd_count is not None:
            _setter("local_ssd_count", local_ssd_count)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[int]]:
        """
        Defines the number of local SSDs to be attached per node for this VNG.
        """
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_ssd_count", value)


@pulumi.input_type
class OceanLaunchSpecStrategyArgs:
    def __init__(__self__, *,
                 preemptible_percentage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] preemptible_percentage: Defines the desired preemptible percentage for this launch specification.
        """
        OceanLaunchSpecStrategyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            preemptible_percentage=preemptible_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             preemptible_percentage: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if preemptible_percentage is not None:
            _setter("preemptible_percentage", preemptible_percentage)

    @property
    @pulumi.getter(name="preemptiblePercentage")
    def preemptible_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Defines the desired preemptible percentage for this launch specification.
        """
        return pulumi.get(self, "preemptible_percentage")

    @preemptible_percentage.setter
    def preemptible_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preemptible_percentage", value)


@pulumi.input_type
class OceanLaunchSpecTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effect: The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
        :param pulumi.Input[str] key: The label key.
        :param pulumi.Input[str] value: The label value.
        """
        OceanLaunchSpecTaintArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The label key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The label value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class OceanLaunchSpecUpdatePolicyArgs:
    def __init__(__self__, *,
                 should_roll: pulumi.Input[bool],
                 roll_config: Optional[pulumi.Input['OceanLaunchSpecUpdatePolicyRollConfigArgs']] = None):
        OceanLaunchSpecUpdatePolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            should_roll=should_roll,
            roll_config=roll_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             should_roll: pulumi.Input[bool],
             roll_config: Optional[pulumi.Input['OceanLaunchSpecUpdatePolicyRollConfigArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("should_roll", should_roll)
        if roll_config is not None:
            _setter("roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "should_roll")

    @should_roll.setter
    def should_roll(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_roll", value)

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional[pulumi.Input['OceanLaunchSpecUpdatePolicyRollConfigArgs']]:
        return pulumi.get(self, "roll_config")

    @roll_config.setter
    def roll_config(self, value: Optional[pulumi.Input['OceanLaunchSpecUpdatePolicyRollConfigArgs']]):
        pulumi.set(self, "roll_config", value)


@pulumi.input_type
class OceanLaunchSpecUpdatePolicyRollConfigArgs:
    def __init__(__self__, *,
                 batch_size_percentage: pulumi.Input[int]):
        OceanLaunchSpecUpdatePolicyRollConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            batch_size_percentage=batch_size_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             batch_size_percentage: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("batch_size_percentage", batch_size_percentage)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> pulumi.Input[int]:
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: pulumi.Input[int]):
        pulumi.set(self, "batch_size_percentage", value)


