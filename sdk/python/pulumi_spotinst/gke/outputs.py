# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ElastigroupBackendService',
    'ElastigroupBackendServiceBackendBalancing',
    'ElastigroupBackendServiceNamedPort',
    'ElastigroupDisk',
    'ElastigroupDiskInitializeParam',
    'ElastigroupGpu',
    'ElastigroupInstanceTypesCustom',
    'ElastigroupIntegrationDockerSwarm',
    'ElastigroupIntegrationGke',
    'ElastigroupIntegrationGkeAutoscaleDown',
    'ElastigroupIntegrationGkeAutoscaleHeadroom',
    'ElastigroupIntegrationGkeAutoscaleLabel',
    'ElastigroupLabel',
    'ElastigroupMetadata',
    'ElastigroupNetworkInterface',
    'ElastigroupNetworkInterfaceAccessConfig',
    'ElastigroupNetworkInterfaceAliasIpRange',
    'ElastigroupRevertToPreemptible',
    'ElastigroupScalingDownPolicy',
    'ElastigroupScalingDownPolicyDimension',
    'ElastigroupScalingUpPolicy',
    'ElastigroupScalingUpPolicyDimension',
    'ElastigroupShieldedInstanceConfig',
    'OceanImportAutoUpdate',
    'OceanImportAutoscaler',
    'OceanImportAutoscalerDown',
    'OceanImportAutoscalerHeadroom',
    'OceanImportAutoscalerResourceLimits',
    'OceanImportBackendService',
    'OceanImportBackendServiceNamedPort',
    'OceanImportFilters',
    'OceanImportScheduledTask',
    'OceanImportScheduledTaskShutdownHours',
    'OceanImportScheduledTaskTask',
    'OceanImportScheduledTaskTaskTaskParameters',
    'OceanImportScheduledTaskTaskTaskParametersClusterRoll',
    'OceanImportShieldedInstanceConfig',
    'OceanImportStrategy',
    'OceanImportUpdatePolicy',
    'OceanImportUpdatePolicyRollConfig',
    'OceanLaunchSpecAutoscaleHeadroom',
    'OceanLaunchSpecAutoscaleHeadroomsAutomatic',
    'OceanLaunchSpecCreateOptions',
    'OceanLaunchSpecLabel',
    'OceanLaunchSpecMetadata',
    'OceanLaunchSpecNetworkInterface',
    'OceanLaunchSpecNetworkInterfaceAccessConfig',
    'OceanLaunchSpecNetworkInterfaceAliasIpRange',
    'OceanLaunchSpecResourceLimits',
    'OceanLaunchSpecSchedulingTask',
    'OceanLaunchSpecSchedulingTaskTaskHeadroom',
    'OceanLaunchSpecShieldedInstanceConfig',
    'OceanLaunchSpecStorage',
    'OceanLaunchSpecStrategy',
    'OceanLaunchSpecTaint',
    'OceanLaunchSpecUpdatePolicy',
    'OceanLaunchSpecUpdatePolicyRollConfig',
]

@pulumi.output_type
class ElastigroupBackendService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"
        elif key == "backendBalancing":
            suggest = "backend_balancing"
        elif key == "locationType":
            suggest = "location_type"
        elif key == "namedPorts":
            suggest = "named_ports"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupBackendService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupBackendService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupBackendService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_name: _builtins.str,
                 backend_balancing: Optional['outputs.ElastigroupBackendServiceBackendBalancing'] = None,
                 location_type: Optional[_builtins.str] = None,
                 named_ports: Optional[Sequence['outputs.ElastigroupBackendServiceNamedPort']] = None,
                 scheme: Optional[_builtins.str] = None):
        pulumi.set(__self__, "service_name", service_name)
        if backend_balancing is not None:
            pulumi.set(__self__, "backend_balancing", backend_balancing)
        if location_type is not None:
            pulumi.set(__self__, "location_type", location_type)
        if named_ports is not None:
            pulumi.set(__self__, "named_ports", named_ports)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> _builtins.str:
        return pulumi.get(self, "service_name")

    @_builtins.property
    @pulumi.getter(name="backendBalancing")
    def backend_balancing(self) -> Optional['outputs.ElastigroupBackendServiceBackendBalancing']:
        return pulumi.get(self, "backend_balancing")

    @_builtins.property
    @pulumi.getter(name="locationType")
    def location_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "location_type")

    @_builtins.property
    @pulumi.getter(name="namedPorts")
    def named_ports(self) -> Optional[Sequence['outputs.ElastigroupBackendServiceNamedPort']]:
        return pulumi.get(self, "named_ports")

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scheme")


@pulumi.output_type
class ElastigroupBackendServiceBackendBalancing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendBalancingMode":
            suggest = "backend_balancing_mode"
        elif key == "maxRatePerInstance":
            suggest = "max_rate_per_instance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupBackendServiceBackendBalancing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupBackendServiceBackendBalancing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupBackendServiceBackendBalancing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_balancing_mode: Optional[_builtins.str] = None,
                 max_rate_per_instance: Optional[_builtins.int] = None):
        if backend_balancing_mode is not None:
            pulumi.set(__self__, "backend_balancing_mode", backend_balancing_mode)
        if max_rate_per_instance is not None:
            pulumi.set(__self__, "max_rate_per_instance", max_rate_per_instance)

    @_builtins.property
    @pulumi.getter(name="backendBalancingMode")
    def backend_balancing_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "backend_balancing_mode")

    @_builtins.property
    @pulumi.getter(name="maxRatePerInstance")
    def max_rate_per_instance(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_rate_per_instance")


@pulumi.output_type
class ElastigroupBackendServiceNamedPort(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 ports: Sequence[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ports")


@pulumi.output_type
class ElastigroupDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDelete":
            suggest = "auto_delete"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "initializeParams":
            suggest = "initialize_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_delete: Optional[_builtins.bool] = None,
                 boot: Optional[_builtins.bool] = None,
                 device_name: Optional[_builtins.str] = None,
                 initialize_params: Optional[Sequence['outputs.ElastigroupDiskInitializeParam']] = None,
                 interface: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if auto_delete is not None:
            pulumi.set(__self__, "auto_delete", auto_delete)
        if boot is not None:
            pulumi.set(__self__, "boot", boot)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if initialize_params is not None:
            pulumi.set(__self__, "initialize_params", initialize_params)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter
    def boot(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "boot")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="initializeParams")
    def initialize_params(self) -> Optional[Sequence['outputs.ElastigroupDiskInitializeParam']]:
        return pulumi.get(self, "initialize_params")

    @_builtins.property
    @pulumi.getter
    def interface(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "interface")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ElastigroupDiskInitializeParam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceImage":
            suggest = "source_image"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "diskType":
            suggest = "disk_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupDiskInitializeParam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupDiskInitializeParam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupDiskInitializeParam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_image: _builtins.str,
                 disk_size_gb: Optional[_builtins.str] = None,
                 disk_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "source_image", source_image)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)

    @_builtins.property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> _builtins.str:
        return pulumi.get(self, "source_image")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "disk_type")


@pulumi.output_type
class ElastigroupGpu(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 type: _builtins.str):
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class ElastigroupInstanceTypesCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryGib":
            suggest = "memory_gib"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupInstanceTypesCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupInstanceTypesCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupInstanceTypesCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 memory_gib: _builtins.int,
                 vcpu: _builtins.int):
        pulumi.set(__self__, "memory_gib", memory_gib)
        pulumi.set(__self__, "vcpu", vcpu)

    @_builtins.property
    @pulumi.getter(name="memoryGib")
    def memory_gib(self) -> _builtins.int:
        return pulumi.get(self, "memory_gib")

    @_builtins.property
    @pulumi.getter
    def vcpu(self) -> _builtins.int:
        return pulumi.get(self, "vcpu")


@pulumi.output_type
class ElastigroupIntegrationDockerSwarm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "masterHost":
            suggest = "master_host"
        elif key == "masterPort":
            suggest = "master_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupIntegrationDockerSwarm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupIntegrationDockerSwarm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupIntegrationDockerSwarm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 master_host: _builtins.str,
                 master_port: _builtins.int):
        pulumi.set(__self__, "master_host", master_host)
        pulumi.set(__self__, "master_port", master_port)

    @_builtins.property
    @pulumi.getter(name="masterHost")
    def master_host(self) -> _builtins.str:
        return pulumi.get(self, "master_host")

    @_builtins.property
    @pulumi.getter(name="masterPort")
    def master_port(self) -> _builtins.int:
        return pulumi.get(self, "master_port")


@pulumi.output_type
class ElastigroupIntegrationGke(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoUpdate":
            suggest = "auto_update"
        elif key == "autoscaleCooldown":
            suggest = "autoscale_cooldown"
        elif key == "autoscaleDown":
            suggest = "autoscale_down"
        elif key == "autoscaleHeadroom":
            suggest = "autoscale_headroom"
        elif key == "autoscaleIsAutoConfig":
            suggest = "autoscale_is_auto_config"
        elif key == "autoscaleIsEnabled":
            suggest = "autoscale_is_enabled"
        elif key == "autoscaleLabels":
            suggest = "autoscale_labels"
        elif key == "clusterId":
            suggest = "cluster_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupIntegrationGke. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupIntegrationGke.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupIntegrationGke.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_update: Optional[_builtins.bool] = None,
                 autoscale_cooldown: Optional[_builtins.int] = None,
                 autoscale_down: Optional['outputs.ElastigroupIntegrationGkeAutoscaleDown'] = None,
                 autoscale_headroom: Optional['outputs.ElastigroupIntegrationGkeAutoscaleHeadroom'] = None,
                 autoscale_is_auto_config: Optional[_builtins.bool] = None,
                 autoscale_is_enabled: Optional[_builtins.bool] = None,
                 autoscale_labels: Optional[Sequence['outputs.ElastigroupIntegrationGkeAutoscaleLabel']] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None):
        """
        :param _builtins.int autoscale_cooldown: The amount of time, in seconds, after a scaling activity completes before any further trigger-related scaling activities can start.
        :param 'ElastigroupIntegrationGkeAutoscaleDownArgs' autoscale_down: Enabling scale down.
        :param 'ElastigroupIntegrationGkeAutoscaleHeadroomArgs' autoscale_headroom: Headroom for the cluster.
        :param _builtins.bool autoscale_is_enabled: Specifies whether the auto scaling feature is enabled.
        :param Sequence['ElastigroupIntegrationGkeAutoscaleLabelArgs'] autoscale_labels: Labels to assign to the resource.
        :param _builtins.str location: The location of your GKE cluster.
        """
        if auto_update is not None:
            pulumi.set(__self__, "auto_update", auto_update)
        if autoscale_cooldown is not None:
            pulumi.set(__self__, "autoscale_cooldown", autoscale_cooldown)
        if autoscale_down is not None:
            pulumi.set(__self__, "autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)
        if autoscale_is_auto_config is not None:
            pulumi.set(__self__, "autoscale_is_auto_config", autoscale_is_auto_config)
        if autoscale_is_enabled is not None:
            pulumi.set(__self__, "autoscale_is_enabled", autoscale_is_enabled)
        if autoscale_labels is not None:
            pulumi.set(__self__, "autoscale_labels", autoscale_labels)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if location is not None:
            pulumi.set(__self__, "location", location)

    @_builtins.property
    @pulumi.getter(name="autoUpdate")
    def auto_update(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "auto_update")

    @_builtins.property
    @pulumi.getter(name="autoscaleCooldown")
    def autoscale_cooldown(self) -> Optional[_builtins.int]:
        """
        The amount of time, in seconds, after a scaling activity completes before any further trigger-related scaling activities can start.
        """
        return pulumi.get(self, "autoscale_cooldown")

    @_builtins.property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional['outputs.ElastigroupIntegrationGkeAutoscaleDown']:
        """
        Enabling scale down.
        """
        return pulumi.get(self, "autoscale_down")

    @_builtins.property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional['outputs.ElastigroupIntegrationGkeAutoscaleHeadroom']:
        """
        Headroom for the cluster.
        """
        return pulumi.get(self, "autoscale_headroom")

    @_builtins.property
    @pulumi.getter(name="autoscaleIsAutoConfig")
    def autoscale_is_auto_config(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "autoscale_is_auto_config")

    @_builtins.property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the auto scaling feature is enabled.
        """
        return pulumi.get(self, "autoscale_is_enabled")

    @_builtins.property
    @pulumi.getter(name="autoscaleLabels")
    def autoscale_labels(self) -> Optional[Sequence['outputs.ElastigroupIntegrationGkeAutoscaleLabel']]:
        """
        Labels to assign to the resource.
        """
        return pulumi.get(self, "autoscale_labels")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        The location of your GKE cluster.
        """
        return pulumi.get(self, "location")


@pulumi.output_type
class ElastigroupIntegrationGkeAutoscaleDown(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluationPeriods":
            suggest = "evaluation_periods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupIntegrationGkeAutoscaleDown. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupIntegrationGkeAutoscaleDown.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupIntegrationGkeAutoscaleDown.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluation_periods: Optional[_builtins.int] = None):
        """
        :param _builtins.int evaluation_periods: Amount of cooldown evaluation periods for scale down.
        """
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)

    @_builtins.property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[_builtins.int]:
        """
        Amount of cooldown evaluation periods for scale down.
        """
        return pulumi.get(self, "evaluation_periods")


@pulumi.output_type
class ElastigroupIntegrationGkeAutoscaleHeadroom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuPerUnit":
            suggest = "cpu_per_unit"
        elif key == "memoryPerUnit":
            suggest = "memory_per_unit"
        elif key == "numOfUnits":
            suggest = "num_of_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupIntegrationGkeAutoscaleHeadroom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupIntegrationGkeAutoscaleHeadroom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupIntegrationGkeAutoscaleHeadroom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_per_unit: Optional[_builtins.int] = None,
                 memory_per_unit: Optional[_builtins.int] = None,
                 num_of_units: Optional[_builtins.int] = None):
        """
        :param _builtins.int cpu_per_unit: Cpu units for compute.
        :param _builtins.int memory_per_unit: RAM units for compute.
        :param _builtins.int num_of_units: Amount of units for compute.
        """
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @_builtins.property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[_builtins.int]:
        """
        Cpu units for compute.
        """
        return pulumi.get(self, "cpu_per_unit")

    @_builtins.property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[_builtins.int]:
        """
        RAM units for compute.
        """
        return pulumi.get(self, "memory_per_unit")

    @_builtins.property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[_builtins.int]:
        """
        Amount of units for compute.
        """
        return pulumi.get(self, "num_of_units")


@pulumi.output_type
class ElastigroupIntegrationGkeAutoscaleLabel(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ElastigroupLabel(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ElastigroupMetadata(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ElastigroupNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConfigs":
            suggest = "access_configs"
        elif key == "aliasIpRanges":
            suggest = "alias_ip_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network: _builtins.str,
                 access_configs: Optional[Sequence['outputs.ElastigroupNetworkInterfaceAccessConfig']] = None,
                 alias_ip_ranges: Optional[Sequence['outputs.ElastigroupNetworkInterfaceAliasIpRange']] = None):
        pulumi.set(__self__, "network", network)
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if alias_ip_ranges is not None:
            pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[Sequence['outputs.ElastigroupNetworkInterfaceAccessConfig']]:
        return pulumi.get(self, "access_configs")

    @_builtins.property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[Sequence['outputs.ElastigroupNetworkInterfaceAliasIpRange']]:
        return pulumi.get(self, "alias_ip_ranges")


@pulumi.output_type
class ElastigroupNetworkInterfaceAccessConfig(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ElastigroupNetworkInterfaceAliasIpRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipCidrRange":
            suggest = "ip_cidr_range"
        elif key == "subnetworkRangeName":
            suggest = "subnetwork_range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupNetworkInterfaceAliasIpRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupNetworkInterfaceAliasIpRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupNetworkInterfaceAliasIpRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_cidr_range: _builtins.str,
                 subnetwork_range_name: _builtins.str):
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @_builtins.property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> _builtins.str:
        return pulumi.get(self, "ip_cidr_range")

    @_builtins.property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> _builtins.str:
        return pulumi.get(self, "subnetwork_range_name")


@pulumi.output_type
class ElastigroupRevertToPreemptible(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "performAt":
            suggest = "perform_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupRevertToPreemptible. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupRevertToPreemptible.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupRevertToPreemptible.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 perform_at: _builtins.str):
        pulumi.set(__self__, "perform_at", perform_at)

    @_builtins.property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> _builtins.str:
        return pulumi.get(self, "perform_at")


@pulumi.output_type
class ElastigroupScalingDownPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "policyName":
            suggest = "policy_name"
        elif key == "actionType":
            suggest = "action_type"
        elif key == "evaluationPeriods":
            suggest = "evaluation_periods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupScalingDownPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupScalingDownPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupScalingDownPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 namespace: _builtins.str,
                 policy_name: _builtins.str,
                 threshold: _builtins.float,
                 unit: _builtins.str,
                 action_type: Optional[_builtins.str] = None,
                 adjustment: Optional[_builtins.int] = None,
                 cooldown: Optional[_builtins.int] = None,
                 dimensions: Optional[Sequence['outputs.ElastigroupScalingDownPolicyDimension']] = None,
                 evaluation_periods: Optional[_builtins.int] = None,
                 operator: Optional[_builtins.str] = None,
                 period: Optional[_builtins.int] = None,
                 source: Optional[_builtins.str] = None,
                 statistic: Optional[_builtins.str] = None):
        """
        :param _builtins.int evaluation_periods: Amount of cooldown evaluation periods for scale down.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> _builtins.str:
        return pulumi.get(self, "policy_name")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.float:
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "action_type")

    @_builtins.property
    @pulumi.getter
    def adjustment(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "adjustment")

    @_builtins.property
    @pulumi.getter
    def cooldown(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cooldown")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ElastigroupScalingDownPolicyDimension']]:
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[_builtins.int]:
        """
        Amount of cooldown evaluation periods for scale down.
        """
        return pulumi.get(self, "evaluation_periods")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def statistic(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "statistic")


@pulumi.output_type
class ElastigroupScalingDownPolicyDimension(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ElastigroupScalingUpPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "policyName":
            suggest = "policy_name"
        elif key == "actionType":
            suggest = "action_type"
        elif key == "evaluationPeriods":
            suggest = "evaluation_periods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupScalingUpPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupScalingUpPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupScalingUpPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 namespace: _builtins.str,
                 policy_name: _builtins.str,
                 threshold: _builtins.float,
                 unit: _builtins.str,
                 action_type: Optional[_builtins.str] = None,
                 adjustment: Optional[_builtins.int] = None,
                 cooldown: Optional[_builtins.int] = None,
                 dimensions: Optional[Sequence['outputs.ElastigroupScalingUpPolicyDimension']] = None,
                 evaluation_periods: Optional[_builtins.int] = None,
                 operator: Optional[_builtins.str] = None,
                 period: Optional[_builtins.int] = None,
                 source: Optional[_builtins.str] = None,
                 statistic: Optional[_builtins.str] = None):
        """
        :param _builtins.int evaluation_periods: Amount of cooldown evaluation periods for scale down.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> _builtins.str:
        return pulumi.get(self, "policy_name")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.float:
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "action_type")

    @_builtins.property
    @pulumi.getter
    def adjustment(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "adjustment")

    @_builtins.property
    @pulumi.getter
    def cooldown(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cooldown")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ElastigroupScalingUpPolicyDimension']]:
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[_builtins.int]:
        """
        Amount of cooldown evaluation periods for scale down.
        """
        return pulumi.get(self, "evaluation_periods")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def statistic(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "statistic")


@pulumi.output_type
class ElastigroupScalingUpPolicyDimension(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ElastigroupShieldedInstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIntegrityMonitoring":
            suggest = "enable_integrity_monitoring"
        elif key == "enableSecureBoot":
            suggest = "enable_secure_boot"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElastigroupShieldedInstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElastigroupShieldedInstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElastigroupShieldedInstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[_builtins.bool] = None,
                 enable_secure_boot: Optional[_builtins.bool] = None):
        if enable_integrity_monitoring is not None:
            pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)

    @_builtins.property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_integrity_monitoring")

    @_builtins.property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_secure_boot")


@pulumi.output_type
class OceanImportAutoUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanImportAutoUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanImportAutoUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanImportAutoUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_enabled: Enable the Ocean Kubernetes AutoUpdate.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable the Ocean Kubernetes AutoUpdate.
        """
        return pulumi.get(self, "is_enabled")


@pulumi.output_type
class OceanImportAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoHeadroomPercentage":
            suggest = "auto_headroom_percentage"
        elif key == "enableAutomaticAndManualHeadroom":
            suggest = "enable_automatic_and_manual_headroom"
        elif key == "isAutoConfig":
            suggest = "is_auto_config"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "resourceLimits":
            suggest = "resource_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanImportAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanImportAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanImportAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_headroom_percentage: Optional[_builtins.int] = None,
                 cooldown: Optional[_builtins.int] = None,
                 down: Optional['outputs.OceanImportAutoscalerDown'] = None,
                 enable_automatic_and_manual_headroom: Optional[_builtins.bool] = None,
                 headroom: Optional['outputs.OceanImportAutoscalerHeadroom'] = None,
                 is_auto_config: Optional[_builtins.bool] = None,
                 is_enabled: Optional[_builtins.bool] = None,
                 resource_limits: Optional['outputs.OceanImportAutoscalerResourceLimits'] = None):
        """
        :param _builtins.int auto_headroom_percentage: Optionally set the auto headroom percentage, set a number between 0-200 to control the headroom % from the cluster. Relevant when isAutoConfig=true.
        :param _builtins.int cooldown: Cooldown period between scaling actions.
        :param 'OceanImportAutoscalerDownArgs' down: Auto Scaling scale down operations.
        :param _builtins.bool enable_automatic_and_manual_headroom: enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
        :param 'OceanImportAutoscalerHeadroomArgs' headroom: Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
        :param _builtins.bool is_auto_config: Automatically configure and optimize headroom resources.
        :param _builtins.bool is_enabled: Enable the Ocean Kubernetes Autoscaler.
        :param 'OceanImportAutoscalerResourceLimitsArgs' resource_limits: Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        if auto_headroom_percentage is not None:
            pulumi.set(__self__, "auto_headroom_percentage", auto_headroom_percentage)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if down is not None:
            pulumi.set(__self__, "down", down)
        if enable_automatic_and_manual_headroom is not None:
            pulumi.set(__self__, "enable_automatic_and_manual_headroom", enable_automatic_and_manual_headroom)
        if headroom is not None:
            pulumi.set(__self__, "headroom", headroom)
        if is_auto_config is not None:
            pulumi.set(__self__, "is_auto_config", is_auto_config)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if resource_limits is not None:
            pulumi.set(__self__, "resource_limits", resource_limits)

    @_builtins.property
    @pulumi.getter(name="autoHeadroomPercentage")
    def auto_headroom_percentage(self) -> Optional[_builtins.int]:
        """
        Optionally set the auto headroom percentage, set a number between 0-200 to control the headroom % from the cluster. Relevant when isAutoConfig=true.
        """
        return pulumi.get(self, "auto_headroom_percentage")

    @_builtins.property
    @pulumi.getter
    def cooldown(self) -> Optional[_builtins.int]:
        """
        Cooldown period between scaling actions.
        """
        return pulumi.get(self, "cooldown")

    @_builtins.property
    @pulumi.getter
    def down(self) -> Optional['outputs.OceanImportAutoscalerDown']:
        """
        Auto Scaling scale down operations.
        """
        return pulumi.get(self, "down")

    @_builtins.property
    @pulumi.getter(name="enableAutomaticAndManualHeadroom")
    def enable_automatic_and_manual_headroom(self) -> Optional[_builtins.bool]:
        """
        enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
        """
        return pulumi.get(self, "enable_automatic_and_manual_headroom")

    @_builtins.property
    @pulumi.getter
    def headroom(self) -> Optional['outputs.OceanImportAutoscalerHeadroom']:
        """
        Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
        """
        return pulumi.get(self, "headroom")

    @_builtins.property
    @pulumi.getter(name="isAutoConfig")
    def is_auto_config(self) -> Optional[_builtins.bool]:
        """
        Automatically configure and optimize headroom resources.
        """
        return pulumi.get(self, "is_auto_config")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable the Ocean Kubernetes Autoscaler.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="resourceLimits")
    def resource_limits(self) -> Optional['outputs.OceanImportAutoscalerResourceLimits']:
        """
        Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        return pulumi.get(self, "resource_limits")


@pulumi.output_type
class OceanImportAutoscalerDown(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluationPeriods":
            suggest = "evaluation_periods"
        elif key == "isAggressiveScaleDownEnabled":
            suggest = "is_aggressive_scale_down_enabled"
        elif key == "maxScaleDownPercentage":
            suggest = "max_scale_down_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanImportAutoscalerDown. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanImportAutoscalerDown.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanImportAutoscalerDown.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluation_periods: Optional[_builtins.int] = None,
                 is_aggressive_scale_down_enabled: Optional[_builtins.bool] = None,
                 max_scale_down_percentage: Optional[_builtins.float] = None):
        """
        :param _builtins.int evaluation_periods: The number of evaluation periods that should accumulate before a scale down action takes place.
        :param _builtins.bool is_aggressive_scale_down_enabled: When set to 'true', the Aggressive Scale Down feature is enabled.
        :param _builtins.float max_scale_down_percentage: Would represent the maximum % to scale-down. Number between 1-100.
        """
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if is_aggressive_scale_down_enabled is not None:
            pulumi.set(__self__, "is_aggressive_scale_down_enabled", is_aggressive_scale_down_enabled)
        if max_scale_down_percentage is not None:
            pulumi.set(__self__, "max_scale_down_percentage", max_scale_down_percentage)

    @_builtins.property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[_builtins.int]:
        """
        The number of evaluation periods that should accumulate before a scale down action takes place.
        """
        return pulumi.get(self, "evaluation_periods")

    @_builtins.property
    @pulumi.getter(name="isAggressiveScaleDownEnabled")
    def is_aggressive_scale_down_enabled(self) -> Optional[_builtins.bool]:
        """
        When set to 'true', the Aggressive Scale Down feature is enabled.
        """
        return pulumi.get(self, "is_aggressive_scale_down_enabled")

    @_builtins.property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[_builtins.float]:
        """
        Would represent the maximum % to scale-down. Number between 1-100.
        """
        return pulumi.get(self, "max_scale_down_percentage")


@pulumi.output_type
class OceanImportAutoscalerHeadroom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuPerUnit":
            suggest = "cpu_per_unit"
        elif key == "gpuPerUnit":
            suggest = "gpu_per_unit"
        elif key == "memoryPerUnit":
            suggest = "memory_per_unit"
        elif key == "numOfUnits":
            suggest = "num_of_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanImportAutoscalerHeadroom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanImportAutoscalerHeadroom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanImportAutoscalerHeadroom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_per_unit: Optional[_builtins.int] = None,
                 gpu_per_unit: Optional[_builtins.int] = None,
                 memory_per_unit: Optional[_builtins.int] = None,
                 num_of_units: Optional[_builtins.int] = None):
        """
        :param _builtins.int cpu_per_unit: Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param _builtins.int gpu_per_unit: How much GPU allocate for headroom unit.
        :param _builtins.int memory_per_unit: Optionally configure the amount of memory (MiB) to allocate the headroom.
        :param _builtins.int num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @_builtins.property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[_builtins.int]:
        """
        Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @_builtins.property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[_builtins.int]:
        """
        How much GPU allocate for headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @_builtins.property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[_builtins.int]:
        """
        Optionally configure the amount of memory (MiB) to allocate the headroom.
        """
        return pulumi.get(self, "memory_per_unit")

    @_builtins.property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[_builtins.int]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        return pulumi.get(self, "num_of_units")


@pulumi.output_type
class OceanImportAutoscalerResourceLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxMemoryGib":
            suggest = "max_memory_gib"
        elif key == "maxVcpu":
            suggest = "max_vcpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanImportAutoscalerResourceLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanImportAutoscalerResourceLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanImportAutoscalerResourceLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_memory_gib: Optional[_builtins.int] = None,
                 max_vcpu: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_memory_gib: The maximum memory in GiB units that can be allocated to the cluster.
        :param _builtins.int max_vcpu: The maximum cpu in vCpu units that can be allocated to the cluster.
        """
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)

    @_builtins.property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[_builtins.int]:
        """
        The maximum memory in GiB units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_memory_gib")

    @_builtins.property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[_builtins.int]:
        """
        The maximum cpu in vCpu units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_vcpu")


@pulumi.output_type
class OceanImportBackendService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"
        elif key == "locationType":
            suggest = "location_type"
        elif key == "namedPorts":
            suggest = "named_ports"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanImportBackendService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanImportBackendService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanImportBackendService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_name: _builtins.str,
                 location_type: Optional[_builtins.str] = None,
                 named_ports: Optional[Sequence['outputs.OceanImportBackendServiceNamedPort']] = None,
                 scheme: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_name: The name of the backend service.
        :param _builtins.str location_type: Sets which location the backend services will be active. Valid values: `regional`, `global`.
        :param _builtins.str scheme: Use when `location_type` is `regional`. Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: `INTERNAL`, `EXTERNAL`.
        """
        pulumi.set(__self__, "service_name", service_name)
        if location_type is not None:
            pulumi.set(__self__, "location_type", location_type)
        if named_ports is not None:
            pulumi.set(__self__, "named_ports", named_ports)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> _builtins.str:
        """
        The name of the backend service.
        """
        return pulumi.get(self, "service_name")

    @_builtins.property
    @pulumi.getter(name="locationType")
    def location_type(self) -> Optional[_builtins.str]:
        """
        Sets which location the backend services will be active. Valid values: `regional`, `global`.
        """
        return pulumi.get(self, "location_type")

    @_builtins.property
    @pulumi.getter(name="namedPorts")
    def named_ports(self) -> Optional[Sequence['outputs.OceanImportBackendServiceNamedPort']]:
        return pulumi.get(self, "named_ports")

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[_builtins.str]:
        """
        Use when `location_type` is `regional`. Set the traffic for the backend service to either between the instances in the vpc or to traffic from the internet. Valid values: `INTERNAL`, `EXTERNAL`.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class OceanImportBackendServiceNamedPort(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 ports: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] ports: A list of ports.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Sequence[_builtins.str]:
        """
        A list of ports.
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class OceanImportFilters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeFamilies":
            suggest = "exclude_families"
        elif key == "includeFamilies":
            suggest = "include_families"
        elif key == "maxMemoryGib":
            suggest = "max_memory_gib"
        elif key == "maxVcpu":
            suggest = "max_vcpu"
        elif key == "minMemoryGib":
            suggest = "min_memory_gib"
        elif key == "minVcpu":
            suggest = "min_vcpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanImportFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanImportFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanImportFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_families: Optional[Sequence[_builtins.str]] = None,
                 include_families: Optional[Sequence[_builtins.str]] = None,
                 max_memory_gib: Optional[_builtins.float] = None,
                 max_vcpu: Optional[_builtins.int] = None,
                 min_memory_gib: Optional[_builtins.float] = None,
                 min_vcpu: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] exclude_families: Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
        :param Sequence[_builtins.str] include_families: Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
        :param _builtins.float max_memory_gib: Maximum amount of Memory (GiB).
        :param _builtins.int max_vcpu: Maximum number of vcpus available.
        :param _builtins.float min_memory_gib: Minimum amount of Memory (GiB).
        :param _builtins.int min_vcpu: Minimum number of vcpus available.
        """
        if exclude_families is not None:
            pulumi.set(__self__, "exclude_families", exclude_families)
        if include_families is not None:
            pulumi.set(__self__, "include_families", include_families)
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)
        if min_memory_gib is not None:
            pulumi.set(__self__, "min_memory_gib", min_memory_gib)
        if min_vcpu is not None:
            pulumi.set(__self__, "min_vcpu", min_vcpu)

    @_builtins.property
    @pulumi.getter(name="excludeFamilies")
    def exclude_families(self) -> Optional[Sequence[_builtins.str]]:
        """
        Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
        """
        return pulumi.get(self, "exclude_families")

    @_builtins.property
    @pulumi.getter(name="includeFamilies")
    def include_families(self) -> Optional[Sequence[_builtins.str]]:
        """
        Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
        """
        return pulumi.get(self, "include_families")

    @_builtins.property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[_builtins.float]:
        """
        Maximum amount of Memory (GiB).
        """
        return pulumi.get(self, "max_memory_gib")

    @_builtins.property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[_builtins.int]:
        """
        Maximum number of vcpus available.
        """
        return pulumi.get(self, "max_vcpu")

    @_builtins.property
    @pulumi.getter(name="minMemoryGib")
    def min_memory_gib(self) -> Optional[_builtins.float]:
        """
        Minimum amount of Memory (GiB).
        """
        return pulumi.get(self, "min_memory_gib")

    @_builtins.property
    @pulumi.getter(name="minVcpu")
    def min_vcpu(self) -> Optional[_builtins.int]:
        """
        Minimum number of vcpus available.
        """
        return pulumi.get(self, "min_vcpu")


@pulumi.output_type
class OceanImportScheduledTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shutdownHours":
            suggest = "shutdown_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanImportScheduledTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanImportScheduledTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanImportScheduledTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 shutdown_hours: Optional['outputs.OceanImportScheduledTaskShutdownHours'] = None,
                 tasks: Optional[Sequence['outputs.OceanImportScheduledTaskTask']] = None):
        """
        :param 'OceanImportScheduledTaskShutdownHoursArgs' shutdown_hours: Set shutdown hours for cluster object.
        :param Sequence['OceanImportScheduledTaskTaskArgs'] tasks: The scheduling tasks for the cluster.
        """
        if shutdown_hours is not None:
            pulumi.set(__self__, "shutdown_hours", shutdown_hours)
        if tasks is not None:
            pulumi.set(__self__, "tasks", tasks)

    @_builtins.property
    @pulumi.getter(name="shutdownHours")
    def shutdown_hours(self) -> Optional['outputs.OceanImportScheduledTaskShutdownHours']:
        """
        Set shutdown hours for cluster object.
        """
        return pulumi.get(self, "shutdown_hours")

    @_builtins.property
    @pulumi.getter
    def tasks(self) -> Optional[Sequence['outputs.OceanImportScheduledTaskTask']]:
        """
        The scheduling tasks for the cluster.
        """
        return pulumi.get(self, "tasks")


@pulumi.output_type
class OceanImportScheduledTaskShutdownHours(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeWindows":
            suggest = "time_windows"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanImportScheduledTaskShutdownHours. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanImportScheduledTaskShutdownHours.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanImportScheduledTaskShutdownHours.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_windows: Sequence[_builtins.str],
                 is_enabled: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] time_windows: Set time windows for shutdown hours. specify a list of 'timeWindows' with at least one time window Each string is in the format of - ddd:hh:mm-ddd:hh:mm ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59. Time windows should not overlap. required on cluster.scheduling.isEnabled = `true`. API Times are in UTC
               Example: Fri:15:30-Wed:14:30
        :param _builtins.bool is_enabled: Flag to enable / disable the shutdown hours.
               Example: `true`
        """
        pulumi.set(__self__, "time_windows", time_windows)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Sequence[_builtins.str]:
        """
        Set time windows for shutdown hours. specify a list of 'timeWindows' with at least one time window Each string is in the format of - ddd:hh:mm-ddd:hh:mm ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59. Time windows should not overlap. required on cluster.scheduling.isEnabled = `true`. API Times are in UTC
        Example: Fri:15:30-Wed:14:30
        """
        return pulumi.get(self, "time_windows")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[_builtins.bool]:
        """
        Flag to enable / disable the shutdown hours.
        Example: `true`
        """
        return pulumi.get(self, "is_enabled")


@pulumi.output_type
class OceanImportScheduledTaskTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "taskParameters":
            suggest = "task_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanImportScheduledTaskTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanImportScheduledTaskTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanImportScheduledTaskTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression: _builtins.str,
                 is_enabled: _builtins.bool,
                 task_type: _builtins.str,
                 task_parameters: Optional['outputs.OceanImportScheduledTaskTaskTaskParameters'] = None):
        """
        :param _builtins.str cron_expression: A valid cron expression. For example : " * * * * * ".The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of frequency or cronExpression should be used at a time. Required for cluster.scheduling.tasks object
               Example: 0 1 * * *
        :param _builtins.bool is_enabled: Describes whether the task is enabled. When true the task should run when false it should not run. Required for cluster.scheduling.tasks object.
        :param _builtins.str task_type: Valid values: "clusterRoll". Required for cluster.scheduling.tasks object.
        :param 'OceanImportScheduledTaskTaskTaskParametersArgs' task_parameters: The scheduling parameters for the cluster.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "task_type", task_type)
        if task_parameters is not None:
            pulumi.set(__self__, "task_parameters", task_parameters)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> _builtins.str:
        """
        A valid cron expression. For example : " * * * * * ".The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of frequency or cronExpression should be used at a time. Required for cluster.scheduling.tasks object
        Example: 0 1 * * *
        """
        return pulumi.get(self, "cron_expression")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        Describes whether the task is enabled. When true the task should run when false it should not run. Required for cluster.scheduling.tasks object.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="taskType")
    def task_type(self) -> _builtins.str:
        """
        Valid values: "clusterRoll". Required for cluster.scheduling.tasks object.
        """
        return pulumi.get(self, "task_type")

    @_builtins.property
    @pulumi.getter(name="taskParameters")
    def task_parameters(self) -> Optional['outputs.OceanImportScheduledTaskTaskTaskParameters']:
        """
        The scheduling parameters for the cluster.
        """
        return pulumi.get(self, "task_parameters")


@pulumi.output_type
class OceanImportScheduledTaskTaskTaskParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterRoll":
            suggest = "cluster_roll"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanImportScheduledTaskTaskTaskParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanImportScheduledTaskTaskTaskParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanImportScheduledTaskTaskTaskParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_roll: Optional['outputs.OceanImportScheduledTaskTaskTaskParametersClusterRoll'] = None):
        """
        :param 'OceanImportScheduledTaskTaskTaskParametersClusterRollArgs' cluster_roll: The cluster roll parameters for the cluster.
        """
        if cluster_roll is not None:
            pulumi.set(__self__, "cluster_roll", cluster_roll)

    @_builtins.property
    @pulumi.getter(name="clusterRoll")
    def cluster_roll(self) -> Optional['outputs.OceanImportScheduledTaskTaskTaskParametersClusterRoll']:
        """
        The cluster roll parameters for the cluster.
        """
        return pulumi.get(self, "cluster_roll")


@pulumi.output_type
class OceanImportScheduledTaskTaskTaskParametersClusterRoll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchMinHealthyPercentage":
            suggest = "batch_min_healthy_percentage"
        elif key == "batchSizePercentage":
            suggest = "batch_size_percentage"
        elif key == "respectPdb":
            suggest = "respect_pdb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanImportScheduledTaskTaskTaskParametersClusterRoll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanImportScheduledTaskTaskTaskParametersClusterRoll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanImportScheduledTaskTaskTaskParametersClusterRoll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_min_healthy_percentage: Optional[_builtins.int] = None,
                 batch_size_percentage: Optional[_builtins.int] = None,
                 comment: Optional[_builtins.str] = None,
                 respect_pdb: Optional[_builtins.bool] = None):
        """
        :param _builtins.int batch_min_healthy_percentage: Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        :param _builtins.int batch_size_percentage: Value as a percent to set the size of a batch in a roll. Valid values are 0-100.
        :param _builtins.str comment: Add a comment description for the roll. The comment is limited to 256 chars.
        :param _builtins.bool respect_pdb: During the roll, if the parameter is set to true we honor PDB during the instance replacement.
        """
        if batch_min_healthy_percentage is not None:
            pulumi.set(__self__, "batch_min_healthy_percentage", batch_min_healthy_percentage)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if respect_pdb is not None:
            pulumi.set(__self__, "respect_pdb", respect_pdb)

    @_builtins.property
    @pulumi.getter(name="batchMinHealthyPercentage")
    def batch_min_healthy_percentage(self) -> Optional[_builtins.int]:
        """
        Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        """
        return pulumi.get(self, "batch_min_healthy_percentage")

    @_builtins.property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[_builtins.int]:
        """
        Value as a percent to set the size of a batch in a roll. Valid values are 0-100.
        """
        return pulumi.get(self, "batch_size_percentage")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Add a comment description for the roll. The comment is limited to 256 chars.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="respectPdb")
    def respect_pdb(self) -> Optional[_builtins.bool]:
        """
        During the roll, if the parameter is set to true we honor PDB during the instance replacement.
        """
        return pulumi.get(self, "respect_pdb")


@pulumi.output_type
class OceanImportShieldedInstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIntegrityMonitoring":
            suggest = "enable_integrity_monitoring"
        elif key == "enableSecureBoot":
            suggest = "enable_secure_boot"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanImportShieldedInstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanImportShieldedInstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanImportShieldedInstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[_builtins.bool] = None,
                 enable_secure_boot: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enable_integrity_monitoring: Boolean. Enable the integrity monitoring parameter on the GCP instances.
        :param _builtins.bool enable_secure_boot: Boolean. Enable the secure boot parameter on the GCP instances.
        """
        if enable_integrity_monitoring is not None:
            pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)

    @_builtins.property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[_builtins.bool]:
        """
        Boolean. Enable the integrity monitoring parameter on the GCP instances.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @_builtins.property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[_builtins.bool]:
        """
        Boolean. Enable the secure boot parameter on the GCP instances.
        """
        return pulumi.get(self, "enable_secure_boot")


@pulumi.output_type
class OceanImportStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainingTimeout":
            suggest = "draining_timeout"
        elif key == "preemptiblePercentage":
            suggest = "preemptible_percentage"
        elif key == "provisioningModel":
            suggest = "provisioning_model"
        elif key == "scalingOrientation":
            suggest = "scaling_orientation"
        elif key == "shouldUtilizeCommitments":
            suggest = "should_utilize_commitments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanImportStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanImportStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanImportStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 draining_timeout: Optional[_builtins.int] = None,
                 preemptible_percentage: Optional[_builtins.int] = None,
                 provisioning_model: Optional[_builtins.str] = None,
                 scaling_orientation: Optional[_builtins.str] = None,
                 should_utilize_commitments: Optional[_builtins.bool] = None):
        """
        :param _builtins.int draining_timeout: The draining timeout (in seconds) before terminating the instance. If no draining timeout is defined, the default draining timeout will be used.
        :param _builtins.int preemptible_percentage: Defines the desired preemptible percentage for the cluster.
        :param _builtins.str provisioning_model: Define the provisioning model of the launched instances. Valid values: `SPOT`, `PREEMPTIBLE`.
        :param _builtins.str scaling_orientation: Valid Values: `"cost", "availability", "balanced"`. Set this value to control the approach that Ocean takes when launching nodes.
        :param _builtins.bool should_utilize_commitments: Enable committed use discounts utilization.
        """
        if draining_timeout is not None:
            pulumi.set(__self__, "draining_timeout", draining_timeout)
        if preemptible_percentage is not None:
            pulumi.set(__self__, "preemptible_percentage", preemptible_percentage)
        if provisioning_model is not None:
            pulumi.set(__self__, "provisioning_model", provisioning_model)
        if scaling_orientation is not None:
            pulumi.set(__self__, "scaling_orientation", scaling_orientation)
        if should_utilize_commitments is not None:
            pulumi.set(__self__, "should_utilize_commitments", should_utilize_commitments)

    @_builtins.property
    @pulumi.getter(name="drainingTimeout")
    def draining_timeout(self) -> Optional[_builtins.int]:
        """
        The draining timeout (in seconds) before terminating the instance. If no draining timeout is defined, the default draining timeout will be used.
        """
        return pulumi.get(self, "draining_timeout")

    @_builtins.property
    @pulumi.getter(name="preemptiblePercentage")
    def preemptible_percentage(self) -> Optional[_builtins.int]:
        """
        Defines the desired preemptible percentage for the cluster.
        """
        return pulumi.get(self, "preemptible_percentage")

    @_builtins.property
    @pulumi.getter(name="provisioningModel")
    def provisioning_model(self) -> Optional[_builtins.str]:
        """
        Define the provisioning model of the launched instances. Valid values: `SPOT`, `PREEMPTIBLE`.
        """
        return pulumi.get(self, "provisioning_model")

    @_builtins.property
    @pulumi.getter(name="scalingOrientation")
    def scaling_orientation(self) -> Optional[_builtins.str]:
        """
        Valid Values: `"cost", "availability", "balanced"`. Set this value to control the approach that Ocean takes when launching nodes.
        """
        return pulumi.get(self, "scaling_orientation")

    @_builtins.property
    @pulumi.getter(name="shouldUtilizeCommitments")
    def should_utilize_commitments(self) -> Optional[_builtins.bool]:
        """
        Enable committed use discounts utilization.
        """
        return pulumi.get(self, "should_utilize_commitments")


@pulumi.output_type
class OceanImportUpdatePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shouldRoll":
            suggest = "should_roll"
        elif key == "conditionedRoll":
            suggest = "conditioned_roll"
        elif key == "rollConfig":
            suggest = "roll_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanImportUpdatePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanImportUpdatePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanImportUpdatePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 should_roll: _builtins.bool,
                 conditioned_roll: Optional[_builtins.bool] = None,
                 roll_config: Optional['outputs.OceanImportUpdatePolicyRollConfig'] = None):
        """
        :param _builtins.bool should_roll: Enables the roll.
        :param _builtins.bool conditioned_roll: Spot will perform a cluster Roll in accordance with a relevant modification of the clusters settings. When set to true , only specific changes in the clusters configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
        :param 'OceanImportUpdatePolicyRollConfigArgs' roll_config: Holds the roll configuration.
        """
        pulumi.set(__self__, "should_roll", should_roll)
        if conditioned_roll is not None:
            pulumi.set(__self__, "conditioned_roll", conditioned_roll)
        if roll_config is not None:
            pulumi.set(__self__, "roll_config", roll_config)

    @_builtins.property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> _builtins.bool:
        """
        Enables the roll.
        """
        return pulumi.get(self, "should_roll")

    @_builtins.property
    @pulumi.getter(name="conditionedRoll")
    def conditioned_roll(self) -> Optional[_builtins.bool]:
        """
        Spot will perform a cluster Roll in accordance with a relevant modification of the clusters settings. When set to true , only specific changes in the clusters configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
        """
        return pulumi.get(self, "conditioned_roll")

    @_builtins.property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional['outputs.OceanImportUpdatePolicyRollConfig']:
        """
        Holds the roll configuration.
        """
        return pulumi.get(self, "roll_config")


@pulumi.output_type
class OceanImportUpdatePolicyRollConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchSizePercentage":
            suggest = "batch_size_percentage"
        elif key == "batchMinHealthyPercentage":
            suggest = "batch_min_healthy_percentage"
        elif key == "launchSpecIds":
            suggest = "launch_spec_ids"
        elif key == "respectPdb":
            suggest = "respect_pdb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanImportUpdatePolicyRollConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanImportUpdatePolicyRollConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanImportUpdatePolicyRollConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_size_percentage: _builtins.int,
                 batch_min_healthy_percentage: Optional[_builtins.int] = None,
                 launch_spec_ids: Optional[Sequence[_builtins.str]] = None,
                 respect_pdb: Optional[_builtins.bool] = None):
        """
        :param _builtins.int batch_size_percentage: Sets the percentage of the instances to deploy in each batch.
        :param _builtins.int batch_min_healthy_percentage: Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        :param Sequence[_builtins.str] launch_spec_ids: List of Virtual Node Group identifiers to be rolled.
        :param _builtins.bool respect_pdb: Default: `false`. During the roll, if the parameter is set to `true` we honor PDB during the instance replacement.
        """
        pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if batch_min_healthy_percentage is not None:
            pulumi.set(__self__, "batch_min_healthy_percentage", batch_min_healthy_percentage)
        if launch_spec_ids is not None:
            pulumi.set(__self__, "launch_spec_ids", launch_spec_ids)
        if respect_pdb is not None:
            pulumi.set(__self__, "respect_pdb", respect_pdb)

    @_builtins.property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> _builtins.int:
        """
        Sets the percentage of the instances to deploy in each batch.
        """
        return pulumi.get(self, "batch_size_percentage")

    @_builtins.property
    @pulumi.getter(name="batchMinHealthyPercentage")
    def batch_min_healthy_percentage(self) -> Optional[_builtins.int]:
        """
        Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        """
        return pulumi.get(self, "batch_min_healthy_percentage")

    @_builtins.property
    @pulumi.getter(name="launchSpecIds")
    def launch_spec_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Virtual Node Group identifiers to be rolled.
        """
        return pulumi.get(self, "launch_spec_ids")

    @_builtins.property
    @pulumi.getter(name="respectPdb")
    def respect_pdb(self) -> Optional[_builtins.bool]:
        """
        Default: `false`. During the roll, if the parameter is set to `true` we honor PDB during the instance replacement.
        """
        return pulumi.get(self, "respect_pdb")


@pulumi.output_type
class OceanLaunchSpecAutoscaleHeadroom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numOfUnits":
            suggest = "num_of_units"
        elif key == "cpuPerUnit":
            suggest = "cpu_per_unit"
        elif key == "gpuPerUnit":
            suggest = "gpu_per_unit"
        elif key == "memoryPerUnit":
            suggest = "memory_per_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecAutoscaleHeadroom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecAutoscaleHeadroom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecAutoscaleHeadroom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_of_units: _builtins.int,
                 cpu_per_unit: Optional[_builtins.int] = None,
                 gpu_per_unit: Optional[_builtins.int] = None,
                 memory_per_unit: Optional[_builtins.int] = None):
        """
        :param _builtins.int num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        :param _builtins.int cpu_per_unit: Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param _builtins.int gpu_per_unit: Optionally configure the number of GPUS to allocate for each headroom unit.
        :param _builtins.int memory_per_unit: Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        pulumi.set(__self__, "num_of_units", num_of_units)
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)

    @_builtins.property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> _builtins.int:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        return pulumi.get(self, "num_of_units")

    @_builtins.property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[_builtins.int]:
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @_builtins.property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[_builtins.int]:
        """
        Optionally configure the number of GPUS to allocate for each headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @_builtins.property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[_builtins.int]:
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        return pulumi.get(self, "memory_per_unit")


@pulumi.output_type
class OceanLaunchSpecAutoscaleHeadroomsAutomatic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoHeadroomPercentage":
            suggest = "auto_headroom_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecAutoscaleHeadroomsAutomatic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecAutoscaleHeadroomsAutomatic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecAutoscaleHeadroomsAutomatic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_headroom_percentage: Optional[_builtins.int] = None):
        """
        :param _builtins.int auto_headroom_percentage: Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.`is_enabled` = true is set on the Ocean cluster.
        """
        if auto_headroom_percentage is not None:
            pulumi.set(__self__, "auto_headroom_percentage", auto_headroom_percentage)

    @_builtins.property
    @pulumi.getter(name="autoHeadroomPercentage")
    def auto_headroom_percentage(self) -> Optional[_builtins.int]:
        """
        Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.`is_enabled` = true is set on the Ocean cluster.
        """
        return pulumi.get(self, "auto_headroom_percentage")


@pulumi.output_type
class OceanLaunchSpecCreateOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialNodes":
            suggest = "initial_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecCreateOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecCreateOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecCreateOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_nodes: Optional[_builtins.int] = None):
        """
        :param _builtins.int initial_nodes: When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group.
        """
        if initial_nodes is not None:
            pulumi.set(__self__, "initial_nodes", initial_nodes)

    @_builtins.property
    @pulumi.getter(name="initialNodes")
    def initial_nodes(self) -> Optional[_builtins.int]:
        """
        When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group.
        """
        return pulumi.get(self, "initial_nodes")


@pulumi.output_type
class OceanLaunchSpecLabel(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The label key.
        :param _builtins.str value: The label value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The label key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The label value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanLaunchSpecMetadata(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The metadata key.
        :param _builtins.str value: The metadata value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The metadata key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The metadata value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanLaunchSpecNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConfigs":
            suggest = "access_configs"
        elif key == "aliasIpRanges":
            suggest = "alias_ip_ranges"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network: _builtins.str,
                 access_configs: Optional[Sequence['outputs.OceanLaunchSpecNetworkInterfaceAccessConfig']] = None,
                 alias_ip_ranges: Optional[Sequence['outputs.OceanLaunchSpecNetworkInterfaceAliasIpRange']] = None,
                 project_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str network: The name of the network.
        :param Sequence['OceanLaunchSpecNetworkInterfaceAccessConfigArgs'] access_configs: The network protocol of the VNG.
        :param Sequence['OceanLaunchSpecNetworkInterfaceAliasIpRangeArgs'] alias_ip_ranges: use the imported node pools associated aliasIpRange to assign secondary IP addresses to the nodes. Cannot be changed after VNG creation.
        :param _builtins.str project_id: Use a network resource from a different project. Set the project identifier to use its network resource. This parameter is relevant only if the network resource is in a different project.
        """
        pulumi.set(__self__, "network", network)
        if access_configs is not None:
            pulumi.set(__self__, "access_configs", access_configs)
        if alias_ip_ranges is not None:
            pulumi.set(__self__, "alias_ip_ranges", alias_ip_ranges)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The name of the network.
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Optional[Sequence['outputs.OceanLaunchSpecNetworkInterfaceAccessConfig']]:
        """
        The network protocol of the VNG.
        """
        return pulumi.get(self, "access_configs")

    @_builtins.property
    @pulumi.getter(name="aliasIpRanges")
    def alias_ip_ranges(self) -> Optional[Sequence['outputs.OceanLaunchSpecNetworkInterfaceAliasIpRange']]:
        """
        use the imported node pools associated aliasIpRange to assign secondary IP addresses to the nodes. Cannot be changed after VNG creation.
        """
        return pulumi.get(self, "alias_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Use a network resource from a different project. Set the project identifier to use its network resource. This parameter is relevant only if the network resource is in a different project.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class OceanLaunchSpecNetworkInterfaceAccessConfig(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the access configuration.
        :param _builtins.str type: The type of the access configuration.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the access configuration.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the access configuration.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OceanLaunchSpecNetworkInterfaceAliasIpRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipCidrRange":
            suggest = "ip_cidr_range"
        elif key == "subnetworkRangeName":
            suggest = "subnetwork_range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecNetworkInterfaceAliasIpRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecNetworkInterfaceAliasIpRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecNetworkInterfaceAliasIpRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_cidr_range: _builtins.str,
                 subnetwork_range_name: _builtins.str):
        """
        :param _builtins.str ip_cidr_range: specify the IP address range in CIDR notation that can be used for the alias IP addresses associated with the imported node pool.
        :param _builtins.str subnetwork_range_name: specify the IP address range for the subnet secondary IP range.
        """
        pulumi.set(__self__, "ip_cidr_range", ip_cidr_range)
        pulumi.set(__self__, "subnetwork_range_name", subnetwork_range_name)

    @_builtins.property
    @pulumi.getter(name="ipCidrRange")
    def ip_cidr_range(self) -> _builtins.str:
        """
        specify the IP address range in CIDR notation that can be used for the alias IP addresses associated with the imported node pool.
        """
        return pulumi.get(self, "ip_cidr_range")

    @_builtins.property
    @pulumi.getter(name="subnetworkRangeName")
    def subnetwork_range_name(self) -> _builtins.str:
        """
        specify the IP address range for the subnet secondary IP range.
        """
        return pulumi.get(self, "subnetwork_range_name")


@pulumi.output_type
class OceanLaunchSpecResourceLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxInstanceCount":
            suggest = "max_instance_count"
        elif key == "minInstanceCount":
            suggest = "min_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecResourceLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecResourceLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecResourceLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_instance_count: Optional[_builtins.int] = None,
                 min_instance_count: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_instance_count: Option to set a maximum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
        :param _builtins.int min_instance_count: Option to set a minimum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
        """
        if max_instance_count is not None:
            pulumi.set(__self__, "max_instance_count", max_instance_count)
        if min_instance_count is not None:
            pulumi.set(__self__, "min_instance_count", min_instance_count)

    @_builtins.property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> Optional[_builtins.int]:
        """
        Option to set a maximum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
        """
        return pulumi.get(self, "max_instance_count")

    @_builtins.property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> Optional[_builtins.int]:
        """
        Option to set a minimum number of instances per virtual node group. Can be null. If set, the value must be greater than or equal to 0.
        """
        return pulumi.get(self, "min_instance_count")


@pulumi.output_type
class OceanLaunchSpecSchedulingTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "taskHeadrooms":
            suggest = "task_headrooms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecSchedulingTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecSchedulingTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecSchedulingTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression: _builtins.str,
                 is_enabled: _builtins.bool,
                 task_type: _builtins.str,
                 task_headrooms: Optional[Sequence['outputs.OceanLaunchSpecSchedulingTaskTaskHeadroom']] = None):
        """
        :param _builtins.str cron_expression: A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
        :param _builtins.bool is_enabled: Describes whether the task is enabled. When `true`, the task runs. When `false`, it does not run.
        :param _builtins.str task_type: The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
        :param Sequence['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs'] task_headrooms: The config of this scheduled task. Depends on the value of taskType.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "task_type", task_type)
        if task_headrooms is not None:
            pulumi.set(__self__, "task_headrooms", task_headrooms)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> _builtins.str:
        """
        A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
        """
        return pulumi.get(self, "cron_expression")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        Describes whether the task is enabled. When `true`, the task runs. When `false`, it does not run.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="taskType")
    def task_type(self) -> _builtins.str:
        """
        The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
        """
        return pulumi.get(self, "task_type")

    @_builtins.property
    @pulumi.getter(name="taskHeadrooms")
    def task_headrooms(self) -> Optional[Sequence['outputs.OceanLaunchSpecSchedulingTaskTaskHeadroom']]:
        """
        The config of this scheduled task. Depends on the value of taskType.
        """
        return pulumi.get(self, "task_headrooms")


@pulumi.output_type
class OceanLaunchSpecSchedulingTaskTaskHeadroom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numOfUnits":
            suggest = "num_of_units"
        elif key == "cpuPerUnit":
            suggest = "cpu_per_unit"
        elif key == "gpuPerUnit":
            suggest = "gpu_per_unit"
        elif key == "memoryPerUnit":
            suggest = "memory_per_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecSchedulingTaskTaskHeadroom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecSchedulingTaskTaskHeadroom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecSchedulingTaskTaskHeadroom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_of_units: _builtins.int,
                 cpu_per_unit: Optional[_builtins.int] = None,
                 gpu_per_unit: Optional[_builtins.int] = None,
                 memory_per_unit: Optional[_builtins.int] = None):
        """
        :param _builtins.int num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        :param _builtins.int cpu_per_unit: Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param _builtins.int gpu_per_unit: Optionally configure the number of GPUS to allocate for each headroom unit.
        :param _builtins.int memory_per_unit: Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        pulumi.set(__self__, "num_of_units", num_of_units)
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)

    @_builtins.property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> _builtins.int:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        return pulumi.get(self, "num_of_units")

    @_builtins.property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[_builtins.int]:
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @_builtins.property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[_builtins.int]:
        """
        Optionally configure the number of GPUS to allocate for each headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @_builtins.property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[_builtins.int]:
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        return pulumi.get(self, "memory_per_unit")


@pulumi.output_type
class OceanLaunchSpecShieldedInstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableIntegrityMonitoring":
            suggest = "enable_integrity_monitoring"
        elif key == "enableSecureBoot":
            suggest = "enable_secure_boot"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecShieldedInstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecShieldedInstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecShieldedInstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_integrity_monitoring: Optional[_builtins.bool] = None,
                 enable_secure_boot: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enable_integrity_monitoring: Boolean. Enable the integrity monitoring parameter on the GCP instances.
        :param _builtins.bool enable_secure_boot: Boolean. Enable the secure boot parameter on the GCP instances.
        """
        if enable_integrity_monitoring is not None:
            pulumi.set(__self__, "enable_integrity_monitoring", enable_integrity_monitoring)
        if enable_secure_boot is not None:
            pulumi.set(__self__, "enable_secure_boot", enable_secure_boot)

    @_builtins.property
    @pulumi.getter(name="enableIntegrityMonitoring")
    def enable_integrity_monitoring(self) -> Optional[_builtins.bool]:
        """
        Boolean. Enable the integrity monitoring parameter on the GCP instances.
        """
        return pulumi.get(self, "enable_integrity_monitoring")

    @_builtins.property
    @pulumi.getter(name="enableSecureBoot")
    def enable_secure_boot(self) -> Optional[_builtins.bool]:
        """
        Boolean. Enable the secure boot parameter on the GCP instances.
        """
        return pulumi.get(self, "enable_secure_boot")


@pulumi.output_type
class OceanLaunchSpecStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localSsdCount":
            suggest = "local_ssd_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_ssd_count: Optional[_builtins.int] = None):
        """
        :param _builtins.int local_ssd_count: Defines the number of local SSDs to be attached per node for this VNG.
        """
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[_builtins.int]:
        """
        Defines the number of local SSDs to be attached per node for this VNG.
        """
        return pulumi.get(self, "local_ssd_count")


@pulumi.output_type
class OceanLaunchSpecStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preemptiblePercentage":
            suggest = "preemptible_percentage"
        elif key == "scalingOrientation":
            suggest = "scaling_orientation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preemptible_percentage: Optional[_builtins.int] = None,
                 scaling_orientation: Optional[_builtins.str] = None):
        """
        :param _builtins.int preemptible_percentage: Defines the desired preemptible percentage for this launch specification.
        :param _builtins.str scaling_orientation: Valid Values: `"cost", "availability", "balanced"`. Set this value to control the approach that Ocean takes when launching nodes.
        """
        if preemptible_percentage is not None:
            pulumi.set(__self__, "preemptible_percentage", preemptible_percentage)
        if scaling_orientation is not None:
            pulumi.set(__self__, "scaling_orientation", scaling_orientation)

    @_builtins.property
    @pulumi.getter(name="preemptiblePercentage")
    def preemptible_percentage(self) -> Optional[_builtins.int]:
        """
        Defines the desired preemptible percentage for this launch specification.
        """
        return pulumi.get(self, "preemptible_percentage")

    @_builtins.property
    @pulumi.getter(name="scalingOrientation")
    def scaling_orientation(self) -> Optional[_builtins.str]:
        """
        Valid Values: `"cost", "availability", "balanced"`. Set this value to control the approach that Ocean takes when launching nodes.
        """
        return pulumi.get(self, "scaling_orientation")


@pulumi.output_type
class OceanLaunchSpecTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[_builtins.str] = None,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str effect: The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
        :param _builtins.str key: The taint key.
        :param _builtins.str value: The taint value.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The taint key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The taint value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanLaunchSpecUpdatePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shouldRoll":
            suggest = "should_roll"
        elif key == "rollConfig":
            suggest = "roll_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecUpdatePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecUpdatePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecUpdatePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 should_roll: _builtins.bool,
                 roll_config: Optional['outputs.OceanLaunchSpecUpdatePolicyRollConfig'] = None):
        """
        :param _builtins.bool should_roll: Enables the roll.
        :param 'OceanLaunchSpecUpdatePolicyRollConfigArgs' roll_config: Holds the roll configuration.
        """
        pulumi.set(__self__, "should_roll", should_roll)
        if roll_config is not None:
            pulumi.set(__self__, "roll_config", roll_config)

    @_builtins.property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> _builtins.bool:
        """
        Enables the roll.
        """
        return pulumi.get(self, "should_roll")

    @_builtins.property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional['outputs.OceanLaunchSpecUpdatePolicyRollConfig']:
        """
        Holds the roll configuration.
        """
        return pulumi.get(self, "roll_config")


@pulumi.output_type
class OceanLaunchSpecUpdatePolicyRollConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchSizePercentage":
            suggest = "batch_size_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecUpdatePolicyRollConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecUpdatePolicyRollConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecUpdatePolicyRollConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_size_percentage: _builtins.int):
        """
        :param _builtins.int batch_size_percentage: Sets the percentage of the instances to deploy in each batch.
        """
        pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)

    @_builtins.property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> _builtins.int:
        """
        Sets the percentage of the instances to deploy in each batch.
        """
        return pulumi.get(self, "batch_size_percentage")


