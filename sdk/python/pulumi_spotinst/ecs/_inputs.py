# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'OceanAutoscalerArgs',
    'OceanAutoscalerDownArgs',
    'OceanAutoscalerHeadroomArgs',
    'OceanAutoscalerResourceLimitsArgs',
    'OceanBlockDeviceMappingArgs',
    'OceanBlockDeviceMappingEbsArgs',
    'OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs',
    'OceanClusterOrientationArgs',
    'OceanFiltersArgs',
    'OceanInstanceMetadataOptionsArgs',
    'OceanLaunchSpecAttributeArgs',
    'OceanLaunchSpecAutoscaleHeadroomArgs',
    'OceanLaunchSpecBlockDeviceMappingArgs',
    'OceanLaunchSpecBlockDeviceMappingEbsArgs',
    'OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs',
    'OceanLaunchSpecInstanceMetadataOptionsArgs',
    'OceanLaunchSpecSchedulingTaskArgs',
    'OceanLaunchSpecSchedulingTaskTaskHeadroomArgs',
    'OceanLaunchSpecStrategyArgs',
    'OceanLaunchSpecTagArgs',
    'OceanLoggingArgs',
    'OceanLoggingExportArgs',
    'OceanLoggingExportS3Args',
    'OceanOptimizeImagesArgs',
    'OceanScheduledTaskArgs',
    'OceanScheduledTaskShutdownHoursArgs',
    'OceanScheduledTaskTaskArgs',
    'OceanTagArgs',
    'OceanUpdatePolicyArgs',
    'OceanUpdatePolicyRollConfigArgs',
]

@pulumi.input_type
class OceanAutoscalerArgs:
    def __init__(__self__, *,
                 auto_headroom_percentage: Optional[pulumi.Input[int]] = None,
                 cooldown: Optional[pulumi.Input[int]] = None,
                 down: Optional[pulumi.Input['OceanAutoscalerDownArgs']] = None,
                 enable_automatic_and_manual_headroom: Optional[pulumi.Input[bool]] = None,
                 headroom: Optional[pulumi.Input['OceanAutoscalerHeadroomArgs']] = None,
                 is_auto_config: Optional[pulumi.Input[bool]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 resource_limits: Optional[pulumi.Input['OceanAutoscalerResourceLimitsArgs']] = None,
                 should_scale_down_non_service_tasks: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] auto_headroom_percentage: The auto-headroom percentage. Set a number between 0-200 to control the headroom % of the cluster. Relevant when `isAutoConfig`= true.
        :param pulumi.Input[int] cooldown: Cooldown period between scaling actions.
        :param pulumi.Input['OceanAutoscalerDownArgs'] down: Auto Scaling scale down operations.
        :param pulumi.Input[bool] enable_automatic_and_manual_headroom: When set to true, both automatic and per custom launch specification manual headroom to be saved concurrently and independently in the cluster. prerequisite: isAutoConfig must be true
               
               ```python
               import pulumi
               ```
        :param pulumi.Input['OceanAutoscalerHeadroomArgs'] headroom: Spare resource capacity management enabling fast assignment of tasks without waiting for new resources to launch.
        :param pulumi.Input[bool] is_auto_config: Automatically configure and optimize headroom resources.
        :param pulumi.Input[bool] is_enabled: Enable the Ocean ECS autoscaler.
        :param pulumi.Input['OceanAutoscalerResourceLimitsArgs'] resource_limits: Optionally set upper and lower bounds on the resource usage of the cluster.
        :param pulumi.Input[bool] should_scale_down_non_service_tasks: Option to scale down non-service tasks. If not set, Ocean does not scale down standalone tasks.
        """
        OceanAutoscalerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_headroom_percentage=auto_headroom_percentage,
            cooldown=cooldown,
            down=down,
            enable_automatic_and_manual_headroom=enable_automatic_and_manual_headroom,
            headroom=headroom,
            is_auto_config=is_auto_config,
            is_enabled=is_enabled,
            resource_limits=resource_limits,
            should_scale_down_non_service_tasks=should_scale_down_non_service_tasks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_headroom_percentage: Optional[pulumi.Input[int]] = None,
             cooldown: Optional[pulumi.Input[int]] = None,
             down: Optional[pulumi.Input['OceanAutoscalerDownArgs']] = None,
             enable_automatic_and_manual_headroom: Optional[pulumi.Input[bool]] = None,
             headroom: Optional[pulumi.Input['OceanAutoscalerHeadroomArgs']] = None,
             is_auto_config: Optional[pulumi.Input[bool]] = None,
             is_enabled: Optional[pulumi.Input[bool]] = None,
             resource_limits: Optional[pulumi.Input['OceanAutoscalerResourceLimitsArgs']] = None,
             should_scale_down_non_service_tasks: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if auto_headroom_percentage is not None:
            _setter("auto_headroom_percentage", auto_headroom_percentage)
        if cooldown is not None:
            _setter("cooldown", cooldown)
        if down is not None:
            _setter("down", down)
        if enable_automatic_and_manual_headroom is not None:
            _setter("enable_automatic_and_manual_headroom", enable_automatic_and_manual_headroom)
        if headroom is not None:
            _setter("headroom", headroom)
        if is_auto_config is not None:
            _setter("is_auto_config", is_auto_config)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if resource_limits is not None:
            _setter("resource_limits", resource_limits)
        if should_scale_down_non_service_tasks is not None:
            _setter("should_scale_down_non_service_tasks", should_scale_down_non_service_tasks)

    @property
    @pulumi.getter(name="autoHeadroomPercentage")
    def auto_headroom_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        The auto-headroom percentage. Set a number between 0-200 to control the headroom % of the cluster. Relevant when `isAutoConfig`= true.
        """
        return pulumi.get(self, "auto_headroom_percentage")

    @auto_headroom_percentage.setter
    def auto_headroom_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auto_headroom_percentage", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[int]]:
        """
        Cooldown period between scaling actions.
        """
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def down(self) -> Optional[pulumi.Input['OceanAutoscalerDownArgs']]:
        """
        Auto Scaling scale down operations.
        """
        return pulumi.get(self, "down")

    @down.setter
    def down(self, value: Optional[pulumi.Input['OceanAutoscalerDownArgs']]):
        pulumi.set(self, "down", value)

    @property
    @pulumi.getter(name="enableAutomaticAndManualHeadroom")
    def enable_automatic_and_manual_headroom(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, both automatic and per custom launch specification manual headroom to be saved concurrently and independently in the cluster. prerequisite: isAutoConfig must be true

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "enable_automatic_and_manual_headroom")

    @enable_automatic_and_manual_headroom.setter
    def enable_automatic_and_manual_headroom(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_automatic_and_manual_headroom", value)

    @property
    @pulumi.getter
    def headroom(self) -> Optional[pulumi.Input['OceanAutoscalerHeadroomArgs']]:
        """
        Spare resource capacity management enabling fast assignment of tasks without waiting for new resources to launch.
        """
        return pulumi.get(self, "headroom")

    @headroom.setter
    def headroom(self, value: Optional[pulumi.Input['OceanAutoscalerHeadroomArgs']]):
        pulumi.set(self, "headroom", value)

    @property
    @pulumi.getter(name="isAutoConfig")
    def is_auto_config(self) -> Optional[pulumi.Input[bool]]:
        """
        Automatically configure and optimize headroom resources.
        """
        return pulumi.get(self, "is_auto_config")

    @is_auto_config.setter
    def is_auto_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_auto_config", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the Ocean ECS autoscaler.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="resourceLimits")
    def resource_limits(self) -> Optional[pulumi.Input['OceanAutoscalerResourceLimitsArgs']]:
        """
        Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        return pulumi.get(self, "resource_limits")

    @resource_limits.setter
    def resource_limits(self, value: Optional[pulumi.Input['OceanAutoscalerResourceLimitsArgs']]):
        pulumi.set(self, "resource_limits", value)

    @property
    @pulumi.getter(name="shouldScaleDownNonServiceTasks")
    def should_scale_down_non_service_tasks(self) -> Optional[pulumi.Input[bool]]:
        """
        Option to scale down non-service tasks. If not set, Ocean does not scale down standalone tasks.
        """
        return pulumi.get(self, "should_scale_down_non_service_tasks")

    @should_scale_down_non_service_tasks.setter
    def should_scale_down_non_service_tasks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_scale_down_non_service_tasks", value)


@pulumi.input_type
class OceanAutoscalerDownArgs:
    def __init__(__self__, *,
                 max_scale_down_percentage: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] max_scale_down_percentage: Would represent the maximum % to scale-down. Number between 1-100.
        """
        OceanAutoscalerDownArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_scale_down_percentage=max_scale_down_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_scale_down_percentage: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_scale_down_percentage is not None:
            _setter("max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        Would represent the maximum % to scale-down. Number between 1-100.
        """
        return pulumi.get(self, "max_scale_down_percentage")

    @max_scale_down_percentage.setter
    def max_scale_down_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_scale_down_percentage", value)


@pulumi.input_type
class OceanAutoscalerHeadroomArgs:
    def __init__(__self__, *,
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None,
                 num_of_units: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] cpu_per_unit: Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[int] memory_per_unit: Optionally configure the amount of memory (MB) to allocate the headroom.
        :param pulumi.Input[int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        OceanAutoscalerHeadroomArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_per_unit=cpu_per_unit,
            memory_per_unit=memory_per_unit,
            num_of_units=num_of_units,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_per_unit: Optional[pulumi.Input[int]] = None,
             memory_per_unit: Optional[pulumi.Input[int]] = None,
             num_of_units: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cpu_per_unit is not None:
            _setter("cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            _setter("memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            _setter("num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the amount of memory (MB) to allocate the headroom.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[pulumi.Input[int]]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_of_units", value)


@pulumi.input_type
class OceanAutoscalerResourceLimitsArgs:
    def __init__(__self__, *,
                 max_memory_gib: Optional[pulumi.Input[int]] = None,
                 max_vcpu: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_memory_gib: Maximum amount of Memory (GiB).
        :param pulumi.Input[int] max_vcpu: Maximum number of vcpus available.
        """
        OceanAutoscalerResourceLimitsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_memory_gib=max_memory_gib,
            max_vcpu=max_vcpu,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_memory_gib: Optional[pulumi.Input[int]] = None,
             max_vcpu: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_memory_gib is not None:
            _setter("max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            _setter("max_vcpu", max_vcpu)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum amount of Memory (GiB).
        """
        return pulumi.get(self, "max_memory_gib")

    @max_memory_gib.setter
    def max_memory_gib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_memory_gib", value)

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of vcpus available.
        """
        return pulumi.get(self, "max_vcpu")

    @max_vcpu.setter
    def max_vcpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_vcpu", value)


@pulumi.input_type
class OceanBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 ebs: Optional[pulumi.Input['OceanBlockDeviceMappingEbsArgs']] = None,
                 no_device: Optional[pulumi.Input[str]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: String. Set device name. Example: `/dev/xvda1`.
        :param pulumi.Input['OceanBlockDeviceMappingEbsArgs'] ebs: Object. Set Elastic Block Store properties.
        :param pulumi.Input[str] no_device: String. Suppresses the specified device included in the block device mapping of the AMI.
        """
        OceanBlockDeviceMappingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            ebs=ebs,
            no_device=no_device,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: pulumi.Input[str],
             ebs: Optional[pulumi.Input['OceanBlockDeviceMappingEbsArgs']] = None,
             no_device: Optional[pulumi.Input[str]] = None,
             virtual_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("device_name", device_name)
        if ebs is not None:
            _setter("ebs", ebs)
        if no_device is not None:
            _setter("no_device", no_device)
        if virtual_name is not None:
            _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        String. Set device name. Example: `/dev/xvda1`.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def ebs(self) -> Optional[pulumi.Input['OceanBlockDeviceMappingEbsArgs']]:
        """
        Object. Set Elastic Block Store properties.
        """
        return pulumi.get(self, "ebs")

    @ebs.setter
    def ebs(self, value: Optional[pulumi.Input['OceanBlockDeviceMappingEbsArgs']]):
        pulumi.set(self, "ebs", value)

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[str]]:
        """
        String. Suppresses the specified device included in the block device mapping of the AMI.
        """
        return pulumi.get(self, "no_device")

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "no_device", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_name", value)


@pulumi.input_type
class OceanBlockDeviceMappingEbsArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 dynamic_volume_size: Optional[pulumi.Input['OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs']] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] delete_on_termination: Boolean. Toggles EBS deletion upon instance termination.
        :param pulumi.Input['OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs'] dynamic_volume_size: Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
        :param pulumi.Input[bool] encrypted: Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        :param pulumi.Input[int] iops: Int. The number of I/O operations per second (IOPS) that the volume supports.
        :param pulumi.Input[str] kms_key_id: String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
        :param pulumi.Input[str] snapshot_id: (Optional) String. The snapshot ID to mount by.
        :param pulumi.Input[int] throughput: The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volume_type` = gp3.
        :param pulumi.Input[int] volume_size: Int. The size (in GB) of the volume.
        :param pulumi.Input[str] volume_type: String. The type of the volume. Example: `gp2`.
        """
        OceanBlockDeviceMappingEbsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            dynamic_volume_size=dynamic_volume_size,
            encrypted=encrypted,
            iops=iops,
            kms_key_id=kms_key_id,
            snapshot_id=snapshot_id,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[pulumi.Input[bool]] = None,
             dynamic_volume_size: Optional[pulumi.Input['OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs']] = None,
             encrypted: Optional[pulumi.Input[bool]] = None,
             iops: Optional[pulumi.Input[int]] = None,
             kms_key_id: Optional[pulumi.Input[str]] = None,
             snapshot_id: Optional[pulumi.Input[str]] = None,
             throughput: Optional[pulumi.Input[int]] = None,
             volume_size: Optional[pulumi.Input[int]] = None,
             volume_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if dynamic_volume_size is not None:
            _setter("dynamic_volume_size", dynamic_volume_size)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean. Toggles EBS deletion upon instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter(name="dynamicVolumeSize")
    def dynamic_volume_size(self) -> Optional[pulumi.Input['OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs']]:
        """
        Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
        """
        return pulumi.get(self, "dynamic_volume_size")

    @dynamic_volume_size.setter
    def dynamic_volume_size(self, value: Optional[pulumi.Input['OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs']]):
        pulumi.set(self, "dynamic_volume_size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Int. The number of I/O operations per second (IOPS) that the volume supports.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) String. The snapshot ID to mount by.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volume_type` = gp3.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        Int. The size (in GB) of the volume.
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        String. The type of the volume. Example: `gp2`.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs:
    def __init__(__self__, *,
                 base_size: pulumi.Input[int],
                 resource: pulumi.Input[str],
                 size_per_resource_unit: pulumi.Input[int]):
        """
        :param pulumi.Input[int] base_size: Int. Initial size for volume. Example: `50`.
        :param pulumi.Input[str] resource: String. Resource type to increase volume size dynamically by. Valid values: `CPU`.
        :param pulumi.Input[int] size_per_resource_unit: Int. Additional size (in GB) per resource unit. Example: When the `baseSize=50`, `sizePerResourceUnit=20`, and instance with two CPUs is launched, its total disk size will be: 90GB.
        """
        OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            base_size=base_size,
            resource=resource,
            size_per_resource_unit=size_per_resource_unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             base_size: pulumi.Input[int],
             resource: pulumi.Input[str],
             size_per_resource_unit: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("base_size", base_size)
        _setter("resource", resource)
        _setter("size_per_resource_unit", size_per_resource_unit)

    @property
    @pulumi.getter(name="baseSize")
    def base_size(self) -> pulumi.Input[int]:
        """
        Int. Initial size for volume. Example: `50`.
        """
        return pulumi.get(self, "base_size")

    @base_size.setter
    def base_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "base_size", value)

    @property
    @pulumi.getter
    def resource(self) -> pulumi.Input[str]:
        """
        String. Resource type to increase volume size dynamically by. Valid values: `CPU`.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter(name="sizePerResourceUnit")
    def size_per_resource_unit(self) -> pulumi.Input[int]:
        """
        Int. Additional size (in GB) per resource unit. Example: When the `baseSize=50`, `sizePerResourceUnit=20`, and instance with two CPUs is launched, its total disk size will be: 90GB.
        """
        return pulumi.get(self, "size_per_resource_unit")

    @size_per_resource_unit.setter
    def size_per_resource_unit(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_per_resource_unit", value)


@pulumi.input_type
class OceanClusterOrientationArgs:
    def __init__(__self__, *,
                 availability_vs_cost: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_vs_cost: You can control the approach that Ocean takes while launching nodes by configuring this value. Possible values: `costOriented`,`balanced`,`cheapest`.
        """
        OceanClusterOrientationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_vs_cost=availability_vs_cost,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_vs_cost: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if availability_vs_cost is not None:
            _setter("availability_vs_cost", availability_vs_cost)

    @property
    @pulumi.getter(name="availabilityVsCost")
    def availability_vs_cost(self) -> Optional[pulumi.Input[str]]:
        """
        You can control the approach that Ocean takes while launching nodes by configuring this value. Possible values: `costOriented`,`balanced`,`cheapest`.
        """
        return pulumi.get(self, "availability_vs_cost")

    @availability_vs_cost.setter
    def availability_vs_cost(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_vs_cost", value)


@pulumi.input_type
class OceanFiltersArgs:
    def __init__(__self__, *,
                 architectures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 disk_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exclude_families: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exclude_metal: Optional[pulumi.Input[bool]] = None,
                 hypervisors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_families: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 is_ena_supported: Optional[pulumi.Input[str]] = None,
                 max_gpu: Optional[pulumi.Input[int]] = None,
                 max_memory_gib: Optional[pulumi.Input[float]] = None,
                 max_network_performance: Optional[pulumi.Input[int]] = None,
                 max_vcpu: Optional[pulumi.Input[int]] = None,
                 min_enis: Optional[pulumi.Input[int]] = None,
                 min_gpu: Optional[pulumi.Input[int]] = None,
                 min_memory_gib: Optional[pulumi.Input[float]] = None,
                 min_network_performance: Optional[pulumi.Input[int]] = None,
                 min_vcpu: Optional[pulumi.Input[int]] = None,
                 root_device_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 virtualization_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] architectures: The filtered instance types will support at least one of the architectures from this list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] categories: The filtered instance types will belong to one of the categories types from this list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] disk_types: The filtered instance types will have one of the disk type from this list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_families: Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
        :param pulumi.Input[bool] exclude_metal: In case excludeMetal is set to true, metal types will not be available for scaling.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hypervisors: The filtered instance types will have a hypervisor type from this list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_families: Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
        :param pulumi.Input[str] is_ena_supported: Ena is supported or not.
        :param pulumi.Input[int] max_gpu: Maximum total number of GPUs.
        :param pulumi.Input[float] max_memory_gib: Maximum amount of Memory (GiB).
        :param pulumi.Input[int] max_network_performance: Maximum Bandwidth in Gib/s of network performance.
        :param pulumi.Input[int] max_vcpu: Maximum number of vcpus available.
        :param pulumi.Input[int] min_enis: Minimum number of network interfaces (ENIs).
        :param pulumi.Input[int] min_gpu: Minimum total number of GPUs.
        :param pulumi.Input[float] min_memory_gib: Minimum amount of Memory (GiB).
        :param pulumi.Input[int] min_network_performance: Minimum Bandwidth in Gib/s of network performance.
        :param pulumi.Input[int] min_vcpu: Minimum number of vcpus available.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] root_device_types: The filtered instance types will have a root device types from this list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] virtualization_types: The filtered instance types will support at least one of the virtualization types from this list.
        """
        OceanFiltersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            architectures=architectures,
            categories=categories,
            disk_types=disk_types,
            exclude_families=exclude_families,
            exclude_metal=exclude_metal,
            hypervisors=hypervisors,
            include_families=include_families,
            is_ena_supported=is_ena_supported,
            max_gpu=max_gpu,
            max_memory_gib=max_memory_gib,
            max_network_performance=max_network_performance,
            max_vcpu=max_vcpu,
            min_enis=min_enis,
            min_gpu=min_gpu,
            min_memory_gib=min_memory_gib,
            min_network_performance=min_network_performance,
            min_vcpu=min_vcpu,
            root_device_types=root_device_types,
            virtualization_types=virtualization_types,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             architectures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             disk_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             exclude_families: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             exclude_metal: Optional[pulumi.Input[bool]] = None,
             hypervisors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             include_families: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             is_ena_supported: Optional[pulumi.Input[str]] = None,
             max_gpu: Optional[pulumi.Input[int]] = None,
             max_memory_gib: Optional[pulumi.Input[float]] = None,
             max_network_performance: Optional[pulumi.Input[int]] = None,
             max_vcpu: Optional[pulumi.Input[int]] = None,
             min_enis: Optional[pulumi.Input[int]] = None,
             min_gpu: Optional[pulumi.Input[int]] = None,
             min_memory_gib: Optional[pulumi.Input[float]] = None,
             min_network_performance: Optional[pulumi.Input[int]] = None,
             min_vcpu: Optional[pulumi.Input[int]] = None,
             root_device_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             virtualization_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if architectures is not None:
            _setter("architectures", architectures)
        if categories is not None:
            _setter("categories", categories)
        if disk_types is not None:
            _setter("disk_types", disk_types)
        if exclude_families is not None:
            _setter("exclude_families", exclude_families)
        if exclude_metal is not None:
            _setter("exclude_metal", exclude_metal)
        if hypervisors is not None:
            _setter("hypervisors", hypervisors)
        if include_families is not None:
            _setter("include_families", include_families)
        if is_ena_supported is not None:
            _setter("is_ena_supported", is_ena_supported)
        if max_gpu is not None:
            _setter("max_gpu", max_gpu)
        if max_memory_gib is not None:
            _setter("max_memory_gib", max_memory_gib)
        if max_network_performance is not None:
            _setter("max_network_performance", max_network_performance)
        if max_vcpu is not None:
            _setter("max_vcpu", max_vcpu)
        if min_enis is not None:
            _setter("min_enis", min_enis)
        if min_gpu is not None:
            _setter("min_gpu", min_gpu)
        if min_memory_gib is not None:
            _setter("min_memory_gib", min_memory_gib)
        if min_network_performance is not None:
            _setter("min_network_performance", min_network_performance)
        if min_vcpu is not None:
            _setter("min_vcpu", min_vcpu)
        if root_device_types is not None:
            _setter("root_device_types", root_device_types)
        if virtualization_types is not None:
            _setter("virtualization_types", virtualization_types)

    @property
    @pulumi.getter
    def architectures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will support at least one of the architectures from this list.
        """
        return pulumi.get(self, "architectures")

    @architectures.setter
    def architectures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "architectures", value)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will belong to one of the categories types from this list.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter(name="diskTypes")
    def disk_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will have one of the disk type from this list.
        """
        return pulumi.get(self, "disk_types")

    @disk_types.setter
    def disk_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "disk_types", value)

    @property
    @pulumi.getter(name="excludeFamilies")
    def exclude_families(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
        """
        return pulumi.get(self, "exclude_families")

    @exclude_families.setter
    def exclude_families(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_families", value)

    @property
    @pulumi.getter(name="excludeMetal")
    def exclude_metal(self) -> Optional[pulumi.Input[bool]]:
        """
        In case excludeMetal is set to true, metal types will not be available for scaling.
        """
        return pulumi.get(self, "exclude_metal")

    @exclude_metal.setter
    def exclude_metal(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude_metal", value)

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will have a hypervisor type from this list.
        """
        return pulumi.get(self, "hypervisors")

    @hypervisors.setter
    def hypervisors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hypervisors", value)

    @property
    @pulumi.getter(name="includeFamilies")
    def include_families(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
        """
        return pulumi.get(self, "include_families")

    @include_families.setter
    def include_families(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_families", value)

    @property
    @pulumi.getter(name="isEnaSupported")
    def is_ena_supported(self) -> Optional[pulumi.Input[str]]:
        """
        Ena is supported or not.
        """
        return pulumi.get(self, "is_ena_supported")

    @is_ena_supported.setter
    def is_ena_supported(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_ena_supported", value)

    @property
    @pulumi.getter(name="maxGpu")
    def max_gpu(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum total number of GPUs.
        """
        return pulumi.get(self, "max_gpu")

    @max_gpu.setter
    def max_gpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_gpu", value)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum amount of Memory (GiB).
        """
        return pulumi.get(self, "max_memory_gib")

    @max_memory_gib.setter
    def max_memory_gib(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_memory_gib", value)

    @property
    @pulumi.getter(name="maxNetworkPerformance")
    def max_network_performance(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum Bandwidth in Gib/s of network performance.
        """
        return pulumi.get(self, "max_network_performance")

    @max_network_performance.setter
    def max_network_performance(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_network_performance", value)

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of vcpus available.
        """
        return pulumi.get(self, "max_vcpu")

    @max_vcpu.setter
    def max_vcpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_vcpu", value)

    @property
    @pulumi.getter(name="minEnis")
    def min_enis(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of network interfaces (ENIs).
        """
        return pulumi.get(self, "min_enis")

    @min_enis.setter
    def min_enis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_enis", value)

    @property
    @pulumi.getter(name="minGpu")
    def min_gpu(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum total number of GPUs.
        """
        return pulumi.get(self, "min_gpu")

    @min_gpu.setter
    def min_gpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_gpu", value)

    @property
    @pulumi.getter(name="minMemoryGib")
    def min_memory_gib(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum amount of Memory (GiB).
        """
        return pulumi.get(self, "min_memory_gib")

    @min_memory_gib.setter
    def min_memory_gib(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_memory_gib", value)

    @property
    @pulumi.getter(name="minNetworkPerformance")
    def min_network_performance(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum Bandwidth in Gib/s of network performance.
        """
        return pulumi.get(self, "min_network_performance")

    @min_network_performance.setter
    def min_network_performance(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_network_performance", value)

    @property
    @pulumi.getter(name="minVcpu")
    def min_vcpu(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of vcpus available.
        """
        return pulumi.get(self, "min_vcpu")

    @min_vcpu.setter
    def min_vcpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_vcpu", value)

    @property
    @pulumi.getter(name="rootDeviceTypes")
    def root_device_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will have a root device types from this list.
        """
        return pulumi.get(self, "root_device_types")

    @root_device_types.setter
    def root_device_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "root_device_types", value)

    @property
    @pulumi.getter(name="virtualizationTypes")
    def virtualization_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will support at least one of the virtualization types from this list.
        """
        return pulumi.get(self, "virtualization_types")

    @virtualization_types.setter
    def virtualization_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "virtualization_types", value)


@pulumi.input_type
class OceanInstanceMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_tokens: pulumi.Input[str],
                 http_put_response_hop_limit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] http_tokens: Determines if a signed token is required or not. Valid values: `optional` or `required`.
        :param pulumi.Input[int] http_put_response_hop_limit: An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
        """
        OceanInstanceMetadataOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_tokens=http_tokens,
            http_put_response_hop_limit=http_put_response_hop_limit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_tokens: pulumi.Input[str],
             http_put_response_hop_limit: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("http_tokens", http_tokens)
        if http_put_response_hop_limit is not None:
            _setter("http_put_response_hop_limit", http_put_response_hop_limit)

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> pulumi.Input[str]:
        """
        Determines if a signed token is required or not. Valid values: `optional` or `required`.
        """
        return pulumi.get(self, "http_tokens")

    @http_tokens.setter
    def http_tokens(self, value: pulumi.Input[str]):
        pulumi.set(self, "http_tokens", value)

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[int]]:
        """
        An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_put_response_hop_limit", value)


@pulumi.input_type
class OceanLaunchSpecAttributeArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The label key.
        :param pulumi.Input[str] value: The label value.
        """
        OceanLaunchSpecAttributeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The label key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class OceanLaunchSpecAutoscaleHeadroomArgs:
    def __init__(__self__, *,
                 num_of_units: pulumi.Input[int],
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        :param pulumi.Input[int] cpu_per_unit: Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[int] memory_per_unit: Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        OceanLaunchSpecAutoscaleHeadroomArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            num_of_units=num_of_units,
            cpu_per_unit=cpu_per_unit,
            memory_per_unit=memory_per_unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             num_of_units: pulumi.Input[int],
             cpu_per_unit: Optional[pulumi.Input[int]] = None,
             memory_per_unit: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("num_of_units", num_of_units)
        if cpu_per_unit is not None:
            _setter("cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            _setter("memory_per_unit", memory_per_unit)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> pulumi.Input[int]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "num_of_units", value)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)


@pulumi.input_type
class OceanLaunchSpecBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 ebs: Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsArgs']] = None,
                 no_device: Optional[pulumi.Input[str]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        OceanLaunchSpecBlockDeviceMappingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            ebs=ebs,
            no_device=no_device,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: pulumi.Input[str],
             ebs: Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsArgs']] = None,
             no_device: Optional[pulumi.Input[str]] = None,
             virtual_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("device_name", device_name)
        if ebs is not None:
            _setter("ebs", ebs)
        if no_device is not None:
            _setter("no_device", no_device)
        if virtual_name is not None:
            _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def ebs(self) -> Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsArgs']]:
        return pulumi.get(self, "ebs")

    @ebs.setter
    def ebs(self, value: Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsArgs']]):
        pulumi.set(self, "ebs", value)

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "no_device")

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "no_device", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_name", value)


@pulumi.input_type
class OceanLaunchSpecBlockDeviceMappingEbsArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 dynamic_volume_size: Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs']] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        OceanLaunchSpecBlockDeviceMappingEbsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            dynamic_volume_size=dynamic_volume_size,
            encrypted=encrypted,
            iops=iops,
            kms_key_id=kms_key_id,
            snapshot_id=snapshot_id,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[pulumi.Input[bool]] = None,
             dynamic_volume_size: Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs']] = None,
             encrypted: Optional[pulumi.Input[bool]] = None,
             iops: Optional[pulumi.Input[int]] = None,
             kms_key_id: Optional[pulumi.Input[str]] = None,
             snapshot_id: Optional[pulumi.Input[str]] = None,
             throughput: Optional[pulumi.Input[int]] = None,
             volume_size: Optional[pulumi.Input[int]] = None,
             volume_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if dynamic_volume_size is not None:
            _setter("dynamic_volume_size", dynamic_volume_size)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter(name="dynamicVolumeSize")
    def dynamic_volume_size(self) -> Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs']]:
        return pulumi.get(self, "dynamic_volume_size")

    @dynamic_volume_size.setter
    def dynamic_volume_size(self, value: Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs']]):
        pulumi.set(self, "dynamic_volume_size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs:
    def __init__(__self__, *,
                 base_size: pulumi.Input[int],
                 resource: pulumi.Input[str],
                 size_per_resource_unit: pulumi.Input[int]):
        OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            base_size=base_size,
            resource=resource,
            size_per_resource_unit=size_per_resource_unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             base_size: pulumi.Input[int],
             resource: pulumi.Input[str],
             size_per_resource_unit: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("base_size", base_size)
        _setter("resource", resource)
        _setter("size_per_resource_unit", size_per_resource_unit)

    @property
    @pulumi.getter(name="baseSize")
    def base_size(self) -> pulumi.Input[int]:
        return pulumi.get(self, "base_size")

    @base_size.setter
    def base_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "base_size", value)

    @property
    @pulumi.getter
    def resource(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter(name="sizePerResourceUnit")
    def size_per_resource_unit(self) -> pulumi.Input[int]:
        return pulumi.get(self, "size_per_resource_unit")

    @size_per_resource_unit.setter
    def size_per_resource_unit(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_per_resource_unit", value)


@pulumi.input_type
class OceanLaunchSpecInstanceMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_tokens: pulumi.Input[str],
                 http_put_response_hop_limit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] http_tokens: Determines if a signed token is required or not. Valid values: `optional` or `required`.
        :param pulumi.Input[int] http_put_response_hop_limit: An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
        """
        OceanLaunchSpecInstanceMetadataOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_tokens=http_tokens,
            http_put_response_hop_limit=http_put_response_hop_limit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_tokens: pulumi.Input[str],
             http_put_response_hop_limit: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("http_tokens", http_tokens)
        if http_put_response_hop_limit is not None:
            _setter("http_put_response_hop_limit", http_put_response_hop_limit)

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> pulumi.Input[str]:
        """
        Determines if a signed token is required or not. Valid values: `optional` or `required`.
        """
        return pulumi.get(self, "http_tokens")

    @http_tokens.setter
    def http_tokens(self, value: pulumi.Input[str]):
        pulumi.set(self, "http_tokens", value)

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[int]]:
        """
        An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_put_response_hop_limit", value)


@pulumi.input_type
class OceanLaunchSpecSchedulingTaskArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[str],
                 is_enabled: pulumi.Input[bool],
                 task_type: pulumi.Input[str],
                 task_headrooms: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]] = None):
        """
        :param pulumi.Input[str] cron_expression: A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
        :param pulumi.Input[bool] is_enabled: Describes whether the task is enabled. When True, the task runs. When False, it does not run.
        :param pulumi.Input[str] task_type: The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
        :param pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]] task_headrooms: The config of this scheduled task. Depends on the value of taskType.
        """
        OceanLaunchSpecSchedulingTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cron_expression=cron_expression,
            is_enabled=is_enabled,
            task_type=task_type,
            task_headrooms=task_headrooms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cron_expression: pulumi.Input[str],
             is_enabled: pulumi.Input[bool],
             task_type: pulumi.Input[str],
             task_headrooms: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cron_expression", cron_expression)
        _setter("is_enabled", is_enabled)
        _setter("task_type", task_type)
        if task_headrooms is not None:
            _setter("task_headrooms", task_headrooms)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[str]:
        """
        A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Describes whether the task is enabled. When True, the task runs. When False, it does not run.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input[str]:
        """
        The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_type", value)

    @property
    @pulumi.getter(name="taskHeadrooms")
    def task_headrooms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]]:
        """
        The config of this scheduled task. Depends on the value of taskType.
        """
        return pulumi.get(self, "task_headrooms")

    @task_headrooms.setter
    def task_headrooms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]]):
        pulumi.set(self, "task_headrooms", value)


@pulumi.input_type
class OceanLaunchSpecSchedulingTaskTaskHeadroomArgs:
    def __init__(__self__, *,
                 num_of_units: pulumi.Input[int],
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        :param pulumi.Input[int] cpu_per_unit: Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[int] memory_per_unit: Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        OceanLaunchSpecSchedulingTaskTaskHeadroomArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            num_of_units=num_of_units,
            cpu_per_unit=cpu_per_unit,
            memory_per_unit=memory_per_unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             num_of_units: pulumi.Input[int],
             cpu_per_unit: Optional[pulumi.Input[int]] = None,
             memory_per_unit: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("num_of_units", num_of_units)
        if cpu_per_unit is not None:
            _setter("cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            _setter("memory_per_unit", memory_per_unit)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> pulumi.Input[int]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "num_of_units", value)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)


@pulumi.input_type
class OceanLaunchSpecStrategyArgs:
    def __init__(__self__, *,
                 spot_percentage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] spot_percentage: When set, Ocean will proactively try to maintain as close as possible to the percentage of Spot instances out of all the Virtual Node Group instances.
               
               <a id="block-devices"></a>
        """
        OceanLaunchSpecStrategyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            spot_percentage=spot_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             spot_percentage: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if spot_percentage is not None:
            _setter("spot_percentage", spot_percentage)

    @property
    @pulumi.getter(name="spotPercentage")
    def spot_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        When set, Ocean will proactively try to maintain as close as possible to the percentage of Spot instances out of all the Virtual Node Group instances.

        <a id="block-devices"></a>
        """
        return pulumi.get(self, "spot_percentage")

    @spot_percentage.setter
    def spot_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spot_percentage", value)


@pulumi.input_type
class OceanLaunchSpecTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The label key.
        :param pulumi.Input[str] value: The label value.
        """
        OceanLaunchSpecTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The label key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class OceanLoggingArgs:
    def __init__(__self__, *,
                 export: Optional[pulumi.Input['OceanLoggingExportArgs']] = None):
        """
        :param pulumi.Input['OceanLoggingExportArgs'] export: Logging Export configuration.
        """
        OceanLoggingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            export=export,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             export: Optional[pulumi.Input['OceanLoggingExportArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if export is not None:
            _setter("export", export)

    @property
    @pulumi.getter
    def export(self) -> Optional[pulumi.Input['OceanLoggingExportArgs']]:
        """
        Logging Export configuration.
        """
        return pulumi.get(self, "export")

    @export.setter
    def export(self, value: Optional[pulumi.Input['OceanLoggingExportArgs']]):
        pulumi.set(self, "export", value)


@pulumi.input_type
class OceanLoggingExportArgs:
    def __init__(__self__, *,
                 s3s: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLoggingExportS3Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OceanLoggingExportS3Args']]] s3s: Exports your cluster's logs to the S3 bucket and subdir configured on the S3 data integration given.
        """
        OceanLoggingExportArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            s3s=s3s,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             s3s: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLoggingExportS3Args']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if s3s is not None:
            _setter("s3s", s3s)

    @property
    @pulumi.getter
    def s3s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanLoggingExportS3Args']]]]:
        """
        Exports your cluster's logs to the S3 bucket and subdir configured on the S3 data integration given.
        """
        return pulumi.get(self, "s3s")

    @s3s.setter
    def s3s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLoggingExportS3Args']]]]):
        pulumi.set(self, "s3s", value)


@pulumi.input_type
class OceanLoggingExportS3Args:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The identifier of The S3 data integration to export the logs to.
        """
        OceanLoggingExportS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The identifier of The S3 data integration to export the logs to.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class OceanOptimizeImagesArgs:
    def __init__(__self__, *,
                 perform_at: pulumi.Input[str],
                 should_optimize_ecs_ami: pulumi.Input[bool],
                 time_windows: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] perform_at: String. Valid values: "always" "never" "timeWindow".
        :param pulumi.Input[bool] should_optimize_ecs_ami: Boolean. Enable auto image (AMI) update for the ECS container instances. The auto update applies for ECS-Optimized AMIs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] time_windows: Array of strings. Set time windows for image update, at least one time window. Each string is in the format of ddd:hh:mm-ddd:hh:mm ddd. Time windows should not overlap.
        """
        OceanOptimizeImagesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            perform_at=perform_at,
            should_optimize_ecs_ami=should_optimize_ecs_ami,
            time_windows=time_windows,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             perform_at: pulumi.Input[str],
             should_optimize_ecs_ami: pulumi.Input[bool],
             time_windows: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("perform_at", perform_at)
        _setter("should_optimize_ecs_ami", should_optimize_ecs_ami)
        if time_windows is not None:
            _setter("time_windows", time_windows)

    @property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> pulumi.Input[str]:
        """
        String. Valid values: "always" "never" "timeWindow".
        """
        return pulumi.get(self, "perform_at")

    @perform_at.setter
    def perform_at(self, value: pulumi.Input[str]):
        pulumi.set(self, "perform_at", value)

    @property
    @pulumi.getter(name="shouldOptimizeEcsAmi")
    def should_optimize_ecs_ami(self) -> pulumi.Input[bool]:
        """
        Boolean. Enable auto image (AMI) update for the ECS container instances. The auto update applies for ECS-Optimized AMIs.
        """
        return pulumi.get(self, "should_optimize_ecs_ami")

    @should_optimize_ecs_ami.setter
    def should_optimize_ecs_ami(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_optimize_ecs_ami", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of strings. Set time windows for image update, at least one time window. Each string is in the format of ddd:hh:mm-ddd:hh:mm ddd. Time windows should not overlap.
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "time_windows", value)


@pulumi.input_type
class OceanScheduledTaskArgs:
    def __init__(__self__, *,
                 shutdown_hours: Optional[pulumi.Input['OceanScheduledTaskShutdownHoursArgs']] = None,
                 tasks: Optional[pulumi.Input[Sequence[pulumi.Input['OceanScheduledTaskTaskArgs']]]] = None):
        """
        :param pulumi.Input['OceanScheduledTaskShutdownHoursArgs'] shutdown_hours: Set shutdown hours for cluster object.
        :param pulumi.Input[Sequence[pulumi.Input['OceanScheduledTaskTaskArgs']]] tasks: The scheduling tasks for the cluster.
        """
        OceanScheduledTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            shutdown_hours=shutdown_hours,
            tasks=tasks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             shutdown_hours: Optional[pulumi.Input['OceanScheduledTaskShutdownHoursArgs']] = None,
             tasks: Optional[pulumi.Input[Sequence[pulumi.Input['OceanScheduledTaskTaskArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if shutdown_hours is not None:
            _setter("shutdown_hours", shutdown_hours)
        if tasks is not None:
            _setter("tasks", tasks)

    @property
    @pulumi.getter(name="shutdownHours")
    def shutdown_hours(self) -> Optional[pulumi.Input['OceanScheduledTaskShutdownHoursArgs']]:
        """
        Set shutdown hours for cluster object.
        """
        return pulumi.get(self, "shutdown_hours")

    @shutdown_hours.setter
    def shutdown_hours(self, value: Optional[pulumi.Input['OceanScheduledTaskShutdownHoursArgs']]):
        pulumi.set(self, "shutdown_hours", value)

    @property
    @pulumi.getter
    def tasks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanScheduledTaskTaskArgs']]]]:
        """
        The scheduling tasks for the cluster.
        """
        return pulumi.get(self, "tasks")

    @tasks.setter
    def tasks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanScheduledTaskTaskArgs']]]]):
        pulumi.set(self, "tasks", value)


@pulumi.input_type
class OceanScheduledTaskShutdownHoursArgs:
    def __init__(__self__, *,
                 time_windows: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] time_windows: Array of strings. Set time windows for image update, at least one time window. Each string is in the format of ddd:hh:mm-ddd:hh:mm ddd. Time windows should not overlap.
        :param pulumi.Input[bool] is_enabled: Enable the Ocean ECS autoscaler.
        """
        OceanScheduledTaskShutdownHoursArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            time_windows=time_windows,
            is_enabled=is_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             time_windows: pulumi.Input[Sequence[pulumi.Input[str]]],
             is_enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("time_windows", time_windows)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Array of strings. Set time windows for image update, at least one time window. Each string is in the format of ddd:hh:mm-ddd:hh:mm ddd. Time windows should not overlap.
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the Ocean ECS autoscaler.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


@pulumi.input_type
class OceanScheduledTaskTaskArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[str],
                 is_enabled: pulumi.Input[bool],
                 task_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cron_expression: A valid cron expression. The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of `frequency` or `cronExpression` should be used at a time. Required for `cluster.scheduling.tasks` object. Example: `0 1 * * *`.
        :param pulumi.Input[bool] is_enabled: Enable the Ocean ECS autoscaler.
        :param pulumi.Input[str] task_type: Valid values: "clusterRoll". Required for `cluster.scheduling.tasks object`. Example: `clusterRoll`.
               
               ```python
               import pulumi
               ```
               
               
               <a id="attributes-reference"></a>
        """
        OceanScheduledTaskTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cron_expression=cron_expression,
            is_enabled=is_enabled,
            task_type=task_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cron_expression: pulumi.Input[str],
             is_enabled: pulumi.Input[bool],
             task_type: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cron_expression", cron_expression)
        _setter("is_enabled", is_enabled)
        _setter("task_type", task_type)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[str]:
        """
        A valid cron expression. The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of `frequency` or `cronExpression` should be used at a time. Required for `cluster.scheduling.tasks` object. Example: `0 1 * * *`.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Enable the Ocean ECS autoscaler.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input[str]:
        """
        Valid values: "clusterRoll". Required for `cluster.scheduling.tasks object`. Example: `clusterRoll`.

        ```python
        import pulumi
        ```


        <a id="attributes-reference"></a>
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_type", value)


@pulumi.input_type
class OceanTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The tag key.
        :param pulumi.Input[str] value: The tag value.
        """
        OceanTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class OceanUpdatePolicyArgs:
    def __init__(__self__, *,
                 should_roll: pulumi.Input[bool],
                 auto_apply_tags: Optional[pulumi.Input[bool]] = None,
                 conditioned_roll: Optional[pulumi.Input[bool]] = None,
                 roll_config: Optional[pulumi.Input['OceanUpdatePolicyRollConfigArgs']] = None):
        """
        :param pulumi.Input[bool] should_roll: Enables the roll.
        :param pulumi.Input[bool] auto_apply_tags: will update instance tags on the fly without rolling the cluster.
        :param pulumi.Input[bool] conditioned_roll: Spot will perform a cluster Roll in accordance with a relevant modification of the clusters settings. When set to true , only specific changes in the clusters configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
        """
        OceanUpdatePolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            should_roll=should_roll,
            auto_apply_tags=auto_apply_tags,
            conditioned_roll=conditioned_roll,
            roll_config=roll_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             should_roll: pulumi.Input[bool],
             auto_apply_tags: Optional[pulumi.Input[bool]] = None,
             conditioned_roll: Optional[pulumi.Input[bool]] = None,
             roll_config: Optional[pulumi.Input['OceanUpdatePolicyRollConfigArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("should_roll", should_roll)
        if auto_apply_tags is not None:
            _setter("auto_apply_tags", auto_apply_tags)
        if conditioned_roll is not None:
            _setter("conditioned_roll", conditioned_roll)
        if roll_config is not None:
            _setter("roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> pulumi.Input[bool]:
        """
        Enables the roll.
        """
        return pulumi.get(self, "should_roll")

    @should_roll.setter
    def should_roll(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_roll", value)

    @property
    @pulumi.getter(name="autoApplyTags")
    def auto_apply_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        will update instance tags on the fly without rolling the cluster.
        """
        return pulumi.get(self, "auto_apply_tags")

    @auto_apply_tags.setter
    def auto_apply_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_apply_tags", value)

    @property
    @pulumi.getter(name="conditionedRoll")
    def conditioned_roll(self) -> Optional[pulumi.Input[bool]]:
        """
        Spot will perform a cluster Roll in accordance with a relevant modification of the clusters settings. When set to true , only specific changes in the clusters configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
        """
        return pulumi.get(self, "conditioned_roll")

    @conditioned_roll.setter
    def conditioned_roll(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "conditioned_roll", value)

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional[pulumi.Input['OceanUpdatePolicyRollConfigArgs']]:
        return pulumi.get(self, "roll_config")

    @roll_config.setter
    def roll_config(self, value: Optional[pulumi.Input['OceanUpdatePolicyRollConfigArgs']]):
        pulumi.set(self, "roll_config", value)


@pulumi.input_type
class OceanUpdatePolicyRollConfigArgs:
    def __init__(__self__, *,
                 batch_size_percentage: pulumi.Input[int],
                 batch_min_healthy_percentage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] batch_size_percentage: Sets the percentage of the instances to deploy in each batch.
        :param pulumi.Input[int] batch_min_healthy_percentage: Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
               
               ```python
               import pulumi
               ```
        """
        OceanUpdatePolicyRollConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            batch_size_percentage=batch_size_percentage,
            batch_min_healthy_percentage=batch_min_healthy_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             batch_size_percentage: pulumi.Input[int],
             batch_min_healthy_percentage: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("batch_size_percentage", batch_size_percentage)
        if batch_min_healthy_percentage is not None:
            _setter("batch_min_healthy_percentage", batch_min_healthy_percentage)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> pulumi.Input[int]:
        """
        Sets the percentage of the instances to deploy in each batch.
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: pulumi.Input[int]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter(name="batchMinHealthyPercentage")
    def batch_min_healthy_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "batch_min_healthy_percentage")

    @batch_min_healthy_percentage.setter
    def batch_min_healthy_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_min_healthy_percentage", value)


