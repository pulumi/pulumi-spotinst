# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'OceanAutoscalerArgs',
    'OceanAutoscalerDownArgs',
    'OceanAutoscalerHeadroomArgs',
    'OceanAutoscalerResourceLimitsArgs',
    'OceanBlockDeviceMappingArgs',
    'OceanBlockDeviceMappingEbsArgs',
    'OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs',
    'OceanInstanceMetadataOptionsArgs',
    'OceanLaunchSpecAttributeArgs',
    'OceanLaunchSpecAutoscaleHeadroomArgs',
    'OceanLaunchSpecBlockDeviceMappingArgs',
    'OceanLaunchSpecBlockDeviceMappingEbsArgs',
    'OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs',
    'OceanLaunchSpecSchedulingTaskArgs',
    'OceanLaunchSpecSchedulingTaskTaskHeadroomArgs',
    'OceanLaunchSpecTagArgs',
    'OceanOptimizeImagesArgs',
    'OceanScheduledTaskArgs',
    'OceanScheduledTaskShutdownHoursArgs',
    'OceanScheduledTaskTaskArgs',
    'OceanTagArgs',
    'OceanUpdatePolicyArgs',
    'OceanUpdatePolicyRollConfigArgs',
]

@pulumi.input_type
class OceanAutoscalerArgs:
    def __init__(__self__, *,
                 auto_headroom_percentage: Optional[pulumi.Input[int]] = None,
                 cooldown: Optional[pulumi.Input[int]] = None,
                 down: Optional[pulumi.Input['OceanAutoscalerDownArgs']] = None,
                 headroom: Optional[pulumi.Input['OceanAutoscalerHeadroomArgs']] = None,
                 is_auto_config: Optional[pulumi.Input[bool]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 resource_limits: Optional[pulumi.Input['OceanAutoscalerResourceLimitsArgs']] = None):
        """
        :param pulumi.Input[int] auto_headroom_percentage: The auto-headroom percentage. Set a number between 0-200 to control the headroom % of the cluster. Relevant when `isAutoConfig`= true.
        :param pulumi.Input[int] cooldown: Cooldown period between scaling actions.
        :param pulumi.Input['OceanAutoscalerDownArgs'] down: Auto Scaling scale down operations.
        :param pulumi.Input['OceanAutoscalerHeadroomArgs'] headroom: Spare resource capacity management enabling fast assignment of tasks without waiting for new resources to launch.
        :param pulumi.Input[bool] is_auto_config: Automatically configure and optimize headroom resources.
        :param pulumi.Input[bool] is_enabled: Describes whether the task is enabled. When true the task should run when false it should not run. Required for `cluster.scheduling.tasks` object.
        :param pulumi.Input['OceanAutoscalerResourceLimitsArgs'] resource_limits: Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        if auto_headroom_percentage is not None:
            pulumi.set(__self__, "auto_headroom_percentage", auto_headroom_percentage)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if down is not None:
            pulumi.set(__self__, "down", down)
        if headroom is not None:
            pulumi.set(__self__, "headroom", headroom)
        if is_auto_config is not None:
            pulumi.set(__self__, "is_auto_config", is_auto_config)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if resource_limits is not None:
            pulumi.set(__self__, "resource_limits", resource_limits)

    @property
    @pulumi.getter(name="autoHeadroomPercentage")
    def auto_headroom_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        The auto-headroom percentage. Set a number between 0-200 to control the headroom % of the cluster. Relevant when `isAutoConfig`= true.
        """
        return pulumi.get(self, "auto_headroom_percentage")

    @auto_headroom_percentage.setter
    def auto_headroom_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auto_headroom_percentage", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[int]]:
        """
        Cooldown period between scaling actions.
        """
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def down(self) -> Optional[pulumi.Input['OceanAutoscalerDownArgs']]:
        """
        Auto Scaling scale down operations.
        """
        return pulumi.get(self, "down")

    @down.setter
    def down(self, value: Optional[pulumi.Input['OceanAutoscalerDownArgs']]):
        pulumi.set(self, "down", value)

    @property
    @pulumi.getter
    def headroom(self) -> Optional[pulumi.Input['OceanAutoscalerHeadroomArgs']]:
        """
        Spare resource capacity management enabling fast assignment of tasks without waiting for new resources to launch.
        """
        return pulumi.get(self, "headroom")

    @headroom.setter
    def headroom(self, value: Optional[pulumi.Input['OceanAutoscalerHeadroomArgs']]):
        pulumi.set(self, "headroom", value)

    @property
    @pulumi.getter(name="isAutoConfig")
    def is_auto_config(self) -> Optional[pulumi.Input[bool]]:
        """
        Automatically configure and optimize headroom resources.
        """
        return pulumi.get(self, "is_auto_config")

    @is_auto_config.setter
    def is_auto_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_auto_config", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes whether the task is enabled. When true the task should run when false it should not run. Required for `cluster.scheduling.tasks` object.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="resourceLimits")
    def resource_limits(self) -> Optional[pulumi.Input['OceanAutoscalerResourceLimitsArgs']]:
        """
        Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        return pulumi.get(self, "resource_limits")

    @resource_limits.setter
    def resource_limits(self, value: Optional[pulumi.Input['OceanAutoscalerResourceLimitsArgs']]):
        pulumi.set(self, "resource_limits", value)


@pulumi.input_type
class OceanAutoscalerDownArgs:
    def __init__(__self__, *,
                 max_scale_down_percentage: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] max_scale_down_percentage: Would represent the maximum % to scale-down. Number between 1-100.
        """
        if max_scale_down_percentage is not None:
            pulumi.set(__self__, "max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        Would represent the maximum % to scale-down. Number between 1-100.
        """
        return pulumi.get(self, "max_scale_down_percentage")

    @max_scale_down_percentage.setter
    def max_scale_down_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_scale_down_percentage", value)


@pulumi.input_type
class OceanAutoscalerHeadroomArgs:
    def __init__(__self__, *,
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None,
                 num_of_units: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] cpu_per_unit: Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[int] memory_per_unit: Optionally configure the amount of memory (MB) to allocate the headroom.
        :param pulumi.Input[int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the amount of memory (MB) to allocate the headroom.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[pulumi.Input[int]]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_of_units", value)


@pulumi.input_type
class OceanAutoscalerResourceLimitsArgs:
    def __init__(__self__, *,
                 max_memory_gib: Optional[pulumi.Input[int]] = None,
                 max_vcpu: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_memory_gib: The maximum memory in GiB units that can be allocated to the cluster.
        :param pulumi.Input[int] max_vcpu: The maximum cpu in vCPU units that can be allocated to the cluster.
        """
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum memory in GiB units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_memory_gib")

    @max_memory_gib.setter
    def max_memory_gib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_memory_gib", value)

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum cpu in vCPU units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_vcpu")

    @max_vcpu.setter
    def max_vcpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_vcpu", value)


@pulumi.input_type
class OceanBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 ebs: Optional[pulumi.Input['OceanBlockDeviceMappingEbsArgs']] = None,
                 no_device: Optional[pulumi.Input[str]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: String. Set device name. Example: `/dev/xvda1`.
        :param pulumi.Input['OceanBlockDeviceMappingEbsArgs'] ebs: Object. Set Elastic Block Store properties.
        :param pulumi.Input[str] no_device: String. Suppresses the specified device included in the block device mapping of the AMI.
        """
        pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        String. Set device name. Example: `/dev/xvda1`.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def ebs(self) -> Optional[pulumi.Input['OceanBlockDeviceMappingEbsArgs']]:
        """
        Object. Set Elastic Block Store properties.
        """
        return pulumi.get(self, "ebs")

    @ebs.setter
    def ebs(self, value: Optional[pulumi.Input['OceanBlockDeviceMappingEbsArgs']]):
        pulumi.set(self, "ebs", value)

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[str]]:
        """
        String. Suppresses the specified device included in the block device mapping of the AMI.
        """
        return pulumi.get(self, "no_device")

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "no_device", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_name", value)


@pulumi.input_type
class OceanBlockDeviceMappingEbsArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 dynamic_volume_size: Optional[pulumi.Input['OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs']] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] delete_on_termination: Boolean. Toggles EBS deletion upon instance termination.
        :param pulumi.Input['OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs'] dynamic_volume_size: Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
        :param pulumi.Input[bool] encrypted: Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        :param pulumi.Input[int] iops: Int. The number of I/O operations per second (IOPS) that the volume supports.
        :param pulumi.Input[str] kms_key_id: String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
        :param pulumi.Input[str] snapshot_id: (Optional) String. The snapshot ID to mount by.
        :param pulumi.Input[int] throughput: The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volume_type` = gp3.
        :param pulumi.Input[int] volume_size: Int. The size (in GB) of the volume.
        :param pulumi.Input[str] volume_type: String. The type of the volume. Example: `gp2`.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if dynamic_volume_size is not None:
            pulumi.set(__self__, "dynamic_volume_size", dynamic_volume_size)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean. Toggles EBS deletion upon instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter(name="dynamicVolumeSize")
    def dynamic_volume_size(self) -> Optional[pulumi.Input['OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs']]:
        """
        Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
        """
        return pulumi.get(self, "dynamic_volume_size")

    @dynamic_volume_size.setter
    def dynamic_volume_size(self, value: Optional[pulumi.Input['OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs']]):
        pulumi.set(self, "dynamic_volume_size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Int. The number of I/O operations per second (IOPS) that the volume supports.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) String. The snapshot ID to mount by.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volume_type` = gp3.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        Int. The size (in GB) of the volume.
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        String. The type of the volume. Example: `gp2`.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs:
    def __init__(__self__, *,
                 base_size: pulumi.Input[int],
                 resource: pulumi.Input[str],
                 size_per_resource_unit: pulumi.Input[int]):
        """
        :param pulumi.Input[int] base_size: Int. Initial size for volume. Example: `50`.
        :param pulumi.Input[str] resource: String. Resource type to increase volume size dynamically by. Valid values: `CPU`.
        :param pulumi.Input[int] size_per_resource_unit: Int. Additional size (in GB) per resource unit. Example: When the `baseSize=50`, `sizePerResourceUnit=20`, and instance with two CPUs is launched, its total disk size will be: 90GB.
        """
        pulumi.set(__self__, "base_size", base_size)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "size_per_resource_unit", size_per_resource_unit)

    @property
    @pulumi.getter(name="baseSize")
    def base_size(self) -> pulumi.Input[int]:
        """
        Int. Initial size for volume. Example: `50`.
        """
        return pulumi.get(self, "base_size")

    @base_size.setter
    def base_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "base_size", value)

    @property
    @pulumi.getter
    def resource(self) -> pulumi.Input[str]:
        """
        String. Resource type to increase volume size dynamically by. Valid values: `CPU`.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter(name="sizePerResourceUnit")
    def size_per_resource_unit(self) -> pulumi.Input[int]:
        """
        Int. Additional size (in GB) per resource unit. Example: When the `baseSize=50`, `sizePerResourceUnit=20`, and instance with two CPUs is launched, its total disk size will be: 90GB.
        """
        return pulumi.get(self, "size_per_resource_unit")

    @size_per_resource_unit.setter
    def size_per_resource_unit(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_per_resource_unit", value)


@pulumi.input_type
class OceanInstanceMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_tokens: pulumi.Input[str],
                 http_put_response_hop_limit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] http_tokens: Determines if a signed token is required or not. Valid values: `optional` or `required`.
        :param pulumi.Input[int] http_put_response_hop_limit: An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
        """
        pulumi.set(__self__, "http_tokens", http_tokens)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> pulumi.Input[str]:
        """
        Determines if a signed token is required or not. Valid values: `optional` or `required`.
        """
        return pulumi.get(self, "http_tokens")

    @http_tokens.setter
    def http_tokens(self, value: pulumi.Input[str]):
        pulumi.set(self, "http_tokens", value)

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[int]]:
        """
        An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_put_response_hop_limit", value)


@pulumi.input_type
class OceanLaunchSpecAttributeArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The label key.
        :param pulumi.Input[str] value: The label value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The label key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class OceanLaunchSpecAutoscaleHeadroomArgs:
    def __init__(__self__, *,
                 num_of_units: pulumi.Input[int],
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        :param pulumi.Input[int] cpu_per_unit: Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[int] memory_per_unit: Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        pulumi.set(__self__, "num_of_units", num_of_units)
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> pulumi.Input[int]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "num_of_units", value)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)


@pulumi.input_type
class OceanLaunchSpecBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 ebs: Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsArgs']] = None,
                 no_device: Optional[pulumi.Input[str]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def ebs(self) -> Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsArgs']]:
        return pulumi.get(self, "ebs")

    @ebs.setter
    def ebs(self, value: Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsArgs']]):
        pulumi.set(self, "ebs", value)

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "no_device")

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "no_device", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_name", value)


@pulumi.input_type
class OceanLaunchSpecBlockDeviceMappingEbsArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 dynamic_volume_size: Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs']] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if dynamic_volume_size is not None:
            pulumi.set(__self__, "dynamic_volume_size", dynamic_volume_size)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter(name="dynamicVolumeSize")
    def dynamic_volume_size(self) -> Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs']]:
        return pulumi.get(self, "dynamic_volume_size")

    @dynamic_volume_size.setter
    def dynamic_volume_size(self, value: Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs']]):
        pulumi.set(self, "dynamic_volume_size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs:
    def __init__(__self__, *,
                 base_size: pulumi.Input[int],
                 resource: pulumi.Input[str],
                 size_per_resource_unit: pulumi.Input[int]):
        pulumi.set(__self__, "base_size", base_size)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "size_per_resource_unit", size_per_resource_unit)

    @property
    @pulumi.getter(name="baseSize")
    def base_size(self) -> pulumi.Input[int]:
        return pulumi.get(self, "base_size")

    @base_size.setter
    def base_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "base_size", value)

    @property
    @pulumi.getter
    def resource(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter(name="sizePerResourceUnit")
    def size_per_resource_unit(self) -> pulumi.Input[int]:
        return pulumi.get(self, "size_per_resource_unit")

    @size_per_resource_unit.setter
    def size_per_resource_unit(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_per_resource_unit", value)


@pulumi.input_type
class OceanLaunchSpecSchedulingTaskArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[str],
                 is_enabled: pulumi.Input[bool],
                 task_type: pulumi.Input[str],
                 task_headrooms: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]] = None):
        """
        :param pulumi.Input[str] cron_expression: A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
        :param pulumi.Input[bool] is_enabled: Describes whether the task is enabled. When True, the task runs. When False, it does not run.
        :param pulumi.Input[str] task_type: The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
        :param pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]] task_headrooms: The config of this scheduled task. Depends on the value of taskType.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "task_type", task_type)
        if task_headrooms is not None:
            pulumi.set(__self__, "task_headrooms", task_headrooms)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[str]:
        """
        A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Describes whether the task is enabled. When True, the task runs. When False, it does not run.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input[str]:
        """
        The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_type", value)

    @property
    @pulumi.getter(name="taskHeadrooms")
    def task_headrooms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]]:
        """
        The config of this scheduled task. Depends on the value of taskType.
        """
        return pulumi.get(self, "task_headrooms")

    @task_headrooms.setter
    def task_headrooms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]]):
        pulumi.set(self, "task_headrooms", value)


@pulumi.input_type
class OceanLaunchSpecSchedulingTaskTaskHeadroomArgs:
    def __init__(__self__, *,
                 num_of_units: pulumi.Input[int],
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        :param pulumi.Input[int] cpu_per_unit: Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[int] memory_per_unit: Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        pulumi.set(__self__, "num_of_units", num_of_units)
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> pulumi.Input[int]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "num_of_units", value)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)


@pulumi.input_type
class OceanLaunchSpecTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The label key.
        :param pulumi.Input[str] value: The label value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The label key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class OceanOptimizeImagesArgs:
    def __init__(__self__, *,
                 perform_at: pulumi.Input[str],
                 should_optimize_ecs_ami: pulumi.Input[bool],
                 time_windows: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] perform_at: String. Valid values: "always" "never" "timeWindow".
        :param pulumi.Input[bool] should_optimize_ecs_ami: Boolean. Enable auto image (AMI) update for the ECS container instances. The auto update applies for ECS-Optimized AMIs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] time_windows: Set time windows for shutdown hours. Specify a list of `timeWindows` with at least one time window Each string is in the format of `ddd:hh:mm-ddd:hh:mm` (ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59). Time windows should not overlap. Required when `cluster.scheduling.isEnabled` is true. API Times are in UTC. Example: `Fri:15:30-Wed:14:30`.
        """
        pulumi.set(__self__, "perform_at", perform_at)
        pulumi.set(__self__, "should_optimize_ecs_ami", should_optimize_ecs_ami)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)

    @property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> pulumi.Input[str]:
        """
        String. Valid values: "always" "never" "timeWindow".
        """
        return pulumi.get(self, "perform_at")

    @perform_at.setter
    def perform_at(self, value: pulumi.Input[str]):
        pulumi.set(self, "perform_at", value)

    @property
    @pulumi.getter(name="shouldOptimizeEcsAmi")
    def should_optimize_ecs_ami(self) -> pulumi.Input[bool]:
        """
        Boolean. Enable auto image (AMI) update for the ECS container instances. The auto update applies for ECS-Optimized AMIs.
        """
        return pulumi.get(self, "should_optimize_ecs_ami")

    @should_optimize_ecs_ami.setter
    def should_optimize_ecs_ami(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_optimize_ecs_ami", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set time windows for shutdown hours. Specify a list of `timeWindows` with at least one time window Each string is in the format of `ddd:hh:mm-ddd:hh:mm` (ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59). Time windows should not overlap. Required when `cluster.scheduling.isEnabled` is true. API Times are in UTC. Example: `Fri:15:30-Wed:14:30`.
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "time_windows", value)


@pulumi.input_type
class OceanScheduledTaskArgs:
    def __init__(__self__, *,
                 shutdown_hours: Optional[pulumi.Input['OceanScheduledTaskShutdownHoursArgs']] = None,
                 tasks: Optional[pulumi.Input[Sequence[pulumi.Input['OceanScheduledTaskTaskArgs']]]] = None):
        """
        :param pulumi.Input['OceanScheduledTaskShutdownHoursArgs'] shutdown_hours: Set shutdown hours for cluster object.
        :param pulumi.Input[Sequence[pulumi.Input['OceanScheduledTaskTaskArgs']]] tasks: The scheduling tasks for the cluster.
        """
        if shutdown_hours is not None:
            pulumi.set(__self__, "shutdown_hours", shutdown_hours)
        if tasks is not None:
            pulumi.set(__self__, "tasks", tasks)

    @property
    @pulumi.getter(name="shutdownHours")
    def shutdown_hours(self) -> Optional[pulumi.Input['OceanScheduledTaskShutdownHoursArgs']]:
        """
        Set shutdown hours for cluster object.
        """
        return pulumi.get(self, "shutdown_hours")

    @shutdown_hours.setter
    def shutdown_hours(self, value: Optional[pulumi.Input['OceanScheduledTaskShutdownHoursArgs']]):
        pulumi.set(self, "shutdown_hours", value)

    @property
    @pulumi.getter
    def tasks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanScheduledTaskTaskArgs']]]]:
        """
        The scheduling tasks for the cluster.
        """
        return pulumi.get(self, "tasks")

    @tasks.setter
    def tasks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanScheduledTaskTaskArgs']]]]):
        pulumi.set(self, "tasks", value)


@pulumi.input_type
class OceanScheduledTaskShutdownHoursArgs:
    def __init__(__self__, *,
                 time_windows: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] time_windows: Set time windows for shutdown hours. Specify a list of `timeWindows` with at least one time window Each string is in the format of `ddd:hh:mm-ddd:hh:mm` (ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59). Time windows should not overlap. Required when `cluster.scheduling.isEnabled` is true. API Times are in UTC. Example: `Fri:15:30-Wed:14:30`.
        :param pulumi.Input[bool] is_enabled: Describes whether the task is enabled. When true the task should run when false it should not run. Required for `cluster.scheduling.tasks` object.
        """
        pulumi.set(__self__, "time_windows", time_windows)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set time windows for shutdown hours. Specify a list of `timeWindows` with at least one time window Each string is in the format of `ddd:hh:mm-ddd:hh:mm` (ddd = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat hh = hour 24 = 0 -23 mm = minute = 0 - 59). Time windows should not overlap. Required when `cluster.scheduling.isEnabled` is true. API Times are in UTC. Example: `Fri:15:30-Wed:14:30`.
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes whether the task is enabled. When true the task should run when false it should not run. Required for `cluster.scheduling.tasks` object.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


@pulumi.input_type
class OceanScheduledTaskTaskArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[str],
                 is_enabled: pulumi.Input[bool],
                 task_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cron_expression: A valid cron expression. The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of `frequency` or `cronExpression` should be used at a time. Required for `cluster.scheduling.tasks` object. Example: `0 1 * * *`.
        :param pulumi.Input[bool] is_enabled: Describes whether the task is enabled. When true the task should run when false it should not run. Required for `cluster.scheduling.tasks` object.
        :param pulumi.Input[str] task_type: Valid values: "clusterRoll". Required for `cluster.scheduling.tasks object`. Example: `clusterRoll`.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[str]:
        """
        A valid cron expression. The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of `frequency` or `cronExpression` should be used at a time. Required for `cluster.scheduling.tasks` object. Example: `0 1 * * *`.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Describes whether the task is enabled. When true the task should run when false it should not run. Required for `cluster.scheduling.tasks` object.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input[str]:
        """
        Valid values: "clusterRoll". Required for `cluster.scheduling.tasks object`. Example: `clusterRoll`.
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_type", value)


@pulumi.input_type
class OceanTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The tag key.
        :param pulumi.Input[str] value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class OceanUpdatePolicyArgs:
    def __init__(__self__, *,
                 should_roll: pulumi.Input[bool],
                 conditioned_roll: Optional[pulumi.Input[bool]] = None,
                 roll_config: Optional[pulumi.Input['OceanUpdatePolicyRollConfigArgs']] = None):
        """
        :param pulumi.Input[bool] should_roll: Enables the roll.
        :param pulumi.Input[bool] conditioned_roll: Spot will perform a cluster Roll in accordance with a relevant modification of the clusters settings. When set to true , only specific changes in the clusters configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
        """
        pulumi.set(__self__, "should_roll", should_roll)
        if conditioned_roll is not None:
            pulumi.set(__self__, "conditioned_roll", conditioned_roll)
        if roll_config is not None:
            pulumi.set(__self__, "roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> pulumi.Input[bool]:
        """
        Enables the roll.
        """
        return pulumi.get(self, "should_roll")

    @should_roll.setter
    def should_roll(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_roll", value)

    @property
    @pulumi.getter(name="conditionedRoll")
    def conditioned_roll(self) -> Optional[pulumi.Input[bool]]:
        """
        Spot will perform a cluster Roll in accordance with a relevant modification of the clusters settings. When set to true , only specific changes in the clusters configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
        """
        return pulumi.get(self, "conditioned_roll")

    @conditioned_roll.setter
    def conditioned_roll(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "conditioned_roll", value)

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional[pulumi.Input['OceanUpdatePolicyRollConfigArgs']]:
        return pulumi.get(self, "roll_config")

    @roll_config.setter
    def roll_config(self, value: Optional[pulumi.Input['OceanUpdatePolicyRollConfigArgs']]):
        pulumi.set(self, "roll_config", value)


@pulumi.input_type
class OceanUpdatePolicyRollConfigArgs:
    def __init__(__self__, *,
                 batch_size_percentage: pulumi.Input[int]):
        """
        :param pulumi.Input[int] batch_size_percentage: Sets the percentage of the instances to deploy in each batch.
        """
        pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> pulumi.Input[int]:
        """
        Sets the percentage of the instances to deploy in each batch.
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: pulumi.Input[int]):
        pulumi.set(self, "batch_size_percentage", value)


