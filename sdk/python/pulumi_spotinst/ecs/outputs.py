# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'OceanAutoscaler',
    'OceanAutoscalerDown',
    'OceanAutoscalerHeadroom',
    'OceanAutoscalerResourceLimits',
    'OceanBlockDeviceMapping',
    'OceanBlockDeviceMappingEbs',
    'OceanBlockDeviceMappingEbsDynamicVolumeSize',
    'OceanClusterOrientation',
    'OceanFilters',
    'OceanInstanceMetadataOptions',
    'OceanLaunchSpecAttribute',
    'OceanLaunchSpecAutoscaleHeadroom',
    'OceanLaunchSpecBlockDeviceMapping',
    'OceanLaunchSpecBlockDeviceMappingEbs',
    'OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize',
    'OceanLaunchSpecImage',
    'OceanLaunchSpecInstanceMetadataOptions',
    'OceanLaunchSpecSchedulingTask',
    'OceanLaunchSpecSchedulingTaskTaskHeadroom',
    'OceanLaunchSpecStrategy',
    'OceanLaunchSpecTag',
    'OceanLogging',
    'OceanLoggingExport',
    'OceanLoggingExportS3',
    'OceanOptimizeImages',
    'OceanScheduledTask',
    'OceanScheduledTaskShutdownHours',
    'OceanScheduledTaskTask',
    'OceanTag',
    'OceanUpdatePolicy',
    'OceanUpdatePolicyRollConfig',
]

@pulumi.output_type
class OceanAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoHeadroomPercentage":
            suggest = "auto_headroom_percentage"
        elif key == "enableAutomaticAndManualHeadroom":
            suggest = "enable_automatic_and_manual_headroom"
        elif key == "isAutoConfig":
            suggest = "is_auto_config"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "resourceLimits":
            suggest = "resource_limits"
        elif key == "shouldScaleDownNonServiceTasks":
            suggest = "should_scale_down_non_service_tasks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_headroom_percentage: Optional[int] = None,
                 cooldown: Optional[int] = None,
                 down: Optional['outputs.OceanAutoscalerDown'] = None,
                 enable_automatic_and_manual_headroom: Optional[bool] = None,
                 headroom: Optional['outputs.OceanAutoscalerHeadroom'] = None,
                 is_auto_config: Optional[bool] = None,
                 is_enabled: Optional[bool] = None,
                 resource_limits: Optional['outputs.OceanAutoscalerResourceLimits'] = None,
                 should_scale_down_non_service_tasks: Optional[bool] = None):
        if auto_headroom_percentage is not None:
            pulumi.set(__self__, "auto_headroom_percentage", auto_headroom_percentage)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if down is not None:
            pulumi.set(__self__, "down", down)
        if enable_automatic_and_manual_headroom is not None:
            pulumi.set(__self__, "enable_automatic_and_manual_headroom", enable_automatic_and_manual_headroom)
        if headroom is not None:
            pulumi.set(__self__, "headroom", headroom)
        if is_auto_config is not None:
            pulumi.set(__self__, "is_auto_config", is_auto_config)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if resource_limits is not None:
            pulumi.set(__self__, "resource_limits", resource_limits)
        if should_scale_down_non_service_tasks is not None:
            pulumi.set(__self__, "should_scale_down_non_service_tasks", should_scale_down_non_service_tasks)

    @property
    @pulumi.getter(name="autoHeadroomPercentage")
    def auto_headroom_percentage(self) -> Optional[int]:
        return pulumi.get(self, "auto_headroom_percentage")

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[int]:
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter
    def down(self) -> Optional['outputs.OceanAutoscalerDown']:
        return pulumi.get(self, "down")

    @property
    @pulumi.getter(name="enableAutomaticAndManualHeadroom")
    def enable_automatic_and_manual_headroom(self) -> Optional[bool]:
        return pulumi.get(self, "enable_automatic_and_manual_headroom")

    @property
    @pulumi.getter
    def headroom(self) -> Optional['outputs.OceanAutoscalerHeadroom']:
        return pulumi.get(self, "headroom")

    @property
    @pulumi.getter(name="isAutoConfig")
    def is_auto_config(self) -> Optional[bool]:
        return pulumi.get(self, "is_auto_config")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="resourceLimits")
    def resource_limits(self) -> Optional['outputs.OceanAutoscalerResourceLimits']:
        return pulumi.get(self, "resource_limits")

    @property
    @pulumi.getter(name="shouldScaleDownNonServiceTasks")
    def should_scale_down_non_service_tasks(self) -> Optional[bool]:
        return pulumi.get(self, "should_scale_down_non_service_tasks")


@pulumi.output_type
class OceanAutoscalerDown(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxScaleDownPercentage":
            suggest = "max_scale_down_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanAutoscalerDown. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanAutoscalerDown.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanAutoscalerDown.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_scale_down_percentage: Optional[float] = None):
        if max_scale_down_percentage is not None:
            pulumi.set(__self__, "max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[float]:
        return pulumi.get(self, "max_scale_down_percentage")


@pulumi.output_type
class OceanAutoscalerHeadroom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuPerUnit":
            suggest = "cpu_per_unit"
        elif key == "memoryPerUnit":
            suggest = "memory_per_unit"
        elif key == "numOfUnits":
            suggest = "num_of_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanAutoscalerHeadroom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanAutoscalerHeadroom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanAutoscalerHeadroom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_per_unit: Optional[int] = None,
                 memory_per_unit: Optional[int] = None,
                 num_of_units: Optional[int] = None):
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "cpu_per_unit")

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "memory_per_unit")

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[int]:
        return pulumi.get(self, "num_of_units")


@pulumi.output_type
class OceanAutoscalerResourceLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxMemoryGib":
            suggest = "max_memory_gib"
        elif key == "maxVcpu":
            suggest = "max_vcpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanAutoscalerResourceLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanAutoscalerResourceLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanAutoscalerResourceLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_memory_gib: Optional[int] = None,
                 max_vcpu: Optional[int] = None):
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[int]:
        return pulumi.get(self, "max_memory_gib")

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[int]:
        return pulumi.get(self, "max_vcpu")


@pulumi.output_type
class OceanBlockDeviceMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 ebs: Optional['outputs.OceanBlockDeviceMappingEbs'] = None,
                 no_device: Optional[str] = None,
                 virtual_name: Optional[str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.OceanBlockDeviceMappingEbs']:
        return pulumi.get(self, "ebs")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[str]:
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class OceanBlockDeviceMappingEbs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "dynamicVolumeSize":
            suggest = "dynamic_volume_size"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanBlockDeviceMappingEbs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanBlockDeviceMappingEbs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanBlockDeviceMappingEbs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 dynamic_volume_size: Optional['outputs.OceanBlockDeviceMappingEbsDynamicVolumeSize'] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 throughput: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if dynamic_volume_size is not None:
            pulumi.set(__self__, "dynamic_volume_size", dynamic_volume_size)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter(name="dynamicVolumeSize")
    def dynamic_volume_size(self) -> Optional['outputs.OceanBlockDeviceMappingEbsDynamicVolumeSize']:
        return pulumi.get(self, "dynamic_volume_size")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class OceanBlockDeviceMappingEbsDynamicVolumeSize(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseSize":
            suggest = "base_size"
        elif key == "sizePerResourceUnit":
            suggest = "size_per_resource_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanBlockDeviceMappingEbsDynamicVolumeSize. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanBlockDeviceMappingEbsDynamicVolumeSize.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanBlockDeviceMappingEbsDynamicVolumeSize.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_size: int,
                 resource: str,
                 size_per_resource_unit: int):
        pulumi.set(__self__, "base_size", base_size)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "size_per_resource_unit", size_per_resource_unit)

    @property
    @pulumi.getter(name="baseSize")
    def base_size(self) -> int:
        return pulumi.get(self, "base_size")

    @property
    @pulumi.getter
    def resource(self) -> str:
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="sizePerResourceUnit")
    def size_per_resource_unit(self) -> int:
        return pulumi.get(self, "size_per_resource_unit")


@pulumi.output_type
class OceanClusterOrientation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityVsCost":
            suggest = "availability_vs_cost"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanClusterOrientation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanClusterOrientation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanClusterOrientation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_vs_cost: Optional[str] = None):
        """
        :param str availability_vs_cost: You can control the approach that Ocean takes while launching nodes by configuring this value. Possible values: `costOriented`,`balanced`,`cheapest`.
        """
        if availability_vs_cost is not None:
            pulumi.set(__self__, "availability_vs_cost", availability_vs_cost)

    @property
    @pulumi.getter(name="availabilityVsCost")
    def availability_vs_cost(self) -> Optional[str]:
        """
        You can control the approach that Ocean takes while launching nodes by configuring this value. Possible values: `costOriented`,`balanced`,`cheapest`.
        """
        return pulumi.get(self, "availability_vs_cost")


@pulumi.output_type
class OceanFilters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskTypes":
            suggest = "disk_types"
        elif key == "excludeFamilies":
            suggest = "exclude_families"
        elif key == "excludeMetal":
            suggest = "exclude_metal"
        elif key == "includeFamilies":
            suggest = "include_families"
        elif key == "isEnaSupported":
            suggest = "is_ena_supported"
        elif key == "maxGpu":
            suggest = "max_gpu"
        elif key == "maxMemoryGib":
            suggest = "max_memory_gib"
        elif key == "maxNetworkPerformance":
            suggest = "max_network_performance"
        elif key == "maxVcpu":
            suggest = "max_vcpu"
        elif key == "minEnis":
            suggest = "min_enis"
        elif key == "minGpu":
            suggest = "min_gpu"
        elif key == "minMemoryGib":
            suggest = "min_memory_gib"
        elif key == "minNetworkPerformance":
            suggest = "min_network_performance"
        elif key == "minVcpu":
            suggest = "min_vcpu"
        elif key == "rootDeviceTypes":
            suggest = "root_device_types"
        elif key == "virtualizationTypes":
            suggest = "virtualization_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanFilters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanFilters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanFilters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 architectures: Optional[Sequence[str]] = None,
                 categories: Optional[Sequence[str]] = None,
                 disk_types: Optional[Sequence[str]] = None,
                 exclude_families: Optional[Sequence[str]] = None,
                 exclude_metal: Optional[bool] = None,
                 hypervisors: Optional[Sequence[str]] = None,
                 include_families: Optional[Sequence[str]] = None,
                 is_ena_supported: Optional[str] = None,
                 max_gpu: Optional[int] = None,
                 max_memory_gib: Optional[float] = None,
                 max_network_performance: Optional[int] = None,
                 max_vcpu: Optional[int] = None,
                 min_enis: Optional[int] = None,
                 min_gpu: Optional[int] = None,
                 min_memory_gib: Optional[float] = None,
                 min_network_performance: Optional[int] = None,
                 min_vcpu: Optional[int] = None,
                 root_device_types: Optional[Sequence[str]] = None,
                 virtualization_types: Optional[Sequence[str]] = None):
        if architectures is not None:
            pulumi.set(__self__, "architectures", architectures)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if disk_types is not None:
            pulumi.set(__self__, "disk_types", disk_types)
        if exclude_families is not None:
            pulumi.set(__self__, "exclude_families", exclude_families)
        if exclude_metal is not None:
            pulumi.set(__self__, "exclude_metal", exclude_metal)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if include_families is not None:
            pulumi.set(__self__, "include_families", include_families)
        if is_ena_supported is not None:
            pulumi.set(__self__, "is_ena_supported", is_ena_supported)
        if max_gpu is not None:
            pulumi.set(__self__, "max_gpu", max_gpu)
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_network_performance is not None:
            pulumi.set(__self__, "max_network_performance", max_network_performance)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)
        if min_enis is not None:
            pulumi.set(__self__, "min_enis", min_enis)
        if min_gpu is not None:
            pulumi.set(__self__, "min_gpu", min_gpu)
        if min_memory_gib is not None:
            pulumi.set(__self__, "min_memory_gib", min_memory_gib)
        if min_network_performance is not None:
            pulumi.set(__self__, "min_network_performance", min_network_performance)
        if min_vcpu is not None:
            pulumi.set(__self__, "min_vcpu", min_vcpu)
        if root_device_types is not None:
            pulumi.set(__self__, "root_device_types", root_device_types)
        if virtualization_types is not None:
            pulumi.set(__self__, "virtualization_types", virtualization_types)

    @property
    @pulumi.getter
    def architectures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "architectures")

    @property
    @pulumi.getter
    def categories(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter(name="diskTypes")
    def disk_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "disk_types")

    @property
    @pulumi.getter(name="excludeFamilies")
    def exclude_families(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclude_families")

    @property
    @pulumi.getter(name="excludeMetal")
    def exclude_metal(self) -> Optional[bool]:
        return pulumi.get(self, "exclude_metal")

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hypervisors")

    @property
    @pulumi.getter(name="includeFamilies")
    def include_families(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "include_families")

    @property
    @pulumi.getter(name="isEnaSupported")
    def is_ena_supported(self) -> Optional[str]:
        return pulumi.get(self, "is_ena_supported")

    @property
    @pulumi.getter(name="maxGpu")
    def max_gpu(self) -> Optional[int]:
        return pulumi.get(self, "max_gpu")

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[float]:
        return pulumi.get(self, "max_memory_gib")

    @property
    @pulumi.getter(name="maxNetworkPerformance")
    def max_network_performance(self) -> Optional[int]:
        return pulumi.get(self, "max_network_performance")

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[int]:
        return pulumi.get(self, "max_vcpu")

    @property
    @pulumi.getter(name="minEnis")
    def min_enis(self) -> Optional[int]:
        return pulumi.get(self, "min_enis")

    @property
    @pulumi.getter(name="minGpu")
    def min_gpu(self) -> Optional[int]:
        return pulumi.get(self, "min_gpu")

    @property
    @pulumi.getter(name="minMemoryGib")
    def min_memory_gib(self) -> Optional[float]:
        return pulumi.get(self, "min_memory_gib")

    @property
    @pulumi.getter(name="minNetworkPerformance")
    def min_network_performance(self) -> Optional[int]:
        return pulumi.get(self, "min_network_performance")

    @property
    @pulumi.getter(name="minVcpu")
    def min_vcpu(self) -> Optional[int]:
        return pulumi.get(self, "min_vcpu")

    @property
    @pulumi.getter(name="rootDeviceTypes")
    def root_device_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "root_device_types")

    @property
    @pulumi.getter(name="virtualizationTypes")
    def virtualization_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "virtualization_types")


@pulumi.output_type
class OceanInstanceMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpTokens":
            suggest = "http_tokens"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanInstanceMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanInstanceMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanInstanceMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_tokens: str,
                 http_put_response_hop_limit: Optional[int] = None):
        """
        :param str http_tokens: Determines if a signed token is required or not. Valid values: `optional` or `required`.
        :param int http_put_response_hop_limit: An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
        """
        pulumi.set(__self__, "http_tokens", http_tokens)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> str:
        """
        Determines if a signed token is required or not. Valid values: `optional` or `required`.
        """
        return pulumi.get(self, "http_tokens")

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[int]:
        """
        An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
        """
        return pulumi.get(self, "http_put_response_hop_limit")


@pulumi.output_type
class OceanLaunchSpecAttribute(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The label key.
        :param str value: The label value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The label key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The label value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanLaunchSpecAutoscaleHeadroom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numOfUnits":
            suggest = "num_of_units"
        elif key == "cpuPerUnit":
            suggest = "cpu_per_unit"
        elif key == "memoryPerUnit":
            suggest = "memory_per_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecAutoscaleHeadroom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecAutoscaleHeadroom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecAutoscaleHeadroom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_of_units: int,
                 cpu_per_unit: Optional[int] = None,
                 memory_per_unit: Optional[int] = None):
        """
        :param int num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        :param int cpu_per_unit: Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in CPU units, where 1024 units = 1 vCPU.
        :param int memory_per_unit: Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        pulumi.set(__self__, "num_of_units", num_of_units)
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> int:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        return pulumi.get(self, "num_of_units")

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[int]:
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in CPU units, where 1024 units = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[int]:
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        return pulumi.get(self, "memory_per_unit")


@pulumi.output_type
class OceanLaunchSpecBlockDeviceMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 ebs: Optional['outputs.OceanLaunchSpecBlockDeviceMappingEbs'] = None,
                 no_device: Optional[str] = None,
                 virtual_name: Optional[str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.OceanLaunchSpecBlockDeviceMappingEbs']:
        return pulumi.get(self, "ebs")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[str]:
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class OceanLaunchSpecBlockDeviceMappingEbs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "dynamicVolumeSize":
            suggest = "dynamic_volume_size"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecBlockDeviceMappingEbs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecBlockDeviceMappingEbs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecBlockDeviceMappingEbs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 dynamic_volume_size: Optional['outputs.OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize'] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 throughput: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if dynamic_volume_size is not None:
            pulumi.set(__self__, "dynamic_volume_size", dynamic_volume_size)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter(name="dynamicVolumeSize")
    def dynamic_volume_size(self) -> Optional['outputs.OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize']:
        return pulumi.get(self, "dynamic_volume_size")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseSize":
            suggest = "base_size"
        elif key == "sizePerResourceUnit":
            suggest = "size_per_resource_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_size: int,
                 resource: str,
                 size_per_resource_unit: int):
        pulumi.set(__self__, "base_size", base_size)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "size_per_resource_unit", size_per_resource_unit)

    @property
    @pulumi.getter(name="baseSize")
    def base_size(self) -> int:
        return pulumi.get(self, "base_size")

    @property
    @pulumi.getter
    def resource(self) -> str:
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="sizePerResourceUnit")
    def size_per_resource_unit(self) -> int:
        return pulumi.get(self, "size_per_resource_unit")


@pulumi.output_type
class OceanLaunchSpecImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageId":
            suggest = "image_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_id: Optional[str] = None):
        """
        :param str image_id: Identifier of the image in AWS. Valid values: any string which is not empty or null.
        """
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[str]:
        """
        Identifier of the image in AWS. Valid values: any string which is not empty or null.
        """
        return pulumi.get(self, "image_id")


@pulumi.output_type
class OceanLaunchSpecInstanceMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpTokens":
            suggest = "http_tokens"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecInstanceMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecInstanceMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecInstanceMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_tokens: str,
                 http_put_response_hop_limit: Optional[int] = None):
        """
        :param str http_tokens: Determines if a signed token is required or not. Valid values: `optional` or `required`.
        :param int http_put_response_hop_limit: An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
        """
        pulumi.set(__self__, "http_tokens", http_tokens)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> str:
        """
        Determines if a signed token is required or not. Valid values: `optional` or `required`.
        """
        return pulumi.get(self, "http_tokens")

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[int]:
        """
        An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
        """
        return pulumi.get(self, "http_put_response_hop_limit")


@pulumi.output_type
class OceanLaunchSpecSchedulingTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "taskHeadrooms":
            suggest = "task_headrooms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecSchedulingTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecSchedulingTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecSchedulingTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression: str,
                 is_enabled: bool,
                 task_type: str,
                 task_headrooms: Optional[Sequence['outputs.OceanLaunchSpecSchedulingTaskTaskHeadroom']] = None):
        """
        :param str cron_expression: A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
        :param bool is_enabled: Describes whether the task is enabled. When True, the task runs. When False, it does not run.
        :param str task_type: The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
        :param Sequence['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs'] task_headrooms: The config of this scheduled task. Depends on the value of taskType.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "task_type", task_type)
        if task_headrooms is not None:
            pulumi.set(__self__, "task_headrooms", task_headrooms)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> str:
        """
        A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
        """
        return pulumi.get(self, "cron_expression")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Describes whether the task is enabled. When True, the task runs. When False, it does not run.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        """
        The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
        """
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="taskHeadrooms")
    def task_headrooms(self) -> Optional[Sequence['outputs.OceanLaunchSpecSchedulingTaskTaskHeadroom']]:
        """
        The config of this scheduled task. Depends on the value of taskType.
        """
        return pulumi.get(self, "task_headrooms")


@pulumi.output_type
class OceanLaunchSpecSchedulingTaskTaskHeadroom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numOfUnits":
            suggest = "num_of_units"
        elif key == "cpuPerUnit":
            suggest = "cpu_per_unit"
        elif key == "memoryPerUnit":
            suggest = "memory_per_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecSchedulingTaskTaskHeadroom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecSchedulingTaskTaskHeadroom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecSchedulingTaskTaskHeadroom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_of_units: int,
                 cpu_per_unit: Optional[int] = None,
                 memory_per_unit: Optional[int] = None):
        pulumi.set(__self__, "num_of_units", num_of_units)
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> int:
        return pulumi.get(self, "num_of_units")

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "cpu_per_unit")

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "memory_per_unit")


@pulumi.output_type
class OceanLaunchSpecStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spotPercentage":
            suggest = "spot_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanLaunchSpecStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanLaunchSpecStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanLaunchSpecStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 spot_percentage: Optional[int] = None):
        """
        :param int spot_percentage: When set, Ocean will proactively try to maintain as close as possible to the percentage of Spot instances out of all the Virtual Node Group instances.
               
               <a id="block-devices"></a>
        """
        if spot_percentage is not None:
            pulumi.set(__self__, "spot_percentage", spot_percentage)

    @property
    @pulumi.getter(name="spotPercentage")
    def spot_percentage(self) -> Optional[int]:
        """
        When set, Ocean will proactively try to maintain as close as possible to the percentage of Spot instances out of all the Virtual Node Group instances.

        <a id="block-devices"></a>
        """
        return pulumi.get(self, "spot_percentage")


@pulumi.output_type
class OceanLaunchSpecTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanLogging(dict):
    def __init__(__self__, *,
                 export: Optional['outputs.OceanLoggingExport'] = None):
        """
        :param 'OceanLoggingExportArgs' export: Logging Export configuration.
        """
        if export is not None:
            pulumi.set(__self__, "export", export)

    @property
    @pulumi.getter
    def export(self) -> Optional['outputs.OceanLoggingExport']:
        """
        Logging Export configuration.
        """
        return pulumi.get(self, "export")


@pulumi.output_type
class OceanLoggingExport(dict):
    def __init__(__self__, *,
                 s3s: Optional[Sequence['outputs.OceanLoggingExportS3']] = None):
        if s3s is not None:
            pulumi.set(__self__, "s3s", s3s)

    @property
    @pulumi.getter
    def s3s(self) -> Optional[Sequence['outputs.OceanLoggingExportS3']]:
        return pulumi.get(self, "s3s")


@pulumi.output_type
class OceanLoggingExportS3(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The Spotinst Ocean ID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The Spotinst Ocean ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class OceanOptimizeImages(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "performAt":
            suggest = "perform_at"
        elif key == "shouldOptimizeEcsAmi":
            suggest = "should_optimize_ecs_ami"
        elif key == "timeWindows":
            suggest = "time_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanOptimizeImages. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanOptimizeImages.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanOptimizeImages.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 perform_at: str,
                 should_optimize_ecs_ami: bool,
                 time_windows: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "perform_at", perform_at)
        pulumi.set(__self__, "should_optimize_ecs_ami", should_optimize_ecs_ami)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)

    @property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> str:
        return pulumi.get(self, "perform_at")

    @property
    @pulumi.getter(name="shouldOptimizeEcsAmi")
    def should_optimize_ecs_ami(self) -> bool:
        return pulumi.get(self, "should_optimize_ecs_ami")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "time_windows")


@pulumi.output_type
class OceanScheduledTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shutdownHours":
            suggest = "shutdown_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanScheduledTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanScheduledTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanScheduledTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 shutdown_hours: Optional['outputs.OceanScheduledTaskShutdownHours'] = None,
                 tasks: Optional[Sequence['outputs.OceanScheduledTaskTask']] = None):
        if shutdown_hours is not None:
            pulumi.set(__self__, "shutdown_hours", shutdown_hours)
        if tasks is not None:
            pulumi.set(__self__, "tasks", tasks)

    @property
    @pulumi.getter(name="shutdownHours")
    def shutdown_hours(self) -> Optional['outputs.OceanScheduledTaskShutdownHours']:
        return pulumi.get(self, "shutdown_hours")

    @property
    @pulumi.getter
    def tasks(self) -> Optional[Sequence['outputs.OceanScheduledTaskTask']]:
        return pulumi.get(self, "tasks")


@pulumi.output_type
class OceanScheduledTaskShutdownHours(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeWindows":
            suggest = "time_windows"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanScheduledTaskShutdownHours. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanScheduledTaskShutdownHours.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanScheduledTaskShutdownHours.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_windows: Sequence[str],
                 is_enabled: Optional[bool] = None):
        pulumi.set(__self__, "time_windows", time_windows)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Sequence[str]:
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")


@pulumi.output_type
class OceanScheduledTaskTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "taskType":
            suggest = "task_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanScheduledTaskTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanScheduledTaskTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanScheduledTaskTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression: str,
                 is_enabled: bool,
                 task_type: str):
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> str:
        return pulumi.get(self, "cron_expression")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        return pulumi.get(self, "task_type")


@pulumi.output_type
class OceanTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The tag key.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OceanUpdatePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shouldRoll":
            suggest = "should_roll"
        elif key == "autoApplyTags":
            suggest = "auto_apply_tags"
        elif key == "conditionedRoll":
            suggest = "conditioned_roll"
        elif key == "rollConfig":
            suggest = "roll_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanUpdatePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanUpdatePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanUpdatePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 should_roll: bool,
                 auto_apply_tags: Optional[bool] = None,
                 conditioned_roll: Optional[bool] = None,
                 roll_config: Optional['outputs.OceanUpdatePolicyRollConfig'] = None):
        pulumi.set(__self__, "should_roll", should_roll)
        if auto_apply_tags is not None:
            pulumi.set(__self__, "auto_apply_tags", auto_apply_tags)
        if conditioned_roll is not None:
            pulumi.set(__self__, "conditioned_roll", conditioned_roll)
        if roll_config is not None:
            pulumi.set(__self__, "roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> bool:
        return pulumi.get(self, "should_roll")

    @property
    @pulumi.getter(name="autoApplyTags")
    def auto_apply_tags(self) -> Optional[bool]:
        return pulumi.get(self, "auto_apply_tags")

    @property
    @pulumi.getter(name="conditionedRoll")
    def conditioned_roll(self) -> Optional[bool]:
        return pulumi.get(self, "conditioned_roll")

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional['outputs.OceanUpdatePolicyRollConfig']:
        return pulumi.get(self, "roll_config")


@pulumi.output_type
class OceanUpdatePolicyRollConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchSizePercentage":
            suggest = "batch_size_percentage"
        elif key == "batchMinHealthyPercentage":
            suggest = "batch_min_healthy_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OceanUpdatePolicyRollConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OceanUpdatePolicyRollConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OceanUpdatePolicyRollConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_size_percentage: int,
                 batch_min_healthy_percentage: Optional[int] = None):
        pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if batch_min_healthy_percentage is not None:
            pulumi.set(__self__, "batch_min_healthy_percentage", batch_min_healthy_percentage)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> int:
        return pulumi.get(self, "batch_size_percentage")

    @property
    @pulumi.getter(name="batchMinHealthyPercentage")
    def batch_min_healthy_percentage(self) -> Optional[int]:
        return pulumi.get(self, "batch_min_healthy_percentage")


