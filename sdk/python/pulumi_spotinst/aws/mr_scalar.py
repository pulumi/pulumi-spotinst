# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import json
import warnings
import pulumi
import pulumi.runtime
from typing import Union
from .. import utilities, tables

class MrScalar(pulumi.CustomResource):
    additional_info: pulumi.Output[str]
    additional_primary_security_groups: pulumi.Output[list]
    additional_replica_security_groups: pulumi.Output[list]
    applications: pulumi.Output[list]
    availability_zones: pulumi.Output[list]
    bootstrap_actions_files: pulumi.Output[list]
    cluster_id: pulumi.Output[str]
    """
    The MrScaler cluster id.
    """
    configurations_files: pulumi.Output[list]
    core_desired_capacity: pulumi.Output[float]
    core_ebs_block_devices: pulumi.Output[list]
    core_ebs_optimized: pulumi.Output[bool]
    core_instance_types: pulumi.Output[list]
    core_lifecycle: pulumi.Output[str]
    core_max_size: pulumi.Output[float]
    core_min_size: pulumi.Output[float]
    core_scaling_down_policies: pulumi.Output[list]
    core_scaling_up_policies: pulumi.Output[list]
    core_unit: pulumi.Output[str]
    custom_ami_id: pulumi.Output[str]
    description: pulumi.Output[str]
    """
    The MrScaler description.
    """
    ebs_root_volume_size: pulumi.Output[float]
    ec2_key_name: pulumi.Output[str]
    expose_cluster_id: pulumi.Output[bool]
    instance_weights: pulumi.Output[list]
    job_flow_role: pulumi.Output[str]
    keep_job_flow_alive: pulumi.Output[bool]
    log_uri: pulumi.Output[str]
    managed_primary_security_group: pulumi.Output[str]
    managed_replica_security_group: pulumi.Output[str]
    master_ebs_block_devices: pulumi.Output[list]
    master_ebs_optimized: pulumi.Output[bool]
    master_instance_types: pulumi.Output[list]
    master_lifecycle: pulumi.Output[str]
    name: pulumi.Output[str]
    """
    The MrScaler name.
    """
    output_cluster_id: pulumi.Output[str]
    provisioning_timeout: pulumi.Output[dict]
    region: pulumi.Output[str]
    """
    The MrScaler region.
    """
    release_label: pulumi.Output[str]
    repo_upgrade_on_boot: pulumi.Output[str]
    retries: pulumi.Output[float]
    scheduled_tasks: pulumi.Output[list]
    security_config: pulumi.Output[str]
    service_access_security_group: pulumi.Output[str]
    service_role: pulumi.Output[str]
    steps_files: pulumi.Output[list]
    strategy: pulumi.Output[str]
    """
    The MrScaler strategy. Allowed values are `new` `clone` and `wrap`.
    """
    tags: pulumi.Output[list]
    task_desired_capacity: pulumi.Output[float]
    task_ebs_block_devices: pulumi.Output[list]
    task_ebs_optimized: pulumi.Output[bool]
    task_instance_types: pulumi.Output[list]
    task_lifecycle: pulumi.Output[str]
    task_max_size: pulumi.Output[float]
    task_min_size: pulumi.Output[float]
    task_scaling_down_policies: pulumi.Output[list]
    task_scaling_up_policies: pulumi.Output[list]
    task_unit: pulumi.Output[str]
    termination_policies: pulumi.Output[list]
    """
    Allows defining termination policies for EMR clusters based on CloudWatch Metrics.

      * `statements` (`list`)
        * `evaluationPeriods` (`float`) - The number of periods over which data is compared to the specified threshold.
        * `metricName` (`str`) - The name of the metric in CloudWatch which the statement will be based on.
        * `namespace` (`str`) - Must contain the value: `AWS/ElasticMapReduce`.
        * `operator` (`str`) - The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
        * `period` (`float`) - The time window in seconds over which the statistic is applied.
        * `statistic` (`str`) - The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`                 
        * `threshold` (`float`) - The value that the specified statistic is compared to.
        * `unit` (`str`) - The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`                     
    """
    termination_protected: pulumi.Output[bool]
    visible_to_all_users: pulumi.Output[bool]
    def __init__(__self__, resource_name, opts=None, additional_info=None, additional_primary_security_groups=None, additional_replica_security_groups=None, applications=None, availability_zones=None, bootstrap_actions_files=None, cluster_id=None, configurations_files=None, core_desired_capacity=None, core_ebs_block_devices=None, core_ebs_optimized=None, core_instance_types=None, core_lifecycle=None, core_max_size=None, core_min_size=None, core_scaling_down_policies=None, core_scaling_up_policies=None, core_unit=None, custom_ami_id=None, description=None, ebs_root_volume_size=None, ec2_key_name=None, expose_cluster_id=None, instance_weights=None, job_flow_role=None, keep_job_flow_alive=None, log_uri=None, managed_primary_security_group=None, managed_replica_security_group=None, master_ebs_block_devices=None, master_ebs_optimized=None, master_instance_types=None, master_lifecycle=None, name=None, provisioning_timeout=None, region=None, release_label=None, repo_upgrade_on_boot=None, retries=None, scheduled_tasks=None, security_config=None, service_access_security_group=None, service_role=None, steps_files=None, strategy=None, tags=None, task_desired_capacity=None, task_ebs_block_devices=None, task_ebs_optimized=None, task_instance_types=None, task_lifecycle=None, task_max_size=None, task_min_size=None, task_scaling_down_policies=None, task_scaling_up_policies=None, task_unit=None, termination_policies=None, termination_protected=None, visible_to_all_users=None, __props__=None, __name__=None, __opts__=None):
        """
        Create a MrScalar resource with the given unique name, props, and options.
        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] cluster_id: The MrScaler cluster id.
        :param pulumi.Input[str] description: The MrScaler description.
        :param pulumi.Input[str] name: The MrScaler name.
        :param pulumi.Input[str] region: The MrScaler region.
        :param pulumi.Input[str] strategy: The MrScaler strategy. Allowed values are `new` `clone` and `wrap`.
        :param pulumi.Input[list] termination_policies: Allows defining termination policies for EMR clusters based on CloudWatch Metrics.

        The **applications** object supports the following:

          * `args` (`pulumi.Input[list]`)
          * `name` (`pulumi.Input[str]`) - The MrScaler name.
          * `version` (`pulumi.Input[str]`)

        The **bootstrap_actions_files** object supports the following:

          * `bucket` (`pulumi.Input[str]`)
          * `key` (`pulumi.Input[str]`)

        The **configurations_files** object supports the following:

          * `bucket` (`pulumi.Input[str]`)
          * `key` (`pulumi.Input[str]`)

        The **core_ebs_block_devices** object supports the following:

          * `iops` (`pulumi.Input[float]`)
          * `sizeInGb` (`pulumi.Input[float]`)
          * `volumeType` (`pulumi.Input[str]`)
          * `volumesPerInstance` (`pulumi.Input[float]`)

        The **core_scaling_down_policies** object supports the following:

          * `actionType` (`pulumi.Input[str]`)
          * `adjustment` (`pulumi.Input[str]`)
          * `cooldown` (`pulumi.Input[float]`)
          * `dimensions` (`pulumi.Input[dict]`)
          * `evaluationPeriods` (`pulumi.Input[float]`) - The number of periods over which data is compared to the specified threshold.
          * `maxTargetCapacity` (`pulumi.Input[str]`)
          * `maximum` (`pulumi.Input[str]`)
          * `metricName` (`pulumi.Input[str]`) - The name of the metric in CloudWatch which the statement will be based on.
          * `minTargetCapacity` (`pulumi.Input[str]`)
          * `minimum` (`pulumi.Input[str]`)
          * `namespace` (`pulumi.Input[str]`) - Must contain the value: `AWS/ElasticMapReduce`.
          * `operator` (`pulumi.Input[str]`) - The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
          * `period` (`pulumi.Input[float]`) - The time window in seconds over which the statistic is applied.
          * `policyName` (`pulumi.Input[str]`)
          * `statistic` (`pulumi.Input[str]`) - The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`                 
          * `target` (`pulumi.Input[str]`)
          * `threshold` (`pulumi.Input[float]`) - The value that the specified statistic is compared to.
          * `unit` (`pulumi.Input[str]`) - The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`                     

        The **core_scaling_up_policies** object supports the following:

          * `actionType` (`pulumi.Input[str]`)
          * `adjustment` (`pulumi.Input[str]`)
          * `cooldown` (`pulumi.Input[float]`)
          * `dimensions` (`pulumi.Input[dict]`)
          * `evaluationPeriods` (`pulumi.Input[float]`) - The number of periods over which data is compared to the specified threshold.
          * `maxTargetCapacity` (`pulumi.Input[str]`)
          * `maximum` (`pulumi.Input[str]`)
          * `metricName` (`pulumi.Input[str]`) - The name of the metric in CloudWatch which the statement will be based on.
          * `minTargetCapacity` (`pulumi.Input[str]`)
          * `minimum` (`pulumi.Input[str]`)
          * `namespace` (`pulumi.Input[str]`) - Must contain the value: `AWS/ElasticMapReduce`.
          * `operator` (`pulumi.Input[str]`) - The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
          * `period` (`pulumi.Input[float]`) - The time window in seconds over which the statistic is applied.
          * `policyName` (`pulumi.Input[str]`)
          * `statistic` (`pulumi.Input[str]`) - The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`                 
          * `target` (`pulumi.Input[str]`)
          * `threshold` (`pulumi.Input[float]`) - The value that the specified statistic is compared to.
          * `unit` (`pulumi.Input[str]`) - The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`                     

        The **instance_weights** object supports the following:

          * `instanceType` (`pulumi.Input[str]`)
          * `weightedCapacity` (`pulumi.Input[float]`)

        The **master_ebs_block_devices** object supports the following:

          * `iops` (`pulumi.Input[float]`)
          * `sizeInGb` (`pulumi.Input[float]`)
          * `volumeType` (`pulumi.Input[str]`)
          * `volumesPerInstance` (`pulumi.Input[float]`)

        The **provisioning_timeout** object supports the following:

          * `timeout` (`pulumi.Input[float]`)
          * `timeoutAction` (`pulumi.Input[str]`)

        The **scheduled_tasks** object supports the following:

          * `cron` (`pulumi.Input[str]`)
          * `desired_capacity` (`pulumi.Input[str]`)
          * `instanceGroupType` (`pulumi.Input[str]`)
          * `isEnabled` (`pulumi.Input[bool]`)
          * `maxCapacity` (`pulumi.Input[str]`)
          * `minCapacity` (`pulumi.Input[str]`)
          * `taskType` (`pulumi.Input[str]`)

        The **steps_files** object supports the following:

          * `bucket` (`pulumi.Input[str]`)
          * `key` (`pulumi.Input[str]`)

        The **tags** object supports the following:

          * `key` (`pulumi.Input[str]`)
          * `value` (`pulumi.Input[str]`)

        The **task_ebs_block_devices** object supports the following:

          * `iops` (`pulumi.Input[float]`)
          * `sizeInGb` (`pulumi.Input[float]`)
          * `volumeType` (`pulumi.Input[str]`)
          * `volumesPerInstance` (`pulumi.Input[float]`)

        The **task_scaling_down_policies** object supports the following:

          * `actionType` (`pulumi.Input[str]`)
          * `adjustment` (`pulumi.Input[str]`)
          * `cooldown` (`pulumi.Input[float]`)
          * `dimensions` (`pulumi.Input[dict]`)
          * `evaluationPeriods` (`pulumi.Input[float]`) - The number of periods over which data is compared to the specified threshold.
          * `maxTargetCapacity` (`pulumi.Input[str]`)
          * `maximum` (`pulumi.Input[str]`)
          * `metricName` (`pulumi.Input[str]`) - The name of the metric in CloudWatch which the statement will be based on.
          * `minTargetCapacity` (`pulumi.Input[str]`)
          * `minimum` (`pulumi.Input[str]`)
          * `namespace` (`pulumi.Input[str]`) - Must contain the value: `AWS/ElasticMapReduce`.
          * `operator` (`pulumi.Input[str]`) - The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
          * `period` (`pulumi.Input[float]`) - The time window in seconds over which the statistic is applied.
          * `policyName` (`pulumi.Input[str]`)
          * `statistic` (`pulumi.Input[str]`) - The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`                 
          * `target` (`pulumi.Input[str]`)
          * `threshold` (`pulumi.Input[float]`) - The value that the specified statistic is compared to.
          * `unit` (`pulumi.Input[str]`) - The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`                     

        The **task_scaling_up_policies** object supports the following:

          * `actionType` (`pulumi.Input[str]`)
          * `adjustment` (`pulumi.Input[str]`)
          * `cooldown` (`pulumi.Input[float]`)
          * `dimensions` (`pulumi.Input[dict]`)
          * `evaluationPeriods` (`pulumi.Input[float]`) - The number of periods over which data is compared to the specified threshold.
          * `maxTargetCapacity` (`pulumi.Input[str]`)
          * `maximum` (`pulumi.Input[str]`)
          * `metricName` (`pulumi.Input[str]`) - The name of the metric in CloudWatch which the statement will be based on.
          * `minTargetCapacity` (`pulumi.Input[str]`)
          * `minimum` (`pulumi.Input[str]`)
          * `namespace` (`pulumi.Input[str]`) - Must contain the value: `AWS/ElasticMapReduce`.
          * `operator` (`pulumi.Input[str]`) - The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
          * `period` (`pulumi.Input[float]`) - The time window in seconds over which the statistic is applied.
          * `policyName` (`pulumi.Input[str]`)
          * `statistic` (`pulumi.Input[str]`) - The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`                 
          * `target` (`pulumi.Input[str]`)
          * `threshold` (`pulumi.Input[float]`) - The value that the specified statistic is compared to.
          * `unit` (`pulumi.Input[str]`) - The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`                     

        The **termination_policies** object supports the following:

          * `statements` (`pulumi.Input[list]`)
            * `evaluationPeriods` (`pulumi.Input[float]`) - The number of periods over which data is compared to the specified threshold.
            * `metricName` (`pulumi.Input[str]`) - The name of the metric in CloudWatch which the statement will be based on.
            * `namespace` (`pulumi.Input[str]`) - Must contain the value: `AWS/ElasticMapReduce`.
            * `operator` (`pulumi.Input[str]`) - The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
            * `period` (`pulumi.Input[float]`) - The time window in seconds over which the statistic is applied.
            * `statistic` (`pulumi.Input[str]`) - The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`                 
            * `threshold` (`pulumi.Input[float]`) - The value that the specified statistic is compared to.
            * `unit` (`pulumi.Input[str]`) - The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`                     
        """
        if __name__ is not None:
            warnings.warn("explicit use of __name__ is deprecated", DeprecationWarning)
            resource_name = __name__
        if __opts__ is not None:
            warnings.warn("explicit use of __opts__ is deprecated, use 'opts' instead", DeprecationWarning)
            opts = __opts__
        if opts is None:
            opts = pulumi.ResourceOptions()
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.version is None:
            opts.version = utilities.get_version()
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = dict()

            __props__['additional_info'] = additional_info
            __props__['additional_primary_security_groups'] = additional_primary_security_groups
            __props__['additional_replica_security_groups'] = additional_replica_security_groups
            __props__['applications'] = applications
            __props__['availability_zones'] = availability_zones
            __props__['bootstrap_actions_files'] = bootstrap_actions_files
            __props__['cluster_id'] = cluster_id
            __props__['configurations_files'] = configurations_files
            __props__['core_desired_capacity'] = core_desired_capacity
            __props__['core_ebs_block_devices'] = core_ebs_block_devices
            __props__['core_ebs_optimized'] = core_ebs_optimized
            __props__['core_instance_types'] = core_instance_types
            __props__['core_lifecycle'] = core_lifecycle
            __props__['core_max_size'] = core_max_size
            __props__['core_min_size'] = core_min_size
            __props__['core_scaling_down_policies'] = core_scaling_down_policies
            __props__['core_scaling_up_policies'] = core_scaling_up_policies
            __props__['core_unit'] = core_unit
            __props__['custom_ami_id'] = custom_ami_id
            __props__['description'] = description
            __props__['ebs_root_volume_size'] = ebs_root_volume_size
            __props__['ec2_key_name'] = ec2_key_name
            __props__['expose_cluster_id'] = expose_cluster_id
            __props__['instance_weights'] = instance_weights
            __props__['job_flow_role'] = job_flow_role
            __props__['keep_job_flow_alive'] = keep_job_flow_alive
            __props__['log_uri'] = log_uri
            __props__['managed_primary_security_group'] = managed_primary_security_group
            __props__['managed_replica_security_group'] = managed_replica_security_group
            __props__['master_ebs_block_devices'] = master_ebs_block_devices
            __props__['master_ebs_optimized'] = master_ebs_optimized
            __props__['master_instance_types'] = master_instance_types
            __props__['master_lifecycle'] = master_lifecycle
            __props__['name'] = name
            __props__['provisioning_timeout'] = provisioning_timeout
            __props__['region'] = region
            __props__['release_label'] = release_label
            __props__['repo_upgrade_on_boot'] = repo_upgrade_on_boot
            __props__['retries'] = retries
            __props__['scheduled_tasks'] = scheduled_tasks
            __props__['security_config'] = security_config
            __props__['service_access_security_group'] = service_access_security_group
            __props__['service_role'] = service_role
            __props__['steps_files'] = steps_files
            if strategy is None:
                raise TypeError("Missing required property 'strategy'")
            __props__['strategy'] = strategy
            __props__['tags'] = tags
            __props__['task_desired_capacity'] = task_desired_capacity
            __props__['task_ebs_block_devices'] = task_ebs_block_devices
            __props__['task_ebs_optimized'] = task_ebs_optimized
            __props__['task_instance_types'] = task_instance_types
            __props__['task_lifecycle'] = task_lifecycle
            __props__['task_max_size'] = task_max_size
            __props__['task_min_size'] = task_min_size
            __props__['task_scaling_down_policies'] = task_scaling_down_policies
            __props__['task_scaling_up_policies'] = task_scaling_up_policies
            __props__['task_unit'] = task_unit
            __props__['termination_policies'] = termination_policies
            __props__['termination_protected'] = termination_protected
            __props__['visible_to_all_users'] = visible_to_all_users
            __props__['output_cluster_id'] = None
        super(MrScalar, __self__).__init__(
            'spotinst:aws/mrScalar:MrScalar',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name, id, opts=None, additional_info=None, additional_primary_security_groups=None, additional_replica_security_groups=None, applications=None, availability_zones=None, bootstrap_actions_files=None, cluster_id=None, configurations_files=None, core_desired_capacity=None, core_ebs_block_devices=None, core_ebs_optimized=None, core_instance_types=None, core_lifecycle=None, core_max_size=None, core_min_size=None, core_scaling_down_policies=None, core_scaling_up_policies=None, core_unit=None, custom_ami_id=None, description=None, ebs_root_volume_size=None, ec2_key_name=None, expose_cluster_id=None, instance_weights=None, job_flow_role=None, keep_job_flow_alive=None, log_uri=None, managed_primary_security_group=None, managed_replica_security_group=None, master_ebs_block_devices=None, master_ebs_optimized=None, master_instance_types=None, master_lifecycle=None, name=None, output_cluster_id=None, provisioning_timeout=None, region=None, release_label=None, repo_upgrade_on_boot=None, retries=None, scheduled_tasks=None, security_config=None, service_access_security_group=None, service_role=None, steps_files=None, strategy=None, tags=None, task_desired_capacity=None, task_ebs_block_devices=None, task_ebs_optimized=None, task_instance_types=None, task_lifecycle=None, task_max_size=None, task_min_size=None, task_scaling_down_policies=None, task_scaling_up_policies=None, task_unit=None, termination_policies=None, termination_protected=None, visible_to_all_users=None):
        """
        Get an existing MrScalar resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param str id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] cluster_id: The MrScaler cluster id.
        :param pulumi.Input[str] description: The MrScaler description.
        :param pulumi.Input[str] name: The MrScaler name.
        :param pulumi.Input[str] region: The MrScaler region.
        :param pulumi.Input[str] strategy: The MrScaler strategy. Allowed values are `new` `clone` and `wrap`.
        :param pulumi.Input[list] termination_policies: Allows defining termination policies for EMR clusters based on CloudWatch Metrics.

        The **applications** object supports the following:

          * `args` (`pulumi.Input[list]`)
          * `name` (`pulumi.Input[str]`) - The MrScaler name.
          * `version` (`pulumi.Input[str]`)

        The **bootstrap_actions_files** object supports the following:

          * `bucket` (`pulumi.Input[str]`)
          * `key` (`pulumi.Input[str]`)

        The **configurations_files** object supports the following:

          * `bucket` (`pulumi.Input[str]`)
          * `key` (`pulumi.Input[str]`)

        The **core_ebs_block_devices** object supports the following:

          * `iops` (`pulumi.Input[float]`)
          * `sizeInGb` (`pulumi.Input[float]`)
          * `volumeType` (`pulumi.Input[str]`)
          * `volumesPerInstance` (`pulumi.Input[float]`)

        The **core_scaling_down_policies** object supports the following:

          * `actionType` (`pulumi.Input[str]`)
          * `adjustment` (`pulumi.Input[str]`)
          * `cooldown` (`pulumi.Input[float]`)
          * `dimensions` (`pulumi.Input[dict]`)
          * `evaluationPeriods` (`pulumi.Input[float]`) - The number of periods over which data is compared to the specified threshold.
          * `maxTargetCapacity` (`pulumi.Input[str]`)
          * `maximum` (`pulumi.Input[str]`)
          * `metricName` (`pulumi.Input[str]`) - The name of the metric in CloudWatch which the statement will be based on.
          * `minTargetCapacity` (`pulumi.Input[str]`)
          * `minimum` (`pulumi.Input[str]`)
          * `namespace` (`pulumi.Input[str]`) - Must contain the value: `AWS/ElasticMapReduce`.
          * `operator` (`pulumi.Input[str]`) - The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
          * `period` (`pulumi.Input[float]`) - The time window in seconds over which the statistic is applied.
          * `policyName` (`pulumi.Input[str]`)
          * `statistic` (`pulumi.Input[str]`) - The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`                 
          * `target` (`pulumi.Input[str]`)
          * `threshold` (`pulumi.Input[float]`) - The value that the specified statistic is compared to.
          * `unit` (`pulumi.Input[str]`) - The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`                     

        The **core_scaling_up_policies** object supports the following:

          * `actionType` (`pulumi.Input[str]`)
          * `adjustment` (`pulumi.Input[str]`)
          * `cooldown` (`pulumi.Input[float]`)
          * `dimensions` (`pulumi.Input[dict]`)
          * `evaluationPeriods` (`pulumi.Input[float]`) - The number of periods over which data is compared to the specified threshold.
          * `maxTargetCapacity` (`pulumi.Input[str]`)
          * `maximum` (`pulumi.Input[str]`)
          * `metricName` (`pulumi.Input[str]`) - The name of the metric in CloudWatch which the statement will be based on.
          * `minTargetCapacity` (`pulumi.Input[str]`)
          * `minimum` (`pulumi.Input[str]`)
          * `namespace` (`pulumi.Input[str]`) - Must contain the value: `AWS/ElasticMapReduce`.
          * `operator` (`pulumi.Input[str]`) - The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
          * `period` (`pulumi.Input[float]`) - The time window in seconds over which the statistic is applied.
          * `policyName` (`pulumi.Input[str]`)
          * `statistic` (`pulumi.Input[str]`) - The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`                 
          * `target` (`pulumi.Input[str]`)
          * `threshold` (`pulumi.Input[float]`) - The value that the specified statistic is compared to.
          * `unit` (`pulumi.Input[str]`) - The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`                     

        The **instance_weights** object supports the following:

          * `instanceType` (`pulumi.Input[str]`)
          * `weightedCapacity` (`pulumi.Input[float]`)

        The **master_ebs_block_devices** object supports the following:

          * `iops` (`pulumi.Input[float]`)
          * `sizeInGb` (`pulumi.Input[float]`)
          * `volumeType` (`pulumi.Input[str]`)
          * `volumesPerInstance` (`pulumi.Input[float]`)

        The **provisioning_timeout** object supports the following:

          * `timeout` (`pulumi.Input[float]`)
          * `timeoutAction` (`pulumi.Input[str]`)

        The **scheduled_tasks** object supports the following:

          * `cron` (`pulumi.Input[str]`)
          * `desired_capacity` (`pulumi.Input[str]`)
          * `instanceGroupType` (`pulumi.Input[str]`)
          * `isEnabled` (`pulumi.Input[bool]`)
          * `maxCapacity` (`pulumi.Input[str]`)
          * `minCapacity` (`pulumi.Input[str]`)
          * `taskType` (`pulumi.Input[str]`)

        The **steps_files** object supports the following:

          * `bucket` (`pulumi.Input[str]`)
          * `key` (`pulumi.Input[str]`)

        The **tags** object supports the following:

          * `key` (`pulumi.Input[str]`)
          * `value` (`pulumi.Input[str]`)

        The **task_ebs_block_devices** object supports the following:

          * `iops` (`pulumi.Input[float]`)
          * `sizeInGb` (`pulumi.Input[float]`)
          * `volumeType` (`pulumi.Input[str]`)
          * `volumesPerInstance` (`pulumi.Input[float]`)

        The **task_scaling_down_policies** object supports the following:

          * `actionType` (`pulumi.Input[str]`)
          * `adjustment` (`pulumi.Input[str]`)
          * `cooldown` (`pulumi.Input[float]`)
          * `dimensions` (`pulumi.Input[dict]`)
          * `evaluationPeriods` (`pulumi.Input[float]`) - The number of periods over which data is compared to the specified threshold.
          * `maxTargetCapacity` (`pulumi.Input[str]`)
          * `maximum` (`pulumi.Input[str]`)
          * `metricName` (`pulumi.Input[str]`) - The name of the metric in CloudWatch which the statement will be based on.
          * `minTargetCapacity` (`pulumi.Input[str]`)
          * `minimum` (`pulumi.Input[str]`)
          * `namespace` (`pulumi.Input[str]`) - Must contain the value: `AWS/ElasticMapReduce`.
          * `operator` (`pulumi.Input[str]`) - The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
          * `period` (`pulumi.Input[float]`) - The time window in seconds over which the statistic is applied.
          * `policyName` (`pulumi.Input[str]`)
          * `statistic` (`pulumi.Input[str]`) - The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`                 
          * `target` (`pulumi.Input[str]`)
          * `threshold` (`pulumi.Input[float]`) - The value that the specified statistic is compared to.
          * `unit` (`pulumi.Input[str]`) - The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`                     

        The **task_scaling_up_policies** object supports the following:

          * `actionType` (`pulumi.Input[str]`)
          * `adjustment` (`pulumi.Input[str]`)
          * `cooldown` (`pulumi.Input[float]`)
          * `dimensions` (`pulumi.Input[dict]`)
          * `evaluationPeriods` (`pulumi.Input[float]`) - The number of periods over which data is compared to the specified threshold.
          * `maxTargetCapacity` (`pulumi.Input[str]`)
          * `maximum` (`pulumi.Input[str]`)
          * `metricName` (`pulumi.Input[str]`) - The name of the metric in CloudWatch which the statement will be based on.
          * `minTargetCapacity` (`pulumi.Input[str]`)
          * `minimum` (`pulumi.Input[str]`)
          * `namespace` (`pulumi.Input[str]`) - Must contain the value: `AWS/ElasticMapReduce`.
          * `operator` (`pulumi.Input[str]`) - The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
          * `period` (`pulumi.Input[float]`) - The time window in seconds over which the statistic is applied.
          * `policyName` (`pulumi.Input[str]`)
          * `statistic` (`pulumi.Input[str]`) - The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`                 
          * `target` (`pulumi.Input[str]`)
          * `threshold` (`pulumi.Input[float]`) - The value that the specified statistic is compared to.
          * `unit` (`pulumi.Input[str]`) - The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`                     

        The **termination_policies** object supports the following:

          * `statements` (`pulumi.Input[list]`)
            * `evaluationPeriods` (`pulumi.Input[float]`) - The number of periods over which data is compared to the specified threshold.
            * `metricName` (`pulumi.Input[str]`) - The name of the metric in CloudWatch which the statement will be based on.
            * `namespace` (`pulumi.Input[str]`) - Must contain the value: `AWS/ElasticMapReduce`.
            * `operator` (`pulumi.Input[str]`) - The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
            * `period` (`pulumi.Input[float]`) - The time window in seconds over which the statistic is applied.
            * `statistic` (`pulumi.Input[str]`) - The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`                 
            * `threshold` (`pulumi.Input[float]`) - The value that the specified statistic is compared to.
            * `unit` (`pulumi.Input[str]`) - The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`                     
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = dict()

        __props__["additional_info"] = additional_info
        __props__["additional_primary_security_groups"] = additional_primary_security_groups
        __props__["additional_replica_security_groups"] = additional_replica_security_groups
        __props__["applications"] = applications
        __props__["availability_zones"] = availability_zones
        __props__["bootstrap_actions_files"] = bootstrap_actions_files
        __props__["cluster_id"] = cluster_id
        __props__["configurations_files"] = configurations_files
        __props__["core_desired_capacity"] = core_desired_capacity
        __props__["core_ebs_block_devices"] = core_ebs_block_devices
        __props__["core_ebs_optimized"] = core_ebs_optimized
        __props__["core_instance_types"] = core_instance_types
        __props__["core_lifecycle"] = core_lifecycle
        __props__["core_max_size"] = core_max_size
        __props__["core_min_size"] = core_min_size
        __props__["core_scaling_down_policies"] = core_scaling_down_policies
        __props__["core_scaling_up_policies"] = core_scaling_up_policies
        __props__["core_unit"] = core_unit
        __props__["custom_ami_id"] = custom_ami_id
        __props__["description"] = description
        __props__["ebs_root_volume_size"] = ebs_root_volume_size
        __props__["ec2_key_name"] = ec2_key_name
        __props__["expose_cluster_id"] = expose_cluster_id
        __props__["instance_weights"] = instance_weights
        __props__["job_flow_role"] = job_flow_role
        __props__["keep_job_flow_alive"] = keep_job_flow_alive
        __props__["log_uri"] = log_uri
        __props__["managed_primary_security_group"] = managed_primary_security_group
        __props__["managed_replica_security_group"] = managed_replica_security_group
        __props__["master_ebs_block_devices"] = master_ebs_block_devices
        __props__["master_ebs_optimized"] = master_ebs_optimized
        __props__["master_instance_types"] = master_instance_types
        __props__["master_lifecycle"] = master_lifecycle
        __props__["name"] = name
        __props__["output_cluster_id"] = output_cluster_id
        __props__["provisioning_timeout"] = provisioning_timeout
        __props__["region"] = region
        __props__["release_label"] = release_label
        __props__["repo_upgrade_on_boot"] = repo_upgrade_on_boot
        __props__["retries"] = retries
        __props__["scheduled_tasks"] = scheduled_tasks
        __props__["security_config"] = security_config
        __props__["service_access_security_group"] = service_access_security_group
        __props__["service_role"] = service_role
        __props__["steps_files"] = steps_files
        __props__["strategy"] = strategy
        __props__["tags"] = tags
        __props__["task_desired_capacity"] = task_desired_capacity
        __props__["task_ebs_block_devices"] = task_ebs_block_devices
        __props__["task_ebs_optimized"] = task_ebs_optimized
        __props__["task_instance_types"] = task_instance_types
        __props__["task_lifecycle"] = task_lifecycle
        __props__["task_max_size"] = task_max_size
        __props__["task_min_size"] = task_min_size
        __props__["task_scaling_down_policies"] = task_scaling_down_policies
        __props__["task_scaling_up_policies"] = task_scaling_up_policies
        __props__["task_unit"] = task_unit
        __props__["termination_policies"] = termination_policies
        __props__["termination_protected"] = termination_protected
        __props__["visible_to_all_users"] = visible_to_all_users
        return MrScalar(resource_name, opts=opts, __props__=__props__)
    def translate_output_property(self, prop):
        return tables._CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop

    def translate_input_property(self, prop):
        return tables._SNAKE_TO_CAMEL_CASE_TABLE.get(prop) or prop

