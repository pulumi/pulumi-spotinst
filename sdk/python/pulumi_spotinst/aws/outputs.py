# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from .. import _utilities, _tables
from . import outputs

__all__ = [
    'BeanstalkDeploymentPreferences',
    'BeanstalkDeploymentPreferencesStrategy',
    'BeanstalkManagedActions',
    'BeanstalkManagedActionsPlatformUpdate',
    'BeanstalkScheduledTask',
    'ElastigroupEbsBlockDevice',
    'ElastigroupEphemeralBlockDevice',
    'ElastigroupInstanceTypesWeight',
    'ElastigroupIntegrationBeanstalk',
    'ElastigroupIntegrationBeanstalkDeploymentPreferences',
    'ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategy',
    'ElastigroupIntegrationBeanstalkManagedActions',
    'ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdate',
    'ElastigroupIntegrationCodedeploy',
    'ElastigroupIntegrationCodedeployDeploymentGroup',
    'ElastigroupIntegrationDockerSwarm',
    'ElastigroupIntegrationDockerSwarmAutoscaleDown',
    'ElastigroupIntegrationDockerSwarmAutoscaleHeadroom',
    'ElastigroupIntegrationEcs',
    'ElastigroupIntegrationEcsAutoscaleAttribute',
    'ElastigroupIntegrationEcsAutoscaleDown',
    'ElastigroupIntegrationEcsAutoscaleHeadroom',
    'ElastigroupIntegrationGitlab',
    'ElastigroupIntegrationGitlabRunner',
    'ElastigroupIntegrationKubernetes',
    'ElastigroupIntegrationKubernetesAutoscaleDown',
    'ElastigroupIntegrationKubernetesAutoscaleHeadroom',
    'ElastigroupIntegrationKubernetesAutoscaleLabel',
    'ElastigroupIntegrationMesosphere',
    'ElastigroupIntegrationMultaiRuntime',
    'ElastigroupIntegrationNomad',
    'ElastigroupIntegrationNomadAutoscaleConstraint',
    'ElastigroupIntegrationNomadAutoscaleDown',
    'ElastigroupIntegrationNomadAutoscaleHeadroom',
    'ElastigroupIntegrationRancher',
    'ElastigroupIntegrationRoute53',
    'ElastigroupIntegrationRoute53Domain',
    'ElastigroupIntegrationRoute53DomainRecordSet',
    'ElastigroupMultaiTargetSet',
    'ElastigroupNetworkInterface',
    'ElastigroupRevertToSpot',
    'ElastigroupScalingDownPolicy',
    'ElastigroupScalingDownPolicyDimension',
    'ElastigroupScalingStrategy',
    'ElastigroupScalingTargetPolicy',
    'ElastigroupScalingTargetPolicyDimension',
    'ElastigroupScalingUpPolicy',
    'ElastigroupScalingUpPolicyDimension',
    'ElastigroupScheduledTask',
    'ElastigroupSignal',
    'ElastigroupStatefulDeallocation',
    'ElastigroupTag',
    'ElastigroupUpdatePolicy',
    'ElastigroupUpdatePolicyRollConfig',
    'ElastigroupUpdatePolicyRollConfigStrategy',
    'ElastigroupUpdatePolicyRollConfigStrategyOnFailure',
    'ManagedInstanceIntegrationRoute53',
    'ManagedInstanceIntegrationRoute53Domain',
    'ManagedInstanceIntegrationRoute53DomainRecordSet',
    'ManagedInstanceLoadBalancer',
    'ManagedInstanceNetworkInterface',
    'ManagedInstanceRevertToSpot',
    'ManagedInstanceScheduledTask',
    'ManagedInstanceTag',
    'MrScalarApplication',
    'MrScalarBootstrapActionsFile',
    'MrScalarConfigurationsFile',
    'MrScalarCoreEbsBlockDevice',
    'MrScalarCoreScalingDownPolicy',
    'MrScalarCoreScalingUpPolicy',
    'MrScalarInstanceWeight',
    'MrScalarMasterEbsBlockDevice',
    'MrScalarProvisioningTimeout',
    'MrScalarScheduledTask',
    'MrScalarStepsFile',
    'MrScalarTag',
    'MrScalarTaskEbsBlockDevice',
    'MrScalarTaskScalingDownPolicy',
    'MrScalarTaskScalingUpPolicy',
    'MrScalarTerminationPolicy',
    'MrScalarTerminationPolicyStatement',
    'OceanAutoscaler',
    'OceanAutoscalerAutoscaleDown',
    'OceanAutoscalerAutoscaleHeadroom',
    'OceanAutoscalerResourceLimits',
    'OceanLaunchSpecAutoscaleHeadroom',
    'OceanLaunchSpecBlockDeviceMapping',
    'OceanLaunchSpecBlockDeviceMappingEbs',
    'OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize',
    'OceanLaunchSpecElasticIpPool',
    'OceanLaunchSpecElasticIpPoolTagSelector',
    'OceanLaunchSpecLabel',
    'OceanLaunchSpecResourceLimit',
    'OceanLaunchSpecTag',
    'OceanLaunchSpecTaint',
    'OceanLoadBalancer',
    'OceanScheduledTask',
    'OceanScheduledTaskShutdownHours',
    'OceanScheduledTaskTask',
    'OceanTag',
    'OceanUpdatePolicy',
    'OceanUpdatePolicyRollConfig',
]

@pulumi.output_type
class BeanstalkDeploymentPreferences(dict):
    def __init__(__self__, *,
                 automatic_roll: Optional[bool] = None,
                 batch_size_percentage: Optional[int] = None,
                 grace_period: Optional[int] = None,
                 strategies: Optional[Sequence['outputs.BeanstalkDeploymentPreferencesStrategy']] = None):
        """
        :param bool automatic_roll: Should roll perform automatically
        :param int batch_size_percentage: Percent size of each batch
        :param int grace_period: Amount of time to wait between batches
        :param Sequence['BeanstalkDeploymentPreferencesStrategyArgs'] strategies: Strategy parameters
        """
        if automatic_roll is not None:
            pulumi.set(__self__, "automatic_roll", automatic_roll)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if strategies is not None:
            pulumi.set(__self__, "strategies", strategies)

    @property
    @pulumi.getter(name="automaticRoll")
    def automatic_roll(self) -> Optional[bool]:
        """
        Should roll perform automatically
        """
        return pulumi.get(self, "automatic_roll")

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[int]:
        """
        Percent size of each batch
        """
        return pulumi.get(self, "batch_size_percentage")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        """
        Amount of time to wait between batches
        """
        return pulumi.get(self, "grace_period")

    @property
    @pulumi.getter
    def strategies(self) -> Optional[Sequence['outputs.BeanstalkDeploymentPreferencesStrategy']]:
        """
        Strategy parameters
        """
        return pulumi.get(self, "strategies")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BeanstalkDeploymentPreferencesStrategy(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 should_drain_instances: Optional[bool] = None):
        """
        :param str action: Action to take
        :param bool should_drain_instances: Bool value if to wait to drain instance
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if should_drain_instances is not None:
            pulumi.set(__self__, "should_drain_instances", should_drain_instances)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action to take
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="shouldDrainInstances")
    def should_drain_instances(self) -> Optional[bool]:
        """
        Bool value if to wait to drain instance
        """
        return pulumi.get(self, "should_drain_instances")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BeanstalkManagedActions(dict):
    def __init__(__self__, *,
                 platform_update: Optional['outputs.BeanstalkManagedActionsPlatformUpdate'] = None):
        """
        :param 'BeanstalkManagedActionsPlatformUpdateArgs' platform_update: Platform Update parameters
        """
        if platform_update is not None:
            pulumi.set(__self__, "platform_update", platform_update)

    @property
    @pulumi.getter(name="platformUpdate")
    def platform_update(self) -> Optional['outputs.BeanstalkManagedActionsPlatformUpdate']:
        """
        Platform Update parameters
        """
        return pulumi.get(self, "platform_update")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BeanstalkManagedActionsPlatformUpdate(dict):
    def __init__(__self__, *,
                 perform_at: Optional[str] = None,
                 time_window: Optional[str] = None,
                 update_level: Optional[str] = None):
        """
        :param str perform_at: Actions to perform (options: timeWindow, never)
        :param str time_window: Time Window for when action occurs ex. Mon:23:50-Tue:00:20
        :param str update_level: - Level to update
        """
        if perform_at is not None:
            pulumi.set(__self__, "perform_at", perform_at)
        if time_window is not None:
            pulumi.set(__self__, "time_window", time_window)
        if update_level is not None:
            pulumi.set(__self__, "update_level", update_level)

    @property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> Optional[str]:
        """
        Actions to perform (options: timeWindow, never)
        """
        return pulumi.get(self, "perform_at")

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> Optional[str]:
        """
        Time Window for when action occurs ex. Mon:23:50-Tue:00:20
        """
        return pulumi.get(self, "time_window")

    @property
    @pulumi.getter(name="updateLevel")
    def update_level(self) -> Optional[str]:
        """
        - Level to update
        """
        return pulumi.get(self, "update_level")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BeanstalkScheduledTask(dict):
    def __init__(__self__, *,
                 task_type: str,
                 adjustment: Optional[str] = None,
                 adjustment_percentage: Optional[str] = None,
                 batch_size_percentage: Optional[str] = None,
                 cron_expression: Optional[str] = None,
                 frequency: Optional[str] = None,
                 grace_period: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 max_capacity: Optional[str] = None,
                 min_capacity: Optional[str] = None,
                 scale_max_capacity: Optional[str] = None,
                 scale_min_capacity: Optional[str] = None,
                 scale_target_capacity: Optional[str] = None,
                 start_time: Optional[str] = None,
                 target_capacity: Optional[str] = None):
        """
        :param str batch_size_percentage: Percent size of each batch
        :param str grace_period: Amount of time to wait between batches
        """
        pulumi.set(__self__, "task_type", task_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if adjustment_percentage is not None:
            pulumi.set(__self__, "adjustment_percentage", adjustment_percentage)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if min_capacity is not None:
            pulumi.set(__self__, "min_capacity", min_capacity)
        if scale_max_capacity is not None:
            pulumi.set(__self__, "scale_max_capacity", scale_max_capacity)
        if scale_min_capacity is not None:
            pulumi.set(__self__, "scale_min_capacity", scale_min_capacity)
        if scale_target_capacity is not None:
            pulumi.set(__self__, "scale_target_capacity", scale_target_capacity)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if target_capacity is not None:
            pulumi.set(__self__, "target_capacity", target_capacity)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter(name="adjustmentPercentage")
    def adjustment_percentage(self) -> Optional[str]:
        return pulumi.get(self, "adjustment_percentage")

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[str]:
        """
        Percent size of each batch
        """
        return pulumi.get(self, "batch_size_percentage")

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[str]:
        return pulumi.get(self, "cron_expression")

    @property
    @pulumi.getter
    def frequency(self) -> Optional[str]:
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[str]:
        """
        Amount of time to wait between batches
        """
        return pulumi.get(self, "grace_period")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[str]:
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> Optional[str]:
        return pulumi.get(self, "min_capacity")

    @property
    @pulumi.getter(name="scaleMaxCapacity")
    def scale_max_capacity(self) -> Optional[str]:
        return pulumi.get(self, "scale_max_capacity")

    @property
    @pulumi.getter(name="scaleMinCapacity")
    def scale_min_capacity(self) -> Optional[str]:
        return pulumi.get(self, "scale_min_capacity")

    @property
    @pulumi.getter(name="scaleTargetCapacity")
    def scale_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "scale_target_capacity")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="targetCapacity")
    def target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "target_capacity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupEbsBlockDevice(dict):
    def __init__(__self__, *,
                 device_name: str,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        return pulumi.get(self, "volume_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupEphemeralBlockDevice(dict):
    def __init__(__self__, *,
                 device_name: str,
                 virtual_name: str):
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> str:
        return pulumi.get(self, "virtual_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupInstanceTypesWeight(dict):
    def __init__(__self__, *,
                 instance_type: str,
                 weight: int):
        """
        :param str instance_type: Name of instance type (String).
        :param int weight: Weight per instance type (Integer).
        """
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        """
        Name of instance type (String).
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight per instance type (Integer).
        """
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationBeanstalk(dict):
    def __init__(__self__, *,
                 deployment_preferences: Optional['outputs.ElastigroupIntegrationBeanstalkDeploymentPreferences'] = None,
                 environment_id: Optional[str] = None,
                 managed_actions: Optional['outputs.ElastigroupIntegrationBeanstalkManagedActions'] = None):
        if deployment_preferences is not None:
            pulumi.set(__self__, "deployment_preferences", deployment_preferences)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if managed_actions is not None:
            pulumi.set(__self__, "managed_actions", managed_actions)

    @property
    @pulumi.getter(name="deploymentPreferences")
    def deployment_preferences(self) -> Optional['outputs.ElastigroupIntegrationBeanstalkDeploymentPreferences']:
        return pulumi.get(self, "deployment_preferences")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[str]:
        return pulumi.get(self, "environment_id")

    @property
    @pulumi.getter(name="managedActions")
    def managed_actions(self) -> Optional['outputs.ElastigroupIntegrationBeanstalkManagedActions']:
        return pulumi.get(self, "managed_actions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationBeanstalkDeploymentPreferences(dict):
    def __init__(__self__, *,
                 automatic_roll: Optional[bool] = None,
                 batch_size_percentage: Optional[int] = None,
                 grace_period: Optional[int] = None,
                 strategy: Optional['outputs.ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategy'] = None):
        if automatic_roll is not None:
            pulumi.set(__self__, "automatic_roll", automatic_roll)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="automaticRoll")
    def automatic_roll(self) -> Optional[bool]:
        return pulumi.get(self, "automatic_roll")

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[int]:
        return pulumi.get(self, "batch_size_percentage")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        return pulumi.get(self, "grace_period")

    @property
    @pulumi.getter
    def strategy(self) -> Optional['outputs.ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategy']:
        return pulumi.get(self, "strategy")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategy(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 should_drain_instances: Optional[bool] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)
        if should_drain_instances is not None:
            pulumi.set(__self__, "should_drain_instances", should_drain_instances)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="shouldDrainInstances")
    def should_drain_instances(self) -> Optional[bool]:
        return pulumi.get(self, "should_drain_instances")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationBeanstalkManagedActions(dict):
    def __init__(__self__, *,
                 platform_update: Optional['outputs.ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdate'] = None):
        if platform_update is not None:
            pulumi.set(__self__, "platform_update", platform_update)

    @property
    @pulumi.getter(name="platformUpdate")
    def platform_update(self) -> Optional['outputs.ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdate']:
        return pulumi.get(self, "platform_update")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdate(dict):
    def __init__(__self__, *,
                 perform_at: Optional[str] = None,
                 time_window: Optional[str] = None,
                 update_level: Optional[str] = None):
        """
        :param str perform_at: In the event of a fallback to On-Demand instances, select the time period to revert back to Spot. Supported Arguments – always (default), timeWindow, never. For timeWindow or never to be valid the group must have availabilityOriented OR persistence defined.
        """
        if perform_at is not None:
            pulumi.set(__self__, "perform_at", perform_at)
        if time_window is not None:
            pulumi.set(__self__, "time_window", time_window)
        if update_level is not None:
            pulumi.set(__self__, "update_level", update_level)

    @property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> Optional[str]:
        """
        In the event of a fallback to On-Demand instances, select the time period to revert back to Spot. Supported Arguments – always (default), timeWindow, never. For timeWindow or never to be valid the group must have availabilityOriented OR persistence defined.
        """
        return pulumi.get(self, "perform_at")

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> Optional[str]:
        return pulumi.get(self, "time_window")

    @property
    @pulumi.getter(name="updateLevel")
    def update_level(self) -> Optional[str]:
        return pulumi.get(self, "update_level")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationCodedeploy(dict):
    def __init__(__self__, *,
                 cleanup_on_failure: bool,
                 deployment_groups: Sequence['outputs.ElastigroupIntegrationCodedeployDeploymentGroup'],
                 terminate_instance_on_failure: bool):
        pulumi.set(__self__, "cleanup_on_failure", cleanup_on_failure)
        pulumi.set(__self__, "deployment_groups", deployment_groups)
        pulumi.set(__self__, "terminate_instance_on_failure", terminate_instance_on_failure)

    @property
    @pulumi.getter(name="cleanupOnFailure")
    def cleanup_on_failure(self) -> bool:
        return pulumi.get(self, "cleanup_on_failure")

    @property
    @pulumi.getter(name="deploymentGroups")
    def deployment_groups(self) -> Sequence['outputs.ElastigroupIntegrationCodedeployDeploymentGroup']:
        return pulumi.get(self, "deployment_groups")

    @property
    @pulumi.getter(name="terminateInstanceOnFailure")
    def terminate_instance_on_failure(self) -> bool:
        return pulumi.get(self, "terminate_instance_on_failure")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationCodedeployDeploymentGroup(dict):
    def __init__(__self__, *,
                 application_name: str,
                 deployment_group_name: str):
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "deployment_group_name", deployment_group_name)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> str:
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="deploymentGroupName")
    def deployment_group_name(self) -> str:
        return pulumi.get(self, "deployment_group_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationDockerSwarm(dict):
    def __init__(__self__, *,
                 master_host: str,
                 master_port: int,
                 autoscale_cooldown: Optional[int] = None,
                 autoscale_down: Optional['outputs.ElastigroupIntegrationDockerSwarmAutoscaleDown'] = None,
                 autoscale_headroom: Optional['outputs.ElastigroupIntegrationDockerSwarmAutoscaleHeadroom'] = None,
                 autoscale_is_enabled: Optional[bool] = None):
        pulumi.set(__self__, "master_host", master_host)
        pulumi.set(__self__, "master_port", master_port)
        if autoscale_cooldown is not None:
            pulumi.set(__self__, "autoscale_cooldown", autoscale_cooldown)
        if autoscale_down is not None:
            pulumi.set(__self__, "autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)
        if autoscale_is_enabled is not None:
            pulumi.set(__self__, "autoscale_is_enabled", autoscale_is_enabled)

    @property
    @pulumi.getter(name="masterHost")
    def master_host(self) -> str:
        return pulumi.get(self, "master_host")

    @property
    @pulumi.getter(name="masterPort")
    def master_port(self) -> int:
        return pulumi.get(self, "master_port")

    @property
    @pulumi.getter(name="autoscaleCooldown")
    def autoscale_cooldown(self) -> Optional[int]:
        return pulumi.get(self, "autoscale_cooldown")

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional['outputs.ElastigroupIntegrationDockerSwarmAutoscaleDown']:
        return pulumi.get(self, "autoscale_down")

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional['outputs.ElastigroupIntegrationDockerSwarmAutoscaleHeadroom']:
        return pulumi.get(self, "autoscale_headroom")

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "autoscale_is_enabled")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationDockerSwarmAutoscaleDown(dict):
    def __init__(__self__, *,
                 evaluation_periods: Optional[int] = None):
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        return pulumi.get(self, "evaluation_periods")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationDockerSwarmAutoscaleHeadroom(dict):
    def __init__(__self__, *,
                 cpu_per_unit: Optional[int] = None,
                 memory_per_unit: Optional[int] = None,
                 num_of_units: Optional[int] = None):
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "cpu_per_unit")

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "memory_per_unit")

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[int]:
        return pulumi.get(self, "num_of_units")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationEcs(dict):
    def __init__(__self__, *,
                 cluster_name: str,
                 autoscale_attributes: Optional[Sequence['outputs.ElastigroupIntegrationEcsAutoscaleAttribute']] = None,
                 autoscale_cooldown: Optional[int] = None,
                 autoscale_down: Optional['outputs.ElastigroupIntegrationEcsAutoscaleDown'] = None,
                 autoscale_headroom: Optional['outputs.ElastigroupIntegrationEcsAutoscaleHeadroom'] = None,
                 autoscale_is_auto_config: Optional[bool] = None,
                 autoscale_is_enabled: Optional[bool] = None,
                 autoscale_scale_down_non_service_tasks: Optional[bool] = None):
        pulumi.set(__self__, "cluster_name", cluster_name)
        if autoscale_attributes is not None:
            pulumi.set(__self__, "autoscale_attributes", autoscale_attributes)
        if autoscale_cooldown is not None:
            pulumi.set(__self__, "autoscale_cooldown", autoscale_cooldown)
        if autoscale_down is not None:
            pulumi.set(__self__, "autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)
        if autoscale_is_auto_config is not None:
            pulumi.set(__self__, "autoscale_is_auto_config", autoscale_is_auto_config)
        if autoscale_is_enabled is not None:
            pulumi.set(__self__, "autoscale_is_enabled", autoscale_is_enabled)
        if autoscale_scale_down_non_service_tasks is not None:
            pulumi.set(__self__, "autoscale_scale_down_non_service_tasks", autoscale_scale_down_non_service_tasks)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="autoscaleAttributes")
    def autoscale_attributes(self) -> Optional[Sequence['outputs.ElastigroupIntegrationEcsAutoscaleAttribute']]:
        return pulumi.get(self, "autoscale_attributes")

    @property
    @pulumi.getter(name="autoscaleCooldown")
    def autoscale_cooldown(self) -> Optional[int]:
        return pulumi.get(self, "autoscale_cooldown")

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional['outputs.ElastigroupIntegrationEcsAutoscaleDown']:
        return pulumi.get(self, "autoscale_down")

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional['outputs.ElastigroupIntegrationEcsAutoscaleHeadroom']:
        return pulumi.get(self, "autoscale_headroom")

    @property
    @pulumi.getter(name="autoscaleIsAutoConfig")
    def autoscale_is_auto_config(self) -> Optional[bool]:
        return pulumi.get(self, "autoscale_is_auto_config")

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "autoscale_is_enabled")

    @property
    @pulumi.getter(name="autoscaleScaleDownNonServiceTasks")
    def autoscale_scale_down_non_service_tasks(self) -> Optional[bool]:
        return pulumi.get(self, "autoscale_scale_down_non_service_tasks")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationEcsAutoscaleAttribute(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationEcsAutoscaleDown(dict):
    def __init__(__self__, *,
                 evaluation_periods: Optional[int] = None,
                 max_scale_down_percentage: Optional[float] = None):
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_scale_down_percentage is not None:
            pulumi.set(__self__, "max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[float]:
        return pulumi.get(self, "max_scale_down_percentage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationEcsAutoscaleHeadroom(dict):
    def __init__(__self__, *,
                 cpu_per_unit: Optional[int] = None,
                 memory_per_unit: Optional[int] = None,
                 num_of_units: Optional[int] = None):
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "cpu_per_unit")

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "memory_per_unit")

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[int]:
        return pulumi.get(self, "num_of_units")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationGitlab(dict):
    def __init__(__self__, *,
                 runner: Optional['outputs.ElastigroupIntegrationGitlabRunner'] = None):
        if runner is not None:
            pulumi.set(__self__, "runner", runner)

    @property
    @pulumi.getter
    def runner(self) -> Optional['outputs.ElastigroupIntegrationGitlabRunner']:
        return pulumi.get(self, "runner")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationGitlabRunner(dict):
    def __init__(__self__, *,
                 is_enabled: Optional[bool] = None):
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationKubernetes(dict):
    def __init__(__self__, *,
                 api_server: Optional[str] = None,
                 autoscale_cooldown: Optional[int] = None,
                 autoscale_down: Optional['outputs.ElastigroupIntegrationKubernetesAutoscaleDown'] = None,
                 autoscale_headroom: Optional['outputs.ElastigroupIntegrationKubernetesAutoscaleHeadroom'] = None,
                 autoscale_is_auto_config: Optional[bool] = None,
                 autoscale_is_enabled: Optional[bool] = None,
                 autoscale_labels: Optional[Sequence['outputs.ElastigroupIntegrationKubernetesAutoscaleLabel']] = None,
                 cluster_identifier: Optional[str] = None,
                 integration_mode: Optional[str] = None,
                 token: Optional[str] = None):
        if api_server is not None:
            pulumi.set(__self__, "api_server", api_server)
        if autoscale_cooldown is not None:
            pulumi.set(__self__, "autoscale_cooldown", autoscale_cooldown)
        if autoscale_down is not None:
            pulumi.set(__self__, "autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)
        if autoscale_is_auto_config is not None:
            pulumi.set(__self__, "autoscale_is_auto_config", autoscale_is_auto_config)
        if autoscale_is_enabled is not None:
            pulumi.set(__self__, "autoscale_is_enabled", autoscale_is_enabled)
        if autoscale_labels is not None:
            pulumi.set(__self__, "autoscale_labels", autoscale_labels)
        if cluster_identifier is not None:
            pulumi.set(__self__, "cluster_identifier", cluster_identifier)
        if integration_mode is not None:
            pulumi.set(__self__, "integration_mode", integration_mode)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="apiServer")
    def api_server(self) -> Optional[str]:
        return pulumi.get(self, "api_server")

    @property
    @pulumi.getter(name="autoscaleCooldown")
    def autoscale_cooldown(self) -> Optional[int]:
        return pulumi.get(self, "autoscale_cooldown")

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional['outputs.ElastigroupIntegrationKubernetesAutoscaleDown']:
        return pulumi.get(self, "autoscale_down")

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional['outputs.ElastigroupIntegrationKubernetesAutoscaleHeadroom']:
        return pulumi.get(self, "autoscale_headroom")

    @property
    @pulumi.getter(name="autoscaleIsAutoConfig")
    def autoscale_is_auto_config(self) -> Optional[bool]:
        return pulumi.get(self, "autoscale_is_auto_config")

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "autoscale_is_enabled")

    @property
    @pulumi.getter(name="autoscaleLabels")
    def autoscale_labels(self) -> Optional[Sequence['outputs.ElastigroupIntegrationKubernetesAutoscaleLabel']]:
        return pulumi.get(self, "autoscale_labels")

    @property
    @pulumi.getter(name="clusterIdentifier")
    def cluster_identifier(self) -> Optional[str]:
        return pulumi.get(self, "cluster_identifier")

    @property
    @pulumi.getter(name="integrationMode")
    def integration_mode(self) -> Optional[str]:
        return pulumi.get(self, "integration_mode")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        return pulumi.get(self, "token")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationKubernetesAutoscaleDown(dict):
    def __init__(__self__, *,
                 evaluation_periods: Optional[int] = None):
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        return pulumi.get(self, "evaluation_periods")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationKubernetesAutoscaleHeadroom(dict):
    def __init__(__self__, *,
                 cpu_per_unit: Optional[int] = None,
                 memory_per_unit: Optional[int] = None,
                 num_of_units: Optional[int] = None):
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "cpu_per_unit")

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "memory_per_unit")

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[int]:
        return pulumi.get(self, "num_of_units")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationKubernetesAutoscaleLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationMesosphere(dict):
    def __init__(__self__, *,
                 api_server: str):
        pulumi.set(__self__, "api_server", api_server)

    @property
    @pulumi.getter(name="apiServer")
    def api_server(self) -> str:
        return pulumi.get(self, "api_server")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationMultaiRuntime(dict):
    def __init__(__self__, *,
                 deployment_id: str):
        pulumi.set(__self__, "deployment_id", deployment_id)

    @property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> str:
        return pulumi.get(self, "deployment_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationNomad(dict):
    def __init__(__self__, *,
                 master_host: str,
                 master_port: int,
                 acl_token: Optional[str] = None,
                 autoscale_constraints: Optional[Sequence['outputs.ElastigroupIntegrationNomadAutoscaleConstraint']] = None,
                 autoscale_cooldown: Optional[int] = None,
                 autoscale_down: Optional['outputs.ElastigroupIntegrationNomadAutoscaleDown'] = None,
                 autoscale_headroom: Optional['outputs.ElastigroupIntegrationNomadAutoscaleHeadroom'] = None,
                 autoscale_is_enabled: Optional[bool] = None):
        pulumi.set(__self__, "master_host", master_host)
        pulumi.set(__self__, "master_port", master_port)
        if acl_token is not None:
            pulumi.set(__self__, "acl_token", acl_token)
        if autoscale_constraints is not None:
            pulumi.set(__self__, "autoscale_constraints", autoscale_constraints)
        if autoscale_cooldown is not None:
            pulumi.set(__self__, "autoscale_cooldown", autoscale_cooldown)
        if autoscale_down is not None:
            pulumi.set(__self__, "autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)
        if autoscale_is_enabled is not None:
            pulumi.set(__self__, "autoscale_is_enabled", autoscale_is_enabled)

    @property
    @pulumi.getter(name="masterHost")
    def master_host(self) -> str:
        return pulumi.get(self, "master_host")

    @property
    @pulumi.getter(name="masterPort")
    def master_port(self) -> int:
        return pulumi.get(self, "master_port")

    @property
    @pulumi.getter(name="aclToken")
    def acl_token(self) -> Optional[str]:
        return pulumi.get(self, "acl_token")

    @property
    @pulumi.getter(name="autoscaleConstraints")
    def autoscale_constraints(self) -> Optional[Sequence['outputs.ElastigroupIntegrationNomadAutoscaleConstraint']]:
        return pulumi.get(self, "autoscale_constraints")

    @property
    @pulumi.getter(name="autoscaleCooldown")
    def autoscale_cooldown(self) -> Optional[int]:
        return pulumi.get(self, "autoscale_cooldown")

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional['outputs.ElastigroupIntegrationNomadAutoscaleDown']:
        return pulumi.get(self, "autoscale_down")

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional['outputs.ElastigroupIntegrationNomadAutoscaleHeadroom']:
        return pulumi.get(self, "autoscale_headroom")

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "autoscale_is_enabled")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationNomadAutoscaleConstraint(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationNomadAutoscaleDown(dict):
    def __init__(__self__, *,
                 evaluation_periods: Optional[int] = None):
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        return pulumi.get(self, "evaluation_periods")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationNomadAutoscaleHeadroom(dict):
    def __init__(__self__, *,
                 cpu_per_unit: Optional[int] = None,
                 memory_per_unit: Optional[int] = None,
                 num_of_units: Optional[int] = None):
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "cpu_per_unit")

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "memory_per_unit")

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[int]:
        return pulumi.get(self, "num_of_units")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationRancher(dict):
    def __init__(__self__, *,
                 access_key: str,
                 master_host: str,
                 secret_key: str,
                 version: Optional[str] = None):
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "master_host", master_host)
        pulumi.set(__self__, "secret_key", secret_key)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="masterHost")
    def master_host(self) -> str:
        return pulumi.get(self, "master_host")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationRoute53(dict):
    def __init__(__self__, *,
                 domains: Sequence['outputs.ElastigroupIntegrationRoute53Domain']):
        pulumi.set(__self__, "domains", domains)

    @property
    @pulumi.getter
    def domains(self) -> Sequence['outputs.ElastigroupIntegrationRoute53Domain']:
        return pulumi.get(self, "domains")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationRoute53Domain(dict):
    def __init__(__self__, *,
                 hosted_zone_id: str,
                 record_sets: Sequence['outputs.ElastigroupIntegrationRoute53DomainRecordSet'],
                 record_set_type: Optional[str] = None,
                 spotinst_acct_id: Optional[str] = None):
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)
        pulumi.set(__self__, "record_sets", record_sets)
        if record_set_type is not None:
            pulumi.set(__self__, "record_set_type", record_set_type)
        if spotinst_acct_id is not None:
            pulumi.set(__self__, "spotinst_acct_id", spotinst_acct_id)

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> str:
        return pulumi.get(self, "hosted_zone_id")

    @property
    @pulumi.getter(name="recordSets")
    def record_sets(self) -> Sequence['outputs.ElastigroupIntegrationRoute53DomainRecordSet']:
        return pulumi.get(self, "record_sets")

    @property
    @pulumi.getter(name="recordSetType")
    def record_set_type(self) -> Optional[str]:
        return pulumi.get(self, "record_set_type")

    @property
    @pulumi.getter(name="spotinstAcctId")
    def spotinst_acct_id(self) -> Optional[str]:
        return pulumi.get(self, "spotinst_acct_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupIntegrationRoute53DomainRecordSet(dict):
    def __init__(__self__, *,
                 name: str,
                 use_public_dns: Optional[bool] = None,
                 use_public_ip: Optional[bool] = None):
        """
        :param str name: The group name.
        """
        pulumi.set(__self__, "name", name)
        if use_public_dns is not None:
            pulumi.set(__self__, "use_public_dns", use_public_dns)
        if use_public_ip is not None:
            pulumi.set(__self__, "use_public_ip", use_public_ip)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="usePublicDns")
    def use_public_dns(self) -> Optional[bool]:
        return pulumi.get(self, "use_public_dns")

    @property
    @pulumi.getter(name="usePublicIp")
    def use_public_ip(self) -> Optional[bool]:
        return pulumi.get(self, "use_public_ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupMultaiTargetSet(dict):
    def __init__(__self__, *,
                 balancer_id: str,
                 target_set_id: str):
        pulumi.set(__self__, "balancer_id", balancer_id)
        pulumi.set(__self__, "target_set_id", target_set_id)

    @property
    @pulumi.getter(name="balancerId")
    def balancer_id(self) -> str:
        return pulumi.get(self, "balancer_id")

    @property
    @pulumi.getter(name="targetSetId")
    def target_set_id(self) -> str:
        return pulumi.get(self, "target_set_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupNetworkInterface(dict):
    def __init__(__self__, *,
                 device_index: str,
                 associate_ipv6_address: Optional[bool] = None,
                 associate_public_ip_address: Optional[bool] = None,
                 delete_on_termination: Optional[bool] = None,
                 description: Optional[str] = None,
                 network_interface_id: Optional[str] = None,
                 private_ip_address: Optional[str] = None,
                 secondary_private_ip_address_count: Optional[str] = None):
        """
        :param str description: The group description.
        """
        pulumi.set(__self__, "device_index", device_index)
        if associate_ipv6_address is not None:
            pulumi.set(__self__, "associate_ipv6_address", associate_ipv6_address)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if secondary_private_ip_address_count is not None:
            pulumi.set(__self__, "secondary_private_ip_address_count", secondary_private_ip_address_count)

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> str:
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter(name="associateIpv6Address")
    def associate_ipv6_address(self) -> Optional[bool]:
        return pulumi.get(self, "associate_ipv6_address")

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[bool]:
        return pulumi.get(self, "associate_public_ip_address")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The group description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> Optional[str]:
        return pulumi.get(self, "secondary_private_ip_address_count")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupRevertToSpot(dict):
    def __init__(__self__, *,
                 perform_at: str,
                 time_windows: Optional[Sequence[str]] = None):
        """
        :param str perform_at: In the event of a fallback to On-Demand instances, select the time period to revert back to Spot. Supported Arguments – always (default), timeWindow, never. For timeWindow or never to be valid the group must have availabilityOriented OR persistence defined.
        :param Sequence[str] time_windows: Specify a list of time windows for to execute revertToSpot strategy. Time window format: `ddd:hh:mm-ddd:hh:mm`. Example: `Mon:03:00-Wed:02:30`
        """
        pulumi.set(__self__, "perform_at", perform_at)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)

    @property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> str:
        """
        In the event of a fallback to On-Demand instances, select the time period to revert back to Spot. Supported Arguments – always (default), timeWindow, never. For timeWindow or never to be valid the group must have availabilityOriented OR persistence defined.
        """
        return pulumi.get(self, "perform_at")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[Sequence[str]]:
        """
        Specify a list of time windows for to execute revertToSpot strategy. Time window format: `ddd:hh:mm-ddd:hh:mm`. Example: `Mon:03:00-Wed:02:30`
        """
        return pulumi.get(self, "time_windows")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupScalingDownPolicy(dict):
    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 policy_name: str,
                 threshold: float,
                 unit: str,
                 action_type: Optional[str] = None,
                 adjustment: Optional[str] = None,
                 cooldown: Optional[int] = None,
                 dimensions: Optional[Sequence['outputs.ElastigroupScalingDownPolicyDimension']] = None,
                 evaluation_periods: Optional[int] = None,
                 is_enabled: Optional[bool] = None,
                 max_target_capacity: Optional[str] = None,
                 maximum: Optional[str] = None,
                 min_target_capacity: Optional[str] = None,
                 minimum: Optional[str] = None,
                 operator: Optional[str] = None,
                 period: Optional[int] = None,
                 source: Optional[str] = None,
                 statistic: Optional[str] = None,
                 target: Optional[str] = None):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> str:
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[int]:
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ElastigroupScalingDownPolicyDimension']]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "max_target_capacity")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[str]:
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[str]:
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupScalingDownPolicyDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: The group name.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupScalingStrategy(dict):
    def __init__(__self__, *,
                 terminate_at_end_of_billing_hour: Optional[bool] = None,
                 termination_policy: Optional[str] = None):
        """
        :param bool terminate_at_end_of_billing_hour: Specify whether to terminate instances at the end of each billing hour.
        :param str termination_policy: - Determines whether to terminate the newest instances when performing a scaling action. Valid values: `"default"`, `"newestInstance"`.
        """
        if terminate_at_end_of_billing_hour is not None:
            pulumi.set(__self__, "terminate_at_end_of_billing_hour", terminate_at_end_of_billing_hour)
        if termination_policy is not None:
            pulumi.set(__self__, "termination_policy", termination_policy)

    @property
    @pulumi.getter(name="terminateAtEndOfBillingHour")
    def terminate_at_end_of_billing_hour(self) -> Optional[bool]:
        """
        Specify whether to terminate instances at the end of each billing hour.
        """
        return pulumi.get(self, "terminate_at_end_of_billing_hour")

    @property
    @pulumi.getter(name="terminationPolicy")
    def termination_policy(self) -> Optional[str]:
        """
        - Determines whether to terminate the newest instances when performing a scaling action. Valid values: `"default"`, `"newestInstance"`.
        """
        return pulumi.get(self, "termination_policy")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupScalingTargetPolicy(dict):
    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 policy_name: str,
                 target: float,
                 unit: str,
                 cooldown: Optional[int] = None,
                 dimensions: Optional[Sequence['outputs.ElastigroupScalingTargetPolicyDimension']] = None,
                 max_capacity_per_scale: Optional[str] = None,
                 predictive_mode: Optional[str] = None,
                 source: Optional[str] = None,
                 statistic: Optional[str] = None):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "unit", unit)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if max_capacity_per_scale is not None:
            pulumi.set(__self__, "max_capacity_per_scale", max_capacity_per_scale)
        if predictive_mode is not None:
            pulumi.set(__self__, "predictive_mode", predictive_mode)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> str:
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter
    def target(self) -> float:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[int]:
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ElastigroupScalingTargetPolicyDimension']]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="maxCapacityPerScale")
    def max_capacity_per_scale(self) -> Optional[str]:
        return pulumi.get(self, "max_capacity_per_scale")

    @property
    @pulumi.getter(name="predictiveMode")
    def predictive_mode(self) -> Optional[str]:
        return pulumi.get(self, "predictive_mode")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        return pulumi.get(self, "statistic")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupScalingTargetPolicyDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: The group name.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupScalingUpPolicy(dict):
    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 policy_name: str,
                 threshold: float,
                 unit: str,
                 action_type: Optional[str] = None,
                 adjustment: Optional[str] = None,
                 cooldown: Optional[int] = None,
                 dimensions: Optional[Sequence['outputs.ElastigroupScalingUpPolicyDimension']] = None,
                 evaluation_periods: Optional[int] = None,
                 is_enabled: Optional[bool] = None,
                 max_target_capacity: Optional[str] = None,
                 maximum: Optional[str] = None,
                 min_target_capacity: Optional[str] = None,
                 minimum: Optional[str] = None,
                 operator: Optional[str] = None,
                 period: Optional[int] = None,
                 source: Optional[str] = None,
                 statistic: Optional[str] = None,
                 target: Optional[str] = None):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> str:
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[int]:
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ElastigroupScalingUpPolicyDimension']]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "max_target_capacity")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[str]:
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[str]:
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupScalingUpPolicyDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str name: The group name.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupScheduledTask(dict):
    def __init__(__self__, *,
                 task_type: str,
                 adjustment: Optional[str] = None,
                 adjustment_percentage: Optional[str] = None,
                 batch_size_percentage: Optional[str] = None,
                 cron_expression: Optional[str] = None,
                 frequency: Optional[str] = None,
                 grace_period: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 max_capacity: Optional[str] = None,
                 min_capacity: Optional[str] = None,
                 scale_max_capacity: Optional[str] = None,
                 scale_min_capacity: Optional[str] = None,
                 scale_target_capacity: Optional[str] = None,
                 start_time: Optional[str] = None,
                 target_capacity: Optional[str] = None):
        pulumi.set(__self__, "task_type", task_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if adjustment_percentage is not None:
            pulumi.set(__self__, "adjustment_percentage", adjustment_percentage)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if min_capacity is not None:
            pulumi.set(__self__, "min_capacity", min_capacity)
        if scale_max_capacity is not None:
            pulumi.set(__self__, "scale_max_capacity", scale_max_capacity)
        if scale_min_capacity is not None:
            pulumi.set(__self__, "scale_min_capacity", scale_min_capacity)
        if scale_target_capacity is not None:
            pulumi.set(__self__, "scale_target_capacity", scale_target_capacity)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if target_capacity is not None:
            pulumi.set(__self__, "target_capacity", target_capacity)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter(name="adjustmentPercentage")
    def adjustment_percentage(self) -> Optional[str]:
        return pulumi.get(self, "adjustment_percentage")

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[str]:
        return pulumi.get(self, "batch_size_percentage")

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[str]:
        return pulumi.get(self, "cron_expression")

    @property
    @pulumi.getter
    def frequency(self) -> Optional[str]:
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[str]:
        return pulumi.get(self, "grace_period")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[str]:
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> Optional[str]:
        return pulumi.get(self, "min_capacity")

    @property
    @pulumi.getter(name="scaleMaxCapacity")
    def scale_max_capacity(self) -> Optional[str]:
        return pulumi.get(self, "scale_max_capacity")

    @property
    @pulumi.getter(name="scaleMinCapacity")
    def scale_min_capacity(self) -> Optional[str]:
        return pulumi.get(self, "scale_min_capacity")

    @property
    @pulumi.getter(name="scaleTargetCapacity")
    def scale_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "scale_target_capacity")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="targetCapacity")
    def target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "target_capacity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupSignal(dict):
    def __init__(__self__, *,
                 name: str,
                 timeout: Optional[int] = None):
        """
        :param str name: The group name.
        """
        pulumi.set(__self__, "name", name)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupStatefulDeallocation(dict):
    def __init__(__self__, *,
                 should_delete_images: Optional[bool] = None,
                 should_delete_network_interfaces: Optional[bool] = None,
                 should_delete_snapshots: Optional[bool] = None,
                 should_delete_volumes: Optional[bool] = None):
        if should_delete_images is not None:
            pulumi.set(__self__, "should_delete_images", should_delete_images)
        if should_delete_network_interfaces is not None:
            pulumi.set(__self__, "should_delete_network_interfaces", should_delete_network_interfaces)
        if should_delete_snapshots is not None:
            pulumi.set(__self__, "should_delete_snapshots", should_delete_snapshots)
        if should_delete_volumes is not None:
            pulumi.set(__self__, "should_delete_volumes", should_delete_volumes)

    @property
    @pulumi.getter(name="shouldDeleteImages")
    def should_delete_images(self) -> Optional[bool]:
        return pulumi.get(self, "should_delete_images")

    @property
    @pulumi.getter(name="shouldDeleteNetworkInterfaces")
    def should_delete_network_interfaces(self) -> Optional[bool]:
        return pulumi.get(self, "should_delete_network_interfaces")

    @property
    @pulumi.getter(name="shouldDeleteSnapshots")
    def should_delete_snapshots(self) -> Optional[bool]:
        return pulumi.get(self, "should_delete_snapshots")

    @property
    @pulumi.getter(name="shouldDeleteVolumes")
    def should_delete_volumes(self) -> Optional[bool]:
        return pulumi.get(self, "should_delete_volumes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupUpdatePolicy(dict):
    def __init__(__self__, *,
                 should_resume_stateful: bool,
                 should_roll: bool,
                 auto_apply_tags: Optional[bool] = None,
                 roll_config: Optional['outputs.ElastigroupUpdatePolicyRollConfig'] = None):
        pulumi.set(__self__, "should_resume_stateful", should_resume_stateful)
        pulumi.set(__self__, "should_roll", should_roll)
        if auto_apply_tags is not None:
            pulumi.set(__self__, "auto_apply_tags", auto_apply_tags)
        if roll_config is not None:
            pulumi.set(__self__, "roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldResumeStateful")
    def should_resume_stateful(self) -> bool:
        return pulumi.get(self, "should_resume_stateful")

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> bool:
        return pulumi.get(self, "should_roll")

    @property
    @pulumi.getter(name="autoApplyTags")
    def auto_apply_tags(self) -> Optional[bool]:
        return pulumi.get(self, "auto_apply_tags")

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional['outputs.ElastigroupUpdatePolicyRollConfig']:
        return pulumi.get(self, "roll_config")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupUpdatePolicyRollConfig(dict):
    def __init__(__self__, *,
                 batch_size_percentage: int,
                 grace_period: Optional[int] = None,
                 health_check_type: Optional[str] = None,
                 strategy: Optional['outputs.ElastigroupUpdatePolicyRollConfigStrategy'] = None,
                 wait_for_roll_percentage: Optional[int] = None,
                 wait_for_roll_timeout: Optional[int] = None):
        """
        :param str health_check_type: The service that will perform health checks for the instance. Valid values: `"ELB"`, `"HCS"`, `"TARGET_GROUP"`, `"MLB"`, `"EC2"`, `"MULTAI_TARGET_SET"`, `"MLB_RUNTIME"`, `"K8S_NODE"`, `"NOMAD_NODE"`, `"ECS_CLUSTER_INSTANCE"`.
        """
        pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if health_check_type is not None:
            pulumi.set(__self__, "health_check_type", health_check_type)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)
        if wait_for_roll_percentage is not None:
            pulumi.set(__self__, "wait_for_roll_percentage", wait_for_roll_percentage)
        if wait_for_roll_timeout is not None:
            pulumi.set(__self__, "wait_for_roll_timeout", wait_for_roll_timeout)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> int:
        return pulumi.get(self, "batch_size_percentage")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        return pulumi.get(self, "grace_period")

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> Optional[str]:
        """
        The service that will perform health checks for the instance. Valid values: `"ELB"`, `"HCS"`, `"TARGET_GROUP"`, `"MLB"`, `"EC2"`, `"MULTAI_TARGET_SET"`, `"MLB_RUNTIME"`, `"K8S_NODE"`, `"NOMAD_NODE"`, `"ECS_CLUSTER_INSTANCE"`.
        """
        return pulumi.get(self, "health_check_type")

    @property
    @pulumi.getter
    def strategy(self) -> Optional['outputs.ElastigroupUpdatePolicyRollConfigStrategy']:
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="waitForRollPercentage")
    def wait_for_roll_percentage(self) -> Optional[int]:
        return pulumi.get(self, "wait_for_roll_percentage")

    @property
    @pulumi.getter(name="waitForRollTimeout")
    def wait_for_roll_timeout(self) -> Optional[int]:
        return pulumi.get(self, "wait_for_roll_timeout")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupUpdatePolicyRollConfigStrategy(dict):
    def __init__(__self__, *,
                 action: str,
                 batch_min_healthy_percentage: Optional[int] = None,
                 on_failure: Optional['outputs.ElastigroupUpdatePolicyRollConfigStrategyOnFailure'] = None,
                 should_drain_instances: Optional[bool] = None):
        pulumi.set(__self__, "action", action)
        if batch_min_healthy_percentage is not None:
            pulumi.set(__self__, "batch_min_healthy_percentage", batch_min_healthy_percentage)
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if should_drain_instances is not None:
            pulumi.set(__self__, "should_drain_instances", should_drain_instances)

    @property
    @pulumi.getter
    def action(self) -> str:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="batchMinHealthyPercentage")
    def batch_min_healthy_percentage(self) -> Optional[int]:
        return pulumi.get(self, "batch_min_healthy_percentage")

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional['outputs.ElastigroupUpdatePolicyRollConfigStrategyOnFailure']:
        return pulumi.get(self, "on_failure")

    @property
    @pulumi.getter(name="shouldDrainInstances")
    def should_drain_instances(self) -> Optional[bool]:
        return pulumi.get(self, "should_drain_instances")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ElastigroupUpdatePolicyRollConfigStrategyOnFailure(dict):
    def __init__(__self__, *,
                 action_type: str,
                 batch_num: Optional[int] = None,
                 draining_timeout: Optional[int] = None,
                 should_decrement_target_capacity: Optional[bool] = None,
                 should_handle_all_batches: Optional[bool] = None):
        """
        :param int draining_timeout: The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
        """
        pulumi.set(__self__, "action_type", action_type)
        if batch_num is not None:
            pulumi.set(__self__, "batch_num", batch_num)
        if draining_timeout is not None:
            pulumi.set(__self__, "draining_timeout", draining_timeout)
        if should_decrement_target_capacity is not None:
            pulumi.set(__self__, "should_decrement_target_capacity", should_decrement_target_capacity)
        if should_handle_all_batches is not None:
            pulumi.set(__self__, "should_handle_all_batches", should_handle_all_batches)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="batchNum")
    def batch_num(self) -> Optional[int]:
        return pulumi.get(self, "batch_num")

    @property
    @pulumi.getter(name="drainingTimeout")
    def draining_timeout(self) -> Optional[int]:
        """
        The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
        """
        return pulumi.get(self, "draining_timeout")

    @property
    @pulumi.getter(name="shouldDecrementTargetCapacity")
    def should_decrement_target_capacity(self) -> Optional[bool]:
        return pulumi.get(self, "should_decrement_target_capacity")

    @property
    @pulumi.getter(name="shouldHandleAllBatches")
    def should_handle_all_batches(self) -> Optional[bool]:
        return pulumi.get(self, "should_handle_all_batches")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedInstanceIntegrationRoute53(dict):
    def __init__(__self__, *,
                 domains: Sequence['outputs.ManagedInstanceIntegrationRoute53Domain']):
        pulumi.set(__self__, "domains", domains)

    @property
    @pulumi.getter
    def domains(self) -> Sequence['outputs.ManagedInstanceIntegrationRoute53Domain']:
        return pulumi.get(self, "domains")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedInstanceIntegrationRoute53Domain(dict):
    def __init__(__self__, *,
                 hosted_zone_id: str,
                 record_sets: Sequence['outputs.ManagedInstanceIntegrationRoute53DomainRecordSet'],
                 record_set_type: Optional[str] = None,
                 spotinst_acct_id: Optional[str] = None):
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)
        pulumi.set(__self__, "record_sets", record_sets)
        if record_set_type is not None:
            pulumi.set(__self__, "record_set_type", record_set_type)
        if spotinst_acct_id is not None:
            pulumi.set(__self__, "spotinst_acct_id", spotinst_acct_id)

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> str:
        return pulumi.get(self, "hosted_zone_id")

    @property
    @pulumi.getter(name="recordSets")
    def record_sets(self) -> Sequence['outputs.ManagedInstanceIntegrationRoute53DomainRecordSet']:
        return pulumi.get(self, "record_sets")

    @property
    @pulumi.getter(name="recordSetType")
    def record_set_type(self) -> Optional[str]:
        return pulumi.get(self, "record_set_type")

    @property
    @pulumi.getter(name="spotinstAcctId")
    def spotinst_acct_id(self) -> Optional[str]:
        return pulumi.get(self, "spotinst_acct_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedInstanceIntegrationRoute53DomainRecordSet(dict):
    def __init__(__self__, *,
                 name: str,
                 use_public_dns: Optional[bool] = None,
                 use_public_ip: Optional[bool] = None):
        """
        :param str name: The ManagedInstance name.
        """
        pulumi.set(__self__, "name", name)
        if use_public_dns is not None:
            pulumi.set(__self__, "use_public_dns", use_public_dns)
        if use_public_ip is not None:
            pulumi.set(__self__, "use_public_ip", use_public_ip)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The ManagedInstance name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="usePublicDns")
    def use_public_dns(self) -> Optional[bool]:
        return pulumi.get(self, "use_public_dns")

    @property
    @pulumi.getter(name="usePublicIp")
    def use_public_ip(self) -> Optional[bool]:
        return pulumi.get(self, "use_public_ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedInstanceLoadBalancer(dict):
    def __init__(__self__, *,
                 type: str,
                 arn: Optional[str] = None,
                 auto_weight: Optional[bool] = None,
                 az_awareness: Optional[bool] = None,
                 balancer_id: Optional[str] = None,
                 name: Optional[str] = None,
                 target_set_id: Optional[str] = None):
        """
        :param str name: The ManagedInstance name.
        """
        pulumi.set(__self__, "type", type)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if auto_weight is not None:
            pulumi.set(__self__, "auto_weight", auto_weight)
        if az_awareness is not None:
            pulumi.set(__self__, "az_awareness", az_awareness)
        if balancer_id is not None:
            pulumi.set(__self__, "balancer_id", balancer_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_set_id is not None:
            pulumi.set(__self__, "target_set_id", target_set_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="autoWeight")
    def auto_weight(self) -> Optional[bool]:
        return pulumi.get(self, "auto_weight")

    @property
    @pulumi.getter(name="azAwareness")
    def az_awareness(self) -> Optional[bool]:
        return pulumi.get(self, "az_awareness")

    @property
    @pulumi.getter(name="balancerId")
    def balancer_id(self) -> Optional[str]:
        return pulumi.get(self, "balancer_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The ManagedInstance name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetSetId")
    def target_set_id(self) -> Optional[str]:
        return pulumi.get(self, "target_set_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedInstanceNetworkInterface(dict):
    def __init__(__self__, *,
                 device_index: str,
                 associate_ipv6_address: Optional[bool] = None,
                 associate_public_ip_address: Optional[bool] = None):
        pulumi.set(__self__, "device_index", device_index)
        if associate_ipv6_address is not None:
            pulumi.set(__self__, "associate_ipv6_address", associate_ipv6_address)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> str:
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter(name="associateIpv6Address")
    def associate_ipv6_address(self) -> Optional[bool]:
        return pulumi.get(self, "associate_ipv6_address")

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[bool]:
        return pulumi.get(self, "associate_public_ip_address")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedInstanceRevertToSpot(dict):
    def __init__(__self__, *,
                 perform_at: str):
        """
        :param str perform_at: Valid values: `"always"`, `"never"`, `"timeWindow"`.
               Default `"never"`.
        """
        pulumi.set(__self__, "perform_at", perform_at)

    @property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> str:
        """
        Valid values: `"always"`, `"never"`, `"timeWindow"`.
        Default `"never"`.
        """
        return pulumi.get(self, "perform_at")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedInstanceScheduledTask(dict):
    def __init__(__self__, *,
                 task_type: str,
                 cron_expression: Optional[str] = None,
                 frequency: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 start_time: Optional[str] = None):
        pulumi.set(__self__, "task_type", task_type)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[str]:
        return pulumi.get(self, "cron_expression")

    @property
    @pulumi.getter
    def frequency(self) -> Optional[str]:
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        return pulumi.get(self, "start_time")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ManagedInstanceTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: Tag's key.
        :param str value: Tag's name.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Tag's key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Tag's name.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarApplication(dict):
    def __init__(__self__, *,
                 name: str,
                 args: Optional[Sequence[str]] = None,
                 version: Optional[str] = None):
        """
        :param str name: The MrScaler name.
        """
        pulumi.set(__self__, "name", name)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The MrScaler name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarBootstrapActionsFile(dict):
    def __init__(__self__, *,
                 bucket: str,
                 key: str):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarConfigurationsFile(dict):
    def __init__(__self__, *,
                 bucket: str,
                 key: str):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarCoreEbsBlockDevice(dict):
    def __init__(__self__, *,
                 size_in_gb: int,
                 volume_type: str,
                 iops: Optional[int] = None,
                 volumes_per_instance: Optional[int] = None):
        pulumi.set(__self__, "size_in_gb", size_in_gb)
        pulumi.set(__self__, "volume_type", volume_type)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if volumes_per_instance is not None:
            pulumi.set(__self__, "volumes_per_instance", volumes_per_instance)

    @property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> int:
        return pulumi.get(self, "size_in_gb")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        return pulumi.get(self, "volume_type")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="volumesPerInstance")
    def volumes_per_instance(self) -> Optional[int]:
        return pulumi.get(self, "volumes_per_instance")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarCoreScalingDownPolicy(dict):
    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 policy_name: str,
                 threshold: float,
                 unit: str,
                 action_type: Optional[str] = None,
                 adjustment: Optional[str] = None,
                 cooldown: Optional[int] = None,
                 dimensions: Optional[Mapping[str, Any]] = None,
                 evaluation_periods: Optional[int] = None,
                 max_target_capacity: Optional[str] = None,
                 maximum: Optional[str] = None,
                 min_target_capacity: Optional[str] = None,
                 minimum: Optional[str] = None,
                 operator: Optional[str] = None,
                 period: Optional[int] = None,
                 statistic: Optional[str] = None,
                 target: Optional[str] = None):
        """
        :param str metric_name: The name of the metric in CloudWatch which the statement will be based on.
        :param str namespace: Must contain the value: `AWS/ElasticMapReduce`.
        :param float threshold: The value that the specified statistic is compared to.
        :param str unit: The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
        :param int evaluation_periods: The number of periods over which data is compared to the specified threshold.
        :param str operator: The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
        :param int period: The time window in seconds over which the statistic is applied.
        :param str statistic: The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the metric in CloudWatch which the statement will be based on.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Must contain the value: `AWS/ElasticMapReduce`.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> str:
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        The value that the specified statistic is compared to.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[int]:
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        """
        The number of periods over which data is compared to the specified threshold.
        """
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "max_target_capacity")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[str]:
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[str]:
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        """
        The time window in seconds over which the statistic is applied.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        """
        The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
        """
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarCoreScalingUpPolicy(dict):
    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 policy_name: str,
                 threshold: float,
                 unit: str,
                 action_type: Optional[str] = None,
                 adjustment: Optional[str] = None,
                 cooldown: Optional[int] = None,
                 dimensions: Optional[Mapping[str, Any]] = None,
                 evaluation_periods: Optional[int] = None,
                 max_target_capacity: Optional[str] = None,
                 maximum: Optional[str] = None,
                 min_target_capacity: Optional[str] = None,
                 minimum: Optional[str] = None,
                 operator: Optional[str] = None,
                 period: Optional[int] = None,
                 statistic: Optional[str] = None,
                 target: Optional[str] = None):
        """
        :param str metric_name: The name of the metric in CloudWatch which the statement will be based on.
        :param str namespace: Must contain the value: `AWS/ElasticMapReduce`.
        :param float threshold: The value that the specified statistic is compared to.
        :param str unit: The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
        :param int evaluation_periods: The number of periods over which data is compared to the specified threshold.
        :param str operator: The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
        :param int period: The time window in seconds over which the statistic is applied.
        :param str statistic: The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the metric in CloudWatch which the statement will be based on.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Must contain the value: `AWS/ElasticMapReduce`.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> str:
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        The value that the specified statistic is compared to.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[int]:
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        """
        The number of periods over which data is compared to the specified threshold.
        """
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "max_target_capacity")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[str]:
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[str]:
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        """
        The time window in seconds over which the statistic is applied.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        """
        The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
        """
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarInstanceWeight(dict):
    def __init__(__self__, *,
                 instance_type: str,
                 weighted_capacity: int):
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> int:
        return pulumi.get(self, "weighted_capacity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarMasterEbsBlockDevice(dict):
    def __init__(__self__, *,
                 size_in_gb: int,
                 volume_type: str,
                 iops: Optional[int] = None,
                 volumes_per_instance: Optional[int] = None):
        pulumi.set(__self__, "size_in_gb", size_in_gb)
        pulumi.set(__self__, "volume_type", volume_type)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if volumes_per_instance is not None:
            pulumi.set(__self__, "volumes_per_instance", volumes_per_instance)

    @property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> int:
        return pulumi.get(self, "size_in_gb")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        return pulumi.get(self, "volume_type")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="volumesPerInstance")
    def volumes_per_instance(self) -> Optional[int]:
        return pulumi.get(self, "volumes_per_instance")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarProvisioningTimeout(dict):
    def __init__(__self__, *,
                 timeout: int,
                 timeout_action: str):
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "timeout_action", timeout_action)

    @property
    @pulumi.getter
    def timeout(self) -> int:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="timeoutAction")
    def timeout_action(self) -> str:
        return pulumi.get(self, "timeout_action")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarScheduledTask(dict):
    def __init__(__self__, *,
                 cron: str,
                 instance_group_type: str,
                 task_type: str,
                 desired_capacity: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 max_capacity: Optional[str] = None,
                 min_capacity: Optional[str] = None):
        pulumi.set(__self__, "cron", cron)
        pulumi.set(__self__, "instance_group_type", instance_group_type)
        pulumi.set(__self__, "task_type", task_type)
        if desired_capacity is not None:
            pulumi.set(__self__, "desired_capacity", desired_capacity)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if min_capacity is not None:
            pulumi.set(__self__, "min_capacity", min_capacity)

    @property
    @pulumi.getter
    def cron(self) -> str:
        return pulumi.get(self, "cron")

    @property
    @pulumi.getter(name="instanceGroupType")
    def instance_group_type(self) -> str:
        return pulumi.get(self, "instance_group_type")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="desiredCapacity")
    def desired_capacity(self) -> Optional[str]:
        return pulumi.get(self, "desired_capacity")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[str]:
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> Optional[str]:
        return pulumi.get(self, "min_capacity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarStepsFile(dict):
    def __init__(__self__, *,
                 bucket: str,
                 key: str):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarTaskEbsBlockDevice(dict):
    def __init__(__self__, *,
                 size_in_gb: int,
                 volume_type: str,
                 iops: Optional[int] = None,
                 volumes_per_instance: Optional[int] = None):
        pulumi.set(__self__, "size_in_gb", size_in_gb)
        pulumi.set(__self__, "volume_type", volume_type)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if volumes_per_instance is not None:
            pulumi.set(__self__, "volumes_per_instance", volumes_per_instance)

    @property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> int:
        return pulumi.get(self, "size_in_gb")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        return pulumi.get(self, "volume_type")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="volumesPerInstance")
    def volumes_per_instance(self) -> Optional[int]:
        return pulumi.get(self, "volumes_per_instance")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarTaskScalingDownPolicy(dict):
    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 policy_name: str,
                 threshold: float,
                 unit: str,
                 action_type: Optional[str] = None,
                 adjustment: Optional[str] = None,
                 cooldown: Optional[int] = None,
                 dimensions: Optional[Mapping[str, Any]] = None,
                 evaluation_periods: Optional[int] = None,
                 max_target_capacity: Optional[str] = None,
                 maximum: Optional[str] = None,
                 min_target_capacity: Optional[str] = None,
                 minimum: Optional[str] = None,
                 operator: Optional[str] = None,
                 period: Optional[int] = None,
                 statistic: Optional[str] = None,
                 target: Optional[str] = None):
        """
        :param str metric_name: The name of the metric in CloudWatch which the statement will be based on.
        :param str namespace: Must contain the value: `AWS/ElasticMapReduce`.
        :param float threshold: The value that the specified statistic is compared to.
        :param str unit: The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
        :param int evaluation_periods: The number of periods over which data is compared to the specified threshold.
        :param str operator: The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
        :param int period: The time window in seconds over which the statistic is applied.
        :param str statistic: The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the metric in CloudWatch which the statement will be based on.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Must contain the value: `AWS/ElasticMapReduce`.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> str:
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        The value that the specified statistic is compared to.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[int]:
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        """
        The number of periods over which data is compared to the specified threshold.
        """
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "max_target_capacity")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[str]:
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[str]:
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        """
        The time window in seconds over which the statistic is applied.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        """
        The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
        """
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarTaskScalingUpPolicy(dict):
    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 policy_name: str,
                 threshold: float,
                 unit: str,
                 action_type: Optional[str] = None,
                 adjustment: Optional[str] = None,
                 cooldown: Optional[int] = None,
                 dimensions: Optional[Mapping[str, Any]] = None,
                 evaluation_periods: Optional[int] = None,
                 max_target_capacity: Optional[str] = None,
                 maximum: Optional[str] = None,
                 min_target_capacity: Optional[str] = None,
                 minimum: Optional[str] = None,
                 operator: Optional[str] = None,
                 period: Optional[int] = None,
                 statistic: Optional[str] = None,
                 target: Optional[str] = None):
        """
        :param str metric_name: The name of the metric in CloudWatch which the statement will be based on.
        :param str namespace: Must contain the value: `AWS/ElasticMapReduce`.
        :param float threshold: The value that the specified statistic is compared to.
        :param str unit: The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
        :param int evaluation_periods: The number of periods over which data is compared to the specified threshold.
        :param str operator: The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
        :param int period: The time window in seconds over which the statistic is applied.
        :param str statistic: The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the metric in CloudWatch which the statement will be based on.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Must contain the value: `AWS/ElasticMapReduce`.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> str:
        return pulumi.get(self, "policy_name")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        The value that the specified statistic is compared to.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[str]:
        return pulumi.get(self, "adjustment")

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[int]:
        return pulumi.get(self, "cooldown")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        """
        The number of periods over which data is compared to the specified threshold.
        """
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "max_target_capacity")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[str]:
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[str]:
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[str]:
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        """
        The time window in seconds over which the statistic is applied.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        """
        The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
        """
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarTerminationPolicy(dict):
    def __init__(__self__, *,
                 statements: Sequence['outputs.MrScalarTerminationPolicyStatement']):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> Sequence['outputs.MrScalarTerminationPolicyStatement']:
        return pulumi.get(self, "statements")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class MrScalarTerminationPolicyStatement(dict):
    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 threshold: float,
                 evaluation_periods: Optional[int] = None,
                 operator: Optional[str] = None,
                 period: Optional[int] = None,
                 statistic: Optional[str] = None,
                 unit: Optional[str] = None):
        """
        :param str metric_name: The name of the metric in CloudWatch which the statement will be based on.
        :param str namespace: Must contain the value: `AWS/ElasticMapReduce`.
        :param float threshold: The value that the specified statistic is compared to.
        :param int evaluation_periods: The number of periods over which data is compared to the specified threshold.
        :param str operator: The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
        :param int period: The time window in seconds over which the statistic is applied.
        :param str statistic: The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
        :param str unit: The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "threshold", threshold)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The name of the metric in CloudWatch which the statement will be based on.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Must contain the value: `AWS/ElasticMapReduce`.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        The value that the specified statistic is compared to.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        """
        The number of periods over which data is compared to the specified threshold.
        """
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        """
        The time window in seconds over which the statistic is applied.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        """
        The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
        """
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
        """
        return pulumi.get(self, "unit")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanAutoscaler(dict):
    def __init__(__self__, *,
                 auto_headroom_percentage: Optional[int] = None,
                 autoscale_cooldown: Optional[int] = None,
                 autoscale_down: Optional['outputs.OceanAutoscalerAutoscaleDown'] = None,
                 autoscale_headroom: Optional['outputs.OceanAutoscalerAutoscaleHeadroom'] = None,
                 autoscale_is_auto_config: Optional[bool] = None,
                 autoscale_is_enabled: Optional[bool] = None,
                 resource_limits: Optional['outputs.OceanAutoscalerResourceLimits'] = None):
        if auto_headroom_percentage is not None:
            pulumi.set(__self__, "auto_headroom_percentage", auto_headroom_percentage)
        if autoscale_cooldown is not None:
            pulumi.set(__self__, "autoscale_cooldown", autoscale_cooldown)
        if autoscale_down is not None:
            pulumi.set(__self__, "autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)
        if autoscale_is_auto_config is not None:
            pulumi.set(__self__, "autoscale_is_auto_config", autoscale_is_auto_config)
        if autoscale_is_enabled is not None:
            pulumi.set(__self__, "autoscale_is_enabled", autoscale_is_enabled)
        if resource_limits is not None:
            pulumi.set(__self__, "resource_limits", resource_limits)

    @property
    @pulumi.getter(name="autoHeadroomPercentage")
    def auto_headroom_percentage(self) -> Optional[int]:
        return pulumi.get(self, "auto_headroom_percentage")

    @property
    @pulumi.getter(name="autoscaleCooldown")
    def autoscale_cooldown(self) -> Optional[int]:
        return pulumi.get(self, "autoscale_cooldown")

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional['outputs.OceanAutoscalerAutoscaleDown']:
        return pulumi.get(self, "autoscale_down")

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional['outputs.OceanAutoscalerAutoscaleHeadroom']:
        return pulumi.get(self, "autoscale_headroom")

    @property
    @pulumi.getter(name="autoscaleIsAutoConfig")
    def autoscale_is_auto_config(self) -> Optional[bool]:
        return pulumi.get(self, "autoscale_is_auto_config")

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "autoscale_is_enabled")

    @property
    @pulumi.getter(name="resourceLimits")
    def resource_limits(self) -> Optional['outputs.OceanAutoscalerResourceLimits']:
        return pulumi.get(self, "resource_limits")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanAutoscalerAutoscaleDown(dict):
    def __init__(__self__, *,
                 evaluation_periods: Optional[int] = None,
                 max_scale_down_percentage: Optional[float] = None):
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_scale_down_percentage is not None:
            pulumi.set(__self__, "max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[float]:
        return pulumi.get(self, "max_scale_down_percentage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanAutoscalerAutoscaleHeadroom(dict):
    def __init__(__self__, *,
                 cpu_per_unit: Optional[int] = None,
                 gpu_per_unit: Optional[int] = None,
                 memory_per_unit: Optional[int] = None,
                 num_of_units: Optional[int] = None):
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "cpu_per_unit")

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "gpu_per_unit")

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[int]:
        return pulumi.get(self, "memory_per_unit")

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[int]:
        return pulumi.get(self, "num_of_units")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanAutoscalerResourceLimits(dict):
    def __init__(__self__, *,
                 max_memory_gib: Optional[int] = None,
                 max_vcpu: Optional[int] = None):
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[int]:
        return pulumi.get(self, "max_memory_gib")

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[int]:
        return pulumi.get(self, "max_vcpu")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanLaunchSpecAutoscaleHeadroom(dict):
    def __init__(__self__, *,
                 num_of_units: int,
                 cpu_per_unit: Optional[int] = None,
                 gpu_per_unit: Optional[int] = None,
                 memory_per_unit: Optional[int] = None):
        """
        :param int num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        :param int cpu_per_unit: Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param int gpu_per_unit: Optionally configure the number of GPUS to allocate for each headroom unit.
        :param int memory_per_unit: Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        pulumi.set(__self__, "num_of_units", num_of_units)
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> int:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        return pulumi.get(self, "num_of_units")

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[int]:
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[int]:
        """
        Optionally configure the number of GPUS to allocate for each headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[int]:
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        return pulumi.get(self, "memory_per_unit")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanLaunchSpecBlockDeviceMapping(dict):
    def __init__(__self__, *,
                 device_name: str,
                 ebs: Optional['outputs.OceanLaunchSpecBlockDeviceMappingEbs'] = None,
                 no_device: Optional[str] = None,
                 virtual_name: Optional[str] = None):
        """
        :param str device_name: String. Set device name. (Example: "/dev/xvda1").
        :param 'OceanLaunchSpecBlockDeviceMappingEbsArgs' ebs: Object. Set Elastic Block Store properties .
        :param str no_device: String. suppresses the specified device included in the block device mapping of the AMI.
        """
        pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        String. Set device name. (Example: "/dev/xvda1").
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.OceanLaunchSpecBlockDeviceMappingEbs']:
        """
        Object. Set Elastic Block Store properties .
        """
        return pulumi.get(self, "ebs")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[str]:
        """
        String. suppresses the specified device included in the block device mapping of the AMI.
        """
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        return pulumi.get(self, "virtual_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanLaunchSpecBlockDeviceMappingEbs(dict):
    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 dynamic_volume_size: Optional['outputs.OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize'] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        :param bool delete_on_termination: Boolean. Flag to delete the EBS on instance termination.
        :param 'OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs' dynamic_volume_size: Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
        :param bool encrypted: Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        :param int iops: Int. The number of I/O operations per second (IOPS) that the volume supports.
        :param str kms_key_id: String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
        :param str snapshot_id: (Optional) String. The Snapshot ID to mount by.
        :param int volume_size: Int. The size, in GB of the volume.
        :param str volume_type: String. The type of the volume (example: "gp2").
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if dynamic_volume_size is not None:
            pulumi.set(__self__, "dynamic_volume_size", dynamic_volume_size)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Boolean. Flag to delete the EBS on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter(name="dynamicVolumeSize")
    def dynamic_volume_size(self) -> Optional['outputs.OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize']:
        """
        Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
        """
        return pulumi.get(self, "dynamic_volume_size")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        Int. The number of I/O operations per second (IOPS) that the volume supports.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        (Optional) String. The Snapshot ID to mount by.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        Int. The size, in GB of the volume.
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        String. The type of the volume (example: "gp2").
        """
        return pulumi.get(self, "volume_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize(dict):
    def __init__(__self__, *,
                 base_size: int,
                 resource: str,
                 size_per_resource_unit: int):
        """
        :param int base_size: Int. Initial size for volume. (Example: 50)
        :param str resource: String. Resource type to increase volume size dynamically by. (valid values: "CPU")
        :param int size_per_resource_unit: Int. Additional size (in GB) per resource unit. (Example: baseSize= 50, sizePerResourceUnit=20, and instance with 2 CPU is launched - its total disk size will be: 90GB)
        """
        pulumi.set(__self__, "base_size", base_size)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "size_per_resource_unit", size_per_resource_unit)

    @property
    @pulumi.getter(name="baseSize")
    def base_size(self) -> int:
        """
        Int. Initial size for volume. (Example: 50)
        """
        return pulumi.get(self, "base_size")

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        String. Resource type to increase volume size dynamically by. (valid values: "CPU")
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="sizePerResourceUnit")
    def size_per_resource_unit(self) -> int:
        """
        Int. Additional size (in GB) per resource unit. (Example: baseSize= 50, sizePerResourceUnit=20, and instance with 2 CPU is launched - its total disk size will be: 90GB)
        """
        return pulumi.get(self, "size_per_resource_unit")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanLaunchSpecElasticIpPool(dict):
    def __init__(__self__, *,
                 tag_selector: Optional['outputs.OceanLaunchSpecElasticIpPoolTagSelector'] = None):
        """
        :param 'OceanLaunchSpecElasticIpPoolTagSelectorArgs' tag_selector: Key-value object, which defines an Elastic IP from the customer pool. Can be null.
        """
        if tag_selector is not None:
            pulumi.set(__self__, "tag_selector", tag_selector)

    @property
    @pulumi.getter(name="tagSelector")
    def tag_selector(self) -> Optional['outputs.OceanLaunchSpecElasticIpPoolTagSelector']:
        """
        Key-value object, which defines an Elastic IP from the customer pool. Can be null.
        """
        return pulumi.get(self, "tag_selector")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanLaunchSpecElasticIpPoolTagSelector(dict):
    def __init__(__self__, *,
                 tag_key: str,
                 tag_value: Optional[str] = None):
        """
        :param str tag_key: Elastic IP tag key. The launch spec will consider all elastic IPs tagged with this tag as a part of the elastic IP pool to use.
        :param str tag_value: Elastic IP tag value. Can be null.
        """
        pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> str:
        """
        Elastic IP tag key. The launch spec will consider all elastic IPs tagged with this tag as a part of the elastic IP pool to use.
        """
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[str]:
        """
        Elastic IP tag value. Can be null.
        """
        return pulumi.get(self, "tag_value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanLaunchSpecLabel(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The tag key.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanLaunchSpecResourceLimit(dict):
    def __init__(__self__, *,
                 max_instance_count: Optional[int] = None):
        """
        :param int max_instance_count: set a maximum number of instances per launch specification. Can be null. If set, value must be greater than or equal to 0.
        """
        if max_instance_count is not None:
            pulumi.set(__self__, "max_instance_count", max_instance_count)

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> Optional[int]:
        """
        set a maximum number of instances per launch specification. Can be null. If set, value must be greater than or equal to 0.
        """
        return pulumi.get(self, "max_instance_count")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanLaunchSpecTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The tag key.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanLaunchSpecTaint(dict):
    def __init__(__self__, *,
                 effect: str,
                 key: str,
                 value: str):
        """
        :param str effect: The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
        :param str key: The tag key.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> str:
        """
        The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanLoadBalancer(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str arn: Required if type is set to TARGET_GROUP
        :param str name: Required if type is set to CLASSIC
        :param str type: Can be set to CLASSIC or TARGET_GROUP
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Required if type is set to TARGET_GROUP
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Required if type is set to CLASSIC
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Can be set to CLASSIC or TARGET_GROUP
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanScheduledTask(dict):
    def __init__(__self__, *,
                 shutdown_hours: Optional['outputs.OceanScheduledTaskShutdownHours'] = None,
                 tasks: Optional[Sequence['outputs.OceanScheduledTaskTask']] = None):
        if shutdown_hours is not None:
            pulumi.set(__self__, "shutdown_hours", shutdown_hours)
        if tasks is not None:
            pulumi.set(__self__, "tasks", tasks)

    @property
    @pulumi.getter(name="shutdownHours")
    def shutdown_hours(self) -> Optional['outputs.OceanScheduledTaskShutdownHours']:
        return pulumi.get(self, "shutdown_hours")

    @property
    @pulumi.getter
    def tasks(self) -> Optional[Sequence['outputs.OceanScheduledTaskTask']]:
        return pulumi.get(self, "tasks")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanScheduledTaskShutdownHours(dict):
    def __init__(__self__, *,
                 time_windows: Sequence[str],
                 is_enabled: Optional[bool] = None):
        pulumi.set(__self__, "time_windows", time_windows)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Sequence[str]:
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanScheduledTaskTask(dict):
    def __init__(__self__, *,
                 cron_expression: str,
                 is_enabled: bool,
                 task_type: str):
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> str:
        return pulumi.get(self, "cron_expression")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> str:
        return pulumi.get(self, "task_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The tag key.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanUpdatePolicy(dict):
    def __init__(__self__, *,
                 should_roll: bool,
                 roll_config: Optional['outputs.OceanUpdatePolicyRollConfig'] = None):
        pulumi.set(__self__, "should_roll", should_roll)
        if roll_config is not None:
            pulumi.set(__self__, "roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> bool:
        return pulumi.get(self, "should_roll")

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional['outputs.OceanUpdatePolicyRollConfig']:
        return pulumi.get(self, "roll_config")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class OceanUpdatePolicyRollConfig(dict):
    def __init__(__self__, *,
                 batch_size_percentage: int):
        pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> int:
        return pulumi.get(self, "batch_size_percentage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


