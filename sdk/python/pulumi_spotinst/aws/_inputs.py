# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'BeanstalkDeploymentPreferencesArgs',
    'BeanstalkDeploymentPreferencesArgsDict',
    'BeanstalkDeploymentPreferencesStrategyArgs',
    'BeanstalkDeploymentPreferencesStrategyArgsDict',
    'BeanstalkManagedActionsArgs',
    'BeanstalkManagedActionsArgsDict',
    'BeanstalkManagedActionsPlatformUpdateArgs',
    'BeanstalkManagedActionsPlatformUpdateArgsDict',
    'BeanstalkScheduledTaskArgs',
    'BeanstalkScheduledTaskArgsDict',
    'ElastigroupCpuOptionsArgs',
    'ElastigroupCpuOptionsArgsDict',
    'ElastigroupEbsBlockDeviceArgs',
    'ElastigroupEbsBlockDeviceArgsDict',
    'ElastigroupEbsBlockDeviceDynamicIopsArgs',
    'ElastigroupEbsBlockDeviceDynamicIopsArgsDict',
    'ElastigroupEbsBlockDeviceDynamicVolumeSizeArgs',
    'ElastigroupEbsBlockDeviceDynamicVolumeSizeArgsDict',
    'ElastigroupEphemeralBlockDeviceArgs',
    'ElastigroupEphemeralBlockDeviceArgsDict',
    'ElastigroupImageArgs',
    'ElastigroupImageArgsDict',
    'ElastigroupImageImageArgs',
    'ElastigroupImageImageArgsDict',
    'ElastigroupInstanceTypesWeightArgs',
    'ElastigroupInstanceTypesWeightArgsDict',
    'ElastigroupIntegrationBeanstalkArgs',
    'ElastigroupIntegrationBeanstalkArgsDict',
    'ElastigroupIntegrationBeanstalkDeploymentPreferencesArgs',
    'ElastigroupIntegrationBeanstalkDeploymentPreferencesArgsDict',
    'ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategyArgs',
    'ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategyArgsDict',
    'ElastigroupIntegrationBeanstalkManagedActionsArgs',
    'ElastigroupIntegrationBeanstalkManagedActionsArgsDict',
    'ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdateArgs',
    'ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdateArgsDict',
    'ElastigroupIntegrationCodedeployArgs',
    'ElastigroupIntegrationCodedeployArgsDict',
    'ElastigroupIntegrationCodedeployDeploymentGroupArgs',
    'ElastigroupIntegrationCodedeployDeploymentGroupArgsDict',
    'ElastigroupIntegrationDockerSwarmArgs',
    'ElastigroupIntegrationDockerSwarmArgsDict',
    'ElastigroupIntegrationDockerSwarmAutoscaleDownArgs',
    'ElastigroupIntegrationDockerSwarmAutoscaleDownArgsDict',
    'ElastigroupIntegrationDockerSwarmAutoscaleHeadroomArgs',
    'ElastigroupIntegrationDockerSwarmAutoscaleHeadroomArgsDict',
    'ElastigroupIntegrationEcsArgs',
    'ElastigroupIntegrationEcsArgsDict',
    'ElastigroupIntegrationEcsAutoscaleAttributeArgs',
    'ElastigroupIntegrationEcsAutoscaleAttributeArgsDict',
    'ElastigroupIntegrationEcsAutoscaleDownArgs',
    'ElastigroupIntegrationEcsAutoscaleDownArgsDict',
    'ElastigroupIntegrationEcsAutoscaleHeadroomArgs',
    'ElastigroupIntegrationEcsAutoscaleHeadroomArgsDict',
    'ElastigroupIntegrationEcsBatchArgs',
    'ElastigroupIntegrationEcsBatchArgsDict',
    'ElastigroupIntegrationGitlabArgs',
    'ElastigroupIntegrationGitlabArgsDict',
    'ElastigroupIntegrationGitlabRunnerArgs',
    'ElastigroupIntegrationGitlabRunnerArgsDict',
    'ElastigroupIntegrationKubernetesArgs',
    'ElastigroupIntegrationKubernetesArgsDict',
    'ElastigroupIntegrationKubernetesAutoscaleDownArgs',
    'ElastigroupIntegrationKubernetesAutoscaleDownArgsDict',
    'ElastigroupIntegrationKubernetesAutoscaleHeadroomArgs',
    'ElastigroupIntegrationKubernetesAutoscaleHeadroomArgsDict',
    'ElastigroupIntegrationKubernetesAutoscaleLabelArgs',
    'ElastigroupIntegrationKubernetesAutoscaleLabelArgsDict',
    'ElastigroupIntegrationMesosphereArgs',
    'ElastigroupIntegrationMesosphereArgsDict',
    'ElastigroupIntegrationNomadArgs',
    'ElastigroupIntegrationNomadArgsDict',
    'ElastigroupIntegrationNomadAutoscaleConstraintArgs',
    'ElastigroupIntegrationNomadAutoscaleConstraintArgsDict',
    'ElastigroupIntegrationNomadAutoscaleDownArgs',
    'ElastigroupIntegrationNomadAutoscaleDownArgsDict',
    'ElastigroupIntegrationNomadAutoscaleHeadroomArgs',
    'ElastigroupIntegrationNomadAutoscaleHeadroomArgsDict',
    'ElastigroupIntegrationRancherArgs',
    'ElastigroupIntegrationRancherArgsDict',
    'ElastigroupIntegrationRoute53Args',
    'ElastigroupIntegrationRoute53ArgsDict',
    'ElastigroupIntegrationRoute53DomainArgs',
    'ElastigroupIntegrationRoute53DomainArgsDict',
    'ElastigroupIntegrationRoute53DomainRecordSetArgs',
    'ElastigroupIntegrationRoute53DomainRecordSetArgsDict',
    'ElastigroupItfArgs',
    'ElastigroupItfArgsDict',
    'ElastigroupItfDefaultStaticTargetGroupArgs',
    'ElastigroupItfDefaultStaticTargetGroupArgsDict',
    'ElastigroupItfLoadBalancerArgs',
    'ElastigroupItfLoadBalancerArgsDict',
    'ElastigroupItfLoadBalancerListenerRuleArgs',
    'ElastigroupItfLoadBalancerListenerRuleArgsDict',
    'ElastigroupItfLoadBalancerListenerRuleStaticTargetGroupArgs',
    'ElastigroupItfLoadBalancerListenerRuleStaticTargetGroupArgsDict',
    'ElastigroupItfTargetGroupConfigArgs',
    'ElastigroupItfTargetGroupConfigArgsDict',
    'ElastigroupItfTargetGroupConfigMatcherArgs',
    'ElastigroupItfTargetGroupConfigMatcherArgsDict',
    'ElastigroupItfTargetGroupConfigTagArgs',
    'ElastigroupItfTargetGroupConfigTagArgsDict',
    'ElastigroupLoggingArgs',
    'ElastigroupLoggingArgsDict',
    'ElastigroupLoggingExportArgs',
    'ElastigroupLoggingExportArgsDict',
    'ElastigroupLoggingExportS3Args',
    'ElastigroupLoggingExportS3ArgsDict',
    'ElastigroupMetadataOptionsArgs',
    'ElastigroupMetadataOptionsArgsDict',
    'ElastigroupMultipleMetricsArgs',
    'ElastigroupMultipleMetricsArgsDict',
    'ElastigroupMultipleMetricsExpressionArgs',
    'ElastigroupMultipleMetricsExpressionArgsDict',
    'ElastigroupMultipleMetricsMetricArgs',
    'ElastigroupMultipleMetricsMetricArgsDict',
    'ElastigroupMultipleMetricsMetricDimensionArgs',
    'ElastigroupMultipleMetricsMetricDimensionArgsDict',
    'ElastigroupNetworkInterfaceArgs',
    'ElastigroupNetworkInterfaceArgsDict',
    'ElastigroupResourceRequirementArgs',
    'ElastigroupResourceRequirementArgsDict',
    'ElastigroupResourceTagSpecificationArgs',
    'ElastigroupResourceTagSpecificationArgsDict',
    'ElastigroupRevertToSpotArgs',
    'ElastigroupRevertToSpotArgsDict',
    'ElastigroupScalingDownPolicyArgs',
    'ElastigroupScalingDownPolicyArgsDict',
    'ElastigroupScalingDownPolicyDimensionArgs',
    'ElastigroupScalingDownPolicyDimensionArgsDict',
    'ElastigroupScalingDownPolicyStepAdjustmentArgs',
    'ElastigroupScalingDownPolicyStepAdjustmentArgsDict',
    'ElastigroupScalingDownPolicyStepAdjustmentActionArgs',
    'ElastigroupScalingDownPolicyStepAdjustmentActionArgsDict',
    'ElastigroupScalingStrategyArgs',
    'ElastigroupScalingStrategyArgsDict',
    'ElastigroupScalingTargetPolicyArgs',
    'ElastigroupScalingTargetPolicyArgsDict',
    'ElastigroupScalingTargetPolicyDimensionArgs',
    'ElastigroupScalingTargetPolicyDimensionArgsDict',
    'ElastigroupScalingUpPolicyArgs',
    'ElastigroupScalingUpPolicyArgsDict',
    'ElastigroupScalingUpPolicyDimensionArgs',
    'ElastigroupScalingUpPolicyDimensionArgsDict',
    'ElastigroupScalingUpPolicyStepAdjustmentArgs',
    'ElastigroupScalingUpPolicyStepAdjustmentArgsDict',
    'ElastigroupScalingUpPolicyStepAdjustmentActionArgs',
    'ElastigroupScalingUpPolicyStepAdjustmentActionArgsDict',
    'ElastigroupScheduledTaskArgs',
    'ElastigroupScheduledTaskArgsDict',
    'ElastigroupSignalArgs',
    'ElastigroupSignalArgsDict',
    'ElastigroupStatefulDeallocationArgs',
    'ElastigroupStatefulDeallocationArgsDict',
    'ElastigroupStatefulInstanceActionArgs',
    'ElastigroupStatefulInstanceActionArgsDict',
    'ElastigroupTagArgs',
    'ElastigroupTagArgsDict',
    'ElastigroupUpdatePolicyArgs',
    'ElastigroupUpdatePolicyArgsDict',
    'ElastigroupUpdatePolicyRollConfigArgs',
    'ElastigroupUpdatePolicyRollConfigArgsDict',
    'ElastigroupUpdatePolicyRollConfigStrategyArgs',
    'ElastigroupUpdatePolicyRollConfigStrategyArgsDict',
    'ElastigroupUpdatePolicyRollConfigStrategyOnFailureArgs',
    'ElastigroupUpdatePolicyRollConfigStrategyOnFailureArgsDict',
    'ManagedInstanceBlockDeviceMappingArgs',
    'ManagedInstanceBlockDeviceMappingArgsDict',
    'ManagedInstanceBlockDeviceMappingEbsArgs',
    'ManagedInstanceBlockDeviceMappingEbsArgsDict',
    'ManagedInstanceDeleteArgs',
    'ManagedInstanceDeleteArgsDict',
    'ManagedInstanceIntegrationRoute53Args',
    'ManagedInstanceIntegrationRoute53ArgsDict',
    'ManagedInstanceIntegrationRoute53DomainArgs',
    'ManagedInstanceIntegrationRoute53DomainArgsDict',
    'ManagedInstanceIntegrationRoute53DomainRecordSetArgs',
    'ManagedInstanceIntegrationRoute53DomainRecordSetArgsDict',
    'ManagedInstanceLoadBalancerArgs',
    'ManagedInstanceLoadBalancerArgsDict',
    'ManagedInstanceManagedInstanceActionArgs',
    'ManagedInstanceManagedInstanceActionArgsDict',
    'ManagedInstanceMetadataOptionsArgs',
    'ManagedInstanceMetadataOptionsArgsDict',
    'ManagedInstanceNetworkInterfaceArgs',
    'ManagedInstanceNetworkInterfaceArgsDict',
    'ManagedInstanceResourceTagSpecificationArgs',
    'ManagedInstanceResourceTagSpecificationArgsDict',
    'ManagedInstanceRevertToSpotArgs',
    'ManagedInstanceRevertToSpotArgsDict',
    'ManagedInstanceScheduledTaskArgs',
    'ManagedInstanceScheduledTaskArgsDict',
    'ManagedInstanceTagArgs',
    'ManagedInstanceTagArgsDict',
    'MrScalarApplicationArgs',
    'MrScalarApplicationArgsDict',
    'MrScalarBootstrapActionsFileArgs',
    'MrScalarBootstrapActionsFileArgsDict',
    'MrScalarConfigurationsFileArgs',
    'MrScalarConfigurationsFileArgsDict',
    'MrScalarCoreEbsBlockDeviceArgs',
    'MrScalarCoreEbsBlockDeviceArgsDict',
    'MrScalarCoreScalingDownPolicyArgs',
    'MrScalarCoreScalingDownPolicyArgsDict',
    'MrScalarCoreScalingUpPolicyArgs',
    'MrScalarCoreScalingUpPolicyArgsDict',
    'MrScalarInstanceWeightArgs',
    'MrScalarInstanceWeightArgsDict',
    'MrScalarMasterEbsBlockDeviceArgs',
    'MrScalarMasterEbsBlockDeviceArgsDict',
    'MrScalarProvisioningTimeoutArgs',
    'MrScalarProvisioningTimeoutArgsDict',
    'MrScalarScheduledTaskArgs',
    'MrScalarScheduledTaskArgsDict',
    'MrScalarStepsFileArgs',
    'MrScalarStepsFileArgsDict',
    'MrScalarTagArgs',
    'MrScalarTagArgsDict',
    'MrScalarTaskEbsBlockDeviceArgs',
    'MrScalarTaskEbsBlockDeviceArgsDict',
    'MrScalarTaskScalingDownPolicyArgs',
    'MrScalarTaskScalingDownPolicyArgsDict',
    'MrScalarTaskScalingUpPolicyArgs',
    'MrScalarTaskScalingUpPolicyArgsDict',
    'MrScalarTerminationPolicyArgs',
    'MrScalarTerminationPolicyArgsDict',
    'MrScalarTerminationPolicyStatementArgs',
    'MrScalarTerminationPolicyStatementArgsDict',
    'OceanAttachLoadBalancerArgs',
    'OceanAttachLoadBalancerArgsDict',
    'OceanAutoscalerArgs',
    'OceanAutoscalerArgsDict',
    'OceanAutoscalerAutoscaleDownArgs',
    'OceanAutoscalerAutoscaleDownArgsDict',
    'OceanAutoscalerAutoscaleHeadroomArgs',
    'OceanAutoscalerAutoscaleHeadroomArgsDict',
    'OceanAutoscalerResourceLimitsArgs',
    'OceanAutoscalerResourceLimitsArgsDict',
    'OceanBlockDeviceMappingArgs',
    'OceanBlockDeviceMappingArgsDict',
    'OceanBlockDeviceMappingEbsArgs',
    'OceanBlockDeviceMappingEbsArgsDict',
    'OceanBlockDeviceMappingEbsDynamicIopsArgs',
    'OceanBlockDeviceMappingEbsDynamicIopsArgsDict',
    'OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs',
    'OceanBlockDeviceMappingEbsDynamicVolumeSizeArgsDict',
    'OceanClusterOrientationArgs',
    'OceanClusterOrientationArgsDict',
    'OceanDetachLoadBalancerArgs',
    'OceanDetachLoadBalancerArgsDict',
    'OceanFiltersArgs',
    'OceanFiltersArgsDict',
    'OceanInstanceMetadataOptionsArgs',
    'OceanInstanceMetadataOptionsArgsDict',
    'OceanLaunchSpecAutoscaleDownArgs',
    'OceanLaunchSpecAutoscaleDownArgsDict',
    'OceanLaunchSpecAutoscaleHeadroomArgs',
    'OceanLaunchSpecAutoscaleHeadroomArgsDict',
    'OceanLaunchSpecAutoscaleHeadroomsAutomaticArgs',
    'OceanLaunchSpecAutoscaleHeadroomsAutomaticArgsDict',
    'OceanLaunchSpecBlockDeviceMappingArgs',
    'OceanLaunchSpecBlockDeviceMappingArgsDict',
    'OceanLaunchSpecBlockDeviceMappingEbsArgs',
    'OceanLaunchSpecBlockDeviceMappingEbsArgsDict',
    'OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs',
    'OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgsDict',
    'OceanLaunchSpecCreateOptionsArgs',
    'OceanLaunchSpecCreateOptionsArgsDict',
    'OceanLaunchSpecDeleteOptionsArgs',
    'OceanLaunchSpecDeleteOptionsArgsDict',
    'OceanLaunchSpecElasticIpPoolArgs',
    'OceanLaunchSpecElasticIpPoolArgsDict',
    'OceanLaunchSpecElasticIpPoolTagSelectorArgs',
    'OceanLaunchSpecElasticIpPoolTagSelectorArgsDict',
    'OceanLaunchSpecEphemeralStorageArgs',
    'OceanLaunchSpecEphemeralStorageArgsDict',
    'OceanLaunchSpecImageArgs',
    'OceanLaunchSpecImageArgsDict',
    'OceanLaunchSpecInstanceMetadataOptionsArgs',
    'OceanLaunchSpecInstanceMetadataOptionsArgsDict',
    'OceanLaunchSpecInstanceTypesFiltersArgs',
    'OceanLaunchSpecInstanceTypesFiltersArgsDict',
    'OceanLaunchSpecLabelArgs',
    'OceanLaunchSpecLabelArgsDict',
    'OceanLaunchSpecResourceLimitArgs',
    'OceanLaunchSpecResourceLimitArgsDict',
    'OceanLaunchSpecSchedulingShutdownHoursArgs',
    'OceanLaunchSpecSchedulingShutdownHoursArgsDict',
    'OceanLaunchSpecSchedulingTaskArgs',
    'OceanLaunchSpecSchedulingTaskArgsDict',
    'OceanLaunchSpecSchedulingTaskTaskHeadroomArgs',
    'OceanLaunchSpecSchedulingTaskTaskHeadroomArgsDict',
    'OceanLaunchSpecStrategyArgs',
    'OceanLaunchSpecStrategyArgsDict',
    'OceanLaunchSpecTagArgs',
    'OceanLaunchSpecTagArgsDict',
    'OceanLaunchSpecTaintArgs',
    'OceanLaunchSpecTaintArgsDict',
    'OceanLaunchSpecUpdatePolicyArgs',
    'OceanLaunchSpecUpdatePolicyArgsDict',
    'OceanLaunchSpecUpdatePolicyRollConfigArgs',
    'OceanLaunchSpecUpdatePolicyRollConfigArgsDict',
    'OceanLoadBalancerArgs',
    'OceanLoadBalancerArgsDict',
    'OceanLoggingArgs',
    'OceanLoggingArgsDict',
    'OceanLoggingExportArgs',
    'OceanLoggingExportArgsDict',
    'OceanLoggingExportS3Args',
    'OceanLoggingExportS3ArgsDict',
    'OceanResourceTagSpecificationArgs',
    'OceanResourceTagSpecificationArgsDict',
    'OceanScheduledTaskArgs',
    'OceanScheduledTaskArgsDict',
    'OceanScheduledTaskShutdownHoursArgs',
    'OceanScheduledTaskShutdownHoursArgsDict',
    'OceanScheduledTaskTaskArgs',
    'OceanScheduledTaskTaskArgsDict',
    'OceanScheduledTaskTaskParametersArgs',
    'OceanScheduledTaskTaskParametersArgsDict',
    'OceanScheduledTaskTaskParametersAmiAutoUpdateArgs',
    'OceanScheduledTaskTaskParametersAmiAutoUpdateArgsDict',
    'OceanScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRollArgs',
    'OceanScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRollArgsDict',
    'OceanScheduledTaskTaskParametersParametersClusterRollArgs',
    'OceanScheduledTaskTaskParametersParametersClusterRollArgsDict',
    'OceanTagArgs',
    'OceanTagArgsDict',
    'OceanUpdatePolicyArgs',
    'OceanUpdatePolicyArgsDict',
    'OceanUpdatePolicyRollConfigArgs',
    'OceanUpdatePolicyRollConfigArgsDict',
    'SuspensionSuspensionArgs',
    'SuspensionSuspensionArgsDict',
]

MYPY = False

if not MYPY:
    class BeanstalkDeploymentPreferencesArgsDict(TypedDict):
        automatic_roll: NotRequired[pulumi.Input[bool]]
        """
        Should roll perform automatically
        """
        batch_size_percentage: NotRequired[pulumi.Input[int]]
        """
        Percent size of each batch
        """
        grace_period: NotRequired[pulumi.Input[int]]
        """
        Amount of time to wait between batches
        """
        strategies: NotRequired[pulumi.Input[Sequence[pulumi.Input['BeanstalkDeploymentPreferencesStrategyArgsDict']]]]
        """
        Strategy parameters
        """
elif False:
    BeanstalkDeploymentPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BeanstalkDeploymentPreferencesArgs:
    def __init__(__self__, *,
                 automatic_roll: Optional[pulumi.Input[bool]] = None,
                 batch_size_percentage: Optional[pulumi.Input[int]] = None,
                 grace_period: Optional[pulumi.Input[int]] = None,
                 strategies: Optional[pulumi.Input[Sequence[pulumi.Input['BeanstalkDeploymentPreferencesStrategyArgs']]]] = None):
        """
        :param pulumi.Input[bool] automatic_roll: Should roll perform automatically
        :param pulumi.Input[int] batch_size_percentage: Percent size of each batch
        :param pulumi.Input[int] grace_period: Amount of time to wait between batches
        :param pulumi.Input[Sequence[pulumi.Input['BeanstalkDeploymentPreferencesStrategyArgs']]] strategies: Strategy parameters
        """
        if automatic_roll is not None:
            pulumi.set(__self__, "automatic_roll", automatic_roll)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if strategies is not None:
            pulumi.set(__self__, "strategies", strategies)

    @property
    @pulumi.getter(name="automaticRoll")
    def automatic_roll(self) -> Optional[pulumi.Input[bool]]:
        """
        Should roll perform automatically
        """
        return pulumi.get(self, "automatic_roll")

    @automatic_roll.setter
    def automatic_roll(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automatic_roll", value)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Percent size of each batch
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[int]]:
        """
        Amount of time to wait between batches
        """
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "grace_period", value)

    @property
    @pulumi.getter
    def strategies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BeanstalkDeploymentPreferencesStrategyArgs']]]]:
        """
        Strategy parameters
        """
        return pulumi.get(self, "strategies")

    @strategies.setter
    def strategies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BeanstalkDeploymentPreferencesStrategyArgs']]]]):
        pulumi.set(self, "strategies", value)


if not MYPY:
    class BeanstalkDeploymentPreferencesStrategyArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        """
        Action to take
        """
        should_drain_instances: NotRequired[pulumi.Input[bool]]
        """
        Bool value if to wait to drain instance
        """
elif False:
    BeanstalkDeploymentPreferencesStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BeanstalkDeploymentPreferencesStrategyArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 should_drain_instances: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] action: Action to take
        :param pulumi.Input[bool] should_drain_instances: Bool value if to wait to drain instance
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if should_drain_instances is not None:
            pulumi.set(__self__, "should_drain_instances", should_drain_instances)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to take
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="shouldDrainInstances")
    def should_drain_instances(self) -> Optional[pulumi.Input[bool]]:
        """
        Bool value if to wait to drain instance
        """
        return pulumi.get(self, "should_drain_instances")

    @should_drain_instances.setter
    def should_drain_instances(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_drain_instances", value)


if not MYPY:
    class BeanstalkManagedActionsArgsDict(TypedDict):
        platform_update: NotRequired[pulumi.Input['BeanstalkManagedActionsPlatformUpdateArgsDict']]
        """
        Platform Update parameters
        """
elif False:
    BeanstalkManagedActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BeanstalkManagedActionsArgs:
    def __init__(__self__, *,
                 platform_update: Optional[pulumi.Input['BeanstalkManagedActionsPlatformUpdateArgs']] = None):
        """
        :param pulumi.Input['BeanstalkManagedActionsPlatformUpdateArgs'] platform_update: Platform Update parameters
        """
        if platform_update is not None:
            pulumi.set(__self__, "platform_update", platform_update)

    @property
    @pulumi.getter(name="platformUpdate")
    def platform_update(self) -> Optional[pulumi.Input['BeanstalkManagedActionsPlatformUpdateArgs']]:
        """
        Platform Update parameters
        """
        return pulumi.get(self, "platform_update")

    @platform_update.setter
    def platform_update(self, value: Optional[pulumi.Input['BeanstalkManagedActionsPlatformUpdateArgs']]):
        pulumi.set(self, "platform_update", value)


if not MYPY:
    class BeanstalkManagedActionsPlatformUpdateArgsDict(TypedDict):
        perform_at: NotRequired[pulumi.Input[str]]
        """
        Actions to perform (options: timeWindow, never)
        """
        time_window: NotRequired[pulumi.Input[str]]
        """
        Time Window for when action occurs ex. Mon:23:50-Tue:00:20
        """
        update_level: NotRequired[pulumi.Input[str]]
        """
        Level to update
        """
elif False:
    BeanstalkManagedActionsPlatformUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BeanstalkManagedActionsPlatformUpdateArgs:
    def __init__(__self__, *,
                 perform_at: Optional[pulumi.Input[str]] = None,
                 time_window: Optional[pulumi.Input[str]] = None,
                 update_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] perform_at: Actions to perform (options: timeWindow, never)
        :param pulumi.Input[str] time_window: Time Window for when action occurs ex. Mon:23:50-Tue:00:20
        :param pulumi.Input[str] update_level: Level to update
        """
        if perform_at is not None:
            pulumi.set(__self__, "perform_at", perform_at)
        if time_window is not None:
            pulumi.set(__self__, "time_window", time_window)
        if update_level is not None:
            pulumi.set(__self__, "update_level", update_level)

    @property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> Optional[pulumi.Input[str]]:
        """
        Actions to perform (options: timeWindow, never)
        """
        return pulumi.get(self, "perform_at")

    @perform_at.setter
    def perform_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "perform_at", value)

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> Optional[pulumi.Input[str]]:
        """
        Time Window for when action occurs ex. Mon:23:50-Tue:00:20
        """
        return pulumi.get(self, "time_window")

    @time_window.setter
    def time_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_window", value)

    @property
    @pulumi.getter(name="updateLevel")
    def update_level(self) -> Optional[pulumi.Input[str]]:
        """
        Level to update
        """
        return pulumi.get(self, "update_level")

    @update_level.setter
    def update_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_level", value)


if not MYPY:
    class BeanstalkScheduledTaskArgsDict(TypedDict):
        task_type: pulumi.Input[str]
        """
        The task type to run. Supported task types are: `"scale"`, `"backup_ami"`, `"roll"`, `"scaleUp"`, `"percentageScaleUp"`, `"scaleDown"`, `"percentageScaleDown"`, `"statefulUpdateCapacity"`.
        """
        adjustment: NotRequired[pulumi.Input[str]]
        """
        The number of instances to add or remove.
        """
        adjustment_percentage: NotRequired[pulumi.Input[str]]
        """
        The percentage of instances to add or remove.

        Usage:
        """
        batch_size_percentage: NotRequired[pulumi.Input[str]]
        """
        The percentage size of each batch in the scheduled deployment roll.
        """
        cron_expression: NotRequired[pulumi.Input[str]]
        """
        A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
        """
        frequency: NotRequired[pulumi.Input[str]]
        """
        The recurrence frequency to run this task. Supported values are `"hourly"`, `"daily"`, `"weekly"` and `"continuous"`.
        """
        grace_period: NotRequired[pulumi.Input[str]]
        """
        The period of time (seconds) to wait before checking a batch's health after it's deployment.
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Setting the task to being enabled or disabled.
        """
        max_capacity: NotRequired[pulumi.Input[str]]
        """
        The maximum number of instances the group should have.
        """
        min_capacity: NotRequired[pulumi.Input[str]]
        """
        The minimum number of instances the group should have.
        """
        scale_max_capacity: NotRequired[pulumi.Input[str]]
        """
        The maximum number of instances the group should have.
        """
        scale_min_capacity: NotRequired[pulumi.Input[str]]
        """
        The minimum number of instances the group should have.
        """
        scale_target_capacity: NotRequired[pulumi.Input[str]]
        """
        The desired number of instances the group should have.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        Set a start time for one time tasks.
        """
        target_capacity: NotRequired[pulumi.Input[str]]
        """
        The desired number of instances the group should have.
        """
elif False:
    BeanstalkScheduledTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BeanstalkScheduledTaskArgs:
    def __init__(__self__, *,
                 task_type: pulumi.Input[str],
                 adjustment: Optional[pulumi.Input[str]] = None,
                 adjustment_percentage: Optional[pulumi.Input[str]] = None,
                 batch_size_percentage: Optional[pulumi.Input[str]] = None,
                 cron_expression: Optional[pulumi.Input[str]] = None,
                 frequency: Optional[pulumi.Input[str]] = None,
                 grace_period: Optional[pulumi.Input[str]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 max_capacity: Optional[pulumi.Input[str]] = None,
                 min_capacity: Optional[pulumi.Input[str]] = None,
                 scale_max_capacity: Optional[pulumi.Input[str]] = None,
                 scale_min_capacity: Optional[pulumi.Input[str]] = None,
                 scale_target_capacity: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 target_capacity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] task_type: The task type to run. Supported task types are: `"scale"`, `"backup_ami"`, `"roll"`, `"scaleUp"`, `"percentageScaleUp"`, `"scaleDown"`, `"percentageScaleDown"`, `"statefulUpdateCapacity"`.
        :param pulumi.Input[str] adjustment: The number of instances to add or remove.
        :param pulumi.Input[str] adjustment_percentage: The percentage of instances to add or remove.
               
               Usage:
        :param pulumi.Input[str] batch_size_percentage: The percentage size of each batch in the scheduled deployment roll.
        :param pulumi.Input[str] cron_expression: A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
        :param pulumi.Input[str] frequency: The recurrence frequency to run this task. Supported values are `"hourly"`, `"daily"`, `"weekly"` and `"continuous"`.
        :param pulumi.Input[str] grace_period: The period of time (seconds) to wait before checking a batch's health after it's deployment.
        :param pulumi.Input[bool] is_enabled: Setting the task to being enabled or disabled.
        :param pulumi.Input[str] max_capacity: The maximum number of instances the group should have.
        :param pulumi.Input[str] min_capacity: The minimum number of instances the group should have.
        :param pulumi.Input[str] scale_max_capacity: The maximum number of instances the group should have.
        :param pulumi.Input[str] scale_min_capacity: The minimum number of instances the group should have.
        :param pulumi.Input[str] scale_target_capacity: The desired number of instances the group should have.
        :param pulumi.Input[str] start_time: Set a start time for one time tasks.
        :param pulumi.Input[str] target_capacity: The desired number of instances the group should have.
        """
        pulumi.set(__self__, "task_type", task_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if adjustment_percentage is not None:
            pulumi.set(__self__, "adjustment_percentage", adjustment_percentage)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if min_capacity is not None:
            pulumi.set(__self__, "min_capacity", min_capacity)
        if scale_max_capacity is not None:
            pulumi.set(__self__, "scale_max_capacity", scale_max_capacity)
        if scale_min_capacity is not None:
            pulumi.set(__self__, "scale_min_capacity", scale_min_capacity)
        if scale_target_capacity is not None:
            pulumi.set(__self__, "scale_target_capacity", scale_target_capacity)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if target_capacity is not None:
            pulumi.set(__self__, "target_capacity", target_capacity)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input[str]:
        """
        The task type to run. Supported task types are: `"scale"`, `"backup_ami"`, `"roll"`, `"scaleUp"`, `"percentageScaleUp"`, `"scaleDown"`, `"percentageScaleDown"`, `"statefulUpdateCapacity"`.
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_type", value)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[str]]:
        """
        The number of instances to add or remove.
        """
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter(name="adjustmentPercentage")
    def adjustment_percentage(self) -> Optional[pulumi.Input[str]]:
        """
        The percentage of instances to add or remove.

        Usage:
        """
        return pulumi.get(self, "adjustment_percentage")

    @adjustment_percentage.setter
    def adjustment_percentage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adjustment_percentage", value)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[pulumi.Input[str]]:
        """
        The percentage size of each batch in the scheduled deployment roll.
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[str]]:
        """
        A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[str]]:
        """
        The recurrence frequency to run this task. Supported values are `"hourly"`, `"daily"`, `"weekly"` and `"continuous"`.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[str]]:
        """
        The period of time (seconds) to wait before checking a batch's health after it's deployment.
        """
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "grace_period", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting the task to being enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum number of instances the group should have.
        """
        return pulumi.get(self, "max_capacity")

    @max_capacity.setter
    def max_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_capacity", value)

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum number of instances the group should have.
        """
        return pulumi.get(self, "min_capacity")

    @min_capacity.setter
    def min_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_capacity", value)

    @property
    @pulumi.getter(name="scaleMaxCapacity")
    def scale_max_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum number of instances the group should have.
        """
        return pulumi.get(self, "scale_max_capacity")

    @scale_max_capacity.setter
    def scale_max_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale_max_capacity", value)

    @property
    @pulumi.getter(name="scaleMinCapacity")
    def scale_min_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum number of instances the group should have.
        """
        return pulumi.get(self, "scale_min_capacity")

    @scale_min_capacity.setter
    def scale_min_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale_min_capacity", value)

    @property
    @pulumi.getter(name="scaleTargetCapacity")
    def scale_target_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The desired number of instances the group should have.
        """
        return pulumi.get(self, "scale_target_capacity")

    @scale_target_capacity.setter
    def scale_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale_target_capacity", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Set a start time for one time tasks.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="targetCapacity")
    def target_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The desired number of instances the group should have.
        """
        return pulumi.get(self, "target_capacity")

    @target_capacity.setter
    def target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_capacity", value)


if not MYPY:
    class ElastigroupCpuOptionsArgsDict(TypedDict):
        threads_per_core: pulumi.Input[int]
        """
        The ability to define the number of threads per core in instances that allow this.
        """
elif False:
    ElastigroupCpuOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupCpuOptionsArgs:
    def __init__(__self__, *,
                 threads_per_core: pulumi.Input[int]):
        """
        :param pulumi.Input[int] threads_per_core: The ability to define the number of threads per core in instances that allow this.
        """
        pulumi.set(__self__, "threads_per_core", threads_per_core)

    @property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> pulumi.Input[int]:
        """
        The ability to define the number of threads per core in instances that allow this.
        """
        return pulumi.get(self, "threads_per_core")

    @threads_per_core.setter
    def threads_per_core(self, value: pulumi.Input[int]):
        pulumi.set(self, "threads_per_core", value)


if not MYPY:
    class ElastigroupEbsBlockDeviceArgsDict(TypedDict):
        device_name: pulumi.Input[str]
        """
        The name of the device to mount.
        """
        delete_on_termination: NotRequired[pulumi.Input[bool]]
        """
        Whether the volume should be destroyed on instance termination.
        """
        dynamic_iops: NotRequired[pulumi.Input['ElastigroupEbsBlockDeviceDynamicIopsArgsDict']]
        """
        Set dynamic IOPS properties. When using this object, you cannot use the `iops` object. You must use one or the other.
        """
        dynamic_volume_size: NotRequired[pulumi.Input['ElastigroupEbsBlockDeviceDynamicVolumeSizeArgsDict']]
        """
        Set dynamic volume size properties. When using this object, you cannot use `volume_size`. You must use one or the other.
        """
        encrypted: NotRequired[pulumi.Input[bool]]
        """
        Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        """
        iops: NotRequired[pulumi.Input[int]]
        """
        The amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). This must be set with a `volume_type` of `"io1"`.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        ID for a user managed CMK under which the EBS Volume is encrypted
        """
        snapshot_id: NotRequired[pulumi.Input[str]]
        """
        The Snapshot ID to mount.
        """
        throughput: NotRequired[pulumi.Input[int]]
        """
        The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volume_type` = gp3.
        """
        volume_size: NotRequired[pulumi.Input[int]]
        """
        The size of the volume in gigabytes.
        """
        volume_type: NotRequired[pulumi.Input[str]]
        """
        The type of volume. Can be `"standard"`, `"gp2"`, `"gp3"`, `"io1"`, `"st1"` or `"sc1"`.
        """
elif False:
    ElastigroupEbsBlockDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 dynamic_iops: Optional[pulumi.Input['ElastigroupEbsBlockDeviceDynamicIopsArgs']] = None,
                 dynamic_volume_size: Optional[pulumi.Input['ElastigroupEbsBlockDeviceDynamicVolumeSizeArgs']] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: The name of the device to mount.
        :param pulumi.Input[bool] delete_on_termination: Whether the volume should be destroyed on instance termination.
        :param pulumi.Input['ElastigroupEbsBlockDeviceDynamicIopsArgs'] dynamic_iops: Set dynamic IOPS properties. When using this object, you cannot use the `iops` object. You must use one or the other.
        :param pulumi.Input['ElastigroupEbsBlockDeviceDynamicVolumeSizeArgs'] dynamic_volume_size: Set dynamic volume size properties. When using this object, you cannot use `volume_size`. You must use one or the other.
        :param pulumi.Input[bool] encrypted: Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        :param pulumi.Input[int] iops: The amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). This must be set with a `volume_type` of `"io1"`.
        :param pulumi.Input[str] kms_key_id: ID for a user managed CMK under which the EBS Volume is encrypted
        :param pulumi.Input[str] snapshot_id: The Snapshot ID to mount.
        :param pulumi.Input[int] throughput: The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volume_type` = gp3.
        :param pulumi.Input[int] volume_size: The size of the volume in gigabytes.
        :param pulumi.Input[str] volume_type: The type of volume. Can be `"standard"`, `"gp2"`, `"gp3"`, `"io1"`, `"st1"` or `"sc1"`.
        """
        pulumi.set(__self__, "device_name", device_name)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if dynamic_iops is not None:
            pulumi.set(__self__, "dynamic_iops", dynamic_iops)
        if dynamic_volume_size is not None:
            pulumi.set(__self__, "dynamic_volume_size", dynamic_volume_size)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        The name of the device to mount.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the volume should be destroyed on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter(name="dynamicIops")
    def dynamic_iops(self) -> Optional[pulumi.Input['ElastigroupEbsBlockDeviceDynamicIopsArgs']]:
        """
        Set dynamic IOPS properties. When using this object, you cannot use the `iops` object. You must use one or the other.
        """
        return pulumi.get(self, "dynamic_iops")

    @dynamic_iops.setter
    def dynamic_iops(self, value: Optional[pulumi.Input['ElastigroupEbsBlockDeviceDynamicIopsArgs']]):
        pulumi.set(self, "dynamic_iops", value)

    @property
    @pulumi.getter(name="dynamicVolumeSize")
    def dynamic_volume_size(self) -> Optional[pulumi.Input['ElastigroupEbsBlockDeviceDynamicVolumeSizeArgs']]:
        """
        Set dynamic volume size properties. When using this object, you cannot use `volume_size`. You must use one or the other.
        """
        return pulumi.get(self, "dynamic_volume_size")

    @dynamic_volume_size.setter
    def dynamic_volume_size(self, value: Optional[pulumi.Input['ElastigroupEbsBlockDeviceDynamicVolumeSizeArgs']]):
        pulumi.set(self, "dynamic_volume_size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of provisioned [IOPS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-io-characteristics.html). This must be set with a `volume_type` of `"io1"`.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID for a user managed CMK under which the EBS Volume is encrypted
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Snapshot ID to mount.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volume_type` = gp3.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the volume in gigabytes.
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume. Can be `"standard"`, `"gp2"`, `"gp3"`, `"io1"`, `"st1"` or `"sc1"`.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class ElastigroupEbsBlockDeviceDynamicIopsArgsDict(TypedDict):
        base_size: NotRequired[pulumi.Input[int]]
        """
        Initial size for IOPS.
        """
        resource: NotRequired[pulumi.Input[str]]
        """
        Type of resource, valid values: `"CPU", "MEMORY"`.
        """
        size_per_resource_unit: NotRequired[pulumi.Input[int]]
        """
        Additional size per resource unit (in IOPS).

        Modifying any `ebs_block_device` currently requires resource replacement.

        Usage:
        """
elif False:
    ElastigroupEbsBlockDeviceDynamicIopsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupEbsBlockDeviceDynamicIopsArgs:
    def __init__(__self__, *,
                 base_size: Optional[pulumi.Input[int]] = None,
                 resource: Optional[pulumi.Input[str]] = None,
                 size_per_resource_unit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] base_size: Initial size for IOPS.
        :param pulumi.Input[str] resource: Type of resource, valid values: `"CPU", "MEMORY"`.
        :param pulumi.Input[int] size_per_resource_unit: Additional size per resource unit (in IOPS).
               
               Modifying any `ebs_block_device` currently requires resource replacement.
               
               Usage:
        """
        if base_size is not None:
            pulumi.set(__self__, "base_size", base_size)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if size_per_resource_unit is not None:
            pulumi.set(__self__, "size_per_resource_unit", size_per_resource_unit)

    @property
    @pulumi.getter(name="baseSize")
    def base_size(self) -> Optional[pulumi.Input[int]]:
        """
        Initial size for IOPS.
        """
        return pulumi.get(self, "base_size")

    @base_size.setter
    def base_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "base_size", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[str]]:
        """
        Type of resource, valid values: `"CPU", "MEMORY"`.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter(name="sizePerResourceUnit")
    def size_per_resource_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Additional size per resource unit (in IOPS).

        Modifying any `ebs_block_device` currently requires resource replacement.

        Usage:
        """
        return pulumi.get(self, "size_per_resource_unit")

    @size_per_resource_unit.setter
    def size_per_resource_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_per_resource_unit", value)


if not MYPY:
    class ElastigroupEbsBlockDeviceDynamicVolumeSizeArgsDict(TypedDict):
        base_size: NotRequired[pulumi.Input[int]]
        """
        Initial size for volume.
        """
        resource: NotRequired[pulumi.Input[str]]
        """
        Type of resource, valid values: `"CPU", "MEMORY"`.
        """
        size_per_resource_unit: NotRequired[pulumi.Input[int]]
        """
        Additional size per resource unit (in GB).
        """
elif False:
    ElastigroupEbsBlockDeviceDynamicVolumeSizeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupEbsBlockDeviceDynamicVolumeSizeArgs:
    def __init__(__self__, *,
                 base_size: Optional[pulumi.Input[int]] = None,
                 resource: Optional[pulumi.Input[str]] = None,
                 size_per_resource_unit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] base_size: Initial size for volume.
        :param pulumi.Input[str] resource: Type of resource, valid values: `"CPU", "MEMORY"`.
        :param pulumi.Input[int] size_per_resource_unit: Additional size per resource unit (in GB).
        """
        if base_size is not None:
            pulumi.set(__self__, "base_size", base_size)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if size_per_resource_unit is not None:
            pulumi.set(__self__, "size_per_resource_unit", size_per_resource_unit)

    @property
    @pulumi.getter(name="baseSize")
    def base_size(self) -> Optional[pulumi.Input[int]]:
        """
        Initial size for volume.
        """
        return pulumi.get(self, "base_size")

    @base_size.setter
    def base_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "base_size", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[str]]:
        """
        Type of resource, valid values: `"CPU", "MEMORY"`.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter(name="sizePerResourceUnit")
    def size_per_resource_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Additional size per resource unit (in GB).
        """
        return pulumi.get(self, "size_per_resource_unit")

    @size_per_resource_unit.setter
    def size_per_resource_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_per_resource_unit", value)


if not MYPY:
    class ElastigroupEphemeralBlockDeviceArgsDict(TypedDict):
        device_name: pulumi.Input[str]
        """
        The name of the block device to mount on the instance.
        """
        virtual_name: pulumi.Input[str]
        """
        The [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
        (e.g. `"ephemeral0"`).

        Usage:
        """
elif False:
    ElastigroupEphemeralBlockDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupEphemeralBlockDeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 virtual_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] device_name: The name of the block device to mount on the instance.
        :param pulumi.Input[str] virtual_name: The [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
               (e.g. `"ephemeral0"`).
               
               Usage:
        """
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        The name of the block device to mount on the instance.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> pulumi.Input[str]:
        """
        The [Instance Store Device Name](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html#InstanceStoreDeviceNames)
        (e.g. `"ephemeral0"`).

        Usage:
        """
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_name", value)


if not MYPY:
    class ElastigroupImageArgsDict(TypedDict):
        images: pulumi.Input[Sequence[pulumi.Input['ElastigroupImageImageArgsDict']]]
elif False:
    ElastigroupImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupImageArgs:
    def __init__(__self__, *,
                 images: pulumi.Input[Sequence[pulumi.Input['ElastigroupImageImageArgs']]]):
        pulumi.set(__self__, "images", images)

    @property
    @pulumi.getter
    def images(self) -> pulumi.Input[Sequence[pulumi.Input['ElastigroupImageImageArgs']]]:
        return pulumi.get(self, "images")

    @images.setter
    def images(self, value: pulumi.Input[Sequence[pulumi.Input['ElastigroupImageImageArgs']]]):
        pulumi.set(self, "images", value)


if not MYPY:
    class ElastigroupImageImageArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The group ID.
        """
elif False:
    ElastigroupImageImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupImageImageArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The group ID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The group ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ElastigroupInstanceTypesWeightArgsDict(TypedDict):
        instance_type: pulumi.Input[str]
        """
        Name of instance type (String).
        """
        weight: pulumi.Input[int]
        """
        Weight per instance type (Integer).
        """
elif False:
    ElastigroupInstanceTypesWeightArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupInstanceTypesWeightArgs:
    def __init__(__self__, *,
                 instance_type: pulumi.Input[str],
                 weight: pulumi.Input[int]):
        """
        :param pulumi.Input[str] instance_type: Name of instance type (String).
        :param pulumi.Input[int] weight: Weight per instance type (Integer).
        """
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        """
        Name of instance type (String).
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        Weight per instance type (Integer).
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ElastigroupIntegrationBeanstalkArgsDict(TypedDict):
        deployment_preferences: NotRequired[pulumi.Input['ElastigroupIntegrationBeanstalkDeploymentPreferencesArgsDict']]
        """
        Preferences when performing a roll
        """
        environment_id: NotRequired[pulumi.Input[str]]
        managed_actions: NotRequired[pulumi.Input['ElastigroupIntegrationBeanstalkManagedActionsArgsDict']]
        """
        Managed Actions parameters
        """
elif False:
    ElastigroupIntegrationBeanstalkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationBeanstalkArgs:
    def __init__(__self__, *,
                 deployment_preferences: Optional[pulumi.Input['ElastigroupIntegrationBeanstalkDeploymentPreferencesArgs']] = None,
                 environment_id: Optional[pulumi.Input[str]] = None,
                 managed_actions: Optional[pulumi.Input['ElastigroupIntegrationBeanstalkManagedActionsArgs']] = None):
        """
        :param pulumi.Input['ElastigroupIntegrationBeanstalkDeploymentPreferencesArgs'] deployment_preferences: Preferences when performing a roll
        :param pulumi.Input['ElastigroupIntegrationBeanstalkManagedActionsArgs'] managed_actions: Managed Actions parameters
        """
        if deployment_preferences is not None:
            pulumi.set(__self__, "deployment_preferences", deployment_preferences)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if managed_actions is not None:
            pulumi.set(__self__, "managed_actions", managed_actions)

    @property
    @pulumi.getter(name="deploymentPreferences")
    def deployment_preferences(self) -> Optional[pulumi.Input['ElastigroupIntegrationBeanstalkDeploymentPreferencesArgs']]:
        """
        Preferences when performing a roll
        """
        return pulumi.get(self, "deployment_preferences")

    @deployment_preferences.setter
    def deployment_preferences(self, value: Optional[pulumi.Input['ElastigroupIntegrationBeanstalkDeploymentPreferencesArgs']]):
        pulumi.set(self, "deployment_preferences", value)

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment_id", value)

    @property
    @pulumi.getter(name="managedActions")
    def managed_actions(self) -> Optional[pulumi.Input['ElastigroupIntegrationBeanstalkManagedActionsArgs']]:
        """
        Managed Actions parameters
        """
        return pulumi.get(self, "managed_actions")

    @managed_actions.setter
    def managed_actions(self, value: Optional[pulumi.Input['ElastigroupIntegrationBeanstalkManagedActionsArgs']]):
        pulumi.set(self, "managed_actions", value)


if not MYPY:
    class ElastigroupIntegrationBeanstalkDeploymentPreferencesArgsDict(TypedDict):
        automatic_roll: NotRequired[pulumi.Input[bool]]
        """
        Should roll perform automatically
        """
        batch_size_percentage: NotRequired[pulumi.Input[int]]
        grace_period: NotRequired[pulumi.Input[int]]
        strategy: NotRequired[pulumi.Input['ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategyArgsDict']]
elif False:
    ElastigroupIntegrationBeanstalkDeploymentPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationBeanstalkDeploymentPreferencesArgs:
    def __init__(__self__, *,
                 automatic_roll: Optional[pulumi.Input[bool]] = None,
                 batch_size_percentage: Optional[pulumi.Input[int]] = None,
                 grace_period: Optional[pulumi.Input[int]] = None,
                 strategy: Optional[pulumi.Input['ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategyArgs']] = None):
        """
        :param pulumi.Input[bool] automatic_roll: Should roll perform automatically
        """
        if automatic_roll is not None:
            pulumi.set(__self__, "automatic_roll", automatic_roll)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="automaticRoll")
    def automatic_roll(self) -> Optional[pulumi.Input[bool]]:
        """
        Should roll perform automatically
        """
        return pulumi.get(self, "automatic_roll")

    @automatic_roll.setter
    def automatic_roll(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automatic_roll", value)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "grace_period", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input['ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategyArgs']]:
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input['ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategyArgs']]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategyArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[str]]
        should_drain_instances: NotRequired[pulumi.Input[bool]]
elif False:
    ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationBeanstalkDeploymentPreferencesStrategyArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 should_drain_instances: Optional[pulumi.Input[bool]] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)
        if should_drain_instances is not None:
            pulumi.set(__self__, "should_drain_instances", should_drain_instances)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="shouldDrainInstances")
    def should_drain_instances(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_drain_instances")

    @should_drain_instances.setter
    def should_drain_instances(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_drain_instances", value)


if not MYPY:
    class ElastigroupIntegrationBeanstalkManagedActionsArgsDict(TypedDict):
        platform_update: NotRequired[pulumi.Input['ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdateArgsDict']]
        """
        Platform Update parameters
        """
elif False:
    ElastigroupIntegrationBeanstalkManagedActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationBeanstalkManagedActionsArgs:
    def __init__(__self__, *,
                 platform_update: Optional[pulumi.Input['ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdateArgs']] = None):
        """
        :param pulumi.Input['ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdateArgs'] platform_update: Platform Update parameters
        """
        if platform_update is not None:
            pulumi.set(__self__, "platform_update", platform_update)

    @property
    @pulumi.getter(name="platformUpdate")
    def platform_update(self) -> Optional[pulumi.Input['ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdateArgs']]:
        """
        Platform Update parameters
        """
        return pulumi.get(self, "platform_update")

    @platform_update.setter
    def platform_update(self, value: Optional[pulumi.Input['ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdateArgs']]):
        pulumi.set(self, "platform_update", value)


if not MYPY:
    class ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdateArgsDict(TypedDict):
        perform_at: NotRequired[pulumi.Input[str]]
        time_window: NotRequired[pulumi.Input[str]]
        """
        Time Window for when action occurs ex. Mon:23:50-Tue:00:20
        """
        update_level: NotRequired[pulumi.Input[str]]
        """
        Level to update

        Usage:
        """
elif False:
    ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationBeanstalkManagedActionsPlatformUpdateArgs:
    def __init__(__self__, *,
                 perform_at: Optional[pulumi.Input[str]] = None,
                 time_window: Optional[pulumi.Input[str]] = None,
                 update_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] time_window: Time Window for when action occurs ex. Mon:23:50-Tue:00:20
        :param pulumi.Input[str] update_level: Level to update
               
               Usage:
        """
        if perform_at is not None:
            pulumi.set(__self__, "perform_at", perform_at)
        if time_window is not None:
            pulumi.set(__self__, "time_window", time_window)
        if update_level is not None:
            pulumi.set(__self__, "update_level", update_level)

    @property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "perform_at")

    @perform_at.setter
    def perform_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "perform_at", value)

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> Optional[pulumi.Input[str]]:
        """
        Time Window for when action occurs ex. Mon:23:50-Tue:00:20
        """
        return pulumi.get(self, "time_window")

    @time_window.setter
    def time_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_window", value)

    @property
    @pulumi.getter(name="updateLevel")
    def update_level(self) -> Optional[pulumi.Input[str]]:
        """
        Level to update

        Usage:
        """
        return pulumi.get(self, "update_level")

    @update_level.setter
    def update_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_level", value)


if not MYPY:
    class ElastigroupIntegrationCodedeployArgsDict(TypedDict):
        cleanup_on_failure: pulumi.Input[bool]
        """
        Cleanup automatically after a failed deploy.
        """
        deployment_groups: pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationCodedeployDeploymentGroupArgsDict']]]
        """
        Specify the deployment groups details.
        """
        terminate_instance_on_failure: pulumi.Input[bool]
        """
        Terminate the instance automatically after a failed deploy.
        """
elif False:
    ElastigroupIntegrationCodedeployArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationCodedeployArgs:
    def __init__(__self__, *,
                 cleanup_on_failure: pulumi.Input[bool],
                 deployment_groups: pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationCodedeployDeploymentGroupArgs']]],
                 terminate_instance_on_failure: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] cleanup_on_failure: Cleanup automatically after a failed deploy.
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationCodedeployDeploymentGroupArgs']]] deployment_groups: Specify the deployment groups details.
        :param pulumi.Input[bool] terminate_instance_on_failure: Terminate the instance automatically after a failed deploy.
        """
        pulumi.set(__self__, "cleanup_on_failure", cleanup_on_failure)
        pulumi.set(__self__, "deployment_groups", deployment_groups)
        pulumi.set(__self__, "terminate_instance_on_failure", terminate_instance_on_failure)

    @property
    @pulumi.getter(name="cleanupOnFailure")
    def cleanup_on_failure(self) -> pulumi.Input[bool]:
        """
        Cleanup automatically after a failed deploy.
        """
        return pulumi.get(self, "cleanup_on_failure")

    @cleanup_on_failure.setter
    def cleanup_on_failure(self, value: pulumi.Input[bool]):
        pulumi.set(self, "cleanup_on_failure", value)

    @property
    @pulumi.getter(name="deploymentGroups")
    def deployment_groups(self) -> pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationCodedeployDeploymentGroupArgs']]]:
        """
        Specify the deployment groups details.
        """
        return pulumi.get(self, "deployment_groups")

    @deployment_groups.setter
    def deployment_groups(self, value: pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationCodedeployDeploymentGroupArgs']]]):
        pulumi.set(self, "deployment_groups", value)

    @property
    @pulumi.getter(name="terminateInstanceOnFailure")
    def terminate_instance_on_failure(self) -> pulumi.Input[bool]:
        """
        Terminate the instance automatically after a failed deploy.
        """
        return pulumi.get(self, "terminate_instance_on_failure")

    @terminate_instance_on_failure.setter
    def terminate_instance_on_failure(self, value: pulumi.Input[bool]):
        pulumi.set(self, "terminate_instance_on_failure", value)


if not MYPY:
    class ElastigroupIntegrationCodedeployDeploymentGroupArgsDict(TypedDict):
        application_name: pulumi.Input[str]
        """
        The application name.
        """
        deployment_group_name: pulumi.Input[str]
        """
        The deployment group name.

        Usage:
        """
elif False:
    ElastigroupIntegrationCodedeployDeploymentGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationCodedeployDeploymentGroupArgs:
    def __init__(__self__, *,
                 application_name: pulumi.Input[str],
                 deployment_group_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] application_name: The application name.
        :param pulumi.Input[str] deployment_group_name: The deployment group name.
               
               Usage:
        """
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "deployment_group_name", deployment_group_name)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> pulumi.Input[str]:
        """
        The application name.
        """
        return pulumi.get(self, "application_name")

    @application_name.setter
    def application_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "application_name", value)

    @property
    @pulumi.getter(name="deploymentGroupName")
    def deployment_group_name(self) -> pulumi.Input[str]:
        """
        The deployment group name.

        Usage:
        """
        return pulumi.get(self, "deployment_group_name")

    @deployment_group_name.setter
    def deployment_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "deployment_group_name", value)


if not MYPY:
    class ElastigroupIntegrationDockerSwarmArgsDict(TypedDict):
        master_host: pulumi.Input[str]
        master_port: pulumi.Input[int]
        autoscale_cooldown: NotRequired[pulumi.Input[int]]
        autoscale_down: NotRequired[pulumi.Input['ElastigroupIntegrationDockerSwarmAutoscaleDownArgsDict']]
        autoscale_headroom: NotRequired[pulumi.Input['ElastigroupIntegrationDockerSwarmAutoscaleHeadroomArgsDict']]
        autoscale_is_enabled: NotRequired[pulumi.Input[bool]]
elif False:
    ElastigroupIntegrationDockerSwarmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationDockerSwarmArgs:
    def __init__(__self__, *,
                 master_host: pulumi.Input[str],
                 master_port: pulumi.Input[int],
                 autoscale_cooldown: Optional[pulumi.Input[int]] = None,
                 autoscale_down: Optional[pulumi.Input['ElastigroupIntegrationDockerSwarmAutoscaleDownArgs']] = None,
                 autoscale_headroom: Optional[pulumi.Input['ElastigroupIntegrationDockerSwarmAutoscaleHeadroomArgs']] = None,
                 autoscale_is_enabled: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "master_host", master_host)
        pulumi.set(__self__, "master_port", master_port)
        if autoscale_cooldown is not None:
            pulumi.set(__self__, "autoscale_cooldown", autoscale_cooldown)
        if autoscale_down is not None:
            pulumi.set(__self__, "autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)
        if autoscale_is_enabled is not None:
            pulumi.set(__self__, "autoscale_is_enabled", autoscale_is_enabled)

    @property
    @pulumi.getter(name="masterHost")
    def master_host(self) -> pulumi.Input[str]:
        return pulumi.get(self, "master_host")

    @master_host.setter
    def master_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "master_host", value)

    @property
    @pulumi.getter(name="masterPort")
    def master_port(self) -> pulumi.Input[int]:
        return pulumi.get(self, "master_port")

    @master_port.setter
    def master_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "master_port", value)

    @property
    @pulumi.getter(name="autoscaleCooldown")
    def autoscale_cooldown(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "autoscale_cooldown")

    @autoscale_cooldown.setter
    def autoscale_cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autoscale_cooldown", value)

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional[pulumi.Input['ElastigroupIntegrationDockerSwarmAutoscaleDownArgs']]:
        return pulumi.get(self, "autoscale_down")

    @autoscale_down.setter
    def autoscale_down(self, value: Optional[pulumi.Input['ElastigroupIntegrationDockerSwarmAutoscaleDownArgs']]):
        pulumi.set(self, "autoscale_down", value)

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional[pulumi.Input['ElastigroupIntegrationDockerSwarmAutoscaleHeadroomArgs']]:
        return pulumi.get(self, "autoscale_headroom")

    @autoscale_headroom.setter
    def autoscale_headroom(self, value: Optional[pulumi.Input['ElastigroupIntegrationDockerSwarmAutoscaleHeadroomArgs']]):
        pulumi.set(self, "autoscale_headroom", value)

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "autoscale_is_enabled")

    @autoscale_is_enabled.setter
    def autoscale_is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale_is_enabled", value)


if not MYPY:
    class ElastigroupIntegrationDockerSwarmAutoscaleDownArgsDict(TypedDict):
        evaluation_periods: NotRequired[pulumi.Input[int]]
        max_scale_down_percentage: NotRequired[pulumi.Input[float]]
elif False:
    ElastigroupIntegrationDockerSwarmAutoscaleDownArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationDockerSwarmAutoscaleDownArgs:
    def __init__(__self__, *,
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 max_scale_down_percentage: Optional[pulumi.Input[float]] = None):
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_scale_down_percentage is not None:
            pulumi.set(__self__, "max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "max_scale_down_percentage")

    @max_scale_down_percentage.setter
    def max_scale_down_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_scale_down_percentage", value)


if not MYPY:
    class ElastigroupIntegrationDockerSwarmAutoscaleHeadroomArgsDict(TypedDict):
        cpu_per_unit: NotRequired[pulumi.Input[int]]
        memory_per_unit: NotRequired[pulumi.Input[int]]
        num_of_units: NotRequired[pulumi.Input[int]]
elif False:
    ElastigroupIntegrationDockerSwarmAutoscaleHeadroomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationDockerSwarmAutoscaleHeadroomArgs:
    def __init__(__self__, *,
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None,
                 num_of_units: Optional[pulumi.Input[int]] = None):
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_of_units", value)


if not MYPY:
    class ElastigroupIntegrationEcsArgsDict(TypedDict):
        cluster_name: pulumi.Input[str]
        """
        The name of the EC2 Container Service cluster.
        """
        autoscale_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationEcsAutoscaleAttributeArgsDict']]]]
        """
        A key/value mapping of tags to assign to the resource.
        """
        autoscale_cooldown: NotRequired[pulumi.Input[int]]
        autoscale_down: NotRequired[pulumi.Input['ElastigroupIntegrationEcsAutoscaleDownArgsDict']]
        autoscale_headroom: NotRequired[pulumi.Input['ElastigroupIntegrationEcsAutoscaleHeadroomArgsDict']]
        autoscale_is_auto_config: NotRequired[pulumi.Input[bool]]
        autoscale_is_enabled: NotRequired[pulumi.Input[bool]]
        autoscale_scale_down_non_service_tasks: NotRequired[pulumi.Input[bool]]
        """
        Determines whether to scale down non-service tasks.
        """
        batch: NotRequired[pulumi.Input['ElastigroupIntegrationEcsBatchArgsDict']]
        """
        Batch configuration object:
        """
elif False:
    ElastigroupIntegrationEcsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationEcsArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[str],
                 autoscale_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationEcsAutoscaleAttributeArgs']]]] = None,
                 autoscale_cooldown: Optional[pulumi.Input[int]] = None,
                 autoscale_down: Optional[pulumi.Input['ElastigroupIntegrationEcsAutoscaleDownArgs']] = None,
                 autoscale_headroom: Optional[pulumi.Input['ElastigroupIntegrationEcsAutoscaleHeadroomArgs']] = None,
                 autoscale_is_auto_config: Optional[pulumi.Input[bool]] = None,
                 autoscale_is_enabled: Optional[pulumi.Input[bool]] = None,
                 autoscale_scale_down_non_service_tasks: Optional[pulumi.Input[bool]] = None,
                 batch: Optional[pulumi.Input['ElastigroupIntegrationEcsBatchArgs']] = None):
        """
        :param pulumi.Input[str] cluster_name: The name of the EC2 Container Service cluster.
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationEcsAutoscaleAttributeArgs']]] autoscale_attributes: A key/value mapping of tags to assign to the resource.
        :param pulumi.Input[bool] autoscale_scale_down_non_service_tasks: Determines whether to scale down non-service tasks.
        :param pulumi.Input['ElastigroupIntegrationEcsBatchArgs'] batch: Batch configuration object:
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        if autoscale_attributes is not None:
            pulumi.set(__self__, "autoscale_attributes", autoscale_attributes)
        if autoscale_cooldown is not None:
            pulumi.set(__self__, "autoscale_cooldown", autoscale_cooldown)
        if autoscale_down is not None:
            pulumi.set(__self__, "autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)
        if autoscale_is_auto_config is not None:
            pulumi.set(__self__, "autoscale_is_auto_config", autoscale_is_auto_config)
        if autoscale_is_enabled is not None:
            pulumi.set(__self__, "autoscale_is_enabled", autoscale_is_enabled)
        if autoscale_scale_down_non_service_tasks is not None:
            pulumi.set(__self__, "autoscale_scale_down_non_service_tasks", autoscale_scale_down_non_service_tasks)
        if batch is not None:
            pulumi.set(__self__, "batch", batch)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        The name of the EC2 Container Service cluster.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="autoscaleAttributes")
    def autoscale_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationEcsAutoscaleAttributeArgs']]]]:
        """
        A key/value mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "autoscale_attributes")

    @autoscale_attributes.setter
    def autoscale_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationEcsAutoscaleAttributeArgs']]]]):
        pulumi.set(self, "autoscale_attributes", value)

    @property
    @pulumi.getter(name="autoscaleCooldown")
    def autoscale_cooldown(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "autoscale_cooldown")

    @autoscale_cooldown.setter
    def autoscale_cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autoscale_cooldown", value)

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional[pulumi.Input['ElastigroupIntegrationEcsAutoscaleDownArgs']]:
        return pulumi.get(self, "autoscale_down")

    @autoscale_down.setter
    def autoscale_down(self, value: Optional[pulumi.Input['ElastigroupIntegrationEcsAutoscaleDownArgs']]):
        pulumi.set(self, "autoscale_down", value)

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional[pulumi.Input['ElastigroupIntegrationEcsAutoscaleHeadroomArgs']]:
        return pulumi.get(self, "autoscale_headroom")

    @autoscale_headroom.setter
    def autoscale_headroom(self, value: Optional[pulumi.Input['ElastigroupIntegrationEcsAutoscaleHeadroomArgs']]):
        pulumi.set(self, "autoscale_headroom", value)

    @property
    @pulumi.getter(name="autoscaleIsAutoConfig")
    def autoscale_is_auto_config(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "autoscale_is_auto_config")

    @autoscale_is_auto_config.setter
    def autoscale_is_auto_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale_is_auto_config", value)

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "autoscale_is_enabled")

    @autoscale_is_enabled.setter
    def autoscale_is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale_is_enabled", value)

    @property
    @pulumi.getter(name="autoscaleScaleDownNonServiceTasks")
    def autoscale_scale_down_non_service_tasks(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to scale down non-service tasks.
        """
        return pulumi.get(self, "autoscale_scale_down_non_service_tasks")

    @autoscale_scale_down_non_service_tasks.setter
    def autoscale_scale_down_non_service_tasks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale_scale_down_non_service_tasks", value)

    @property
    @pulumi.getter
    def batch(self) -> Optional[pulumi.Input['ElastigroupIntegrationEcsBatchArgs']]:
        """
        Batch configuration object:
        """
        return pulumi.get(self, "batch")

    @batch.setter
    def batch(self, value: Optional[pulumi.Input['ElastigroupIntegrationEcsBatchArgs']]):
        pulumi.set(self, "batch", value)


if not MYPY:
    class ElastigroupIntegrationEcsAutoscaleAttributeArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    ElastigroupIntegrationEcsAutoscaleAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationEcsAutoscaleAttributeArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ElastigroupIntegrationEcsAutoscaleDownArgsDict(TypedDict):
        evaluation_periods: NotRequired[pulumi.Input[int]]
        max_scale_down_percentage: NotRequired[pulumi.Input[float]]
elif False:
    ElastigroupIntegrationEcsAutoscaleDownArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationEcsAutoscaleDownArgs:
    def __init__(__self__, *,
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 max_scale_down_percentage: Optional[pulumi.Input[float]] = None):
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_scale_down_percentage is not None:
            pulumi.set(__self__, "max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "max_scale_down_percentage")

    @max_scale_down_percentage.setter
    def max_scale_down_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_scale_down_percentage", value)


if not MYPY:
    class ElastigroupIntegrationEcsAutoscaleHeadroomArgsDict(TypedDict):
        cpu_per_unit: NotRequired[pulumi.Input[int]]
        memory_per_unit: NotRequired[pulumi.Input[int]]
        num_of_units: NotRequired[pulumi.Input[int]]
elif False:
    ElastigroupIntegrationEcsAutoscaleHeadroomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationEcsAutoscaleHeadroomArgs:
    def __init__(__self__, *,
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None,
                 num_of_units: Optional[pulumi.Input[int]] = None):
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_of_units", value)


if not MYPY:
    class ElastigroupIntegrationEcsBatchArgsDict(TypedDict):
        job_queue_names: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Array of strings.

        Usage:
        """
elif False:
    ElastigroupIntegrationEcsBatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationEcsBatchArgs:
    def __init__(__self__, *,
                 job_queue_names: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] job_queue_names: Array of strings.
               
               Usage:
        """
        pulumi.set(__self__, "job_queue_names", job_queue_names)

    @property
    @pulumi.getter(name="jobQueueNames")
    def job_queue_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Array of strings.

        Usage:
        """
        return pulumi.get(self, "job_queue_names")

    @job_queue_names.setter
    def job_queue_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "job_queue_names", value)


if not MYPY:
    class ElastigroupIntegrationGitlabArgsDict(TypedDict):
        runner: NotRequired[pulumi.Input['ElastigroupIntegrationGitlabRunnerArgsDict']]
        """
        Settings for Gitlab runner.
        """
elif False:
    ElastigroupIntegrationGitlabArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationGitlabArgs:
    def __init__(__self__, *,
                 runner: Optional[pulumi.Input['ElastigroupIntegrationGitlabRunnerArgs']] = None):
        """
        :param pulumi.Input['ElastigroupIntegrationGitlabRunnerArgs'] runner: Settings for Gitlab runner.
        """
        if runner is not None:
            pulumi.set(__self__, "runner", runner)

    @property
    @pulumi.getter
    def runner(self) -> Optional[pulumi.Input['ElastigroupIntegrationGitlabRunnerArgs']]:
        """
        Settings for Gitlab runner.
        """
        return pulumi.get(self, "runner")

    @runner.setter
    def runner(self, value: Optional[pulumi.Input['ElastigroupIntegrationGitlabRunnerArgs']]):
        pulumi.set(self, "runner", value)


if not MYPY:
    class ElastigroupIntegrationGitlabRunnerArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[bool]]
elif False:
    ElastigroupIntegrationGitlabRunnerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationGitlabRunnerArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class ElastigroupIntegrationKubernetesArgsDict(TypedDict):
        api_server: NotRequired[pulumi.Input[str]]
        autoscale_cooldown: NotRequired[pulumi.Input[int]]
        autoscale_down: NotRequired[pulumi.Input['ElastigroupIntegrationKubernetesAutoscaleDownArgsDict']]
        autoscale_headroom: NotRequired[pulumi.Input['ElastigroupIntegrationKubernetesAutoscaleHeadroomArgsDict']]
        autoscale_is_auto_config: NotRequired[pulumi.Input[bool]]
        autoscale_is_enabled: NotRequired[pulumi.Input[bool]]
        autoscale_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationKubernetesAutoscaleLabelArgsDict']]]]
        """
        A key/value mapping of tags to assign to the resource.

        Usage:
        """
        cluster_identifier: NotRequired[pulumi.Input[str]]
        integration_mode: NotRequired[pulumi.Input[str]]
        """
        Valid values: `"saas"`, `"pod"`.
        """
        token: NotRequired[pulumi.Input[str]]
        """
        Kubernetes Token
        """
elif False:
    ElastigroupIntegrationKubernetesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationKubernetesArgs:
    def __init__(__self__, *,
                 api_server: Optional[pulumi.Input[str]] = None,
                 autoscale_cooldown: Optional[pulumi.Input[int]] = None,
                 autoscale_down: Optional[pulumi.Input['ElastigroupIntegrationKubernetesAutoscaleDownArgs']] = None,
                 autoscale_headroom: Optional[pulumi.Input['ElastigroupIntegrationKubernetesAutoscaleHeadroomArgs']] = None,
                 autoscale_is_auto_config: Optional[pulumi.Input[bool]] = None,
                 autoscale_is_enabled: Optional[pulumi.Input[bool]] = None,
                 autoscale_labels: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationKubernetesAutoscaleLabelArgs']]]] = None,
                 cluster_identifier: Optional[pulumi.Input[str]] = None,
                 integration_mode: Optional[pulumi.Input[str]] = None,
                 token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationKubernetesAutoscaleLabelArgs']]] autoscale_labels: A key/value mapping of tags to assign to the resource.
               
               Usage:
        :param pulumi.Input[str] integration_mode: Valid values: `"saas"`, `"pod"`.
        :param pulumi.Input[str] token: Kubernetes Token
        """
        if api_server is not None:
            pulumi.set(__self__, "api_server", api_server)
        if autoscale_cooldown is not None:
            pulumi.set(__self__, "autoscale_cooldown", autoscale_cooldown)
        if autoscale_down is not None:
            pulumi.set(__self__, "autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)
        if autoscale_is_auto_config is not None:
            pulumi.set(__self__, "autoscale_is_auto_config", autoscale_is_auto_config)
        if autoscale_is_enabled is not None:
            pulumi.set(__self__, "autoscale_is_enabled", autoscale_is_enabled)
        if autoscale_labels is not None:
            pulumi.set(__self__, "autoscale_labels", autoscale_labels)
        if cluster_identifier is not None:
            pulumi.set(__self__, "cluster_identifier", cluster_identifier)
        if integration_mode is not None:
            pulumi.set(__self__, "integration_mode", integration_mode)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="apiServer")
    def api_server(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "api_server")

    @api_server.setter
    def api_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_server", value)

    @property
    @pulumi.getter(name="autoscaleCooldown")
    def autoscale_cooldown(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "autoscale_cooldown")

    @autoscale_cooldown.setter
    def autoscale_cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autoscale_cooldown", value)

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional[pulumi.Input['ElastigroupIntegrationKubernetesAutoscaleDownArgs']]:
        return pulumi.get(self, "autoscale_down")

    @autoscale_down.setter
    def autoscale_down(self, value: Optional[pulumi.Input['ElastigroupIntegrationKubernetesAutoscaleDownArgs']]):
        pulumi.set(self, "autoscale_down", value)

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional[pulumi.Input['ElastigroupIntegrationKubernetesAutoscaleHeadroomArgs']]:
        return pulumi.get(self, "autoscale_headroom")

    @autoscale_headroom.setter
    def autoscale_headroom(self, value: Optional[pulumi.Input['ElastigroupIntegrationKubernetesAutoscaleHeadroomArgs']]):
        pulumi.set(self, "autoscale_headroom", value)

    @property
    @pulumi.getter(name="autoscaleIsAutoConfig")
    def autoscale_is_auto_config(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "autoscale_is_auto_config")

    @autoscale_is_auto_config.setter
    def autoscale_is_auto_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale_is_auto_config", value)

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "autoscale_is_enabled")

    @autoscale_is_enabled.setter
    def autoscale_is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale_is_enabled", value)

    @property
    @pulumi.getter(name="autoscaleLabels")
    def autoscale_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationKubernetesAutoscaleLabelArgs']]]]:
        """
        A key/value mapping of tags to assign to the resource.

        Usage:
        """
        return pulumi.get(self, "autoscale_labels")

    @autoscale_labels.setter
    def autoscale_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationKubernetesAutoscaleLabelArgs']]]]):
        pulumi.set(self, "autoscale_labels", value)

    @property
    @pulumi.getter(name="clusterIdentifier")
    def cluster_identifier(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_identifier")

    @cluster_identifier.setter
    def cluster_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_identifier", value)

    @property
    @pulumi.getter(name="integrationMode")
    def integration_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Valid values: `"saas"`, `"pod"`.
        """
        return pulumi.get(self, "integration_mode")

    @integration_mode.setter
    def integration_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integration_mode", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        Kubernetes Token
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ElastigroupIntegrationKubernetesAutoscaleDownArgsDict(TypedDict):
        evaluation_periods: NotRequired[pulumi.Input[int]]
        max_scale_down_percentage: NotRequired[pulumi.Input[float]]
elif False:
    ElastigroupIntegrationKubernetesAutoscaleDownArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationKubernetesAutoscaleDownArgs:
    def __init__(__self__, *,
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 max_scale_down_percentage: Optional[pulumi.Input[float]] = None):
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_scale_down_percentage is not None:
            pulumi.set(__self__, "max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "max_scale_down_percentage")

    @max_scale_down_percentage.setter
    def max_scale_down_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_scale_down_percentage", value)


if not MYPY:
    class ElastigroupIntegrationKubernetesAutoscaleHeadroomArgsDict(TypedDict):
        cpu_per_unit: NotRequired[pulumi.Input[int]]
        memory_per_unit: NotRequired[pulumi.Input[int]]
        num_of_units: NotRequired[pulumi.Input[int]]
elif False:
    ElastigroupIntegrationKubernetesAutoscaleHeadroomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationKubernetesAutoscaleHeadroomArgs:
    def __init__(__self__, *,
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None,
                 num_of_units: Optional[pulumi.Input[int]] = None):
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_of_units", value)


if not MYPY:
    class ElastigroupIntegrationKubernetesAutoscaleLabelArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    ElastigroupIntegrationKubernetesAutoscaleLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationKubernetesAutoscaleLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ElastigroupIntegrationMesosphereArgsDict(TypedDict):
        api_server: pulumi.Input[str]
elif False:
    ElastigroupIntegrationMesosphereArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationMesosphereArgs:
    def __init__(__self__, *,
                 api_server: pulumi.Input[str]):
        pulumi.set(__self__, "api_server", api_server)

    @property
    @pulumi.getter(name="apiServer")
    def api_server(self) -> pulumi.Input[str]:
        return pulumi.get(self, "api_server")

    @api_server.setter
    def api_server(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_server", value)


if not MYPY:
    class ElastigroupIntegrationNomadArgsDict(TypedDict):
        master_host: pulumi.Input[str]
        master_port: pulumi.Input[int]
        acl_token: NotRequired[pulumi.Input[str]]
        """
        Nomad ACL Token
        """
        autoscale_constraints: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationNomadAutoscaleConstraintArgsDict']]]]
        """
        A key/value mapping of tags to assign to the resource.

        Usage:
        """
        autoscale_cooldown: NotRequired[pulumi.Input[int]]
        autoscale_down: NotRequired[pulumi.Input['ElastigroupIntegrationNomadAutoscaleDownArgsDict']]
        autoscale_headroom: NotRequired[pulumi.Input['ElastigroupIntegrationNomadAutoscaleHeadroomArgsDict']]
        autoscale_is_enabled: NotRequired[pulumi.Input[bool]]
elif False:
    ElastigroupIntegrationNomadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationNomadArgs:
    def __init__(__self__, *,
                 master_host: pulumi.Input[str],
                 master_port: pulumi.Input[int],
                 acl_token: Optional[pulumi.Input[str]] = None,
                 autoscale_constraints: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationNomadAutoscaleConstraintArgs']]]] = None,
                 autoscale_cooldown: Optional[pulumi.Input[int]] = None,
                 autoscale_down: Optional[pulumi.Input['ElastigroupIntegrationNomadAutoscaleDownArgs']] = None,
                 autoscale_headroom: Optional[pulumi.Input['ElastigroupIntegrationNomadAutoscaleHeadroomArgs']] = None,
                 autoscale_is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] acl_token: Nomad ACL Token
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationNomadAutoscaleConstraintArgs']]] autoscale_constraints: A key/value mapping of tags to assign to the resource.
               
               Usage:
        """
        pulumi.set(__self__, "master_host", master_host)
        pulumi.set(__self__, "master_port", master_port)
        if acl_token is not None:
            pulumi.set(__self__, "acl_token", acl_token)
        if autoscale_constraints is not None:
            pulumi.set(__self__, "autoscale_constraints", autoscale_constraints)
        if autoscale_cooldown is not None:
            pulumi.set(__self__, "autoscale_cooldown", autoscale_cooldown)
        if autoscale_down is not None:
            pulumi.set(__self__, "autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)
        if autoscale_is_enabled is not None:
            pulumi.set(__self__, "autoscale_is_enabled", autoscale_is_enabled)

    @property
    @pulumi.getter(name="masterHost")
    def master_host(self) -> pulumi.Input[str]:
        return pulumi.get(self, "master_host")

    @master_host.setter
    def master_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "master_host", value)

    @property
    @pulumi.getter(name="masterPort")
    def master_port(self) -> pulumi.Input[int]:
        return pulumi.get(self, "master_port")

    @master_port.setter
    def master_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "master_port", value)

    @property
    @pulumi.getter(name="aclToken")
    def acl_token(self) -> Optional[pulumi.Input[str]]:
        """
        Nomad ACL Token
        """
        return pulumi.get(self, "acl_token")

    @acl_token.setter
    def acl_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "acl_token", value)

    @property
    @pulumi.getter(name="autoscaleConstraints")
    def autoscale_constraints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationNomadAutoscaleConstraintArgs']]]]:
        """
        A key/value mapping of tags to assign to the resource.

        Usage:
        """
        return pulumi.get(self, "autoscale_constraints")

    @autoscale_constraints.setter
    def autoscale_constraints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationNomadAutoscaleConstraintArgs']]]]):
        pulumi.set(self, "autoscale_constraints", value)

    @property
    @pulumi.getter(name="autoscaleCooldown")
    def autoscale_cooldown(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "autoscale_cooldown")

    @autoscale_cooldown.setter
    def autoscale_cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autoscale_cooldown", value)

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional[pulumi.Input['ElastigroupIntegrationNomadAutoscaleDownArgs']]:
        return pulumi.get(self, "autoscale_down")

    @autoscale_down.setter
    def autoscale_down(self, value: Optional[pulumi.Input['ElastigroupIntegrationNomadAutoscaleDownArgs']]):
        pulumi.set(self, "autoscale_down", value)

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional[pulumi.Input['ElastigroupIntegrationNomadAutoscaleHeadroomArgs']]:
        return pulumi.get(self, "autoscale_headroom")

    @autoscale_headroom.setter
    def autoscale_headroom(self, value: Optional[pulumi.Input['ElastigroupIntegrationNomadAutoscaleHeadroomArgs']]):
        pulumi.set(self, "autoscale_headroom", value)

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "autoscale_is_enabled")

    @autoscale_is_enabled.setter
    def autoscale_is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale_is_enabled", value)


if not MYPY:
    class ElastigroupIntegrationNomadAutoscaleConstraintArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    ElastigroupIntegrationNomadAutoscaleConstraintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationNomadAutoscaleConstraintArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ElastigroupIntegrationNomadAutoscaleDownArgsDict(TypedDict):
        evaluation_periods: NotRequired[pulumi.Input[int]]
elif False:
    ElastigroupIntegrationNomadAutoscaleDownArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationNomadAutoscaleDownArgs:
    def __init__(__self__, *,
                 evaluation_periods: Optional[pulumi.Input[int]] = None):
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)


if not MYPY:
    class ElastigroupIntegrationNomadAutoscaleHeadroomArgsDict(TypedDict):
        cpu_per_unit: NotRequired[pulumi.Input[int]]
        memory_per_unit: NotRequired[pulumi.Input[int]]
        num_of_units: NotRequired[pulumi.Input[int]]
elif False:
    ElastigroupIntegrationNomadAutoscaleHeadroomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationNomadAutoscaleHeadroomArgs:
    def __init__(__self__, *,
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None,
                 num_of_units: Optional[pulumi.Input[int]] = None):
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_of_units", value)


if not MYPY:
    class ElastigroupIntegrationRancherArgsDict(TypedDict):
        access_key: pulumi.Input[str]
        """
        The access key of the Rancher API.
        """
        master_host: pulumi.Input[str]
        secret_key: pulumi.Input[str]
        """
        The secret key of the Rancher API.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        The Rancher version. Must be `"1"` or `"2"`. If this field is omitted, its assumed that the Rancher cluster is version 1. Note that Kubernetes is required when using Rancher version 2^.
        Usage:
        """
elif False:
    ElastigroupIntegrationRancherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationRancherArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 master_host: pulumi.Input[str],
                 secret_key: pulumi.Input[str],
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: The access key of the Rancher API.
        :param pulumi.Input[str] secret_key: The secret key of the Rancher API.
        :param pulumi.Input[str] version: The Rancher version. Must be `"1"` or `"2"`. If this field is omitted, its assumed that the Rancher cluster is version 1. Note that Kubernetes is required when using Rancher version 2^.
               Usage:
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "master_host", master_host)
        pulumi.set(__self__, "secret_key", secret_key)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        The access key of the Rancher API.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="masterHost")
    def master_host(self) -> pulumi.Input[str]:
        return pulumi.get(self, "master_host")

    @master_host.setter
    def master_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "master_host", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[str]:
        """
        The secret key of the Rancher API.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The Rancher version. Must be `"1"` or `"2"`. If this field is omitted, its assumed that the Rancher cluster is version 1. Note that Kubernetes is required when using Rancher version 2^.
        Usage:
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ElastigroupIntegrationRoute53ArgsDict(TypedDict):
        domains: pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationRoute53DomainArgsDict']]]
        """
        Collection of one or more domains to register.
        """
elif False:
    ElastigroupIntegrationRoute53ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationRoute53Args:
    def __init__(__self__, *,
                 domains: pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationRoute53DomainArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationRoute53DomainArgs']]] domains: Collection of one or more domains to register.
        """
        pulumi.set(__self__, "domains", domains)

    @property
    @pulumi.getter
    def domains(self) -> pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationRoute53DomainArgs']]]:
        """
        Collection of one or more domains to register.
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationRoute53DomainArgs']]]):
        pulumi.set(self, "domains", value)


if not MYPY:
    class ElastigroupIntegrationRoute53DomainArgsDict(TypedDict):
        hosted_zone_id: pulumi.Input[str]
        """
        The id associated with a hosted zone.
        """
        record_sets: pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationRoute53DomainRecordSetArgsDict']]]
        """
        Collection of records containing authoritative DNS information for the specified domain name.
        """
        record_set_type: NotRequired[pulumi.Input[str]]
        """
        The type of the record set. Valid values: `"a"`, `"cname"`.
        """
        spotinst_acct_id: NotRequired[pulumi.Input[str]]
        """
        The Spotinst account ID that is linked to the AWS account that holds the Route 53 Hosted Zone ID. The default is the user Spotinst account provided as a URL parameter.
        """
elif False:
    ElastigroupIntegrationRoute53DomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationRoute53DomainArgs:
    def __init__(__self__, *,
                 hosted_zone_id: pulumi.Input[str],
                 record_sets: pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationRoute53DomainRecordSetArgs']]],
                 record_set_type: Optional[pulumi.Input[str]] = None,
                 spotinst_acct_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hosted_zone_id: The id associated with a hosted zone.
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationRoute53DomainRecordSetArgs']]] record_sets: Collection of records containing authoritative DNS information for the specified domain name.
        :param pulumi.Input[str] record_set_type: The type of the record set. Valid values: `"a"`, `"cname"`.
        :param pulumi.Input[str] spotinst_acct_id: The Spotinst account ID that is linked to the AWS account that holds the Route 53 Hosted Zone ID. The default is the user Spotinst account provided as a URL parameter.
        """
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)
        pulumi.set(__self__, "record_sets", record_sets)
        if record_set_type is not None:
            pulumi.set(__self__, "record_set_type", record_set_type)
        if spotinst_acct_id is not None:
            pulumi.set(__self__, "spotinst_acct_id", spotinst_acct_id)

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> pulumi.Input[str]:
        """
        The id associated with a hosted zone.
        """
        return pulumi.get(self, "hosted_zone_id")

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "hosted_zone_id", value)

    @property
    @pulumi.getter(name="recordSets")
    def record_sets(self) -> pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationRoute53DomainRecordSetArgs']]]:
        """
        Collection of records containing authoritative DNS information for the specified domain name.
        """
        return pulumi.get(self, "record_sets")

    @record_sets.setter
    def record_sets(self, value: pulumi.Input[Sequence[pulumi.Input['ElastigroupIntegrationRoute53DomainRecordSetArgs']]]):
        pulumi.set(self, "record_sets", value)

    @property
    @pulumi.getter(name="recordSetType")
    def record_set_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the record set. Valid values: `"a"`, `"cname"`.
        """
        return pulumi.get(self, "record_set_type")

    @record_set_type.setter
    def record_set_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_set_type", value)

    @property
    @pulumi.getter(name="spotinstAcctId")
    def spotinst_acct_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Spotinst account ID that is linked to the AWS account that holds the Route 53 Hosted Zone ID. The default is the user Spotinst account provided as a URL parameter.
        """
        return pulumi.get(self, "spotinst_acct_id")

    @spotinst_acct_id.setter
    def spotinst_acct_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spotinst_acct_id", value)


if not MYPY:
    class ElastigroupIntegrationRoute53DomainRecordSetArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The group name.
        """
        use_public_dns: NotRequired[pulumi.Input[bool]]
        """
        Designates whether the DNS address should be exposed to connections outside the VPC.

        Usage:
        """
        use_public_ip: NotRequired[pulumi.Input[bool]]
        """
        Designates whether the IP address should be exposed to connections outside the VPC.
        """
elif False:
    ElastigroupIntegrationRoute53DomainRecordSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupIntegrationRoute53DomainRecordSetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 use_public_dns: Optional[pulumi.Input[bool]] = None,
                 use_public_ip: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The group name.
        :param pulumi.Input[bool] use_public_dns: Designates whether the DNS address should be exposed to connections outside the VPC.
               
               Usage:
        :param pulumi.Input[bool] use_public_ip: Designates whether the IP address should be exposed to connections outside the VPC.
        """
        pulumi.set(__self__, "name", name)
        if use_public_dns is not None:
            pulumi.set(__self__, "use_public_dns", use_public_dns)
        if use_public_ip is not None:
            pulumi.set(__self__, "use_public_ip", use_public_ip)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The group name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="usePublicDns")
    def use_public_dns(self) -> Optional[pulumi.Input[bool]]:
        """
        Designates whether the DNS address should be exposed to connections outside the VPC.

        Usage:
        """
        return pulumi.get(self, "use_public_dns")

    @use_public_dns.setter
    def use_public_dns(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_public_dns", value)

    @property
    @pulumi.getter(name="usePublicIp")
    def use_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Designates whether the IP address should be exposed to connections outside the VPC.
        """
        return pulumi.get(self, "use_public_ip")

    @use_public_ip.setter
    def use_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_public_ip", value)


if not MYPY:
    class ElastigroupItfArgsDict(TypedDict):
        fixed_target_groups: pulumi.Input[bool]
        load_balancers: pulumi.Input[Sequence[pulumi.Input['ElastigroupItfLoadBalancerArgsDict']]]
        target_group_configs: pulumi.Input[Sequence[pulumi.Input['ElastigroupItfTargetGroupConfigArgsDict']]]
        weight_strategy: pulumi.Input[str]
        default_static_target_group: NotRequired[pulumi.Input['ElastigroupItfDefaultStaticTargetGroupArgsDict']]
        migration_healthiness_threshold: NotRequired[pulumi.Input[int]]
elif False:
    ElastigroupItfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupItfArgs:
    def __init__(__self__, *,
                 fixed_target_groups: pulumi.Input[bool],
                 load_balancers: pulumi.Input[Sequence[pulumi.Input['ElastigroupItfLoadBalancerArgs']]],
                 target_group_configs: pulumi.Input[Sequence[pulumi.Input['ElastigroupItfTargetGroupConfigArgs']]],
                 weight_strategy: pulumi.Input[str],
                 default_static_target_group: Optional[pulumi.Input['ElastigroupItfDefaultStaticTargetGroupArgs']] = None,
                 migration_healthiness_threshold: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "fixed_target_groups", fixed_target_groups)
        pulumi.set(__self__, "load_balancers", load_balancers)
        pulumi.set(__self__, "target_group_configs", target_group_configs)
        pulumi.set(__self__, "weight_strategy", weight_strategy)
        if default_static_target_group is not None:
            pulumi.set(__self__, "default_static_target_group", default_static_target_group)
        if migration_healthiness_threshold is not None:
            pulumi.set(__self__, "migration_healthiness_threshold", migration_healthiness_threshold)

    @property
    @pulumi.getter(name="fixedTargetGroups")
    def fixed_target_groups(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "fixed_target_groups")

    @fixed_target_groups.setter
    def fixed_target_groups(self, value: pulumi.Input[bool]):
        pulumi.set(self, "fixed_target_groups", value)

    @property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> pulumi.Input[Sequence[pulumi.Input['ElastigroupItfLoadBalancerArgs']]]:
        return pulumi.get(self, "load_balancers")

    @load_balancers.setter
    def load_balancers(self, value: pulumi.Input[Sequence[pulumi.Input['ElastigroupItfLoadBalancerArgs']]]):
        pulumi.set(self, "load_balancers", value)

    @property
    @pulumi.getter(name="targetGroupConfigs")
    def target_group_configs(self) -> pulumi.Input[Sequence[pulumi.Input['ElastigroupItfTargetGroupConfigArgs']]]:
        return pulumi.get(self, "target_group_configs")

    @target_group_configs.setter
    def target_group_configs(self, value: pulumi.Input[Sequence[pulumi.Input['ElastigroupItfTargetGroupConfigArgs']]]):
        pulumi.set(self, "target_group_configs", value)

    @property
    @pulumi.getter(name="weightStrategy")
    def weight_strategy(self) -> pulumi.Input[str]:
        return pulumi.get(self, "weight_strategy")

    @weight_strategy.setter
    def weight_strategy(self, value: pulumi.Input[str]):
        pulumi.set(self, "weight_strategy", value)

    @property
    @pulumi.getter(name="defaultStaticTargetGroup")
    def default_static_target_group(self) -> Optional[pulumi.Input['ElastigroupItfDefaultStaticTargetGroupArgs']]:
        return pulumi.get(self, "default_static_target_group")

    @default_static_target_group.setter
    def default_static_target_group(self, value: Optional[pulumi.Input['ElastigroupItfDefaultStaticTargetGroupArgs']]):
        pulumi.set(self, "default_static_target_group", value)

    @property
    @pulumi.getter(name="migrationHealthinessThreshold")
    def migration_healthiness_threshold(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "migration_healthiness_threshold")

    @migration_healthiness_threshold.setter
    def migration_healthiness_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "migration_healthiness_threshold", value)


if not MYPY:
    class ElastigroupItfDefaultStaticTargetGroupArgsDict(TypedDict):
        arn: pulumi.Input[str]
        percentage: pulumi.Input[float]
elif False:
    ElastigroupItfDefaultStaticTargetGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupItfDefaultStaticTargetGroupArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 percentage: pulumi.Input[float]):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter
    def percentage(self) -> pulumi.Input[float]:
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: pulumi.Input[float]):
        pulumi.set(self, "percentage", value)


if not MYPY:
    class ElastigroupItfLoadBalancerArgsDict(TypedDict):
        listener_rules: pulumi.Input[Sequence[pulumi.Input['ElastigroupItfLoadBalancerListenerRuleArgsDict']]]
        load_balancer_arn: pulumi.Input[str]
elif False:
    ElastigroupItfLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupItfLoadBalancerArgs:
    def __init__(__self__, *,
                 listener_rules: pulumi.Input[Sequence[pulumi.Input['ElastigroupItfLoadBalancerListenerRuleArgs']]],
                 load_balancer_arn: pulumi.Input[str]):
        pulumi.set(__self__, "listener_rules", listener_rules)
        pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)

    @property
    @pulumi.getter(name="listenerRules")
    def listener_rules(self) -> pulumi.Input[Sequence[pulumi.Input['ElastigroupItfLoadBalancerListenerRuleArgs']]]:
        return pulumi.get(self, "listener_rules")

    @listener_rules.setter
    def listener_rules(self, value: pulumi.Input[Sequence[pulumi.Input['ElastigroupItfLoadBalancerListenerRuleArgs']]]):
        pulumi.set(self, "listener_rules", value)

    @property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "load_balancer_arn")

    @load_balancer_arn.setter
    def load_balancer_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "load_balancer_arn", value)


if not MYPY:
    class ElastigroupItfLoadBalancerListenerRuleArgsDict(TypedDict):
        rule_arn: pulumi.Input[str]
        static_target_group: NotRequired[pulumi.Input['ElastigroupItfLoadBalancerListenerRuleStaticTargetGroupArgsDict']]
elif False:
    ElastigroupItfLoadBalancerListenerRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupItfLoadBalancerListenerRuleArgs:
    def __init__(__self__, *,
                 rule_arn: pulumi.Input[str],
                 static_target_group: Optional[pulumi.Input['ElastigroupItfLoadBalancerListenerRuleStaticTargetGroupArgs']] = None):
        pulumi.set(__self__, "rule_arn", rule_arn)
        if static_target_group is not None:
            pulumi.set(__self__, "static_target_group", static_target_group)

    @property
    @pulumi.getter(name="ruleArn")
    def rule_arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "rule_arn")

    @rule_arn.setter
    def rule_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_arn", value)

    @property
    @pulumi.getter(name="staticTargetGroup")
    def static_target_group(self) -> Optional[pulumi.Input['ElastigroupItfLoadBalancerListenerRuleStaticTargetGroupArgs']]:
        return pulumi.get(self, "static_target_group")

    @static_target_group.setter
    def static_target_group(self, value: Optional[pulumi.Input['ElastigroupItfLoadBalancerListenerRuleStaticTargetGroupArgs']]):
        pulumi.set(self, "static_target_group", value)


if not MYPY:
    class ElastigroupItfLoadBalancerListenerRuleStaticTargetGroupArgsDict(TypedDict):
        arn: pulumi.Input[str]
        percentage: pulumi.Input[float]
elif False:
    ElastigroupItfLoadBalancerListenerRuleStaticTargetGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupItfLoadBalancerListenerRuleStaticTargetGroupArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 percentage: pulumi.Input[float]):
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "percentage", percentage)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter
    def percentage(self) -> pulumi.Input[float]:
        return pulumi.get(self, "percentage")

    @percentage.setter
    def percentage(self, value: pulumi.Input[float]):
        pulumi.set(self, "percentage", value)


if not MYPY:
    class ElastigroupItfTargetGroupConfigArgsDict(TypedDict):
        health_check_path: pulumi.Input[str]
        port: pulumi.Input[int]
        protocol: pulumi.Input[str]
        vpc_id: pulumi.Input[str]
        health_check_interval_seconds: NotRequired[pulumi.Input[int]]
        health_check_port: NotRequired[pulumi.Input[str]]
        health_check_protocol: NotRequired[pulumi.Input[str]]
        health_check_timeout_seconds: NotRequired[pulumi.Input[int]]
        healthy_threshold_count: NotRequired[pulumi.Input[int]]
        matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupItfTargetGroupConfigMatcherArgsDict']]]]
        protocol_version: NotRequired[pulumi.Input[str]]
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupItfTargetGroupConfigTagArgsDict']]]]
        """
        A key/value mapping of tags to assign to the resource.
        """
        unhealthy_threshold_count: NotRequired[pulumi.Input[int]]
elif False:
    ElastigroupItfTargetGroupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupItfTargetGroupConfigArgs:
    def __init__(__self__, *,
                 health_check_path: pulumi.Input[str],
                 port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 vpc_id: pulumi.Input[str],
                 health_check_interval_seconds: Optional[pulumi.Input[int]] = None,
                 health_check_port: Optional[pulumi.Input[str]] = None,
                 health_check_protocol: Optional[pulumi.Input[str]] = None,
                 health_check_timeout_seconds: Optional[pulumi.Input[int]] = None,
                 healthy_threshold_count: Optional[pulumi.Input[int]] = None,
                 matchers: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupItfTargetGroupConfigMatcherArgs']]]] = None,
                 protocol_version: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupItfTargetGroupConfigTagArgs']]]] = None,
                 unhealthy_threshold_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupItfTargetGroupConfigTagArgs']]] tags: A key/value mapping of tags to assign to the resource.
        """
        pulumi.set(__self__, "health_check_path", health_check_path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if health_check_interval_seconds is not None:
            pulumi.set(__self__, "health_check_interval_seconds", health_check_interval_seconds)
        if health_check_port is not None:
            pulumi.set(__self__, "health_check_port", health_check_port)
        if health_check_protocol is not None:
            pulumi.set(__self__, "health_check_protocol", health_check_protocol)
        if health_check_timeout_seconds is not None:
            pulumi.set(__self__, "health_check_timeout_seconds", health_check_timeout_seconds)
        if healthy_threshold_count is not None:
            pulumi.set(__self__, "healthy_threshold_count", healthy_threshold_count)
        if matchers is not None:
            pulumi.set(__self__, "matchers", matchers)
        if protocol_version is not None:
            pulumi.set(__self__, "protocol_version", protocol_version)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if unhealthy_threshold_count is not None:
            pulumi.set(__self__, "unhealthy_threshold_count", unhealthy_threshold_count)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vpc_id", value)

    @property
    @pulumi.getter(name="healthCheckIntervalSeconds")
    def health_check_interval_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "health_check_interval_seconds")

    @health_check_interval_seconds.setter
    def health_check_interval_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_interval_seconds", value)

    @property
    @pulumi.getter(name="healthCheckPort")
    def health_check_port(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "health_check_port")

    @health_check_port.setter
    def health_check_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_port", value)

    @property
    @pulumi.getter(name="healthCheckProtocol")
    def health_check_protocol(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "health_check_protocol")

    @health_check_protocol.setter
    def health_check_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_protocol", value)

    @property
    @pulumi.getter(name="healthCheckTimeoutSeconds")
    def health_check_timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "health_check_timeout_seconds")

    @health_check_timeout_seconds.setter
    def health_check_timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_timeout_seconds", value)

    @property
    @pulumi.getter(name="healthyThresholdCount")
    def healthy_threshold_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "healthy_threshold_count")

    @healthy_threshold_count.setter
    def healthy_threshold_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "healthy_threshold_count", value)

    @property
    @pulumi.getter
    def matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupItfTargetGroupConfigMatcherArgs']]]]:
        return pulumi.get(self, "matchers")

    @matchers.setter
    def matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupItfTargetGroupConfigMatcherArgs']]]]):
        pulumi.set(self, "matchers", value)

    @property
    @pulumi.getter(name="protocolVersion")
    def protocol_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protocol_version")

    @protocol_version.setter
    def protocol_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol_version", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupItfTargetGroupConfigTagArgs']]]]:
        """
        A key/value mapping of tags to assign to the resource.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupItfTargetGroupConfigTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="unhealthyThresholdCount")
    def unhealthy_threshold_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "unhealthy_threshold_count")

    @unhealthy_threshold_count.setter
    def unhealthy_threshold_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unhealthy_threshold_count", value)


if not MYPY:
    class ElastigroupItfTargetGroupConfigMatcherArgsDict(TypedDict):
        grpc_code: NotRequired[pulumi.Input[str]]
        http_code: NotRequired[pulumi.Input[str]]
elif False:
    ElastigroupItfTargetGroupConfigMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupItfTargetGroupConfigMatcherArgs:
    def __init__(__self__, *,
                 grpc_code: Optional[pulumi.Input[str]] = None,
                 http_code: Optional[pulumi.Input[str]] = None):
        if grpc_code is not None:
            pulumi.set(__self__, "grpc_code", grpc_code)
        if http_code is not None:
            pulumi.set(__self__, "http_code", http_code)

    @property
    @pulumi.getter(name="grpcCode")
    def grpc_code(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "grpc_code")

    @grpc_code.setter
    def grpc_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "grpc_code", value)

    @property
    @pulumi.getter(name="httpCode")
    def http_code(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_code")

    @http_code.setter
    def http_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_code", value)


if not MYPY:
    class ElastigroupItfTargetGroupConfigTagArgsDict(TypedDict):
        tag_key: pulumi.Input[str]
        tag_value: NotRequired[pulumi.Input[str]]
elif False:
    ElastigroupItfTargetGroupConfigTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupItfTargetGroupConfigTagArgs:
    def __init__(__self__, *,
                 tag_key: pulumi.Input[str],
                 tag_value: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class ElastigroupLoggingArgsDict(TypedDict):
        export: NotRequired[pulumi.Input['ElastigroupLoggingExportArgsDict']]
        """
        Logging Export configuration.
        """
elif False:
    ElastigroupLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupLoggingArgs:
    def __init__(__self__, *,
                 export: Optional[pulumi.Input['ElastigroupLoggingExportArgs']] = None):
        """
        :param pulumi.Input['ElastigroupLoggingExportArgs'] export: Logging Export configuration.
        """
        if export is not None:
            pulumi.set(__self__, "export", export)

    @property
    @pulumi.getter
    def export(self) -> Optional[pulumi.Input['ElastigroupLoggingExportArgs']]:
        """
        Logging Export configuration.
        """
        return pulumi.get(self, "export")

    @export.setter
    def export(self, value: Optional[pulumi.Input['ElastigroupLoggingExportArgs']]):
        pulumi.set(self, "export", value)


if not MYPY:
    class ElastigroupLoggingExportArgsDict(TypedDict):
        s3s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupLoggingExportS3ArgsDict']]]]
        """
        Exports your cluster's logs to the S3 bucket and subdir configured on the S3 data integration given.
        """
elif False:
    ElastigroupLoggingExportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupLoggingExportArgs:
    def __init__(__self__, *,
                 s3s: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupLoggingExportS3Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupLoggingExportS3Args']]] s3s: Exports your cluster's logs to the S3 bucket and subdir configured on the S3 data integration given.
        """
        if s3s is not None:
            pulumi.set(__self__, "s3s", s3s)

    @property
    @pulumi.getter
    def s3s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupLoggingExportS3Args']]]]:
        """
        Exports your cluster's logs to the S3 bucket and subdir configured on the S3 data integration given.
        """
        return pulumi.get(self, "s3s")

    @s3s.setter
    def s3s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupLoggingExportS3Args']]]]):
        pulumi.set(self, "s3s", value)


if not MYPY:
    class ElastigroupLoggingExportS3ArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The identifier of The S3 data integration to export the logs to.
        """
elif False:
    ElastigroupLoggingExportS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupLoggingExportS3Args:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The identifier of The S3 data integration to export the logs to.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The identifier of The S3 data integration to export the logs to.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ElastigroupMetadataOptionsArgsDict(TypedDict):
        http_tokens: pulumi.Input[str]
        """
        The state of token usage for your instance metadata requests. Valid values: `optional` or `required`.
        """
        http_put_response_hop_limit: NotRequired[pulumi.Input[int]]
        """
        The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values: Integers from `1` to `64`.
        """
        instance_metadata_tags: NotRequired[pulumi.Input[str]]
        """
        Indicates whether access to instance tags from the instance metadata is enabled or disabled. Cant be null.
        """
elif False:
    ElastigroupMetadataOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_tokens: pulumi.Input[str],
                 http_put_response_hop_limit: Optional[pulumi.Input[int]] = None,
                 instance_metadata_tags: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] http_tokens: The state of token usage for your instance metadata requests. Valid values: `optional` or `required`.
        :param pulumi.Input[int] http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values: Integers from `1` to `64`.
        :param pulumi.Input[str] instance_metadata_tags: Indicates whether access to instance tags from the instance metadata is enabled or disabled. Cant be null.
        """
        pulumi.set(__self__, "http_tokens", http_tokens)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if instance_metadata_tags is not None:
            pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> pulumi.Input[str]:
        """
        The state of token usage for your instance metadata requests. Valid values: `optional` or `required`.
        """
        return pulumi.get(self, "http_tokens")

    @http_tokens.setter
    def http_tokens(self, value: pulumi.Input[str]):
        pulumi.set(self, "http_tokens", value)

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[int]]:
        """
        The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Valid values: Integers from `1` to `64`.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_put_response_hop_limit", value)

    @property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates whether access to instance tags from the instance metadata is enabled or disabled. Cant be null.
        """
        return pulumi.get(self, "instance_metadata_tags")

    @instance_metadata_tags.setter
    def instance_metadata_tags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_metadata_tags", value)


if not MYPY:
    class ElastigroupMultipleMetricsArgsDict(TypedDict):
        expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupMultipleMetricsExpressionArgsDict']]]]
        """
        Array of objects (Expression config)
        """
        metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupMultipleMetricsMetricArgsDict']]]]
        """
        Array of objects (Metric config)
        """
elif False:
    ElastigroupMultipleMetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupMultipleMetricsArgs:
    def __init__(__self__, *,
                 expressions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupMultipleMetricsExpressionArgs']]]] = None,
                 metrics: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupMultipleMetricsMetricArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupMultipleMetricsExpressionArgs']]] expressions: Array of objects (Expression config)
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupMultipleMetricsMetricArgs']]] metrics: Array of objects (Metric config)
        """
        if expressions is not None:
            pulumi.set(__self__, "expressions", expressions)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)

    @property
    @pulumi.getter
    def expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupMultipleMetricsExpressionArgs']]]]:
        """
        Array of objects (Expression config)
        """
        return pulumi.get(self, "expressions")

    @expressions.setter
    def expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupMultipleMetricsExpressionArgs']]]]):
        pulumi.set(self, "expressions", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupMultipleMetricsMetricArgs']]]]:
        """
        Array of objects (Metric config)
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupMultipleMetricsMetricArgs']]]]):
        pulumi.set(self, "metrics", value)


if not MYPY:
    class ElastigroupMultipleMetricsExpressionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        """
        An expression consisting of the metric names listed in the 'metrics' array.
        """
        name: pulumi.Input[str]
        """
        The group name.
        """
elif False:
    ElastigroupMultipleMetricsExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupMultipleMetricsExpressionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: An expression consisting of the metric names listed in the 'metrics' array.
        :param pulumi.Input[str] name: The group name.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        An expression consisting of the metric names listed in the 'metrics' array.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The group name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ElastigroupMultipleMetricsMetricArgsDict(TypedDict):
        metric_name: pulumi.Input[str]
        name: pulumi.Input[str]
        """
        The group name.
        """
        namespace: pulumi.Input[str]
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupMultipleMetricsMetricDimensionArgsDict']]]]
        extended_statistic: NotRequired[pulumi.Input[str]]
        """
        Percentile statistic. Valid values: `"p0.1"` - `"p100"`.
        """
        statistic: NotRequired[pulumi.Input[str]]
        unit: NotRequired[pulumi.Input[str]]
elif False:
    ElastigroupMultipleMetricsMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupMultipleMetricsMetricArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupMultipleMetricsMetricDimensionArgs']]]] = None,
                 extended_statistic: Optional[pulumi.Input[str]] = None,
                 statistic: Optional[pulumi.Input[str]] = None,
                 unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The group name.
        :param pulumi.Input[str] extended_statistic: Percentile statistic. Valid values: `"p0.1"` - `"p100"`.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if extended_statistic is not None:
            pulumi.set(__self__, "extended_statistic", extended_statistic)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The group name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupMultipleMetricsMetricDimensionArgs']]]]:
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupMultipleMetricsMetricDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="extendedStatistic")
    def extended_statistic(self) -> Optional[pulumi.Input[str]]:
        """
        Percentile statistic. Valid values: `"p0.1"` - `"p100"`.
        """
        return pulumi.get(self, "extended_statistic")

    @extended_statistic.setter
    def extended_statistic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "extended_statistic", value)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statistic", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ElastigroupMultipleMetricsMetricDimensionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The group name.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    ElastigroupMultipleMetricsMetricDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupMultipleMetricsMetricDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The group name.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The group name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ElastigroupNetworkInterfaceArgsDict(TypedDict):
        device_index: pulumi.Input[str]
        """
        The index of the device on the instance for the network interface attachment.
        """
        associate_ipv6_address: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to assign IPV6 addresses to your instance. Requires a subnet with IPV6 CIDR block ranges.

        Usage:
        """
        associate_public_ip_address: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to assign a public IP address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one.
        """
        delete_on_termination: NotRequired[pulumi.Input[bool]]
        """
        If set to true, the interface is deleted when the instance is terminated.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the network interface.
        """
        network_interface_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the network interface.
        """
        private_ip_address: NotRequired[pulumi.Input[str]]
        """
        The private IP address of the network interface.
        """
        secondary_private_ip_address_count: NotRequired[pulumi.Input[str]]
        """
        The number of secondary private IP addresses.
        """
elif False:
    ElastigroupNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupNetworkInterfaceArgs:
    def __init__(__self__, *,
                 device_index: pulumi.Input[str],
                 associate_ipv6_address: Optional[pulumi.Input[bool]] = None,
                 associate_public_ip_address: Optional[pulumi.Input[bool]] = None,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 network_interface_id: Optional[pulumi.Input[str]] = None,
                 private_ip_address: Optional[pulumi.Input[str]] = None,
                 secondary_private_ip_address_count: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_index: The index of the device on the instance for the network interface attachment.
        :param pulumi.Input[bool] associate_ipv6_address: Indicates whether to assign IPV6 addresses to your instance. Requires a subnet with IPV6 CIDR block ranges.
               
               Usage:
        :param pulumi.Input[bool] associate_public_ip_address: Indicates whether to assign a public IP address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one.
        :param pulumi.Input[bool] delete_on_termination: If set to true, the interface is deleted when the instance is terminated.
        :param pulumi.Input[str] description: The description of the network interface.
        :param pulumi.Input[str] network_interface_id: The ID of the network interface.
        :param pulumi.Input[str] private_ip_address: The private IP address of the network interface.
        :param pulumi.Input[str] secondary_private_ip_address_count: The number of secondary private IP addresses.
        """
        pulumi.set(__self__, "device_index", device_index)
        if associate_ipv6_address is not None:
            pulumi.set(__self__, "associate_ipv6_address", associate_ipv6_address)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if secondary_private_ip_address_count is not None:
            pulumi.set(__self__, "secondary_private_ip_address_count", secondary_private_ip_address_count)

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> pulumi.Input[str]:
        """
        The index of the device on the instance for the network interface attachment.
        """
        return pulumi.get(self, "device_index")

    @device_index.setter
    def device_index(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_index", value)

    @property
    @pulumi.getter(name="associateIpv6Address")
    def associate_ipv6_address(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to assign IPV6 addresses to your instance. Requires a subnet with IPV6 CIDR block ranges.

        Usage:
        """
        return pulumi.get(self, "associate_ipv6_address")

    @associate_ipv6_address.setter
    def associate_ipv6_address(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "associate_ipv6_address", value)

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to assign a public IP address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one.
        """
        return pulumi.get(self, "associate_public_ip_address")

    @associate_public_ip_address.setter
    def associate_public_ip_address(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "associate_public_ip_address", value)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, the interface is deleted when the instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the network interface.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @network_interface_id.setter
    def network_interface_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_interface_id", value)

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The private IP address of the network interface.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip_address", value)

    @property
    @pulumi.getter(name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> Optional[pulumi.Input[str]]:
        """
        The number of secondary private IP addresses.
        """
        return pulumi.get(self, "secondary_private_ip_address_count")

    @secondary_private_ip_address_count.setter
    def secondary_private_ip_address_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_private_ip_address_count", value)


if not MYPY:
    class ElastigroupResourceRequirementArgsDict(TypedDict):
        required_memory_maximum: pulumi.Input[int]
        """
        Required maximum instance memory (<=512)
        """
        required_memory_minimum: pulumi.Input[int]
        """
        Required minimum instance memory (>=1)
        """
        required_vcpu_maximum: pulumi.Input[int]
        """
        Required maximum instance vCPU (<=64)
        """
        required_vcpu_minimum: pulumi.Input[int]
        """
        Required minimum instance vCPU (>=1)
        """
        excluded_instance_families: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Instance families to exclude
        """
        excluded_instance_generations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Instance generations to exclude
        """
        excluded_instance_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Instance types to exclude
        """
        required_gpu_maximum: NotRequired[pulumi.Input[int]]
        """
        Required maximum instance GPU (<=16)
        """
        required_gpu_minimum: NotRequired[pulumi.Input[int]]
        """
        Required minimum instance GPU (>=1)
        """
elif False:
    ElastigroupResourceRequirementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupResourceRequirementArgs:
    def __init__(__self__, *,
                 required_memory_maximum: pulumi.Input[int],
                 required_memory_minimum: pulumi.Input[int],
                 required_vcpu_maximum: pulumi.Input[int],
                 required_vcpu_minimum: pulumi.Input[int],
                 excluded_instance_families: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_instance_generations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_instance_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 required_gpu_maximum: Optional[pulumi.Input[int]] = None,
                 required_gpu_minimum: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] required_memory_maximum: Required maximum instance memory (<=512)
        :param pulumi.Input[int] required_memory_minimum: Required minimum instance memory (>=1)
        :param pulumi.Input[int] required_vcpu_maximum: Required maximum instance vCPU (<=64)
        :param pulumi.Input[int] required_vcpu_minimum: Required minimum instance vCPU (>=1)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_instance_families: Instance families to exclude
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_instance_generations: Instance generations to exclude
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_instance_types: Instance types to exclude
        :param pulumi.Input[int] required_gpu_maximum: Required maximum instance GPU (<=16)
        :param pulumi.Input[int] required_gpu_minimum: Required minimum instance GPU (>=1)
        """
        pulumi.set(__self__, "required_memory_maximum", required_memory_maximum)
        pulumi.set(__self__, "required_memory_minimum", required_memory_minimum)
        pulumi.set(__self__, "required_vcpu_maximum", required_vcpu_maximum)
        pulumi.set(__self__, "required_vcpu_minimum", required_vcpu_minimum)
        if excluded_instance_families is not None:
            pulumi.set(__self__, "excluded_instance_families", excluded_instance_families)
        if excluded_instance_generations is not None:
            pulumi.set(__self__, "excluded_instance_generations", excluded_instance_generations)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if required_gpu_maximum is not None:
            pulumi.set(__self__, "required_gpu_maximum", required_gpu_maximum)
        if required_gpu_minimum is not None:
            pulumi.set(__self__, "required_gpu_minimum", required_gpu_minimum)

    @property
    @pulumi.getter(name="requiredMemoryMaximum")
    def required_memory_maximum(self) -> pulumi.Input[int]:
        """
        Required maximum instance memory (<=512)
        """
        return pulumi.get(self, "required_memory_maximum")

    @required_memory_maximum.setter
    def required_memory_maximum(self, value: pulumi.Input[int]):
        pulumi.set(self, "required_memory_maximum", value)

    @property
    @pulumi.getter(name="requiredMemoryMinimum")
    def required_memory_minimum(self) -> pulumi.Input[int]:
        """
        Required minimum instance memory (>=1)
        """
        return pulumi.get(self, "required_memory_minimum")

    @required_memory_minimum.setter
    def required_memory_minimum(self, value: pulumi.Input[int]):
        pulumi.set(self, "required_memory_minimum", value)

    @property
    @pulumi.getter(name="requiredVcpuMaximum")
    def required_vcpu_maximum(self) -> pulumi.Input[int]:
        """
        Required maximum instance vCPU (<=64)
        """
        return pulumi.get(self, "required_vcpu_maximum")

    @required_vcpu_maximum.setter
    def required_vcpu_maximum(self, value: pulumi.Input[int]):
        pulumi.set(self, "required_vcpu_maximum", value)

    @property
    @pulumi.getter(name="requiredVcpuMinimum")
    def required_vcpu_minimum(self) -> pulumi.Input[int]:
        """
        Required minimum instance vCPU (>=1)
        """
        return pulumi.get(self, "required_vcpu_minimum")

    @required_vcpu_minimum.setter
    def required_vcpu_minimum(self, value: pulumi.Input[int]):
        pulumi.set(self, "required_vcpu_minimum", value)

    @property
    @pulumi.getter(name="excludedInstanceFamilies")
    def excluded_instance_families(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Instance families to exclude
        """
        return pulumi.get(self, "excluded_instance_families")

    @excluded_instance_families.setter
    def excluded_instance_families(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_instance_families", value)

    @property
    @pulumi.getter(name="excludedInstanceGenerations")
    def excluded_instance_generations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Instance generations to exclude
        """
        return pulumi.get(self, "excluded_instance_generations")

    @excluded_instance_generations.setter
    def excluded_instance_generations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_instance_generations", value)

    @property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Instance types to exclude
        """
        return pulumi.get(self, "excluded_instance_types")

    @excluded_instance_types.setter
    def excluded_instance_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_instance_types", value)

    @property
    @pulumi.getter(name="requiredGpuMaximum")
    def required_gpu_maximum(self) -> Optional[pulumi.Input[int]]:
        """
        Required maximum instance GPU (<=16)
        """
        return pulumi.get(self, "required_gpu_maximum")

    @required_gpu_maximum.setter
    def required_gpu_maximum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "required_gpu_maximum", value)

    @property
    @pulumi.getter(name="requiredGpuMinimum")
    def required_gpu_minimum(self) -> Optional[pulumi.Input[int]]:
        """
        Required minimum instance GPU (>=1)
        """
        return pulumi.get(self, "required_gpu_minimum")

    @required_gpu_minimum.setter
    def required_gpu_minimum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "required_gpu_minimum", value)


if not MYPY:
    class ElastigroupResourceTagSpecificationArgsDict(TypedDict):
        should_tag_amis: NotRequired[pulumi.Input[bool]]
        """
        Tag specification for AMI resources.
        """
        should_tag_enis: NotRequired[pulumi.Input[bool]]
        """
        Tag specification for ENI resources.
        """
        should_tag_snapshots: NotRequired[pulumi.Input[bool]]
        """
        Tag specification for Snapshot resources.
        """
        should_tag_volumes: NotRequired[pulumi.Input[bool]]
        """
        Tag specification for Volume resources.
        """
elif False:
    ElastigroupResourceTagSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupResourceTagSpecificationArgs:
    def __init__(__self__, *,
                 should_tag_amis: Optional[pulumi.Input[bool]] = None,
                 should_tag_enis: Optional[pulumi.Input[bool]] = None,
                 should_tag_snapshots: Optional[pulumi.Input[bool]] = None,
                 should_tag_volumes: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] should_tag_amis: Tag specification for AMI resources.
        :param pulumi.Input[bool] should_tag_enis: Tag specification for ENI resources.
        :param pulumi.Input[bool] should_tag_snapshots: Tag specification for Snapshot resources.
        :param pulumi.Input[bool] should_tag_volumes: Tag specification for Volume resources.
        """
        if should_tag_amis is not None:
            pulumi.set(__self__, "should_tag_amis", should_tag_amis)
        if should_tag_enis is not None:
            pulumi.set(__self__, "should_tag_enis", should_tag_enis)
        if should_tag_snapshots is not None:
            pulumi.set(__self__, "should_tag_snapshots", should_tag_snapshots)
        if should_tag_volumes is not None:
            pulumi.set(__self__, "should_tag_volumes", should_tag_volumes)

    @property
    @pulumi.getter(name="shouldTagAmis")
    def should_tag_amis(self) -> Optional[pulumi.Input[bool]]:
        """
        Tag specification for AMI resources.
        """
        return pulumi.get(self, "should_tag_amis")

    @should_tag_amis.setter
    def should_tag_amis(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_tag_amis", value)

    @property
    @pulumi.getter(name="shouldTagEnis")
    def should_tag_enis(self) -> Optional[pulumi.Input[bool]]:
        """
        Tag specification for ENI resources.
        """
        return pulumi.get(self, "should_tag_enis")

    @should_tag_enis.setter
    def should_tag_enis(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_tag_enis", value)

    @property
    @pulumi.getter(name="shouldTagSnapshots")
    def should_tag_snapshots(self) -> Optional[pulumi.Input[bool]]:
        """
        Tag specification for Snapshot resources.
        """
        return pulumi.get(self, "should_tag_snapshots")

    @should_tag_snapshots.setter
    def should_tag_snapshots(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_tag_snapshots", value)

    @property
    @pulumi.getter(name="shouldTagVolumes")
    def should_tag_volumes(self) -> Optional[pulumi.Input[bool]]:
        """
        Tag specification for Volume resources.
        """
        return pulumi.get(self, "should_tag_volumes")

    @should_tag_volumes.setter
    def should_tag_volumes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_tag_volumes", value)


if not MYPY:
    class ElastigroupRevertToSpotArgsDict(TypedDict):
        perform_at: pulumi.Input[str]
        """
        In the event of a fallback to On-Demand instances, select the time period to revert back to Spot. Supported Arguments  always (default), timeWindow, never. For timeWindow or never to be valid the group must have availabilityOriented OR persistence defined.
        """
        time_windows: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specify a list of time windows for to execute revertToSpot strategy. Time window format: `ddd:hh:mm-ddd:hh:mm`. Example: `Mon:03:00-Wed:02:30`
        """
elif False:
    ElastigroupRevertToSpotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupRevertToSpotArgs:
    def __init__(__self__, *,
                 perform_at: pulumi.Input[str],
                 time_windows: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] perform_at: In the event of a fallback to On-Demand instances, select the time period to revert back to Spot. Supported Arguments  always (default), timeWindow, never. For timeWindow or never to be valid the group must have availabilityOriented OR persistence defined.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] time_windows: Specify a list of time windows for to execute revertToSpot strategy. Time window format: `ddd:hh:mm-ddd:hh:mm`. Example: `Mon:03:00-Wed:02:30`
        """
        pulumi.set(__self__, "perform_at", perform_at)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)

    @property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> pulumi.Input[str]:
        """
        In the event of a fallback to On-Demand instances, select the time period to revert back to Spot. Supported Arguments  always (default), timeWindow, never. For timeWindow or never to be valid the group must have availabilityOriented OR persistence defined.
        """
        return pulumi.get(self, "perform_at")

    @perform_at.setter
    def perform_at(self, value: pulumi.Input[str]):
        pulumi.set(self, "perform_at", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify a list of time windows for to execute revertToSpot strategy. Time window format: `ddd:hh:mm-ddd:hh:mm`. Example: `Mon:03:00-Wed:02:30`
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "time_windows", value)


if not MYPY:
    class ElastigroupScalingDownPolicyArgsDict(TypedDict):
        metric_name: pulumi.Input[str]
        """
        The name of the metric, with or without spaces.
        """
        namespace: pulumi.Input[str]
        """
        The namespace for the alarm's associated metric.
        """
        policy_name: pulumi.Input[str]
        """
        The name of the policy.
        """
        action_type: NotRequired[pulumi.Input[str]]
        """
        The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`. If a `step_adjustment` object is defined, then it cannot be specified.
        """
        adjustment: NotRequired[pulumi.Input[str]]
        """
        The number of instances to add/remove to/from the target capacity when scale is needed. Can be used as advanced expression for scaling of instances to add/remove to/from the target capacity when scale is needed. You can see more information here: Advanced expression. Example value: `"MAX(currCapacity / 5, value * 10)"`
        """
        cooldown: NotRequired[pulumi.Input[int]]
        """
        The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
        """
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgsDict']]]]
        """
        A list of dimensions describing qualities of the metric.
        """
        evaluation_periods: NotRequired[pulumi.Input[int]]
        """
        The number of periods over which data is compared to the specified threshold.
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether the scaling policy described in this block is enabled.
        """
        max_target_capacity: NotRequired[pulumi.Input[str]]
        """
        . The number of the desired target (and maximum) capacity
        """
        maximum: NotRequired[pulumi.Input[str]]
        """
        The maximal number of instances to have in the group.
        """
        min_target_capacity: NotRequired[pulumi.Input[str]]
        minimum: NotRequired[pulumi.Input[str]]
        """
        The minimal number of instances to have in the group.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
        """
        period: NotRequired[pulumi.Input[int]]
        """
        The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
        """
        statistic: NotRequired[pulumi.Input[str]]
        """
        The metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
        """
        step_adjustments: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyStepAdjustmentArgsDict']]]]
        target: NotRequired[pulumi.Input[str]]
        """
        The target number of instances to have in the group.
        """
        threshold: NotRequired[pulumi.Input[float]]
        """
        The value against which the specified statistic is compared. If a `step_adjustment` object is defined, then it cannot be specified.
        """
        unit: NotRequired[pulumi.Input[str]]
        """
        The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
        """
elif False:
    ElastigroupScalingDownPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupScalingDownPolicyArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 policy_name: pulumi.Input[str],
                 action_type: Optional[pulumi.Input[str]] = None,
                 adjustment: Optional[pulumi.Input[str]] = None,
                 cooldown: Optional[pulumi.Input[int]] = None,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgs']]]] = None,
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 max_target_capacity: Optional[pulumi.Input[str]] = None,
                 maximum: Optional[pulumi.Input[str]] = None,
                 min_target_capacity: Optional[pulumi.Input[str]] = None,
                 minimum: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 statistic: Optional[pulumi.Input[str]] = None,
                 step_adjustments: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyStepAdjustmentArgs']]]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric_name: The name of the metric, with or without spaces.
        :param pulumi.Input[str] namespace: The namespace for the alarm's associated metric.
        :param pulumi.Input[str] policy_name: The name of the policy.
        :param pulumi.Input[str] action_type: The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`. If a `step_adjustment` object is defined, then it cannot be specified.
        :param pulumi.Input[str] adjustment: The number of instances to add/remove to/from the target capacity when scale is needed. Can be used as advanced expression for scaling of instances to add/remove to/from the target capacity when scale is needed. You can see more information here: Advanced expression. Example value: `"MAX(currCapacity / 5, value * 10)"`
        :param pulumi.Input[int] cooldown: The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgs']]] dimensions: A list of dimensions describing qualities of the metric.
        :param pulumi.Input[int] evaluation_periods: The number of periods over which data is compared to the specified threshold.
        :param pulumi.Input[bool] is_enabled: Specifies whether the scaling policy described in this block is enabled.
        :param pulumi.Input[str] max_target_capacity: . The number of the desired target (and maximum) capacity
        :param pulumi.Input[str] maximum: The maximal number of instances to have in the group.
        :param pulumi.Input[str] minimum: The minimal number of instances to have in the group.
        :param pulumi.Input[str] operator: The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
        :param pulumi.Input[int] period: The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
        :param pulumi.Input[str] source: The source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
        :param pulumi.Input[str] statistic: The metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
        :param pulumi.Input[str] target: The target number of instances to have in the group.
        :param pulumi.Input[float] threshold: The value against which the specified statistic is compared. If a `step_adjustment` object is defined, then it cannot be specified.
        :param pulumi.Input[str] unit: The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if step_adjustments is not None:
            pulumi.set(__self__, "step_adjustments", step_adjustments)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        The name of the metric, with or without spaces.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        The namespace for the alarm's associated metric.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> pulumi.Input[str]:
        """
        The name of the policy.
        """
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_name", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`. If a `step_adjustment` object is defined, then it cannot be specified.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[str]]:
        """
        The number of instances to add/remove to/from the target capacity when scale is needed. Can be used as advanced expression for scaling of instances to add/remove to/from the target capacity when scale is needed. You can see more information here: Advanced expression. Example value: `"MAX(currCapacity / 5, value * 10)"`
        """
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
        """
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgs']]]]:
        """
        A list of dimensions describing qualities of the metric.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        """
        The number of periods over which data is compared to the specified threshold.
        """
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the scaling policy described in this block is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        . The number of the desired target (and maximum) capacity
        """
        return pulumi.get(self, "max_target_capacity")

    @max_target_capacity.setter
    def max_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_target_capacity", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[str]]:
        """
        The maximal number of instances to have in the group.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "min_target_capacity")

    @min_target_capacity.setter
    def min_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_target_capacity", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[str]]:
        """
        The minimal number of instances to have in the group.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        """
        The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input[str]]:
        """
        The metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
        """
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statistic", value)

    @property
    @pulumi.getter(name="stepAdjustments")
    def step_adjustments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyStepAdjustmentArgs']]]]:
        return pulumi.get(self, "step_adjustments")

    @step_adjustments.setter
    def step_adjustments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingDownPolicyStepAdjustmentArgs']]]]):
        pulumi.set(self, "step_adjustments", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        The target number of instances to have in the group.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The value against which the specified statistic is compared. If a `step_adjustment` object is defined, then it cannot be specified.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        """
        The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ElastigroupScalingDownPolicyDimensionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The dimension name.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The dimension value.
        """
elif False:
    ElastigroupScalingDownPolicyDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupScalingDownPolicyDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The dimension name.
        :param pulumi.Input[str] value: The dimension value.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The dimension name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The dimension value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ElastigroupScalingDownPolicyStepAdjustmentArgsDict(TypedDict):
        action: pulumi.Input['ElastigroupScalingDownPolicyStepAdjustmentActionArgsDict']
        threshold: pulumi.Input[int]
elif False:
    ElastigroupScalingDownPolicyStepAdjustmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupScalingDownPolicyStepAdjustmentArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['ElastigroupScalingDownPolicyStepAdjustmentActionArgs'],
                 threshold: pulumi.Input[int]):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['ElastigroupScalingDownPolicyStepAdjustmentActionArgs']:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['ElastigroupScalingDownPolicyStepAdjustmentActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[int]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class ElastigroupScalingDownPolicyStepAdjustmentActionArgsDict(TypedDict):
        type: pulumi.Input[str]
        adjustment: NotRequired[pulumi.Input[str]]
        max_target_capacity: NotRequired[pulumi.Input[str]]
        maximum: NotRequired[pulumi.Input[str]]
        min_target_capacity: NotRequired[pulumi.Input[str]]
        minimum: NotRequired[pulumi.Input[str]]
        target: NotRequired[pulumi.Input[str]]
elif False:
    ElastigroupScalingDownPolicyStepAdjustmentActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupScalingDownPolicyStepAdjustmentActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 adjustment: Optional[pulumi.Input[str]] = None,
                 max_target_capacity: Optional[pulumi.Input[str]] = None,
                 maximum: Optional[pulumi.Input[str]] = None,
                 min_target_capacity: Optional[pulumi.Input[str]] = None,
                 minimum: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "type", type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_target_capacity")

    @max_target_capacity.setter
    def max_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_target_capacity", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "min_target_capacity")

    @min_target_capacity.setter
    def min_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_target_capacity", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class ElastigroupScalingStrategyArgsDict(TypedDict):
        terminate_at_end_of_billing_hour: NotRequired[pulumi.Input[bool]]
        """
        Specify whether to terminate instances at the end of each billing hour.
        """
        termination_policy: NotRequired[pulumi.Input[str]]
        """
        Determines whether to terminate the newest instances when performing a scaling action. Valid values: `"default"`, `"newestInstance"`.
        """
elif False:
    ElastigroupScalingStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupScalingStrategyArgs:
    def __init__(__self__, *,
                 terminate_at_end_of_billing_hour: Optional[pulumi.Input[bool]] = None,
                 termination_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] terminate_at_end_of_billing_hour: Specify whether to terminate instances at the end of each billing hour.
        :param pulumi.Input[str] termination_policy: Determines whether to terminate the newest instances when performing a scaling action. Valid values: `"default"`, `"newestInstance"`.
        """
        if terminate_at_end_of_billing_hour is not None:
            pulumi.set(__self__, "terminate_at_end_of_billing_hour", terminate_at_end_of_billing_hour)
        if termination_policy is not None:
            pulumi.set(__self__, "termination_policy", termination_policy)

    @property
    @pulumi.getter(name="terminateAtEndOfBillingHour")
    def terminate_at_end_of_billing_hour(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify whether to terminate instances at the end of each billing hour.
        """
        return pulumi.get(self, "terminate_at_end_of_billing_hour")

    @terminate_at_end_of_billing_hour.setter
    def terminate_at_end_of_billing_hour(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "terminate_at_end_of_billing_hour", value)

    @property
    @pulumi.getter(name="terminationPolicy")
    def termination_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Determines whether to terminate the newest instances when performing a scaling action. Valid values: `"default"`, `"newestInstance"`.
        """
        return pulumi.get(self, "termination_policy")

    @termination_policy.setter
    def termination_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "termination_policy", value)


if not MYPY:
    class ElastigroupScalingTargetPolicyArgsDict(TypedDict):
        metric_name: pulumi.Input[str]
        """
        String, the name of the metric, with or without spaces.
        """
        namespace: pulumi.Input[str]
        """
        String, the namespace for the alarm's associated metric.
        """
        policy_name: pulumi.Input[str]
        """
        String, the name of the policy.
        """
        target: pulumi.Input[float]
        """
        The target number of instances to have in the group.
        """
        cooldown: NotRequired[pulumi.Input[int]]
        """
        Integer the amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
        """
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingTargetPolicyDimensionArgsDict']]]]
        """
        A list of dimensions describing qualities of the metric.
        """
        evaluation_periods: NotRequired[pulumi.Input[int]]
        """
        The number of periods over which data is compared to the specified threshold.
        """
        max_capacity_per_scale: NotRequired[pulumi.Input[str]]
        """
        String, restrict the maximal number of instances which can be added in each scale-up action.

        `scaling_target_policies` support predictive scaling:
        """
        period: NotRequired[pulumi.Input[int]]
        """
        The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
        """
        predictive_mode: NotRequired[pulumi.Input[str]]
        """
        Start a metric prediction process to determine the expected target metric value within the next two days. See [Predictive Autoscaling](https://api.spotinst.com/elastigroup-for-aws/concepts/scaling-concepts/predictive-autoscaling/) documentation for more info. Valid values: `FORECAST_AND_SCALE`, `FORECAST_ONLY`.

        Usage:
        """
        source: NotRequired[pulumi.Input[str]]
        """
        String, the source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
        """
        statistic: NotRequired[pulumi.Input[str]]
        """
        String, the metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
        """
        unit: NotRequired[pulumi.Input[str]]
        """
        String, tThe unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
        """
elif False:
    ElastigroupScalingTargetPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupScalingTargetPolicyArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 policy_name: pulumi.Input[str],
                 target: pulumi.Input[float],
                 cooldown: Optional[pulumi.Input[int]] = None,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingTargetPolicyDimensionArgs']]]] = None,
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 max_capacity_per_scale: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 predictive_mode: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 statistic: Optional[pulumi.Input[str]] = None,
                 unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric_name: String, the name of the metric, with or without spaces.
        :param pulumi.Input[str] namespace: String, the namespace for the alarm's associated metric.
        :param pulumi.Input[str] policy_name: String, the name of the policy.
        :param pulumi.Input[float] target: The target number of instances to have in the group.
        :param pulumi.Input[int] cooldown: Integer the amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingTargetPolicyDimensionArgs']]] dimensions: A list of dimensions describing qualities of the metric.
        :param pulumi.Input[int] evaluation_periods: The number of periods over which data is compared to the specified threshold.
        :param pulumi.Input[str] max_capacity_per_scale: String, restrict the maximal number of instances which can be added in each scale-up action.
               
               `scaling_target_policies` support predictive scaling:
        :param pulumi.Input[int] period: The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
        :param pulumi.Input[str] predictive_mode: Start a metric prediction process to determine the expected target metric value within the next two days. See [Predictive Autoscaling](https://api.spotinst.com/elastigroup-for-aws/concepts/scaling-concepts/predictive-autoscaling/) documentation for more info. Valid values: `FORECAST_AND_SCALE`, `FORECAST_ONLY`.
               
               Usage:
        :param pulumi.Input[str] source: String, the source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
        :param pulumi.Input[str] statistic: String, the metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
        :param pulumi.Input[str] unit: String, tThe unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "target", target)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_capacity_per_scale is not None:
            pulumi.set(__self__, "max_capacity_per_scale", max_capacity_per_scale)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if predictive_mode is not None:
            pulumi.set(__self__, "predictive_mode", predictive_mode)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        String, the name of the metric, with or without spaces.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        String, the namespace for the alarm's associated metric.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> pulumi.Input[str]:
        """
        String, the name of the policy.
        """
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_name", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[float]:
        """
        The target number of instances to have in the group.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[float]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[int]]:
        """
        Integer the amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
        """
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingTargetPolicyDimensionArgs']]]]:
        """
        A list of dimensions describing qualities of the metric.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingTargetPolicyDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        """
        The number of periods over which data is compared to the specified threshold.
        """
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter(name="maxCapacityPerScale")
    def max_capacity_per_scale(self) -> Optional[pulumi.Input[str]]:
        """
        String, restrict the maximal number of instances which can be added in each scale-up action.

        `scaling_target_policies` support predictive scaling:
        """
        return pulumi.get(self, "max_capacity_per_scale")

    @max_capacity_per_scale.setter
    def max_capacity_per_scale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_capacity_per_scale", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        """
        The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="predictiveMode")
    def predictive_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Start a metric prediction process to determine the expected target metric value within the next two days. See [Predictive Autoscaling](https://api.spotinst.com/elastigroup-for-aws/concepts/scaling-concepts/predictive-autoscaling/) documentation for more info. Valid values: `FORECAST_AND_SCALE`, `FORECAST_ONLY`.

        Usage:
        """
        return pulumi.get(self, "predictive_mode")

    @predictive_mode.setter
    def predictive_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "predictive_mode", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        String, the source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input[str]]:
        """
        String, the metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
        """
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statistic", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        """
        String, tThe unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ElastigroupScalingTargetPolicyDimensionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        String, the dimension name.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        String, the dimension value.
        """
elif False:
    ElastigroupScalingTargetPolicyDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupScalingTargetPolicyDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: String, the dimension name.
        :param pulumi.Input[str] value: String, the dimension value.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        String, the dimension name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        String, the dimension value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ElastigroupScalingUpPolicyArgsDict(TypedDict):
        metric_name: pulumi.Input[str]
        """
        The name of the metric, with or without spaces.
        """
        namespace: pulumi.Input[str]
        """
        The namespace for the alarm's associated metric.
        """
        policy_name: pulumi.Input[str]
        """
        The name of the policy.
        """
        action_type: NotRequired[pulumi.Input[str]]
        """
        The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`. If a `step_adjustment` object is defined, then it cannot be specified.
        """
        adjustment: NotRequired[pulumi.Input[str]]
        """
        The number of instances to add/remove to/from the target capacity when scale is needed. Can be used as advanced expression for scaling of instances to add/remove to/from the target capacity when scale is needed. You can see more information here: Advanced expression. Example value: `"MAX(currCapacity / 5, value * 10)"`
        """
        cooldown: NotRequired[pulumi.Input[int]]
        """
        The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
        """
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgsDict']]]]
        """
        A list of dimensions describing qualities of the metric.
        """
        evaluation_periods: NotRequired[pulumi.Input[int]]
        """
        The number of periods over which data is compared to the specified threshold.
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether the scaling policy described in this block is enabled.
        """
        max_target_capacity: NotRequired[pulumi.Input[str]]
        maximum: NotRequired[pulumi.Input[str]]
        """
        The maximal number of instances to have in the group.
        """
        min_target_capacity: NotRequired[pulumi.Input[str]]
        """
        . The number of the desired target (and minimum) capacity
        """
        minimum: NotRequired[pulumi.Input[str]]
        """
        The minimal number of instances to have in the group.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
        """
        period: NotRequired[pulumi.Input[int]]
        """
        The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
        """
        statistic: NotRequired[pulumi.Input[str]]
        """
        The metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
        """
        step_adjustments: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyStepAdjustmentArgsDict']]]]
        target: NotRequired[pulumi.Input[str]]
        """
        The target number of instances to have in the group.
        """
        threshold: NotRequired[pulumi.Input[float]]
        """
        The value against which the specified statistic is compared. If a `step_adjustment` object is defined, then it cannot be specified.
        """
        unit: NotRequired[pulumi.Input[str]]
        """
        The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
        """
elif False:
    ElastigroupScalingUpPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupScalingUpPolicyArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 policy_name: pulumi.Input[str],
                 action_type: Optional[pulumi.Input[str]] = None,
                 adjustment: Optional[pulumi.Input[str]] = None,
                 cooldown: Optional[pulumi.Input[int]] = None,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgs']]]] = None,
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 max_target_capacity: Optional[pulumi.Input[str]] = None,
                 maximum: Optional[pulumi.Input[str]] = None,
                 min_target_capacity: Optional[pulumi.Input[str]] = None,
                 minimum: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 statistic: Optional[pulumi.Input[str]] = None,
                 step_adjustments: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyStepAdjustmentArgs']]]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric_name: The name of the metric, with or without spaces.
        :param pulumi.Input[str] namespace: The namespace for the alarm's associated metric.
        :param pulumi.Input[str] policy_name: The name of the policy.
        :param pulumi.Input[str] action_type: The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`. If a `step_adjustment` object is defined, then it cannot be specified.
        :param pulumi.Input[str] adjustment: The number of instances to add/remove to/from the target capacity when scale is needed. Can be used as advanced expression for scaling of instances to add/remove to/from the target capacity when scale is needed. You can see more information here: Advanced expression. Example value: `"MAX(currCapacity / 5, value * 10)"`
        :param pulumi.Input[int] cooldown: The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
        :param pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgs']]] dimensions: A list of dimensions describing qualities of the metric.
        :param pulumi.Input[int] evaluation_periods: The number of periods over which data is compared to the specified threshold.
        :param pulumi.Input[bool] is_enabled: Specifies whether the scaling policy described in this block is enabled.
        :param pulumi.Input[str] maximum: The maximal number of instances to have in the group.
        :param pulumi.Input[str] min_target_capacity: . The number of the desired target (and minimum) capacity
        :param pulumi.Input[str] minimum: The minimal number of instances to have in the group.
        :param pulumi.Input[str] operator: The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
        :param pulumi.Input[int] period: The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
        :param pulumi.Input[str] source: The source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
        :param pulumi.Input[str] statistic: The metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
        :param pulumi.Input[str] target: The target number of instances to have in the group.
        :param pulumi.Input[float] threshold: The value against which the specified statistic is compared. If a `step_adjustment` object is defined, then it cannot be specified.
        :param pulumi.Input[str] unit: The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if step_adjustments is not None:
            pulumi.set(__self__, "step_adjustments", step_adjustments)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        The name of the metric, with or without spaces.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        The namespace for the alarm's associated metric.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> pulumi.Input[str]:
        """
        The name of the policy.
        """
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_name", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of action to perform for scaling. Valid values: `"adjustment"`, `"percentageAdjustment"`, `"setMaxTarget"`, `"setMinTarget"`, `"updateCapacity"`. If a `step_adjustment` object is defined, then it cannot be specified.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[str]]:
        """
        The number of instances to add/remove to/from the target capacity when scale is needed. Can be used as advanced expression for scaling of instances to add/remove to/from the target capacity when scale is needed. You can see more information here: Advanced expression. Example value: `"MAX(currCapacity / 5, value * 10)"`
        """
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start. If this parameter is not specified, the default cooldown period for the group applies.
        """
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgs']]]]:
        """
        A list of dimensions describing qualities of the metric.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        """
        The number of periods over which data is compared to the specified threshold.
        """
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the scaling policy described in this block is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_target_capacity")

    @max_target_capacity.setter
    def max_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_target_capacity", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[str]]:
        """
        The maximal number of instances to have in the group.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        . The number of the desired target (and minimum) capacity
        """
        return pulumi.get(self, "min_target_capacity")

    @min_target_capacity.setter
    def min_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_target_capacity", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[str]]:
        """
        The minimal number of instances to have in the group.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use in order to determine if the scaling policy is applicable. Valid values: `"gt"`, `"gte"`, `"lt"`, `"lte"`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        """
        The granularity, in seconds, of the returned datapoints. Period must be at least 60 seconds and must be a multiple of 60.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The source of the metric. Valid values: `"cloudWatch"`, `"spectrum"`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input[str]]:
        """
        The metric statistics to return. For information about specific statistics go to [Statistics](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/index.html?CHAP_TerminologyandKeyConcepts.html#Statistic) in the Amazon CloudWatch Developer Guide.
        """
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statistic", value)

    @property
    @pulumi.getter(name="stepAdjustments")
    def step_adjustments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyStepAdjustmentArgs']]]]:
        return pulumi.get(self, "step_adjustments")

    @step_adjustments.setter
    def step_adjustments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElastigroupScalingUpPolicyStepAdjustmentArgs']]]]):
        pulumi.set(self, "step_adjustments", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        The target number of instances to have in the group.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The value against which the specified statistic is compared. If a `step_adjustment` object is defined, then it cannot be specified.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        """
        The unit for the alarm's associated metric. Valid values: `"percent`, `"seconds"`, `"microseconds"`, `"milliseconds"`, `"bytes"`, `"kilobytes"`, `"megabytes"`, `"gigabytes"`, `"terabytes"`, `"bits"`, `"kilobits"`, `"megabits"`, `"gigabits"`, `"terabits"`, `"count"`, `"bytes/second"`, `"kilobytes/second"`, `"megabytes/second"`, `"gigabytes/second"`, `"terabytes/second"`, `"bits/second"`, `"kilobits/second"`, `"megabits/second"`, `"gigabits/second"`, `"terabits/second"`, `"count/second"`, `"none"`.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ElastigroupScalingUpPolicyDimensionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The dimension name.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The dimension value.
        """
elif False:
    ElastigroupScalingUpPolicyDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupScalingUpPolicyDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The dimension name.
        :param pulumi.Input[str] value: The dimension value.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The dimension name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The dimension value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ElastigroupScalingUpPolicyStepAdjustmentArgsDict(TypedDict):
        action: pulumi.Input['ElastigroupScalingUpPolicyStepAdjustmentActionArgsDict']
        threshold: pulumi.Input[int]
elif False:
    ElastigroupScalingUpPolicyStepAdjustmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupScalingUpPolicyStepAdjustmentArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['ElastigroupScalingUpPolicyStepAdjustmentActionArgs'],
                 threshold: pulumi.Input[int]):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['ElastigroupScalingUpPolicyStepAdjustmentActionArgs']:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['ElastigroupScalingUpPolicyStepAdjustmentActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[int]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class ElastigroupScalingUpPolicyStepAdjustmentActionArgsDict(TypedDict):
        type: pulumi.Input[str]
        adjustment: NotRequired[pulumi.Input[str]]
        max_target_capacity: NotRequired[pulumi.Input[str]]
        maximum: NotRequired[pulumi.Input[str]]
        min_target_capacity: NotRequired[pulumi.Input[str]]
        minimum: NotRequired[pulumi.Input[str]]
        target: NotRequired[pulumi.Input[str]]
elif False:
    ElastigroupScalingUpPolicyStepAdjustmentActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupScalingUpPolicyStepAdjustmentActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 adjustment: Optional[pulumi.Input[str]] = None,
                 max_target_capacity: Optional[pulumi.Input[str]] = None,
                 maximum: Optional[pulumi.Input[str]] = None,
                 min_target_capacity: Optional[pulumi.Input[str]] = None,
                 minimum: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "type", type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_target_capacity")

    @max_target_capacity.setter
    def max_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_target_capacity", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "min_target_capacity")

    @min_target_capacity.setter
    def min_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_target_capacity", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class ElastigroupScheduledTaskArgsDict(TypedDict):
        task_type: pulumi.Input[str]
        """
        The task type to run. Supported task types are: `"scale"`, `"backup_ami"`, `"roll"`, `"scaleUp"`, `"percentageScaleUp"`, `"scaleDown"`, `"percentageScaleDown"`, `"statefulUpdateCapacity"`.
        """
        adjustment: NotRequired[pulumi.Input[str]]
        """
        The number of instances to add or remove.
        """
        adjustment_percentage: NotRequired[pulumi.Input[str]]
        """
        The percentage of instances to add or remove.

        Usage:
        """
        batch_size_percentage: NotRequired[pulumi.Input[str]]
        """
        The percentage size of each batch in the scheduled deployment roll.
        """
        cron_expression: NotRequired[pulumi.Input[str]]
        """
        A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
        """
        frequency: NotRequired[pulumi.Input[str]]
        """
        The recurrence frequency to run this task. Supported values are `"hourly"`, `"daily"`, `"weekly"` and `"continuous"`.
        """
        grace_period: NotRequired[pulumi.Input[str]]
        """
        The period of time (seconds) to wait before checking a batch's health after it's deployment.
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Setting the task to being enabled or disabled.
        """
        max_capacity: NotRequired[pulumi.Input[str]]
        """
        The maximum number of instances the group should have.
        """
        min_capacity: NotRequired[pulumi.Input[str]]
        """
        The minimum number of instances the group should have.
        """
        scale_max_capacity: NotRequired[pulumi.Input[str]]
        """
        The maximum number of instances the group should have.
        """
        scale_min_capacity: NotRequired[pulumi.Input[str]]
        """
        The minimum number of instances the group should have.
        """
        scale_target_capacity: NotRequired[pulumi.Input[str]]
        """
        The desired number of instances the group should have.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        Set a start time for one time tasks.
        """
        target_capacity: NotRequired[pulumi.Input[str]]
        """
        The desired number of instances the group should have.
        """
elif False:
    ElastigroupScheduledTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupScheduledTaskArgs:
    def __init__(__self__, *,
                 task_type: pulumi.Input[str],
                 adjustment: Optional[pulumi.Input[str]] = None,
                 adjustment_percentage: Optional[pulumi.Input[str]] = None,
                 batch_size_percentage: Optional[pulumi.Input[str]] = None,
                 cron_expression: Optional[pulumi.Input[str]] = None,
                 frequency: Optional[pulumi.Input[str]] = None,
                 grace_period: Optional[pulumi.Input[str]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 max_capacity: Optional[pulumi.Input[str]] = None,
                 min_capacity: Optional[pulumi.Input[str]] = None,
                 scale_max_capacity: Optional[pulumi.Input[str]] = None,
                 scale_min_capacity: Optional[pulumi.Input[str]] = None,
                 scale_target_capacity: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 target_capacity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] task_type: The task type to run. Supported task types are: `"scale"`, `"backup_ami"`, `"roll"`, `"scaleUp"`, `"percentageScaleUp"`, `"scaleDown"`, `"percentageScaleDown"`, `"statefulUpdateCapacity"`.
        :param pulumi.Input[str] adjustment: The number of instances to add or remove.
        :param pulumi.Input[str] adjustment_percentage: The percentage of instances to add or remove.
               
               Usage:
        :param pulumi.Input[str] batch_size_percentage: The percentage size of each batch in the scheduled deployment roll.
        :param pulumi.Input[str] cron_expression: A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
        :param pulumi.Input[str] frequency: The recurrence frequency to run this task. Supported values are `"hourly"`, `"daily"`, `"weekly"` and `"continuous"`.
        :param pulumi.Input[str] grace_period: The period of time (seconds) to wait before checking a batch's health after it's deployment.
        :param pulumi.Input[bool] is_enabled: Setting the task to being enabled or disabled.
        :param pulumi.Input[str] max_capacity: The maximum number of instances the group should have.
        :param pulumi.Input[str] min_capacity: The minimum number of instances the group should have.
        :param pulumi.Input[str] scale_max_capacity: The maximum number of instances the group should have.
        :param pulumi.Input[str] scale_min_capacity: The minimum number of instances the group should have.
        :param pulumi.Input[str] scale_target_capacity: The desired number of instances the group should have.
        :param pulumi.Input[str] start_time: Set a start time for one time tasks.
        :param pulumi.Input[str] target_capacity: The desired number of instances the group should have.
        """
        pulumi.set(__self__, "task_type", task_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if adjustment_percentage is not None:
            pulumi.set(__self__, "adjustment_percentage", adjustment_percentage)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if min_capacity is not None:
            pulumi.set(__self__, "min_capacity", min_capacity)
        if scale_max_capacity is not None:
            pulumi.set(__self__, "scale_max_capacity", scale_max_capacity)
        if scale_min_capacity is not None:
            pulumi.set(__self__, "scale_min_capacity", scale_min_capacity)
        if scale_target_capacity is not None:
            pulumi.set(__self__, "scale_target_capacity", scale_target_capacity)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if target_capacity is not None:
            pulumi.set(__self__, "target_capacity", target_capacity)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input[str]:
        """
        The task type to run. Supported task types are: `"scale"`, `"backup_ami"`, `"roll"`, `"scaleUp"`, `"percentageScaleUp"`, `"scaleDown"`, `"percentageScaleDown"`, `"statefulUpdateCapacity"`.
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_type", value)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[str]]:
        """
        The number of instances to add or remove.
        """
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter(name="adjustmentPercentage")
    def adjustment_percentage(self) -> Optional[pulumi.Input[str]]:
        """
        The percentage of instances to add or remove.

        Usage:
        """
        return pulumi.get(self, "adjustment_percentage")

    @adjustment_percentage.setter
    def adjustment_percentage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adjustment_percentage", value)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[pulumi.Input[str]]:
        """
        The percentage size of each batch in the scheduled deployment roll.
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[str]]:
        """
        A valid cron expression. The cron is running in UTC time zone and is in [Unix cron format](https://en.wikipedia.org/wiki/Cron).
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[str]]:
        """
        The recurrence frequency to run this task. Supported values are `"hourly"`, `"daily"`, `"weekly"` and `"continuous"`.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[str]]:
        """
        The period of time (seconds) to wait before checking a batch's health after it's deployment.
        """
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "grace_period", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting the task to being enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum number of instances the group should have.
        """
        return pulumi.get(self, "max_capacity")

    @max_capacity.setter
    def max_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_capacity", value)

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum number of instances the group should have.
        """
        return pulumi.get(self, "min_capacity")

    @min_capacity.setter
    def min_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_capacity", value)

    @property
    @pulumi.getter(name="scaleMaxCapacity")
    def scale_max_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum number of instances the group should have.
        """
        return pulumi.get(self, "scale_max_capacity")

    @scale_max_capacity.setter
    def scale_max_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale_max_capacity", value)

    @property
    @pulumi.getter(name="scaleMinCapacity")
    def scale_min_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum number of instances the group should have.
        """
        return pulumi.get(self, "scale_min_capacity")

    @scale_min_capacity.setter
    def scale_min_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale_min_capacity", value)

    @property
    @pulumi.getter(name="scaleTargetCapacity")
    def scale_target_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The desired number of instances the group should have.
        """
        return pulumi.get(self, "scale_target_capacity")

    @scale_target_capacity.setter
    def scale_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale_target_capacity", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Set a start time for one time tasks.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="targetCapacity")
    def target_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        The desired number of instances the group should have.
        """
        return pulumi.get(self, "target_capacity")

    @target_capacity.setter
    def target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_capacity", value)


if not MYPY:
    class ElastigroupSignalArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the signal defined for the group. Valid Values: `"INSTANCE_READY"`, `"INSTANCE_READY_TO_SHUTDOWN"`
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        The signals defined timeout- default is 40 minutes (1800 seconds).

        Usage:
        """
elif False:
    ElastigroupSignalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupSignalArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: The name of the signal defined for the group. Valid Values: `"INSTANCE_READY"`, `"INSTANCE_READY_TO_SHUTDOWN"`
        :param pulumi.Input[int] timeout: The signals defined timeout- default is 40 minutes (1800 seconds).
               
               Usage:
        """
        pulumi.set(__self__, "name", name)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the signal defined for the group. Valid Values: `"INSTANCE_READY"`, `"INSTANCE_READY_TO_SHUTDOWN"`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The signals defined timeout- default is 40 minutes (1800 seconds).

        Usage:
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ElastigroupStatefulDeallocationArgsDict(TypedDict):
        should_delete_images: NotRequired[pulumi.Input[bool]]
        """
        For stateful groups: remove persistent images.
        """
        should_delete_network_interfaces: NotRequired[pulumi.Input[bool]]
        """
        For stateful groups: remove network interfaces.
        """
        should_delete_snapshots: NotRequired[pulumi.Input[bool]]
        """
        For stateful groups: remove snapshots.

        Usage:
        """
        should_delete_volumes: NotRequired[pulumi.Input[bool]]
        """
        For stateful groups: remove persistent volumes.
        """
elif False:
    ElastigroupStatefulDeallocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupStatefulDeallocationArgs:
    def __init__(__self__, *,
                 should_delete_images: Optional[pulumi.Input[bool]] = None,
                 should_delete_network_interfaces: Optional[pulumi.Input[bool]] = None,
                 should_delete_snapshots: Optional[pulumi.Input[bool]] = None,
                 should_delete_volumes: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] should_delete_images: For stateful groups: remove persistent images.
        :param pulumi.Input[bool] should_delete_network_interfaces: For stateful groups: remove network interfaces.
        :param pulumi.Input[bool] should_delete_snapshots: For stateful groups: remove snapshots.
               
               Usage:
        :param pulumi.Input[bool] should_delete_volumes: For stateful groups: remove persistent volumes.
        """
        if should_delete_images is not None:
            pulumi.set(__self__, "should_delete_images", should_delete_images)
        if should_delete_network_interfaces is not None:
            pulumi.set(__self__, "should_delete_network_interfaces", should_delete_network_interfaces)
        if should_delete_snapshots is not None:
            pulumi.set(__self__, "should_delete_snapshots", should_delete_snapshots)
        if should_delete_volumes is not None:
            pulumi.set(__self__, "should_delete_volumes", should_delete_volumes)

    @property
    @pulumi.getter(name="shouldDeleteImages")
    def should_delete_images(self) -> Optional[pulumi.Input[bool]]:
        """
        For stateful groups: remove persistent images.
        """
        return pulumi.get(self, "should_delete_images")

    @should_delete_images.setter
    def should_delete_images(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_delete_images", value)

    @property
    @pulumi.getter(name="shouldDeleteNetworkInterfaces")
    def should_delete_network_interfaces(self) -> Optional[pulumi.Input[bool]]:
        """
        For stateful groups: remove network interfaces.
        """
        return pulumi.get(self, "should_delete_network_interfaces")

    @should_delete_network_interfaces.setter
    def should_delete_network_interfaces(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_delete_network_interfaces", value)

    @property
    @pulumi.getter(name="shouldDeleteSnapshots")
    def should_delete_snapshots(self) -> Optional[pulumi.Input[bool]]:
        """
        For stateful groups: remove snapshots.

        Usage:
        """
        return pulumi.get(self, "should_delete_snapshots")

    @should_delete_snapshots.setter
    def should_delete_snapshots(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_delete_snapshots", value)

    @property
    @pulumi.getter(name="shouldDeleteVolumes")
    def should_delete_volumes(self) -> Optional[pulumi.Input[bool]]:
        """
        For stateful groups: remove persistent volumes.
        """
        return pulumi.get(self, "should_delete_volumes")

    @should_delete_volumes.setter
    def should_delete_volumes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_delete_volumes", value)


if not MYPY:
    class ElastigroupStatefulInstanceActionArgsDict(TypedDict):
        stateful_instance_id: pulumi.Input[str]
        """
        String, Stateful Instance ID on which the action should be performed.
        """
        type: pulumi.Input[str]
        """
        String, Action type. Supported action types: `pause`, `resume`, `recycle`, `deallocate`.

        Usage:
        """
elif False:
    ElastigroupStatefulInstanceActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupStatefulInstanceActionArgs:
    def __init__(__self__, *,
                 stateful_instance_id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] stateful_instance_id: String, Stateful Instance ID on which the action should be performed.
        :param pulumi.Input[str] type: String, Action type. Supported action types: `pause`, `resume`, `recycle`, `deallocate`.
               
               Usage:
        """
        pulumi.set(__self__, "stateful_instance_id", stateful_instance_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="statefulInstanceId")
    def stateful_instance_id(self) -> pulumi.Input[str]:
        """
        String, Stateful Instance ID on which the action should be performed.
        """
        return pulumi.get(self, "stateful_instance_id")

    @stateful_instance_id.setter
    def stateful_instance_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "stateful_instance_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        String, Action type. Supported action types: `pause`, `resume`, `recycle`, `deallocate`.

        Usage:
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ElastigroupTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    ElastigroupTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ElastigroupUpdatePolicyArgsDict(TypedDict):
        should_resume_stateful: pulumi.Input[bool]
        """
        This will apply resuming action for Stateful instances in the Elastigroup upon scale up or capacity changes. Example usage will be for Elastigroups that will have scheduling rules to set a target capacity of 0 instances in the night and automatically restore the same state of the instances in the morning.
        """
        should_roll: pulumi.Input[bool]
        """
        Sets the enablement of the roll option.
        """
        auto_apply_tags: NotRequired[pulumi.Input[bool]]
        """
        Enables updates to tags without rolling the group when set to `true`.
        """
        roll_config: NotRequired[pulumi.Input['ElastigroupUpdatePolicyRollConfigArgsDict']]
        """
        While used, you can control whether the group should perform a deployment after an update to the configuration.
        """
elif False:
    ElastigroupUpdatePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupUpdatePolicyArgs:
    def __init__(__self__, *,
                 should_resume_stateful: pulumi.Input[bool],
                 should_roll: pulumi.Input[bool],
                 auto_apply_tags: Optional[pulumi.Input[bool]] = None,
                 roll_config: Optional[pulumi.Input['ElastigroupUpdatePolicyRollConfigArgs']] = None):
        """
        :param pulumi.Input[bool] should_resume_stateful: This will apply resuming action for Stateful instances in the Elastigroup upon scale up or capacity changes. Example usage will be for Elastigroups that will have scheduling rules to set a target capacity of 0 instances in the night and automatically restore the same state of the instances in the morning.
        :param pulumi.Input[bool] should_roll: Sets the enablement of the roll option.
        :param pulumi.Input[bool] auto_apply_tags: Enables updates to tags without rolling the group when set to `true`.
        :param pulumi.Input['ElastigroupUpdatePolicyRollConfigArgs'] roll_config: While used, you can control whether the group should perform a deployment after an update to the configuration.
        """
        pulumi.set(__self__, "should_resume_stateful", should_resume_stateful)
        pulumi.set(__self__, "should_roll", should_roll)
        if auto_apply_tags is not None:
            pulumi.set(__self__, "auto_apply_tags", auto_apply_tags)
        if roll_config is not None:
            pulumi.set(__self__, "roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldResumeStateful")
    def should_resume_stateful(self) -> pulumi.Input[bool]:
        """
        This will apply resuming action for Stateful instances in the Elastigroup upon scale up or capacity changes. Example usage will be for Elastigroups that will have scheduling rules to set a target capacity of 0 instances in the night and automatically restore the same state of the instances in the morning.
        """
        return pulumi.get(self, "should_resume_stateful")

    @should_resume_stateful.setter
    def should_resume_stateful(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_resume_stateful", value)

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> pulumi.Input[bool]:
        """
        Sets the enablement of the roll option.
        """
        return pulumi.get(self, "should_roll")

    @should_roll.setter
    def should_roll(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_roll", value)

    @property
    @pulumi.getter(name="autoApplyTags")
    def auto_apply_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables updates to tags without rolling the group when set to `true`.
        """
        return pulumi.get(self, "auto_apply_tags")

    @auto_apply_tags.setter
    def auto_apply_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_apply_tags", value)

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional[pulumi.Input['ElastigroupUpdatePolicyRollConfigArgs']]:
        """
        While used, you can control whether the group should perform a deployment after an update to the configuration.
        """
        return pulumi.get(self, "roll_config")

    @roll_config.setter
    def roll_config(self, value: Optional[pulumi.Input['ElastigroupUpdatePolicyRollConfigArgs']]):
        pulumi.set(self, "roll_config", value)


if not MYPY:
    class ElastigroupUpdatePolicyRollConfigArgsDict(TypedDict):
        batch_size_percentage: pulumi.Input[int]
        """
        Sets the percentage of the instances to deploy in each batch.
        """
        grace_period: NotRequired[pulumi.Input[int]]
        """
        Sets the grace period for new instances to become healthy.
        """
        health_check_type: NotRequired[pulumi.Input[str]]
        """
        Sets the health check type to use. Valid values: `"EC2"`, `"ECS_CLUSTER_INSTANCE"`, `"ELB"`, `"HCS"`, `"TARGET_GROUP"`, `"NONE"`.
        """
        strategy: NotRequired[pulumi.Input['ElastigroupUpdatePolicyRollConfigStrategyArgsDict']]
        """
        Strategy parameters
        """
        wait_for_roll_percentage: NotRequired[pulumi.Input[float]]
        """
        For use with `should_roll`. Sets minimum % of roll required to complete before continuing the plan. Required if `wait_for_roll_timeout` is set.
        """
        wait_for_roll_timeout: NotRequired[pulumi.Input[int]]
        """
        For use with `should_roll`. Sets how long to wait for the deployed % of a roll to exceed `wait_for_roll_percentage` before continuing the plan. Required if `wait_for_roll_percentage` is set.
        """
elif False:
    ElastigroupUpdatePolicyRollConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupUpdatePolicyRollConfigArgs:
    def __init__(__self__, *,
                 batch_size_percentage: pulumi.Input[int],
                 grace_period: Optional[pulumi.Input[int]] = None,
                 health_check_type: Optional[pulumi.Input[str]] = None,
                 strategy: Optional[pulumi.Input['ElastigroupUpdatePolicyRollConfigStrategyArgs']] = None,
                 wait_for_roll_percentage: Optional[pulumi.Input[float]] = None,
                 wait_for_roll_timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] batch_size_percentage: Sets the percentage of the instances to deploy in each batch.
        :param pulumi.Input[int] grace_period: Sets the grace period for new instances to become healthy.
        :param pulumi.Input[str] health_check_type: Sets the health check type to use. Valid values: `"EC2"`, `"ECS_CLUSTER_INSTANCE"`, `"ELB"`, `"HCS"`, `"TARGET_GROUP"`, `"NONE"`.
        :param pulumi.Input['ElastigroupUpdatePolicyRollConfigStrategyArgs'] strategy: Strategy parameters
        :param pulumi.Input[float] wait_for_roll_percentage: For use with `should_roll`. Sets minimum % of roll required to complete before continuing the plan. Required if `wait_for_roll_timeout` is set.
        :param pulumi.Input[int] wait_for_roll_timeout: For use with `should_roll`. Sets how long to wait for the deployed % of a roll to exceed `wait_for_roll_percentage` before continuing the plan. Required if `wait_for_roll_percentage` is set.
        """
        pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if health_check_type is not None:
            pulumi.set(__self__, "health_check_type", health_check_type)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)
        if wait_for_roll_percentage is not None:
            pulumi.set(__self__, "wait_for_roll_percentage", wait_for_roll_percentage)
        if wait_for_roll_timeout is not None:
            pulumi.set(__self__, "wait_for_roll_timeout", wait_for_roll_timeout)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> pulumi.Input[int]:
        """
        Sets the percentage of the instances to deploy in each batch.
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: pulumi.Input[int]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[int]]:
        """
        Sets the grace period for new instances to become healthy.
        """
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "grace_period", value)

    @property
    @pulumi.getter(name="healthCheckType")
    def health_check_type(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the health check type to use. Valid values: `"EC2"`, `"ECS_CLUSTER_INSTANCE"`, `"ELB"`, `"HCS"`, `"TARGET_GROUP"`, `"NONE"`.
        """
        return pulumi.get(self, "health_check_type")

    @health_check_type.setter
    def health_check_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_type", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input['ElastigroupUpdatePolicyRollConfigStrategyArgs']]:
        """
        Strategy parameters
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input['ElastigroupUpdatePolicyRollConfigStrategyArgs']]):
        pulumi.set(self, "strategy", value)

    @property
    @pulumi.getter(name="waitForRollPercentage")
    def wait_for_roll_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        For use with `should_roll`. Sets minimum % of roll required to complete before continuing the plan. Required if `wait_for_roll_timeout` is set.
        """
        return pulumi.get(self, "wait_for_roll_percentage")

    @wait_for_roll_percentage.setter
    def wait_for_roll_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "wait_for_roll_percentage", value)

    @property
    @pulumi.getter(name="waitForRollTimeout")
    def wait_for_roll_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        For use with `should_roll`. Sets how long to wait for the deployed % of a roll to exceed `wait_for_roll_percentage` before continuing the plan. Required if `wait_for_roll_percentage` is set.
        """
        return pulumi.get(self, "wait_for_roll_timeout")

    @wait_for_roll_timeout.setter
    def wait_for_roll_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wait_for_roll_timeout", value)


if not MYPY:
    class ElastigroupUpdatePolicyRollConfigStrategyArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Action to take. Valid values: `REPLACE_SERVER`, `RESTART_SERVER`.
        """
        batch_min_healthy_percentage: NotRequired[pulumi.Input[int]]
        """
        Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the deployment will fail. Range `1` - `100`.
        """
        on_failure: NotRequired[pulumi.Input['ElastigroupUpdatePolicyRollConfigStrategyOnFailureArgsDict']]
        """
        Set detach options to the deployment.
        """
        should_drain_instances: NotRequired[pulumi.Input[bool]]
        """
        Specify whether to drain incoming TCP connections before terminating a server.
        """
elif False:
    ElastigroupUpdatePolicyRollConfigStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupUpdatePolicyRollConfigStrategyArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 batch_min_healthy_percentage: Optional[pulumi.Input[int]] = None,
                 on_failure: Optional[pulumi.Input['ElastigroupUpdatePolicyRollConfigStrategyOnFailureArgs']] = None,
                 should_drain_instances: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] action: Action to take. Valid values: `REPLACE_SERVER`, `RESTART_SERVER`.
        :param pulumi.Input[int] batch_min_healthy_percentage: Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the deployment will fail. Range `1` - `100`.
        :param pulumi.Input['ElastigroupUpdatePolicyRollConfigStrategyOnFailureArgs'] on_failure: Set detach options to the deployment.
        :param pulumi.Input[bool] should_drain_instances: Specify whether to drain incoming TCP connections before terminating a server.
        """
        pulumi.set(__self__, "action", action)
        if batch_min_healthy_percentage is not None:
            pulumi.set(__self__, "batch_min_healthy_percentage", batch_min_healthy_percentage)
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if should_drain_instances is not None:
            pulumi.set(__self__, "should_drain_instances", should_drain_instances)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action to take. Valid values: `REPLACE_SERVER`, `RESTART_SERVER`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="batchMinHealthyPercentage")
    def batch_min_healthy_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the deployment will fail. Range `1` - `100`.
        """
        return pulumi.get(self, "batch_min_healthy_percentage")

    @batch_min_healthy_percentage.setter
    def batch_min_healthy_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_min_healthy_percentage", value)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['ElastigroupUpdatePolicyRollConfigStrategyOnFailureArgs']]:
        """
        Set detach options to the deployment.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['ElastigroupUpdatePolicyRollConfigStrategyOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)

    @property
    @pulumi.getter(name="shouldDrainInstances")
    def should_drain_instances(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify whether to drain incoming TCP connections before terminating a server.
        """
        return pulumi.get(self, "should_drain_instances")

    @should_drain_instances.setter
    def should_drain_instances(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_drain_instances", value)


if not MYPY:
    class ElastigroupUpdatePolicyRollConfigStrategyOnFailureArgsDict(TypedDict):
        action_type: pulumi.Input[str]
        """
        Sets the action that will take place, Accepted values are: `DETACH_OLD`, `DETACH_NEW`.
        """
        batch_num: NotRequired[pulumi.Input[int]]
        draining_timeout: NotRequired[pulumi.Input[int]]
        """
        Indicates (in seconds) the timeout to wait until instance are detached.
        """
        should_decrement_target_capacity: NotRequired[pulumi.Input[bool]]
        """
        Decrementing the group target capacity after detaching the instances.
        """
        should_handle_all_batches: NotRequired[pulumi.Input[bool]]
        """
        Indicator if the action should apply to all batches of the deployment or only the latest batch.
        """
elif False:
    ElastigroupUpdatePolicyRollConfigStrategyOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElastigroupUpdatePolicyRollConfigStrategyOnFailureArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[str],
                 batch_num: Optional[pulumi.Input[int]] = None,
                 draining_timeout: Optional[pulumi.Input[int]] = None,
                 should_decrement_target_capacity: Optional[pulumi.Input[bool]] = None,
                 should_handle_all_batches: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] action_type: Sets the action that will take place, Accepted values are: `DETACH_OLD`, `DETACH_NEW`.
        :param pulumi.Input[int] draining_timeout: Indicates (in seconds) the timeout to wait until instance are detached.
        :param pulumi.Input[bool] should_decrement_target_capacity: Decrementing the group target capacity after detaching the instances.
        :param pulumi.Input[bool] should_handle_all_batches: Indicator if the action should apply to all batches of the deployment or only the latest batch.
        """
        pulumi.set(__self__, "action_type", action_type)
        if batch_num is not None:
            pulumi.set(__self__, "batch_num", batch_num)
        if draining_timeout is not None:
            pulumi.set(__self__, "draining_timeout", draining_timeout)
        if should_decrement_target_capacity is not None:
            pulumi.set(__self__, "should_decrement_target_capacity", should_decrement_target_capacity)
        if should_handle_all_batches is not None:
            pulumi.set(__self__, "should_handle_all_batches", should_handle_all_batches)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[str]:
        """
        Sets the action that will take place, Accepted values are: `DETACH_OLD`, `DETACH_NEW`.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="batchNum")
    def batch_num(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "batch_num")

    @batch_num.setter
    def batch_num(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_num", value)

    @property
    @pulumi.getter(name="drainingTimeout")
    def draining_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates (in seconds) the timeout to wait until instance are detached.
        """
        return pulumi.get(self, "draining_timeout")

    @draining_timeout.setter
    def draining_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "draining_timeout", value)

    @property
    @pulumi.getter(name="shouldDecrementTargetCapacity")
    def should_decrement_target_capacity(self) -> Optional[pulumi.Input[bool]]:
        """
        Decrementing the group target capacity after detaching the instances.
        """
        return pulumi.get(self, "should_decrement_target_capacity")

    @should_decrement_target_capacity.setter
    def should_decrement_target_capacity(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_decrement_target_capacity", value)

    @property
    @pulumi.getter(name="shouldHandleAllBatches")
    def should_handle_all_batches(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicator if the action should apply to all batches of the deployment or only the latest batch.
        """
        return pulumi.get(self, "should_handle_all_batches")

    @should_handle_all_batches.setter
    def should_handle_all_batches(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_handle_all_batches", value)


if not MYPY:
    class ManagedInstanceBlockDeviceMappingArgsDict(TypedDict):
        device_name: pulumi.Input[str]
        ebs: NotRequired[pulumi.Input['ManagedInstanceBlockDeviceMappingEbsArgsDict']]
elif False:
    ManagedInstanceBlockDeviceMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 ebs: Optional[pulumi.Input['ManagedInstanceBlockDeviceMappingEbsArgs']] = None):
        pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def ebs(self) -> Optional[pulumi.Input['ManagedInstanceBlockDeviceMappingEbsArgs']]:
        return pulumi.get(self, "ebs")

    @ebs.setter
    def ebs(self, value: Optional[pulumi.Input['ManagedInstanceBlockDeviceMappingEbsArgs']]):
        pulumi.set(self, "ebs", value)


if not MYPY:
    class ManagedInstanceBlockDeviceMappingEbsArgsDict(TypedDict):
        delete_on_termination: NotRequired[pulumi.Input[bool]]
        encrypted: NotRequired[pulumi.Input[bool]]
        iops: NotRequired[pulumi.Input[int]]
        kms_key_id: NotRequired[pulumi.Input[str]]
        snapshot_id: NotRequired[pulumi.Input[str]]
        throughput: NotRequired[pulumi.Input[int]]
        volume_size: NotRequired[pulumi.Input[int]]
        volume_type: NotRequired[pulumi.Input[str]]
elif False:
    ManagedInstanceBlockDeviceMappingEbsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceBlockDeviceMappingEbsArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class ManagedInstanceDeleteArgsDict(TypedDict):
        ami_backup_should_delete_images: NotRequired[pulumi.Input[bool]]
        deallocation_config_should_delete_images: NotRequired[pulumi.Input[bool]]
        should_delete_network_interfaces: NotRequired[pulumi.Input[bool]]
        should_delete_snapshots: NotRequired[pulumi.Input[bool]]
        should_delete_volumes: NotRequired[pulumi.Input[bool]]
        should_terminate_instance: NotRequired[pulumi.Input[bool]]
elif False:
    ManagedInstanceDeleteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceDeleteArgs:
    def __init__(__self__, *,
                 ami_backup_should_delete_images: Optional[pulumi.Input[bool]] = None,
                 deallocation_config_should_delete_images: Optional[pulumi.Input[bool]] = None,
                 should_delete_network_interfaces: Optional[pulumi.Input[bool]] = None,
                 should_delete_snapshots: Optional[pulumi.Input[bool]] = None,
                 should_delete_volumes: Optional[pulumi.Input[bool]] = None,
                 should_terminate_instance: Optional[pulumi.Input[bool]] = None):
        if ami_backup_should_delete_images is not None:
            pulumi.set(__self__, "ami_backup_should_delete_images", ami_backup_should_delete_images)
        if deallocation_config_should_delete_images is not None:
            pulumi.set(__self__, "deallocation_config_should_delete_images", deallocation_config_should_delete_images)
        if should_delete_network_interfaces is not None:
            pulumi.set(__self__, "should_delete_network_interfaces", should_delete_network_interfaces)
        if should_delete_snapshots is not None:
            pulumi.set(__self__, "should_delete_snapshots", should_delete_snapshots)
        if should_delete_volumes is not None:
            pulumi.set(__self__, "should_delete_volumes", should_delete_volumes)
        if should_terminate_instance is not None:
            pulumi.set(__self__, "should_terminate_instance", should_terminate_instance)

    @property
    @pulumi.getter(name="amiBackupShouldDeleteImages")
    def ami_backup_should_delete_images(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ami_backup_should_delete_images")

    @ami_backup_should_delete_images.setter
    def ami_backup_should_delete_images(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ami_backup_should_delete_images", value)

    @property
    @pulumi.getter(name="deallocationConfigShouldDeleteImages")
    def deallocation_config_should_delete_images(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "deallocation_config_should_delete_images")

    @deallocation_config_should_delete_images.setter
    def deallocation_config_should_delete_images(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deallocation_config_should_delete_images", value)

    @property
    @pulumi.getter(name="shouldDeleteNetworkInterfaces")
    def should_delete_network_interfaces(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_delete_network_interfaces")

    @should_delete_network_interfaces.setter
    def should_delete_network_interfaces(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_delete_network_interfaces", value)

    @property
    @pulumi.getter(name="shouldDeleteSnapshots")
    def should_delete_snapshots(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_delete_snapshots")

    @should_delete_snapshots.setter
    def should_delete_snapshots(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_delete_snapshots", value)

    @property
    @pulumi.getter(name="shouldDeleteVolumes")
    def should_delete_volumes(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_delete_volumes")

    @should_delete_volumes.setter
    def should_delete_volumes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_delete_volumes", value)

    @property
    @pulumi.getter(name="shouldTerminateInstance")
    def should_terminate_instance(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_terminate_instance")

    @should_terminate_instance.setter
    def should_terminate_instance(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_terminate_instance", value)


if not MYPY:
    class ManagedInstanceIntegrationRoute53ArgsDict(TypedDict):
        domains: pulumi.Input[Sequence[pulumi.Input['ManagedInstanceIntegrationRoute53DomainArgsDict']]]
elif False:
    ManagedInstanceIntegrationRoute53ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceIntegrationRoute53Args:
    def __init__(__self__, *,
                 domains: pulumi.Input[Sequence[pulumi.Input['ManagedInstanceIntegrationRoute53DomainArgs']]]):
        pulumi.set(__self__, "domains", domains)

    @property
    @pulumi.getter
    def domains(self) -> pulumi.Input[Sequence[pulumi.Input['ManagedInstanceIntegrationRoute53DomainArgs']]]:
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: pulumi.Input[Sequence[pulumi.Input['ManagedInstanceIntegrationRoute53DomainArgs']]]):
        pulumi.set(self, "domains", value)


if not MYPY:
    class ManagedInstanceIntegrationRoute53DomainArgsDict(TypedDict):
        hosted_zone_id: pulumi.Input[str]
        record_sets: pulumi.Input[Sequence[pulumi.Input['ManagedInstanceIntegrationRoute53DomainRecordSetArgsDict']]]
        record_set_type: NotRequired[pulumi.Input[str]]
        spotinst_acct_id: NotRequired[pulumi.Input[str]]
elif False:
    ManagedInstanceIntegrationRoute53DomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceIntegrationRoute53DomainArgs:
    def __init__(__self__, *,
                 hosted_zone_id: pulumi.Input[str],
                 record_sets: pulumi.Input[Sequence[pulumi.Input['ManagedInstanceIntegrationRoute53DomainRecordSetArgs']]],
                 record_set_type: Optional[pulumi.Input[str]] = None,
                 spotinst_acct_id: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "hosted_zone_id", hosted_zone_id)
        pulumi.set(__self__, "record_sets", record_sets)
        if record_set_type is not None:
            pulumi.set(__self__, "record_set_type", record_set_type)
        if spotinst_acct_id is not None:
            pulumi.set(__self__, "spotinst_acct_id", spotinst_acct_id)

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "hosted_zone_id")

    @hosted_zone_id.setter
    def hosted_zone_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "hosted_zone_id", value)

    @property
    @pulumi.getter(name="recordSets")
    def record_sets(self) -> pulumi.Input[Sequence[pulumi.Input['ManagedInstanceIntegrationRoute53DomainRecordSetArgs']]]:
        return pulumi.get(self, "record_sets")

    @record_sets.setter
    def record_sets(self, value: pulumi.Input[Sequence[pulumi.Input['ManagedInstanceIntegrationRoute53DomainRecordSetArgs']]]):
        pulumi.set(self, "record_sets", value)

    @property
    @pulumi.getter(name="recordSetType")
    def record_set_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "record_set_type")

    @record_set_type.setter
    def record_set_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_set_type", value)

    @property
    @pulumi.getter(name="spotinstAcctId")
    def spotinst_acct_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "spotinst_acct_id")

    @spotinst_acct_id.setter
    def spotinst_acct_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spotinst_acct_id", value)


if not MYPY:
    class ManagedInstanceIntegrationRoute53DomainRecordSetArgsDict(TypedDict):
        name: pulumi.Input[str]
        use_public_dns: NotRequired[pulumi.Input[bool]]
        use_public_ip: NotRequired[pulumi.Input[bool]]
elif False:
    ManagedInstanceIntegrationRoute53DomainRecordSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceIntegrationRoute53DomainRecordSetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 use_public_dns: Optional[pulumi.Input[bool]] = None,
                 use_public_ip: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "name", name)
        if use_public_dns is not None:
            pulumi.set(__self__, "use_public_dns", use_public_dns)
        if use_public_ip is not None:
            pulumi.set(__self__, "use_public_ip", use_public_ip)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="usePublicDns")
    def use_public_dns(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_public_dns")

    @use_public_dns.setter
    def use_public_dns(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_public_dns", value)

    @property
    @pulumi.getter(name="usePublicIp")
    def use_public_ip(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_public_ip")

    @use_public_ip.setter
    def use_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_public_ip", value)


if not MYPY:
    class ManagedInstanceLoadBalancerArgsDict(TypedDict):
        type: pulumi.Input[str]
        arn: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
elif False:
    ManagedInstanceLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceLoadBalancerArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 arn: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "type", type)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ManagedInstanceManagedInstanceActionArgsDict(TypedDict):
        type: pulumi.Input[str]
elif False:
    ManagedInstanceManagedInstanceActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceManagedInstanceActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ManagedInstanceMetadataOptionsArgsDict(TypedDict):
        http_tokens: pulumi.Input[str]
        http_put_response_hop_limit: NotRequired[pulumi.Input[int]]
        instance_metadata_tags: NotRequired[pulumi.Input[str]]
elif False:
    ManagedInstanceMetadataOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_tokens: pulumi.Input[str],
                 http_put_response_hop_limit: Optional[pulumi.Input[int]] = None,
                 instance_metadata_tags: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "http_tokens", http_tokens)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if instance_metadata_tags is not None:
            pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> pulumi.Input[str]:
        return pulumi.get(self, "http_tokens")

    @http_tokens.setter
    def http_tokens(self, value: pulumi.Input[str]):
        pulumi.set(self, "http_tokens", value)

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "http_put_response_hop_limit")

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_put_response_hop_limit", value)

    @property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_metadata_tags")

    @instance_metadata_tags.setter
    def instance_metadata_tags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_metadata_tags", value)


if not MYPY:
    class ManagedInstanceNetworkInterfaceArgsDict(TypedDict):
        device_index: pulumi.Input[str]
        associate_ipv6_address: NotRequired[pulumi.Input[bool]]
        associate_public_ip_address: NotRequired[pulumi.Input[bool]]
elif False:
    ManagedInstanceNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceNetworkInterfaceArgs:
    def __init__(__self__, *,
                 device_index: pulumi.Input[str],
                 associate_ipv6_address: Optional[pulumi.Input[bool]] = None,
                 associate_public_ip_address: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "device_index", device_index)
        if associate_ipv6_address is not None:
            pulumi.set(__self__, "associate_ipv6_address", associate_ipv6_address)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "device_index")

    @device_index.setter
    def device_index(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_index", value)

    @property
    @pulumi.getter(name="associateIpv6Address")
    def associate_ipv6_address(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "associate_ipv6_address")

    @associate_ipv6_address.setter
    def associate_ipv6_address(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "associate_ipv6_address", value)

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "associate_public_ip_address")

    @associate_public_ip_address.setter
    def associate_public_ip_address(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "associate_public_ip_address", value)


if not MYPY:
    class ManagedInstanceResourceTagSpecificationArgsDict(TypedDict):
        should_tag_amis: NotRequired[pulumi.Input[bool]]
        should_tag_enis: NotRequired[pulumi.Input[bool]]
        should_tag_snapshots: NotRequired[pulumi.Input[bool]]
        should_tag_volumes: NotRequired[pulumi.Input[bool]]
elif False:
    ManagedInstanceResourceTagSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceResourceTagSpecificationArgs:
    def __init__(__self__, *,
                 should_tag_amis: Optional[pulumi.Input[bool]] = None,
                 should_tag_enis: Optional[pulumi.Input[bool]] = None,
                 should_tag_snapshots: Optional[pulumi.Input[bool]] = None,
                 should_tag_volumes: Optional[pulumi.Input[bool]] = None):
        if should_tag_amis is not None:
            pulumi.set(__self__, "should_tag_amis", should_tag_amis)
        if should_tag_enis is not None:
            pulumi.set(__self__, "should_tag_enis", should_tag_enis)
        if should_tag_snapshots is not None:
            pulumi.set(__self__, "should_tag_snapshots", should_tag_snapshots)
        if should_tag_volumes is not None:
            pulumi.set(__self__, "should_tag_volumes", should_tag_volumes)

    @property
    @pulumi.getter(name="shouldTagAmis")
    def should_tag_amis(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_tag_amis")

    @should_tag_amis.setter
    def should_tag_amis(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_tag_amis", value)

    @property
    @pulumi.getter(name="shouldTagEnis")
    def should_tag_enis(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_tag_enis")

    @should_tag_enis.setter
    def should_tag_enis(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_tag_enis", value)

    @property
    @pulumi.getter(name="shouldTagSnapshots")
    def should_tag_snapshots(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_tag_snapshots")

    @should_tag_snapshots.setter
    def should_tag_snapshots(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_tag_snapshots", value)

    @property
    @pulumi.getter(name="shouldTagVolumes")
    def should_tag_volumes(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_tag_volumes")

    @should_tag_volumes.setter
    def should_tag_volumes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_tag_volumes", value)


if not MYPY:
    class ManagedInstanceRevertToSpotArgsDict(TypedDict):
        perform_at: pulumi.Input[str]
elif False:
    ManagedInstanceRevertToSpotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceRevertToSpotArgs:
    def __init__(__self__, *,
                 perform_at: pulumi.Input[str]):
        pulumi.set(__self__, "perform_at", perform_at)

    @property
    @pulumi.getter(name="performAt")
    def perform_at(self) -> pulumi.Input[str]:
        return pulumi.get(self, "perform_at")

    @perform_at.setter
    def perform_at(self, value: pulumi.Input[str]):
        pulumi.set(self, "perform_at", value)


if not MYPY:
    class ManagedInstanceScheduledTaskArgsDict(TypedDict):
        task_type: pulumi.Input[str]
        cron_expression: NotRequired[pulumi.Input[str]]
        frequency: NotRequired[pulumi.Input[str]]
        is_enabled: NotRequired[pulumi.Input[bool]]
        start_time: NotRequired[pulumi.Input[str]]
elif False:
    ManagedInstanceScheduledTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceScheduledTaskArgs:
    def __init__(__self__, *,
                 task_type: pulumi.Input[str],
                 cron_expression: Optional[pulumi.Input[str]] = None,
                 frequency: Optional[pulumi.Input[str]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "task_type", task_type)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_type", value)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class ManagedInstanceTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    ManagedInstanceTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedInstanceTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MrScalarApplicationArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The MrScaler name.
        """
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Arguments for EMR to pass to the application.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        T he version of the application.
        """
elif False:
    MrScalarApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarApplicationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The MrScaler name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: Arguments for EMR to pass to the application.
        :param pulumi.Input[str] version: T he version of the application.
        """
        pulumi.set(__self__, "name", name)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The MrScaler name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Arguments for EMR to pass to the application.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        T he version of the application.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class MrScalarBootstrapActionsFileArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        key: pulumi.Input[str]
elif False:
    MrScalarBootstrapActionsFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarBootstrapActionsFileArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 key: pulumi.Input[str]):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class MrScalarConfigurationsFileArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        key: pulumi.Input[str]
elif False:
    MrScalarConfigurationsFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarConfigurationsFileArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 key: pulumi.Input[str]):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class MrScalarCoreEbsBlockDeviceArgsDict(TypedDict):
        size_in_gb: pulumi.Input[int]
        volume_type: pulumi.Input[str]
        iops: NotRequired[pulumi.Input[int]]
        volumes_per_instance: NotRequired[pulumi.Input[int]]
elif False:
    MrScalarCoreEbsBlockDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarCoreEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 size_in_gb: pulumi.Input[int],
                 volume_type: pulumi.Input[str],
                 iops: Optional[pulumi.Input[int]] = None,
                 volumes_per_instance: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "size_in_gb", size_in_gb)
        pulumi.set(__self__, "volume_type", volume_type)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if volumes_per_instance is not None:
            pulumi.set(__self__, "volumes_per_instance", volumes_per_instance)

    @property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> pulumi.Input[int]:
        return pulumi.get(self, "size_in_gb")

    @size_in_gb.setter
    def size_in_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_in_gb", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "volume_type", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="volumesPerInstance")
    def volumes_per_instance(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "volumes_per_instance")

    @volumes_per_instance.setter
    def volumes_per_instance(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volumes_per_instance", value)


if not MYPY:
    class MrScalarCoreScalingDownPolicyArgsDict(TypedDict):
        metric_name: pulumi.Input[str]
        namespace: pulumi.Input[str]
        policy_name: pulumi.Input[str]
        """
        The name of the policy.
        """
        threshold: pulumi.Input[float]
        unit: pulumi.Input[str]
        action_type: NotRequired[pulumi.Input[str]]
        """
        The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
        """
        adjustment: NotRequired[pulumi.Input[str]]
        """
        The number of instances to add/remove to/from the target capacity when scale is needed.
        """
        cooldown: NotRequired[pulumi.Input[int]]
        """
        The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
        """
        dimensions: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A mapping of dimensions describing qualities of the metric.
        """
        evaluation_periods: NotRequired[pulumi.Input[int]]
        max_target_capacity: NotRequired[pulumi.Input[str]]
        """
        Max target capacity for scale down.
        """
        maximum: NotRequired[pulumi.Input[str]]
        """
        The maximum to set when scale is needed.
        """
        min_target_capacity: NotRequired[pulumi.Input[str]]
        """
        Min target capacity for scale up.
        """
        minimum: NotRequired[pulumi.Input[str]]
        """
        The minimum to set when scale is needed.
        """
        operator: NotRequired[pulumi.Input[str]]
        period: NotRequired[pulumi.Input[int]]
        statistic: NotRequired[pulumi.Input[str]]
        target: NotRequired[pulumi.Input[str]]
        """
        The number of instances to set when scale is needed.
        """
elif False:
    MrScalarCoreScalingDownPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarCoreScalingDownPolicyArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 policy_name: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 unit: pulumi.Input[str],
                 action_type: Optional[pulumi.Input[str]] = None,
                 adjustment: Optional[pulumi.Input[str]] = None,
                 cooldown: Optional[pulumi.Input[int]] = None,
                 dimensions: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 max_target_capacity: Optional[pulumi.Input[str]] = None,
                 maximum: Optional[pulumi.Input[str]] = None,
                 min_target_capacity: Optional[pulumi.Input[str]] = None,
                 minimum: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 statistic: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] policy_name: The name of the policy.
        :param pulumi.Input[str] action_type: The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
        :param pulumi.Input[str] adjustment: The number of instances to add/remove to/from the target capacity when scale is needed.
        :param pulumi.Input[int] cooldown: The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] dimensions: A mapping of dimensions describing qualities of the metric.
        :param pulumi.Input[str] max_target_capacity: Max target capacity for scale down.
        :param pulumi.Input[str] maximum: The maximum to set when scale is needed.
        :param pulumi.Input[str] min_target_capacity: Min target capacity for scale up.
        :param pulumi.Input[str] minimum: The minimum to set when scale is needed.
        :param pulumi.Input[str] target: The number of instances to set when scale is needed.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> pulumi.Input[str]:
        """
        The name of the policy.
        """
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_name", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[str]]:
        """
        The number of instances to add/remove to/from the target capacity when scale is needed.
        """
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
        """
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A mapping of dimensions describing qualities of the metric.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        Max target capacity for scale down.
        """
        return pulumi.get(self, "max_target_capacity")

    @max_target_capacity.setter
    def max_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_target_capacity", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum to set when scale is needed.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        Min target capacity for scale up.
        """
        return pulumi.get(self, "min_target_capacity")

    @min_target_capacity.setter
    def min_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_target_capacity", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum to set when scale is needed.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statistic", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        The number of instances to set when scale is needed.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class MrScalarCoreScalingUpPolicyArgsDict(TypedDict):
        metric_name: pulumi.Input[str]
        namespace: pulumi.Input[str]
        policy_name: pulumi.Input[str]
        """
        The name of the policy.
        """
        threshold: pulumi.Input[float]
        unit: pulumi.Input[str]
        action_type: NotRequired[pulumi.Input[str]]
        """
        The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
        """
        adjustment: NotRequired[pulumi.Input[str]]
        """
        The number of instances to add/remove to/from the target capacity when scale is needed.
        """
        cooldown: NotRequired[pulumi.Input[int]]
        """
        The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
        """
        dimensions: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A mapping of dimensions describing qualities of the metric.
        """
        evaluation_periods: NotRequired[pulumi.Input[int]]
        max_target_capacity: NotRequired[pulumi.Input[str]]
        """
        Max target capacity for scale down.
        """
        maximum: NotRequired[pulumi.Input[str]]
        """
        The maximum to set when scale is needed.
        """
        min_target_capacity: NotRequired[pulumi.Input[str]]
        """
        Min target capacity for scale up.
        """
        minimum: NotRequired[pulumi.Input[str]]
        """
        The minimum to set when scale is needed.
        """
        operator: NotRequired[pulumi.Input[str]]
        period: NotRequired[pulumi.Input[int]]
        statistic: NotRequired[pulumi.Input[str]]
        target: NotRequired[pulumi.Input[str]]
        """
        The number of instances to set when scale is needed.
        """
elif False:
    MrScalarCoreScalingUpPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarCoreScalingUpPolicyArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 policy_name: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 unit: pulumi.Input[str],
                 action_type: Optional[pulumi.Input[str]] = None,
                 adjustment: Optional[pulumi.Input[str]] = None,
                 cooldown: Optional[pulumi.Input[int]] = None,
                 dimensions: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 max_target_capacity: Optional[pulumi.Input[str]] = None,
                 maximum: Optional[pulumi.Input[str]] = None,
                 min_target_capacity: Optional[pulumi.Input[str]] = None,
                 minimum: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 statistic: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] policy_name: The name of the policy.
        :param pulumi.Input[str] action_type: The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
        :param pulumi.Input[str] adjustment: The number of instances to add/remove to/from the target capacity when scale is needed.
        :param pulumi.Input[int] cooldown: The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] dimensions: A mapping of dimensions describing qualities of the metric.
        :param pulumi.Input[str] max_target_capacity: Max target capacity for scale down.
        :param pulumi.Input[str] maximum: The maximum to set when scale is needed.
        :param pulumi.Input[str] min_target_capacity: Min target capacity for scale up.
        :param pulumi.Input[str] minimum: The minimum to set when scale is needed.
        :param pulumi.Input[str] target: The number of instances to set when scale is needed.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> pulumi.Input[str]:
        """
        The name of the policy.
        """
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_name", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[str]]:
        """
        The number of instances to add/remove to/from the target capacity when scale is needed.
        """
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
        """
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A mapping of dimensions describing qualities of the metric.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        Max target capacity for scale down.
        """
        return pulumi.get(self, "max_target_capacity")

    @max_target_capacity.setter
    def max_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_target_capacity", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum to set when scale is needed.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        Min target capacity for scale up.
        """
        return pulumi.get(self, "min_target_capacity")

    @min_target_capacity.setter
    def min_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_target_capacity", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum to set when scale is needed.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statistic", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        The number of instances to set when scale is needed.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class MrScalarInstanceWeightArgsDict(TypedDict):
        instance_type: pulumi.Input[str]
        """
        The type of the instance.
        """
        weighted_capacity: pulumi.Input[int]
        """
        The weight given to the associated instance type.
        """
elif False:
    MrScalarInstanceWeightArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarInstanceWeightArgs:
    def __init__(__self__, *,
                 instance_type: pulumi.Input[str],
                 weighted_capacity: pulumi.Input[int]):
        """
        :param pulumi.Input[str] instance_type: The type of the instance.
        :param pulumi.Input[int] weighted_capacity: The weight given to the associated instance type.
        """
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        """
        The type of the instance.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> pulumi.Input[int]:
        """
        The weight given to the associated instance type.
        """
        return pulumi.get(self, "weighted_capacity")

    @weighted_capacity.setter
    def weighted_capacity(self, value: pulumi.Input[int]):
        pulumi.set(self, "weighted_capacity", value)


if not MYPY:
    class MrScalarMasterEbsBlockDeviceArgsDict(TypedDict):
        size_in_gb: pulumi.Input[int]
        volume_type: pulumi.Input[str]
        iops: NotRequired[pulumi.Input[int]]
        volumes_per_instance: NotRequired[pulumi.Input[int]]
elif False:
    MrScalarMasterEbsBlockDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarMasterEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 size_in_gb: pulumi.Input[int],
                 volume_type: pulumi.Input[str],
                 iops: Optional[pulumi.Input[int]] = None,
                 volumes_per_instance: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "size_in_gb", size_in_gb)
        pulumi.set(__self__, "volume_type", volume_type)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if volumes_per_instance is not None:
            pulumi.set(__self__, "volumes_per_instance", volumes_per_instance)

    @property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> pulumi.Input[int]:
        return pulumi.get(self, "size_in_gb")

    @size_in_gb.setter
    def size_in_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_in_gb", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "volume_type", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="volumesPerInstance")
    def volumes_per_instance(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "volumes_per_instance")

    @volumes_per_instance.setter
    def volumes_per_instance(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volumes_per_instance", value)


if not MYPY:
    class MrScalarProvisioningTimeoutArgsDict(TypedDict):
        timeout: pulumi.Input[int]
        """
        The amount of time (minutes) after which the cluster is automatically terminated if it's still in provisioning status. Minimum: '15'.
        """
        timeout_action: pulumi.Input[str]
        """
        The action to take if the timeout is exceeded. Valid values: `terminate`, `terminateAndRetry`.
        """
elif False:
    MrScalarProvisioningTimeoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarProvisioningTimeoutArgs:
    def __init__(__self__, *,
                 timeout: pulumi.Input[int],
                 timeout_action: pulumi.Input[str]):
        """
        :param pulumi.Input[int] timeout: The amount of time (minutes) after which the cluster is automatically terminated if it's still in provisioning status. Minimum: '15'.
        :param pulumi.Input[str] timeout_action: The action to take if the timeout is exceeded. Valid values: `terminate`, `terminateAndRetry`.
        """
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "timeout_action", timeout_action)

    @property
    @pulumi.getter
    def timeout(self) -> pulumi.Input[int]:
        """
        The amount of time (minutes) after which the cluster is automatically terminated if it's still in provisioning status. Minimum: '15'.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: pulumi.Input[int]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="timeoutAction")
    def timeout_action(self) -> pulumi.Input[str]:
        """
        The action to take if the timeout is exceeded. Valid values: `terminate`, `terminateAndRetry`.
        """
        return pulumi.get(self, "timeout_action")

    @timeout_action.setter
    def timeout_action(self, value: pulumi.Input[str]):
        pulumi.set(self, "timeout_action", value)


if not MYPY:
    class MrScalarScheduledTaskArgsDict(TypedDict):
        cron: pulumi.Input[str]
        """
        A cron expression representing the schedule for the task.
        """
        instance_group_type: pulumi.Input[str]
        """
        Select the EMR instance groups to execute the scheduled task on. Valid values: `task`.
        """
        task_type: pulumi.Input[str]
        """
        The type of task to be scheduled. Valid values: `setCapacity`.
        """
        desired_capacity: NotRequired[pulumi.Input[str]]
        """
        New desired capacity for the elastigroup.
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable/Disable the specified scheduling task.
        """
        max_capacity: NotRequired[pulumi.Input[str]]
        """
        New max capacity for the elastigroup.
        """
        min_capacity: NotRequired[pulumi.Input[str]]
        """
        New min capacity for the elastigroup.
        """
elif False:
    MrScalarScheduledTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarScheduledTaskArgs:
    def __init__(__self__, *,
                 cron: pulumi.Input[str],
                 instance_group_type: pulumi.Input[str],
                 task_type: pulumi.Input[str],
                 desired_capacity: Optional[pulumi.Input[str]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 max_capacity: Optional[pulumi.Input[str]] = None,
                 min_capacity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cron: A cron expression representing the schedule for the task.
        :param pulumi.Input[str] instance_group_type: Select the EMR instance groups to execute the scheduled task on. Valid values: `task`.
        :param pulumi.Input[str] task_type: The type of task to be scheduled. Valid values: `setCapacity`.
        :param pulumi.Input[str] desired_capacity: New desired capacity for the elastigroup.
        :param pulumi.Input[bool] is_enabled: Enable/Disable the specified scheduling task.
        :param pulumi.Input[str] max_capacity: New max capacity for the elastigroup.
        :param pulumi.Input[str] min_capacity: New min capacity for the elastigroup.
        """
        pulumi.set(__self__, "cron", cron)
        pulumi.set(__self__, "instance_group_type", instance_group_type)
        pulumi.set(__self__, "task_type", task_type)
        if desired_capacity is not None:
            pulumi.set(__self__, "desired_capacity", desired_capacity)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if min_capacity is not None:
            pulumi.set(__self__, "min_capacity", min_capacity)

    @property
    @pulumi.getter
    def cron(self) -> pulumi.Input[str]:
        """
        A cron expression representing the schedule for the task.
        """
        return pulumi.get(self, "cron")

    @cron.setter
    def cron(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron", value)

    @property
    @pulumi.getter(name="instanceGroupType")
    def instance_group_type(self) -> pulumi.Input[str]:
        """
        Select the EMR instance groups to execute the scheduled task on. Valid values: `task`.
        """
        return pulumi.get(self, "instance_group_type")

    @instance_group_type.setter
    def instance_group_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_group_type", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input[str]:
        """
        The type of task to be scheduled. Valid values: `setCapacity`.
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_type", value)

    @property
    @pulumi.getter(name="desiredCapacity")
    def desired_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        New desired capacity for the elastigroup.
        """
        return pulumi.get(self, "desired_capacity")

    @desired_capacity.setter
    def desired_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "desired_capacity", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable/Disable the specified scheduling task.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        New max capacity for the elastigroup.
        """
        return pulumi.get(self, "max_capacity")

    @max_capacity.setter
    def max_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_capacity", value)

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        New min capacity for the elastigroup.
        """
        return pulumi.get(self, "min_capacity")

    @min_capacity.setter
    def min_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_capacity", value)


if not MYPY:
    class MrScalarStepsFileArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        key: pulumi.Input[str]
elif False:
    MrScalarStepsFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarStepsFileArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 key: pulumi.Input[str]):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class MrScalarTagArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
        """
        Tag value.

        <a id="Optional Compute Parameters"></a>
        """
elif False:
    MrScalarTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: Tag value.
               
               <a id="Optional Compute Parameters"></a>
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Tag value.

        <a id="Optional Compute Parameters"></a>
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MrScalarTaskEbsBlockDeviceArgsDict(TypedDict):
        size_in_gb: pulumi.Input[int]
        volume_type: pulumi.Input[str]
        iops: NotRequired[pulumi.Input[int]]
        volumes_per_instance: NotRequired[pulumi.Input[int]]
elif False:
    MrScalarTaskEbsBlockDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarTaskEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 size_in_gb: pulumi.Input[int],
                 volume_type: pulumi.Input[str],
                 iops: Optional[pulumi.Input[int]] = None,
                 volumes_per_instance: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "size_in_gb", size_in_gb)
        pulumi.set(__self__, "volume_type", volume_type)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if volumes_per_instance is not None:
            pulumi.set(__self__, "volumes_per_instance", volumes_per_instance)

    @property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> pulumi.Input[int]:
        return pulumi.get(self, "size_in_gb")

    @size_in_gb.setter
    def size_in_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_in_gb", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "volume_type", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="volumesPerInstance")
    def volumes_per_instance(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "volumes_per_instance")

    @volumes_per_instance.setter
    def volumes_per_instance(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volumes_per_instance", value)


if not MYPY:
    class MrScalarTaskScalingDownPolicyArgsDict(TypedDict):
        metric_name: pulumi.Input[str]
        namespace: pulumi.Input[str]
        policy_name: pulumi.Input[str]
        """
        The name of the policy.
        """
        threshold: pulumi.Input[float]
        unit: pulumi.Input[str]
        action_type: NotRequired[pulumi.Input[str]]
        """
        The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
        """
        adjustment: NotRequired[pulumi.Input[str]]
        """
        The number of instances to add/remove to/from the target capacity when scale is needed.
        """
        cooldown: NotRequired[pulumi.Input[int]]
        """
        The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
        """
        dimensions: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A mapping of dimensions describing qualities of the metric.
        """
        evaluation_periods: NotRequired[pulumi.Input[int]]
        max_target_capacity: NotRequired[pulumi.Input[str]]
        """
        Max target capacity for scale down.
        """
        maximum: NotRequired[pulumi.Input[str]]
        """
        The maximum to set when scale is needed.
        """
        min_target_capacity: NotRequired[pulumi.Input[str]]
        """
        Min target capacity for scale up.
        """
        minimum: NotRequired[pulumi.Input[str]]
        """
        The minimum to set when scale is needed.
        """
        operator: NotRequired[pulumi.Input[str]]
        period: NotRequired[pulumi.Input[int]]
        statistic: NotRequired[pulumi.Input[str]]
        target: NotRequired[pulumi.Input[str]]
        """
        The number of instances to set when scale is needed.
        """
elif False:
    MrScalarTaskScalingDownPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarTaskScalingDownPolicyArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 policy_name: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 unit: pulumi.Input[str],
                 action_type: Optional[pulumi.Input[str]] = None,
                 adjustment: Optional[pulumi.Input[str]] = None,
                 cooldown: Optional[pulumi.Input[int]] = None,
                 dimensions: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 max_target_capacity: Optional[pulumi.Input[str]] = None,
                 maximum: Optional[pulumi.Input[str]] = None,
                 min_target_capacity: Optional[pulumi.Input[str]] = None,
                 minimum: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 statistic: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] policy_name: The name of the policy.
        :param pulumi.Input[str] action_type: The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
        :param pulumi.Input[str] adjustment: The number of instances to add/remove to/from the target capacity when scale is needed.
        :param pulumi.Input[int] cooldown: The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] dimensions: A mapping of dimensions describing qualities of the metric.
        :param pulumi.Input[str] max_target_capacity: Max target capacity for scale down.
        :param pulumi.Input[str] maximum: The maximum to set when scale is needed.
        :param pulumi.Input[str] min_target_capacity: Min target capacity for scale up.
        :param pulumi.Input[str] minimum: The minimum to set when scale is needed.
        :param pulumi.Input[str] target: The number of instances to set when scale is needed.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> pulumi.Input[str]:
        """
        The name of the policy.
        """
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_name", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[str]]:
        """
        The number of instances to add/remove to/from the target capacity when scale is needed.
        """
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
        """
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A mapping of dimensions describing qualities of the metric.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        Max target capacity for scale down.
        """
        return pulumi.get(self, "max_target_capacity")

    @max_target_capacity.setter
    def max_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_target_capacity", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum to set when scale is needed.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        Min target capacity for scale up.
        """
        return pulumi.get(self, "min_target_capacity")

    @min_target_capacity.setter
    def min_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_target_capacity", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum to set when scale is needed.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statistic", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        The number of instances to set when scale is needed.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class MrScalarTaskScalingUpPolicyArgsDict(TypedDict):
        metric_name: pulumi.Input[str]
        namespace: pulumi.Input[str]
        policy_name: pulumi.Input[str]
        """
        The name of the policy.
        """
        threshold: pulumi.Input[float]
        unit: pulumi.Input[str]
        action_type: NotRequired[pulumi.Input[str]]
        """
        The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
        """
        adjustment: NotRequired[pulumi.Input[str]]
        """
        The number of instances to add/remove to/from the target capacity when scale is needed.
        """
        cooldown: NotRequired[pulumi.Input[int]]
        """
        The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
        """
        dimensions: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A mapping of dimensions describing qualities of the metric.
        """
        evaluation_periods: NotRequired[pulumi.Input[int]]
        max_target_capacity: NotRequired[pulumi.Input[str]]
        """
        Max target capacity for scale down.
        """
        maximum: NotRequired[pulumi.Input[str]]
        """
        The maximum to set when scale is needed.
        """
        min_target_capacity: NotRequired[pulumi.Input[str]]
        """
        Min target capacity for scale up.
        """
        minimum: NotRequired[pulumi.Input[str]]
        """
        The minimum to set when scale is needed.
        """
        operator: NotRequired[pulumi.Input[str]]
        period: NotRequired[pulumi.Input[int]]
        statistic: NotRequired[pulumi.Input[str]]
        target: NotRequired[pulumi.Input[str]]
        """
        The number of instances to set when scale is needed.
        """
elif False:
    MrScalarTaskScalingUpPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarTaskScalingUpPolicyArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 policy_name: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 unit: pulumi.Input[str],
                 action_type: Optional[pulumi.Input[str]] = None,
                 adjustment: Optional[pulumi.Input[str]] = None,
                 cooldown: Optional[pulumi.Input[int]] = None,
                 dimensions: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 max_target_capacity: Optional[pulumi.Input[str]] = None,
                 maximum: Optional[pulumi.Input[str]] = None,
                 min_target_capacity: Optional[pulumi.Input[str]] = None,
                 minimum: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 statistic: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] policy_name: The name of the policy.
        :param pulumi.Input[str] action_type: The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
        :param pulumi.Input[str] adjustment: The number of instances to add/remove to/from the target capacity when scale is needed.
        :param pulumi.Input[int] cooldown: The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] dimensions: A mapping of dimensions describing qualities of the metric.
        :param pulumi.Input[str] max_target_capacity: Max target capacity for scale down.
        :param pulumi.Input[str] maximum: The maximum to set when scale is needed.
        :param pulumi.Input[str] min_target_capacity: Min target capacity for scale up.
        :param pulumi.Input[str] minimum: The minimum to set when scale is needed.
        :param pulumi.Input[str] target: The number of instances to set when scale is needed.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "unit", unit)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if adjustment is not None:
            pulumi.set(__self__, "adjustment", adjustment)
        if cooldown is not None:
            pulumi.set(__self__, "cooldown", cooldown)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if max_target_capacity is not None:
            pulumi.set(__self__, "max_target_capacity", max_target_capacity)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> pulumi.Input[str]:
        """
        The name of the policy.
        """
        return pulumi.get(self, "policy_name")

    @policy_name.setter
    def policy_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_name", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of action to perform. Allowed values are : 'adjustment', 'setMinTarget', 'setMaxTarget', 'updateCapacity', 'percentageAdjustment'
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def adjustment(self) -> Optional[pulumi.Input[str]]:
        """
        The number of instances to add/remove to/from the target capacity when scale is needed.
        """
        return pulumi.get(self, "adjustment")

    @adjustment.setter
    def adjustment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adjustment", value)

    @property
    @pulumi.getter
    def cooldown(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
        """
        return pulumi.get(self, "cooldown")

    @cooldown.setter
    def cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A mapping of dimensions describing qualities of the metric.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter(name="maxTargetCapacity")
    def max_target_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        Max target capacity for scale down.
        """
        return pulumi.get(self, "max_target_capacity")

    @max_target_capacity.setter
    def max_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_target_capacity", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum to set when scale is needed.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[pulumi.Input[str]]:
        """
        Min target capacity for scale up.
        """
        return pulumi.get(self, "min_target_capacity")

    @min_target_capacity.setter
    def min_target_capacity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_target_capacity", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum to set when scale is needed.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statistic", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        The number of instances to set when scale is needed.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class MrScalarTerminationPolicyArgsDict(TypedDict):
        statements: pulumi.Input[Sequence[pulumi.Input['MrScalarTerminationPolicyStatementArgsDict']]]
elif False:
    MrScalarTerminationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarTerminationPolicyArgs:
    def __init__(__self__, *,
                 statements: pulumi.Input[Sequence[pulumi.Input['MrScalarTerminationPolicyStatementArgs']]]):
        pulumi.set(__self__, "statements", statements)

    @property
    @pulumi.getter
    def statements(self) -> pulumi.Input[Sequence[pulumi.Input['MrScalarTerminationPolicyStatementArgs']]]:
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: pulumi.Input[Sequence[pulumi.Input['MrScalarTerminationPolicyStatementArgs']]]):
        pulumi.set(self, "statements", value)


if not MYPY:
    class MrScalarTerminationPolicyStatementArgsDict(TypedDict):
        metric_name: pulumi.Input[str]
        """
        The name of the metric in CloudWatch which the statement will be based on.
        """
        namespace: pulumi.Input[str]
        """
        Must contain the value: `AWS/ElasticMapReduce`.
        """
        threshold: pulumi.Input[float]
        """
        The value that the specified statistic is compared to.
        """
        evaluation_periods: NotRequired[pulumi.Input[int]]
        """
        The number of periods over which data is compared to the specified threshold.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
        """
        period: NotRequired[pulumi.Input[int]]
        """
        The time window in seconds over which the statistic is applied.
        """
        statistic: NotRequired[pulumi.Input[str]]
        """
        The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
        """
        unit: NotRequired[pulumi.Input[str]]
        """
        The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
        """
elif False:
    MrScalarTerminationPolicyStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MrScalarTerminationPolicyStatementArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 period: Optional[pulumi.Input[int]] = None,
                 statistic: Optional[pulumi.Input[str]] = None,
                 unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric_name: The name of the metric in CloudWatch which the statement will be based on.
        :param pulumi.Input[str] namespace: Must contain the value: `AWS/ElasticMapReduce`.
        :param pulumi.Input[float] threshold: The value that the specified statistic is compared to.
        :param pulumi.Input[int] evaluation_periods: The number of periods over which data is compared to the specified threshold.
        :param pulumi.Input[str] operator: The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
        :param pulumi.Input[int] period: The time window in seconds over which the statistic is applied.
        :param pulumi.Input[str] statistic: The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
        :param pulumi.Input[str] unit: The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "threshold", threshold)
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        The name of the metric in CloudWatch which the statement will be based on.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        Must contain the value: `AWS/ElasticMapReduce`.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        The value that the specified statistic is compared to.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        """
        The number of periods over which data is compared to the specified threshold.
        """
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use in order to determine if the policy is applicable. Valid values: `gt` | `gte` | `lt` | `lte`
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[int]]:
        """
        The time window in seconds over which the statistic is applied.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input[str]]:
        """
        The aggregation method of the given metric. Valid Values: `average` | `sum` | `sampleCount` | `maximum` | `minimum`
        """
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statistic", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        """
        The unit for a given metric. Valid Values: `seconds` | `microseconds` | `milliseconds` | `bytes` | `kilobytes` | `megabytes` | `gigabytes` | `terabytes` | `bits` | `kilobits` | `megabits` | `gigabits` | `terabits` | `percent` | `count` | `bytes/second` | `kilobytes/second` | `megabytes/second` | `gigabytes/second` | `terabytes/second` | `bits/second` | `kilobits/second` | `megabits/second` | `gigabits/second` | `terabits/second` | `count/second` | `none`
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class OceanAttachLoadBalancerArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of load balancer to use.
        """
        arn: NotRequired[pulumi.Input[str]]
        """
        If type is "TARGET_GROUP" then an ARN is required. Otherwise is not allowed.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        If type is "CLASSIC" then a name is required. Otherwise is not allowed.
        """
elif False:
    OceanAttachLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanAttachLoadBalancerArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 arn: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of load balancer to use.
        :param pulumi.Input[str] arn: If type is "TARGET_GROUP" then an ARN is required. Otherwise is not allowed.
        :param pulumi.Input[str] name: If type is "CLASSIC" then a name is required. Otherwise is not allowed.
        """
        pulumi.set(__self__, "type", type)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of load balancer to use.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        """
        If type is "TARGET_GROUP" then an ARN is required. Otherwise is not allowed.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        If type is "CLASSIC" then a name is required. Otherwise is not allowed.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class OceanAutoscalerArgsDict(TypedDict):
        auto_headroom_percentage: NotRequired[pulumi.Input[int]]
        """
        Set the auto headroom percentage (a number in the range [0, 200]) which controls the percentage of headroom from the cluster. Relevant only when `autoscale_is_auto_config` toggled on.
        """
        autoscale_cooldown: NotRequired[pulumi.Input[int]]
        """
        Cooldown period between scaling actions.
        """
        autoscale_down: NotRequired[pulumi.Input['OceanAutoscalerAutoscaleDownArgsDict']]
        """
        Auto Scaling scale down operations.
        """
        autoscale_headroom: NotRequired[pulumi.Input['OceanAutoscalerAutoscaleHeadroomArgsDict']]
        """
        Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
        """
        autoscale_is_auto_config: NotRequired[pulumi.Input[bool]]
        """
        Automatically configure and optimize headroom resources.
        """
        autoscale_is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable the Ocean Kubernetes Auto Scaler.
        """
        enable_automatic_and_manual_headroom: NotRequired[pulumi.Input[bool]]
        """
        enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
        """
        extended_resource_definitions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Ocean extended resource definitions to use in this cluster.
        """
        resource_limits: NotRequired[pulumi.Input['OceanAutoscalerResourceLimitsArgsDict']]
        """
        Optionally set upper and lower bounds on the resource usage of the cluster.
        """
elif False:
    OceanAutoscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanAutoscalerArgs:
    def __init__(__self__, *,
                 auto_headroom_percentage: Optional[pulumi.Input[int]] = None,
                 autoscale_cooldown: Optional[pulumi.Input[int]] = None,
                 autoscale_down: Optional[pulumi.Input['OceanAutoscalerAutoscaleDownArgs']] = None,
                 autoscale_headroom: Optional[pulumi.Input['OceanAutoscalerAutoscaleHeadroomArgs']] = None,
                 autoscale_is_auto_config: Optional[pulumi.Input[bool]] = None,
                 autoscale_is_enabled: Optional[pulumi.Input[bool]] = None,
                 enable_automatic_and_manual_headroom: Optional[pulumi.Input[bool]] = None,
                 extended_resource_definitions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_limits: Optional[pulumi.Input['OceanAutoscalerResourceLimitsArgs']] = None):
        """
        :param pulumi.Input[int] auto_headroom_percentage: Set the auto headroom percentage (a number in the range [0, 200]) which controls the percentage of headroom from the cluster. Relevant only when `autoscale_is_auto_config` toggled on.
        :param pulumi.Input[int] autoscale_cooldown: Cooldown period between scaling actions.
        :param pulumi.Input['OceanAutoscalerAutoscaleDownArgs'] autoscale_down: Auto Scaling scale down operations.
        :param pulumi.Input['OceanAutoscalerAutoscaleHeadroomArgs'] autoscale_headroom: Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
        :param pulumi.Input[bool] autoscale_is_auto_config: Automatically configure and optimize headroom resources.
        :param pulumi.Input[bool] autoscale_is_enabled: Enable the Ocean Kubernetes Auto Scaler.
        :param pulumi.Input[bool] enable_automatic_and_manual_headroom: enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extended_resource_definitions: List of Ocean extended resource definitions to use in this cluster.
        :param pulumi.Input['OceanAutoscalerResourceLimitsArgs'] resource_limits: Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        if auto_headroom_percentage is not None:
            pulumi.set(__self__, "auto_headroom_percentage", auto_headroom_percentage)
        if autoscale_cooldown is not None:
            pulumi.set(__self__, "autoscale_cooldown", autoscale_cooldown)
        if autoscale_down is not None:
            pulumi.set(__self__, "autoscale_down", autoscale_down)
        if autoscale_headroom is not None:
            pulumi.set(__self__, "autoscale_headroom", autoscale_headroom)
        if autoscale_is_auto_config is not None:
            pulumi.set(__self__, "autoscale_is_auto_config", autoscale_is_auto_config)
        if autoscale_is_enabled is not None:
            pulumi.set(__self__, "autoscale_is_enabled", autoscale_is_enabled)
        if enable_automatic_and_manual_headroom is not None:
            pulumi.set(__self__, "enable_automatic_and_manual_headroom", enable_automatic_and_manual_headroom)
        if extended_resource_definitions is not None:
            pulumi.set(__self__, "extended_resource_definitions", extended_resource_definitions)
        if resource_limits is not None:
            pulumi.set(__self__, "resource_limits", resource_limits)

    @property
    @pulumi.getter(name="autoHeadroomPercentage")
    def auto_headroom_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Set the auto headroom percentage (a number in the range [0, 200]) which controls the percentage of headroom from the cluster. Relevant only when `autoscale_is_auto_config` toggled on.
        """
        return pulumi.get(self, "auto_headroom_percentage")

    @auto_headroom_percentage.setter
    def auto_headroom_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auto_headroom_percentage", value)

    @property
    @pulumi.getter(name="autoscaleCooldown")
    def autoscale_cooldown(self) -> Optional[pulumi.Input[int]]:
        """
        Cooldown period between scaling actions.
        """
        return pulumi.get(self, "autoscale_cooldown")

    @autoscale_cooldown.setter
    def autoscale_cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autoscale_cooldown", value)

    @property
    @pulumi.getter(name="autoscaleDown")
    def autoscale_down(self) -> Optional[pulumi.Input['OceanAutoscalerAutoscaleDownArgs']]:
        """
        Auto Scaling scale down operations.
        """
        return pulumi.get(self, "autoscale_down")

    @autoscale_down.setter
    def autoscale_down(self, value: Optional[pulumi.Input['OceanAutoscalerAutoscaleDownArgs']]):
        pulumi.set(self, "autoscale_down", value)

    @property
    @pulumi.getter(name="autoscaleHeadroom")
    def autoscale_headroom(self) -> Optional[pulumi.Input['OceanAutoscalerAutoscaleHeadroomArgs']]:
        """
        Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
        """
        return pulumi.get(self, "autoscale_headroom")

    @autoscale_headroom.setter
    def autoscale_headroom(self, value: Optional[pulumi.Input['OceanAutoscalerAutoscaleHeadroomArgs']]):
        pulumi.set(self, "autoscale_headroom", value)

    @property
    @pulumi.getter(name="autoscaleIsAutoConfig")
    def autoscale_is_auto_config(self) -> Optional[pulumi.Input[bool]]:
        """
        Automatically configure and optimize headroom resources.
        """
        return pulumi.get(self, "autoscale_is_auto_config")

    @autoscale_is_auto_config.setter
    def autoscale_is_auto_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale_is_auto_config", value)

    @property
    @pulumi.getter(name="autoscaleIsEnabled")
    def autoscale_is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the Ocean Kubernetes Auto Scaler.
        """
        return pulumi.get(self, "autoscale_is_enabled")

    @autoscale_is_enabled.setter
    def autoscale_is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autoscale_is_enabled", value)

    @property
    @pulumi.getter(name="enableAutomaticAndManualHeadroom")
    def enable_automatic_and_manual_headroom(self) -> Optional[pulumi.Input[bool]]:
        """
        enables automatic and manual headroom to work in parallel. When set to false, automatic headroom overrides all other headroom definitions manually configured, whether they are at cluster or VNG level.
        """
        return pulumi.get(self, "enable_automatic_and_manual_headroom")

    @enable_automatic_and_manual_headroom.setter
    def enable_automatic_and_manual_headroom(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_automatic_and_manual_headroom", value)

    @property
    @pulumi.getter(name="extendedResourceDefinitions")
    def extended_resource_definitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Ocean extended resource definitions to use in this cluster.
        """
        return pulumi.get(self, "extended_resource_definitions")

    @extended_resource_definitions.setter
    def extended_resource_definitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extended_resource_definitions", value)

    @property
    @pulumi.getter(name="resourceLimits")
    def resource_limits(self) -> Optional[pulumi.Input['OceanAutoscalerResourceLimitsArgs']]:
        """
        Optionally set upper and lower bounds on the resource usage of the cluster.
        """
        return pulumi.get(self, "resource_limits")

    @resource_limits.setter
    def resource_limits(self, value: Optional[pulumi.Input['OceanAutoscalerResourceLimitsArgs']]):
        pulumi.set(self, "resource_limits", value)


if not MYPY:
    class OceanAutoscalerAutoscaleDownArgsDict(TypedDict):
        evaluation_periods: NotRequired[pulumi.Input[int]]
        is_aggressive_scale_down_enabled: NotRequired[pulumi.Input[bool]]
        """
        When set to 'true', the Aggressive Scale Down feature is enabled.
        """
        max_scale_down_percentage: NotRequired[pulumi.Input[float]]
        """
        Would represent the maximum % to scale-down. Number between 1-100.
        """
elif False:
    OceanAutoscalerAutoscaleDownArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanAutoscalerAutoscaleDownArgs:
    def __init__(__self__, *,
                 evaluation_periods: Optional[pulumi.Input[int]] = None,
                 is_aggressive_scale_down_enabled: Optional[pulumi.Input[bool]] = None,
                 max_scale_down_percentage: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[bool] is_aggressive_scale_down_enabled: When set to 'true', the Aggressive Scale Down feature is enabled.
        :param pulumi.Input[float] max_scale_down_percentage: Would represent the maximum % to scale-down. Number between 1-100.
        """
        if evaluation_periods is not None:
            pulumi.set(__self__, "evaluation_periods", evaluation_periods)
        if is_aggressive_scale_down_enabled is not None:
            pulumi.set(__self__, "is_aggressive_scale_down_enabled", is_aggressive_scale_down_enabled)
        if max_scale_down_percentage is not None:
            pulumi.set(__self__, "max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "evaluation_periods")

    @evaluation_periods.setter
    def evaluation_periods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "evaluation_periods", value)

    @property
    @pulumi.getter(name="isAggressiveScaleDownEnabled")
    def is_aggressive_scale_down_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to 'true', the Aggressive Scale Down feature is enabled.
        """
        return pulumi.get(self, "is_aggressive_scale_down_enabled")

    @is_aggressive_scale_down_enabled.setter
    def is_aggressive_scale_down_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_aggressive_scale_down_enabled", value)

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        Would represent the maximum % to scale-down. Number between 1-100.
        """
        return pulumi.get(self, "max_scale_down_percentage")

    @max_scale_down_percentage.setter
    def max_scale_down_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_scale_down_percentage", value)


if not MYPY:
    class OceanAutoscalerAutoscaleHeadroomArgsDict(TypedDict):
        cpu_per_unit: NotRequired[pulumi.Input[int]]
        """
        Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        gpu_per_unit: NotRequired[pulumi.Input[int]]
        """
        Optionally configure the number of GPUs to allocate the headroom.
        """
        memory_per_unit: NotRequired[pulumi.Input[int]]
        """
        Optionally configure the amount of memory (MB) to allocate the headroom.
        """
        num_of_units: NotRequired[pulumi.Input[int]]
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
elif False:
    OceanAutoscalerAutoscaleHeadroomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanAutoscalerAutoscaleHeadroomArgs:
    def __init__(__self__, *,
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 gpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None,
                 num_of_units: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] cpu_per_unit: Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[int] gpu_per_unit: Optionally configure the number of GPUs to allocate the headroom.
        :param pulumi.Input[int] memory_per_unit: Optionally configure the amount of memory (MB) to allocate the headroom.
        :param pulumi.Input[int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)
        if num_of_units is not None:
            pulumi.set(__self__, "num_of_units", num_of_units)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of GPUs to allocate the headroom.
        """
        return pulumi.get(self, "gpu_per_unit")

    @gpu_per_unit.setter
    def gpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the amount of memory (MB) to allocate the headroom.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> Optional[pulumi.Input[int]]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_of_units", value)


if not MYPY:
    class OceanAutoscalerResourceLimitsArgsDict(TypedDict):
        max_memory_gib: NotRequired[pulumi.Input[int]]
        """
        The maximum memory in GiB units that can be allocated to the cluster.
        """
        max_vcpu: NotRequired[pulumi.Input[int]]
        """
        The maximum cpu in vCPU units that can be allocated to the cluster.
        """
elif False:
    OceanAutoscalerResourceLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanAutoscalerResourceLimitsArgs:
    def __init__(__self__, *,
                 max_memory_gib: Optional[pulumi.Input[int]] = None,
                 max_vcpu: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_memory_gib: The maximum memory in GiB units that can be allocated to the cluster.
        :param pulumi.Input[int] max_vcpu: The maximum cpu in vCPU units that can be allocated to the cluster.
        """
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum memory in GiB units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_memory_gib")

    @max_memory_gib.setter
    def max_memory_gib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_memory_gib", value)

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum cpu in vCPU units that can be allocated to the cluster.
        """
        return pulumi.get(self, "max_vcpu")

    @max_vcpu.setter
    def max_vcpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_vcpu", value)


if not MYPY:
    class OceanBlockDeviceMappingArgsDict(TypedDict):
        device_name: NotRequired[pulumi.Input[str]]
        """
        String. Set device name. (Example: `/dev/xvda`).
        """
        ebs: NotRequired[pulumi.Input['OceanBlockDeviceMappingEbsArgsDict']]
        """
        Object. Set Elastic Block Store properties .
        """
elif False:
    OceanBlockDeviceMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 device_name: Optional[pulumi.Input[str]] = None,
                 ebs: Optional[pulumi.Input['OceanBlockDeviceMappingEbsArgs']] = None):
        """
        :param pulumi.Input[str] device_name: String. Set device name. (Example: `/dev/xvda`).
        :param pulumi.Input['OceanBlockDeviceMappingEbsArgs'] ebs: Object. Set Elastic Block Store properties .
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        String. Set device name. (Example: `/dev/xvda`).
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def ebs(self) -> Optional[pulumi.Input['OceanBlockDeviceMappingEbsArgs']]:
        """
        Object. Set Elastic Block Store properties .
        """
        return pulumi.get(self, "ebs")

    @ebs.setter
    def ebs(self, value: Optional[pulumi.Input['OceanBlockDeviceMappingEbsArgs']]):
        pulumi.set(self, "ebs", value)


if not MYPY:
    class OceanBlockDeviceMappingEbsArgsDict(TypedDict):
        delete_on_termination: NotRequired[pulumi.Input[bool]]
        """
        Boolean. Flag to delete the EBS on instance termination.
        """
        dynamic_iops: NotRequired[pulumi.Input['OceanBlockDeviceMappingEbsDynamicIopsArgsDict']]
        """
        Set dynamic IOPS properties. When using this object, you cannot use the `iops` attribute. You must use one or the other.
        """
        dynamic_volume_size: NotRequired[pulumi.Input['OceanBlockDeviceMappingEbsDynamicVolumeSizeArgsDict']]
        """
        Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
        """
        encrypted: NotRequired[pulumi.Input[bool]]
        """
        Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        """
        iops: NotRequired[pulumi.Input[int]]
        """
        Must be greater than or equal to 0.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
        """
        snapshot_id: NotRequired[pulumi.Input[str]]
        """
        (Optional) String. The Snapshot ID to mount by.
        """
        throughput: NotRequired[pulumi.Input[int]]
        """
        The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volume_type` = `gp3`.
        """
        volume_size: NotRequired[pulumi.Input[int]]
        """
        Int. The size, in GB of the volume.
        """
        volume_type: NotRequired[pulumi.Input[str]]
        """
        String. The type of the volume. (Example: `gp2`).
        """
elif False:
    OceanBlockDeviceMappingEbsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanBlockDeviceMappingEbsArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 dynamic_iops: Optional[pulumi.Input['OceanBlockDeviceMappingEbsDynamicIopsArgs']] = None,
                 dynamic_volume_size: Optional[pulumi.Input['OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs']] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] delete_on_termination: Boolean. Flag to delete the EBS on instance termination.
        :param pulumi.Input['OceanBlockDeviceMappingEbsDynamicIopsArgs'] dynamic_iops: Set dynamic IOPS properties. When using this object, you cannot use the `iops` attribute. You must use one or the other.
        :param pulumi.Input['OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs'] dynamic_volume_size: Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
        :param pulumi.Input[bool] encrypted: Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        :param pulumi.Input[int] iops: Must be greater than or equal to 0.
        :param pulumi.Input[str] kms_key_id: String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
        :param pulumi.Input[str] snapshot_id: (Optional) String. The Snapshot ID to mount by.
        :param pulumi.Input[int] throughput: The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volume_type` = `gp3`.
        :param pulumi.Input[int] volume_size: Int. The size, in GB of the volume.
        :param pulumi.Input[str] volume_type: String. The type of the volume. (Example: `gp2`).
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if dynamic_iops is not None:
            pulumi.set(__self__, "dynamic_iops", dynamic_iops)
        if dynamic_volume_size is not None:
            pulumi.set(__self__, "dynamic_volume_size", dynamic_volume_size)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean. Flag to delete the EBS on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter(name="dynamicIops")
    def dynamic_iops(self) -> Optional[pulumi.Input['OceanBlockDeviceMappingEbsDynamicIopsArgs']]:
        """
        Set dynamic IOPS properties. When using this object, you cannot use the `iops` attribute. You must use one or the other.
        """
        return pulumi.get(self, "dynamic_iops")

    @dynamic_iops.setter
    def dynamic_iops(self, value: Optional[pulumi.Input['OceanBlockDeviceMappingEbsDynamicIopsArgs']]):
        pulumi.set(self, "dynamic_iops", value)

    @property
    @pulumi.getter(name="dynamicVolumeSize")
    def dynamic_volume_size(self) -> Optional[pulumi.Input['OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs']]:
        """
        Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
        """
        return pulumi.get(self, "dynamic_volume_size")

    @dynamic_volume_size.setter
    def dynamic_volume_size(self, value: Optional[pulumi.Input['OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs']]):
        pulumi.set(self, "dynamic_volume_size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Must be greater than or equal to 0.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) String. The Snapshot ID to mount by.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volume_type` = `gp3`.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        Int. The size, in GB of the volume.
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        String. The type of the volume. (Example: `gp2`).
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class OceanBlockDeviceMappingEbsDynamicIopsArgsDict(TypedDict):
        base_size: pulumi.Input[int]
        """
        Initial size for IOPS.
        """
        resource: pulumi.Input[str]
        size_per_resource_unit: pulumi.Input[int]
        """
        Additional size per resource unit (in IOPS). (Example: `baseSize=50`, `sizePerResourceUnit=20`, and an instance with 2 CPU is launched; its IOPS size will be: 90).
        """
elif False:
    OceanBlockDeviceMappingEbsDynamicIopsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanBlockDeviceMappingEbsDynamicIopsArgs:
    def __init__(__self__, *,
                 base_size: pulumi.Input[int],
                 resource: pulumi.Input[str],
                 size_per_resource_unit: pulumi.Input[int]):
        """
        :param pulumi.Input[int] base_size: Initial size for IOPS.
        :param pulumi.Input[int] size_per_resource_unit: Additional size per resource unit (in IOPS). (Example: `baseSize=50`, `sizePerResourceUnit=20`, and an instance with 2 CPU is launched; its IOPS size will be: 90).
        """
        pulumi.set(__self__, "base_size", base_size)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "size_per_resource_unit", size_per_resource_unit)

    @property
    @pulumi.getter(name="baseSize")
    def base_size(self) -> pulumi.Input[int]:
        """
        Initial size for IOPS.
        """
        return pulumi.get(self, "base_size")

    @base_size.setter
    def base_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "base_size", value)

    @property
    @pulumi.getter
    def resource(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter(name="sizePerResourceUnit")
    def size_per_resource_unit(self) -> pulumi.Input[int]:
        """
        Additional size per resource unit (in IOPS). (Example: `baseSize=50`, `sizePerResourceUnit=20`, and an instance with 2 CPU is launched; its IOPS size will be: 90).
        """
        return pulumi.get(self, "size_per_resource_unit")

    @size_per_resource_unit.setter
    def size_per_resource_unit(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_per_resource_unit", value)


if not MYPY:
    class OceanBlockDeviceMappingEbsDynamicVolumeSizeArgsDict(TypedDict):
        base_size: pulumi.Input[int]
        """
        Int. Initial size for volume. (Example: 50)
        """
        resource: pulumi.Input[str]
        """
        String. Resource type to increase volume size dynamically by. (Valid values: `CPU`)
        """
        size_per_resource_unit: pulumi.Input[int]
        """
        Int. Additional size (in GB) per resource unit. (Example: `baseSize=50`, `sizePerResourceUnit=20`, and instance with 2 CPU is launched; its total disk size will be: 90GB).
        """
elif False:
    OceanBlockDeviceMappingEbsDynamicVolumeSizeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanBlockDeviceMappingEbsDynamicVolumeSizeArgs:
    def __init__(__self__, *,
                 base_size: pulumi.Input[int],
                 resource: pulumi.Input[str],
                 size_per_resource_unit: pulumi.Input[int]):
        """
        :param pulumi.Input[int] base_size: Int. Initial size for volume. (Example: 50)
        :param pulumi.Input[str] resource: String. Resource type to increase volume size dynamically by. (Valid values: `CPU`)
        :param pulumi.Input[int] size_per_resource_unit: Int. Additional size (in GB) per resource unit. (Example: `baseSize=50`, `sizePerResourceUnit=20`, and instance with 2 CPU is launched; its total disk size will be: 90GB).
        """
        pulumi.set(__self__, "base_size", base_size)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "size_per_resource_unit", size_per_resource_unit)

    @property
    @pulumi.getter(name="baseSize")
    def base_size(self) -> pulumi.Input[int]:
        """
        Int. Initial size for volume. (Example: 50)
        """
        return pulumi.get(self, "base_size")

    @base_size.setter
    def base_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "base_size", value)

    @property
    @pulumi.getter
    def resource(self) -> pulumi.Input[str]:
        """
        String. Resource type to increase volume size dynamically by. (Valid values: `CPU`)
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter(name="sizePerResourceUnit")
    def size_per_resource_unit(self) -> pulumi.Input[int]:
        """
        Int. Additional size (in GB) per resource unit. (Example: `baseSize=50`, `sizePerResourceUnit=20`, and instance with 2 CPU is launched; its total disk size will be: 90GB).
        """
        return pulumi.get(self, "size_per_resource_unit")

    @size_per_resource_unit.setter
    def size_per_resource_unit(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_per_resource_unit", value)


if not MYPY:
    class OceanClusterOrientationArgsDict(TypedDict):
        availability_vs_cost: NotRequired[pulumi.Input[str]]
        """
        You can control the approach that Ocean takes while launching nodes by configuring this value. Possible values: `costOriented`,`balanced`,`cheapest`.
        """
elif False:
    OceanClusterOrientationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanClusterOrientationArgs:
    def __init__(__self__, *,
                 availability_vs_cost: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_vs_cost: You can control the approach that Ocean takes while launching nodes by configuring this value. Possible values: `costOriented`,`balanced`,`cheapest`.
        """
        if availability_vs_cost is not None:
            pulumi.set(__self__, "availability_vs_cost", availability_vs_cost)

    @property
    @pulumi.getter(name="availabilityVsCost")
    def availability_vs_cost(self) -> Optional[pulumi.Input[str]]:
        """
        You can control the approach that Ocean takes while launching nodes by configuring this value. Possible values: `costOriented`,`balanced`,`cheapest`.
        """
        return pulumi.get(self, "availability_vs_cost")

    @availability_vs_cost.setter
    def availability_vs_cost(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_vs_cost", value)


if not MYPY:
    class OceanDetachLoadBalancerArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of load balancer to use.
        """
        arn: NotRequired[pulumi.Input[str]]
        """
        If type is "TARGET_GROUP" then an ARN is required. Otherwise is not allowed.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        If type is "CLASSIC" then a name is required. Otherwise is not allowed.
        """
elif False:
    OceanDetachLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanDetachLoadBalancerArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 arn: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of load balancer to use.
        :param pulumi.Input[str] arn: If type is "TARGET_GROUP" then an ARN is required. Otherwise is not allowed.
        :param pulumi.Input[str] name: If type is "CLASSIC" then a name is required. Otherwise is not allowed.
        """
        pulumi.set(__self__, "type", type)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of load balancer to use.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        """
        If type is "TARGET_GROUP" then an ARN is required. Otherwise is not allowed.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        If type is "CLASSIC" then a name is required. Otherwise is not allowed.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class OceanFiltersArgsDict(TypedDict):
        architectures: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The filtered instance types will support at least one of the architectures from this list.
        """
        categories: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The filtered instance types will belong to one of the categories types from this list.
        """
        disk_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The filtered instance types will have one of the disk type from this list.
        """
        exclude_families: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
        """
        exclude_metal: NotRequired[pulumi.Input[bool]]
        """
        In case excludeMetal is set to true, metal types will not be available for scaling.
        """
        hypervisors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The filtered instance types will have a hypervisor type from this list.
        """
        include_families: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
        """
        is_ena_supported: NotRequired[pulumi.Input[str]]
        """
        Ena is supported or not.
        """
        max_gpu: NotRequired[pulumi.Input[int]]
        """
        Maximum total number of GPUs.
        """
        max_memory_gib: NotRequired[pulumi.Input[float]]
        max_network_performance: NotRequired[pulumi.Input[int]]
        """
        Maximum Bandwidth in Gib/s of network performance.
        """
        max_vcpu: NotRequired[pulumi.Input[int]]
        min_enis: NotRequired[pulumi.Input[int]]
        """
        Minimum number of network interfaces (ENIs).
        """
        min_gpu: NotRequired[pulumi.Input[int]]
        """
        Minimum total number of GPUs.
        """
        min_memory_gib: NotRequired[pulumi.Input[float]]
        """
        Minimum amount of Memory (GiB).
        """
        min_network_performance: NotRequired[pulumi.Input[int]]
        """
        Minimum Bandwidth in Gib/s of network performance.
        """
        min_vcpu: NotRequired[pulumi.Input[int]]
        """
        Minimum number of vcpus available.
        """
        root_device_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The filtered instance types will have a root device types from this list.
        """
        virtualization_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The filtered instance types will support at least one of the virtualization types from this list.
        """
elif False:
    OceanFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanFiltersArgs:
    def __init__(__self__, *,
                 architectures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 disk_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exclude_families: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exclude_metal: Optional[pulumi.Input[bool]] = None,
                 hypervisors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_families: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 is_ena_supported: Optional[pulumi.Input[str]] = None,
                 max_gpu: Optional[pulumi.Input[int]] = None,
                 max_memory_gib: Optional[pulumi.Input[float]] = None,
                 max_network_performance: Optional[pulumi.Input[int]] = None,
                 max_vcpu: Optional[pulumi.Input[int]] = None,
                 min_enis: Optional[pulumi.Input[int]] = None,
                 min_gpu: Optional[pulumi.Input[int]] = None,
                 min_memory_gib: Optional[pulumi.Input[float]] = None,
                 min_network_performance: Optional[pulumi.Input[int]] = None,
                 min_vcpu: Optional[pulumi.Input[int]] = None,
                 root_device_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 virtualization_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] architectures: The filtered instance types will support at least one of the architectures from this list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] categories: The filtered instance types will belong to one of the categories types from this list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] disk_types: The filtered instance types will have one of the disk type from this list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_families: Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
        :param pulumi.Input[bool] exclude_metal: In case excludeMetal is set to true, metal types will not be available for scaling.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hypervisors: The filtered instance types will have a hypervisor type from this list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_families: Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
        :param pulumi.Input[str] is_ena_supported: Ena is supported or not.
        :param pulumi.Input[int] max_gpu: Maximum total number of GPUs.
        :param pulumi.Input[int] max_network_performance: Maximum Bandwidth in Gib/s of network performance.
        :param pulumi.Input[int] min_enis: Minimum number of network interfaces (ENIs).
        :param pulumi.Input[int] min_gpu: Minimum total number of GPUs.
        :param pulumi.Input[float] min_memory_gib: Minimum amount of Memory (GiB).
        :param pulumi.Input[int] min_network_performance: Minimum Bandwidth in Gib/s of network performance.
        :param pulumi.Input[int] min_vcpu: Minimum number of vcpus available.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] root_device_types: The filtered instance types will have a root device types from this list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] virtualization_types: The filtered instance types will support at least one of the virtualization types from this list.
        """
        if architectures is not None:
            pulumi.set(__self__, "architectures", architectures)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if disk_types is not None:
            pulumi.set(__self__, "disk_types", disk_types)
        if exclude_families is not None:
            pulumi.set(__self__, "exclude_families", exclude_families)
        if exclude_metal is not None:
            pulumi.set(__self__, "exclude_metal", exclude_metal)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if include_families is not None:
            pulumi.set(__self__, "include_families", include_families)
        if is_ena_supported is not None:
            pulumi.set(__self__, "is_ena_supported", is_ena_supported)
        if max_gpu is not None:
            pulumi.set(__self__, "max_gpu", max_gpu)
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_network_performance is not None:
            pulumi.set(__self__, "max_network_performance", max_network_performance)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)
        if min_enis is not None:
            pulumi.set(__self__, "min_enis", min_enis)
        if min_gpu is not None:
            pulumi.set(__self__, "min_gpu", min_gpu)
        if min_memory_gib is not None:
            pulumi.set(__self__, "min_memory_gib", min_memory_gib)
        if min_network_performance is not None:
            pulumi.set(__self__, "min_network_performance", min_network_performance)
        if min_vcpu is not None:
            pulumi.set(__self__, "min_vcpu", min_vcpu)
        if root_device_types is not None:
            pulumi.set(__self__, "root_device_types", root_device_types)
        if virtualization_types is not None:
            pulumi.set(__self__, "virtualization_types", virtualization_types)

    @property
    @pulumi.getter
    def architectures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will support at least one of the architectures from this list.
        """
        return pulumi.get(self, "architectures")

    @architectures.setter
    def architectures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "architectures", value)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will belong to one of the categories types from this list.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter(name="diskTypes")
    def disk_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will have one of the disk type from this list.
        """
        return pulumi.get(self, "disk_types")

    @disk_types.setter
    def disk_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "disk_types", value)

    @property
    @pulumi.getter(name="excludeFamilies")
    def exclude_families(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
        """
        return pulumi.get(self, "exclude_families")

    @exclude_families.setter
    def exclude_families(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_families", value)

    @property
    @pulumi.getter(name="excludeMetal")
    def exclude_metal(self) -> Optional[pulumi.Input[bool]]:
        """
        In case excludeMetal is set to true, metal types will not be available for scaling.
        """
        return pulumi.get(self, "exclude_metal")

    @exclude_metal.setter
    def exclude_metal(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude_metal", value)

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will have a hypervisor type from this list.
        """
        return pulumi.get(self, "hypervisors")

    @hypervisors.setter
    def hypervisors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hypervisors", value)

    @property
    @pulumi.getter(name="includeFamilies")
    def include_families(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
        """
        return pulumi.get(self, "include_families")

    @include_families.setter
    def include_families(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_families", value)

    @property
    @pulumi.getter(name="isEnaSupported")
    def is_ena_supported(self) -> Optional[pulumi.Input[str]]:
        """
        Ena is supported or not.
        """
        return pulumi.get(self, "is_ena_supported")

    @is_ena_supported.setter
    def is_ena_supported(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_ena_supported", value)

    @property
    @pulumi.getter(name="maxGpu")
    def max_gpu(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum total number of GPUs.
        """
        return pulumi.get(self, "max_gpu")

    @max_gpu.setter
    def max_gpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_gpu", value)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "max_memory_gib")

    @max_memory_gib.setter
    def max_memory_gib(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_memory_gib", value)

    @property
    @pulumi.getter(name="maxNetworkPerformance")
    def max_network_performance(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum Bandwidth in Gib/s of network performance.
        """
        return pulumi.get(self, "max_network_performance")

    @max_network_performance.setter
    def max_network_performance(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_network_performance", value)

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_vcpu")

    @max_vcpu.setter
    def max_vcpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_vcpu", value)

    @property
    @pulumi.getter(name="minEnis")
    def min_enis(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of network interfaces (ENIs).
        """
        return pulumi.get(self, "min_enis")

    @min_enis.setter
    def min_enis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_enis", value)

    @property
    @pulumi.getter(name="minGpu")
    def min_gpu(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum total number of GPUs.
        """
        return pulumi.get(self, "min_gpu")

    @min_gpu.setter
    def min_gpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_gpu", value)

    @property
    @pulumi.getter(name="minMemoryGib")
    def min_memory_gib(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum amount of Memory (GiB).
        """
        return pulumi.get(self, "min_memory_gib")

    @min_memory_gib.setter
    def min_memory_gib(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_memory_gib", value)

    @property
    @pulumi.getter(name="minNetworkPerformance")
    def min_network_performance(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum Bandwidth in Gib/s of network performance.
        """
        return pulumi.get(self, "min_network_performance")

    @min_network_performance.setter
    def min_network_performance(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_network_performance", value)

    @property
    @pulumi.getter(name="minVcpu")
    def min_vcpu(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of vcpus available.
        """
        return pulumi.get(self, "min_vcpu")

    @min_vcpu.setter
    def min_vcpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_vcpu", value)

    @property
    @pulumi.getter(name="rootDeviceTypes")
    def root_device_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will have a root device types from this list.
        """
        return pulumi.get(self, "root_device_types")

    @root_device_types.setter
    def root_device_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "root_device_types", value)

    @property
    @pulumi.getter(name="virtualizationTypes")
    def virtualization_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will support at least one of the virtualization types from this list.
        """
        return pulumi.get(self, "virtualization_types")

    @virtualization_types.setter
    def virtualization_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "virtualization_types", value)


if not MYPY:
    class OceanInstanceMetadataOptionsArgsDict(TypedDict):
        http_tokens: pulumi.Input[str]
        """
        Determines if a signed token is required or not. Valid values: `optional` or `required`.
        """
        http_put_response_hop_limit: NotRequired[pulumi.Input[int]]
        """
        An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
        """
elif False:
    OceanInstanceMetadataOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanInstanceMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_tokens: pulumi.Input[str],
                 http_put_response_hop_limit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] http_tokens: Determines if a signed token is required or not. Valid values: `optional` or `required`.
        :param pulumi.Input[int] http_put_response_hop_limit: An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
        """
        pulumi.set(__self__, "http_tokens", http_tokens)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> pulumi.Input[str]:
        """
        Determines if a signed token is required or not. Valid values: `optional` or `required`.
        """
        return pulumi.get(self, "http_tokens")

    @http_tokens.setter
    def http_tokens(self, value: pulumi.Input[str]):
        pulumi.set(self, "http_tokens", value)

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[int]]:
        """
        An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_put_response_hop_limit", value)


if not MYPY:
    class OceanLaunchSpecAutoscaleDownArgsDict(TypedDict):
        max_scale_down_percentage: NotRequired[pulumi.Input[float]]
        """
        The maximum percentage allowed to scale down in a single scaling action on the nodes running in a specific VNG. Allowed only if maxScaleDownPercentage is set to null at the cluster level. Number between [0.1-100].
        """
elif False:
    OceanLaunchSpecAutoscaleDownArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecAutoscaleDownArgs:
    def __init__(__self__, *,
                 max_scale_down_percentage: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] max_scale_down_percentage: The maximum percentage allowed to scale down in a single scaling action on the nodes running in a specific VNG. Allowed only if maxScaleDownPercentage is set to null at the cluster level. Number between [0.1-100].
        """
        if max_scale_down_percentage is not None:
            pulumi.set(__self__, "max_scale_down_percentage", max_scale_down_percentage)

    @property
    @pulumi.getter(name="maxScaleDownPercentage")
    def max_scale_down_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        The maximum percentage allowed to scale down in a single scaling action on the nodes running in a specific VNG. Allowed only if maxScaleDownPercentage is set to null at the cluster level. Number between [0.1-100].
        """
        return pulumi.get(self, "max_scale_down_percentage")

    @max_scale_down_percentage.setter
    def max_scale_down_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_scale_down_percentage", value)


if not MYPY:
    class OceanLaunchSpecAutoscaleHeadroomArgsDict(TypedDict):
        num_of_units: pulumi.Input[int]
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        cpu_per_unit: NotRequired[pulumi.Input[int]]
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        gpu_per_unit: NotRequired[pulumi.Input[int]]
        """
        Optionally configure the number of GPUS to allocate for each headroom unit.
        """
        memory_per_unit: NotRequired[pulumi.Input[int]]
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
elif False:
    OceanLaunchSpecAutoscaleHeadroomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecAutoscaleHeadroomArgs:
    def __init__(__self__, *,
                 num_of_units: pulumi.Input[int],
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 gpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        :param pulumi.Input[int] cpu_per_unit: Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[int] gpu_per_unit: Optionally configure the number of GPUS to allocate for each headroom unit.
        :param pulumi.Input[int] memory_per_unit: Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        pulumi.set(__self__, "num_of_units", num_of_units)
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> pulumi.Input[int]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "num_of_units", value)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of GPUS to allocate for each headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @gpu_per_unit.setter
    def gpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)


if not MYPY:
    class OceanLaunchSpecAutoscaleHeadroomsAutomaticArgsDict(TypedDict):
        auto_headroom_percentage: NotRequired[pulumi.Input[int]]
        """
        Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.`is_enabled` = true is set on the Ocean cluster.
        """
elif False:
    OceanLaunchSpecAutoscaleHeadroomsAutomaticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecAutoscaleHeadroomsAutomaticArgs:
    def __init__(__self__, *,
                 auto_headroom_percentage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] auto_headroom_percentage: Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.`is_enabled` = true is set on the Ocean cluster.
        """
        if auto_headroom_percentage is not None:
            pulumi.set(__self__, "auto_headroom_percentage", auto_headroom_percentage)

    @property
    @pulumi.getter(name="autoHeadroomPercentage")
    def auto_headroom_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Number between 0-200 to control the headroom % of the specific Virtual Node Group. Effective when cluster.autoScaler.headroom.automatic.`is_enabled` = true is set on the Ocean cluster.
        """
        return pulumi.get(self, "auto_headroom_percentage")

    @auto_headroom_percentage.setter
    def auto_headroom_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auto_headroom_percentage", value)


if not MYPY:
    class OceanLaunchSpecBlockDeviceMappingArgsDict(TypedDict):
        device_name: NotRequired[pulumi.Input[str]]
        """
        String. Set device name. (Example: `/dev/xvda`).
        """
        ebs: NotRequired[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsArgsDict']]
        """
        Object. Set Elastic Block Store properties .
        """
        no_device: NotRequired[pulumi.Input[str]]
        """
        String. Suppresses the specified device included in the block device mapping of the AMI.
        """
        virtual_name: NotRequired[pulumi.Input[str]]
elif False:
    OceanLaunchSpecBlockDeviceMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 device_name: Optional[pulumi.Input[str]] = None,
                 ebs: Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsArgs']] = None,
                 no_device: Optional[pulumi.Input[str]] = None,
                 virtual_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] device_name: String. Set device name. (Example: `/dev/xvda`).
        :param pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsArgs'] ebs: Object. Set Elastic Block Store properties .
        :param pulumi.Input[str] no_device: String. Suppresses the specified device included in the block device mapping of the AMI.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        String. Set device name. (Example: `/dev/xvda`).
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def ebs(self) -> Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsArgs']]:
        """
        Object. Set Elastic Block Store properties .
        """
        return pulumi.get(self, "ebs")

    @ebs.setter
    def ebs(self, value: Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsArgs']]):
        pulumi.set(self, "ebs", value)

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[str]]:
        """
        String. Suppresses the specified device included in the block device mapping of the AMI.
        """
        return pulumi.get(self, "no_device")

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "no_device", value)

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_name", value)


if not MYPY:
    class OceanLaunchSpecBlockDeviceMappingEbsArgsDict(TypedDict):
        delete_on_termination: NotRequired[pulumi.Input[bool]]
        """
        Boolean. Flag to delete the EBS on instance termination.
        """
        dynamic_volume_size: NotRequired[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgsDict']]
        """
        Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
        """
        encrypted: NotRequired[pulumi.Input[bool]]
        """
        Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        """
        iops: NotRequired[pulumi.Input[int]]
        """
        Int. The number of I/O operations per second (IOPS) that the volume supports.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
        """
        snapshot_id: NotRequired[pulumi.Input[str]]
        """
        (Optional) String. The Snapshot ID to mount by.
        """
        throughput: NotRequired[pulumi.Input[int]]
        """
        The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volume_type` = `gp3`.
        """
        volume_size: NotRequired[pulumi.Input[int]]
        """
        Int. The size, in GB of the volume.
        """
        volume_type: NotRequired[pulumi.Input[str]]
        """
        String. The type of the volume. (Example: `gp2`).
        """
elif False:
    OceanLaunchSpecBlockDeviceMappingEbsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecBlockDeviceMappingEbsArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 dynamic_volume_size: Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs']] = None,
                 encrypted: Optional[pulumi.Input[bool]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 throughput: Optional[pulumi.Input[int]] = None,
                 volume_size: Optional[pulumi.Input[int]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] delete_on_termination: Boolean. Flag to delete the EBS on instance termination.
        :param pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs'] dynamic_volume_size: Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
        :param pulumi.Input[bool] encrypted: Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        :param pulumi.Input[int] iops: Int. The number of I/O operations per second (IOPS) that the volume supports.
        :param pulumi.Input[str] kms_key_id: String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
        :param pulumi.Input[str] snapshot_id: (Optional) String. The Snapshot ID to mount by.
        :param pulumi.Input[int] throughput: The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volume_type` = `gp3`.
        :param pulumi.Input[int] volume_size: Int. The size, in GB of the volume.
        :param pulumi.Input[str] volume_type: String. The type of the volume. (Example: `gp2`).
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if dynamic_volume_size is not None:
            pulumi.set(__self__, "dynamic_volume_size", dynamic_volume_size)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean. Flag to delete the EBS on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter(name="dynamicVolumeSize")
    def dynamic_volume_size(self) -> Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs']]:
        """
        Object. Set dynamic volume size properties. When using this object, you cannot use volumeSize. You must use one or the other.
        """
        return pulumi.get(self, "dynamic_volume_size")

    @dynamic_volume_size.setter
    def dynamic_volume_size(self, value: Optional[pulumi.Input['OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs']]):
        pulumi.set(self, "dynamic_volume_size", value)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean. Enables [EBS encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html) on the volume.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypted", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Int. The number of I/O operations per second (IOPS) that the volume supports.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        String. Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) String. The Snapshot ID to mount by.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of data transferred to or from a storage device per second, you can use this param just in a case that `volume_type` = `gp3`.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        Int. The size, in GB of the volume.
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        String. The type of the volume. (Example: `gp2`).
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgsDict(TypedDict):
        base_size: pulumi.Input[int]
        """
        Int. Initial size for volume. (Example: 50)
        """
        resource: pulumi.Input[str]
        """
        String. Resource type to increase volume size dynamically by. (Valid values: `CPU`)
        """
        size_per_resource_unit: pulumi.Input[int]
        """
        Int. Additional size (in GB) per resource unit. (Example: `baseSize=50`, `sizePerResourceUnit=20`, and instance with 2 CPU is launched; its total disk size will be: 90GB)
        """
elif False:
    OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecBlockDeviceMappingEbsDynamicVolumeSizeArgs:
    def __init__(__self__, *,
                 base_size: pulumi.Input[int],
                 resource: pulumi.Input[str],
                 size_per_resource_unit: pulumi.Input[int]):
        """
        :param pulumi.Input[int] base_size: Int. Initial size for volume. (Example: 50)
        :param pulumi.Input[str] resource: String. Resource type to increase volume size dynamically by. (Valid values: `CPU`)
        :param pulumi.Input[int] size_per_resource_unit: Int. Additional size (in GB) per resource unit. (Example: `baseSize=50`, `sizePerResourceUnit=20`, and instance with 2 CPU is launched; its total disk size will be: 90GB)
        """
        pulumi.set(__self__, "base_size", base_size)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "size_per_resource_unit", size_per_resource_unit)

    @property
    @pulumi.getter(name="baseSize")
    def base_size(self) -> pulumi.Input[int]:
        """
        Int. Initial size for volume. (Example: 50)
        """
        return pulumi.get(self, "base_size")

    @base_size.setter
    def base_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "base_size", value)

    @property
    @pulumi.getter
    def resource(self) -> pulumi.Input[str]:
        """
        String. Resource type to increase volume size dynamically by. (Valid values: `CPU`)
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter(name="sizePerResourceUnit")
    def size_per_resource_unit(self) -> pulumi.Input[int]:
        """
        Int. Additional size (in GB) per resource unit. (Example: `baseSize=50`, `sizePerResourceUnit=20`, and instance with 2 CPU is launched; its total disk size will be: 90GB)
        """
        return pulumi.get(self, "size_per_resource_unit")

    @size_per_resource_unit.setter
    def size_per_resource_unit(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_per_resource_unit", value)


if not MYPY:
    class OceanLaunchSpecCreateOptionsArgsDict(TypedDict):
        initial_nodes: NotRequired[pulumi.Input[int]]
        """
        When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group. The parameter is recommended in case the use_as_template_only (in aws.Ocean resource) is set to true during Ocean resource creation.
        """
elif False:
    OceanLaunchSpecCreateOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecCreateOptionsArgs:
    def __init__(__self__, *,
                 initial_nodes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] initial_nodes: When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group. The parameter is recommended in case the use_as_template_only (in aws.Ocean resource) is set to true during Ocean resource creation.
        """
        if initial_nodes is not None:
            pulumi.set(__self__, "initial_nodes", initial_nodes)

    @property
    @pulumi.getter(name="initialNodes")
    def initial_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        When set to an integer greater than 0, a corresponding amount of nodes will be launched from the created Virtual Node Group. The parameter is recommended in case the use_as_template_only (in aws.Ocean resource) is set to true during Ocean resource creation.
        """
        return pulumi.get(self, "initial_nodes")

    @initial_nodes.setter
    def initial_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_nodes", value)


if not MYPY:
    class OceanLaunchSpecDeleteOptionsArgsDict(TypedDict):
        force_delete: pulumi.Input[bool]
        """
        When set to `true`, delete even if it is the last Virtual Node Group (also, the default Virtual Node Group must be configured with `useAsTemlateOnly = true`). Should be set at creation or update, but will be used only at deletion.
        """
        delete_nodes: NotRequired[pulumi.Input[bool]]
        """
        When set to "true", all instances belonging to the deleted launch specification will be drained, detached, and terminated.
        """
elif False:
    OceanLaunchSpecDeleteOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecDeleteOptionsArgs:
    def __init__(__self__, *,
                 force_delete: pulumi.Input[bool],
                 delete_nodes: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] force_delete: When set to `true`, delete even if it is the last Virtual Node Group (also, the default Virtual Node Group must be configured with `useAsTemlateOnly = true`). Should be set at creation or update, but will be used only at deletion.
        :param pulumi.Input[bool] delete_nodes: When set to "true", all instances belonging to the deleted launch specification will be drained, detached, and terminated.
        """
        pulumi.set(__self__, "force_delete", force_delete)
        if delete_nodes is not None:
            pulumi.set(__self__, "delete_nodes", delete_nodes)

    @property
    @pulumi.getter(name="forceDelete")
    def force_delete(self) -> pulumi.Input[bool]:
        """
        When set to `true`, delete even if it is the last Virtual Node Group (also, the default Virtual Node Group must be configured with `useAsTemlateOnly = true`). Should be set at creation or update, but will be used only at deletion.
        """
        return pulumi.get(self, "force_delete")

    @force_delete.setter
    def force_delete(self, value: pulumi.Input[bool]):
        pulumi.set(self, "force_delete", value)

    @property
    @pulumi.getter(name="deleteNodes")
    def delete_nodes(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to "true", all instances belonging to the deleted launch specification will be drained, detached, and terminated.
        """
        return pulumi.get(self, "delete_nodes")

    @delete_nodes.setter
    def delete_nodes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_nodes", value)


if not MYPY:
    class OceanLaunchSpecElasticIpPoolArgsDict(TypedDict):
        tag_selector: NotRequired[pulumi.Input['OceanLaunchSpecElasticIpPoolTagSelectorArgsDict']]
        """
        A key-value pair, which defines an Elastic IP from the customer pool. Can be null.
        """
elif False:
    OceanLaunchSpecElasticIpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecElasticIpPoolArgs:
    def __init__(__self__, *,
                 tag_selector: Optional[pulumi.Input['OceanLaunchSpecElasticIpPoolTagSelectorArgs']] = None):
        """
        :param pulumi.Input['OceanLaunchSpecElasticIpPoolTagSelectorArgs'] tag_selector: A key-value pair, which defines an Elastic IP from the customer pool. Can be null.
        """
        if tag_selector is not None:
            pulumi.set(__self__, "tag_selector", tag_selector)

    @property
    @pulumi.getter(name="tagSelector")
    def tag_selector(self) -> Optional[pulumi.Input['OceanLaunchSpecElasticIpPoolTagSelectorArgs']]:
        """
        A key-value pair, which defines an Elastic IP from the customer pool. Can be null.
        """
        return pulumi.get(self, "tag_selector")

    @tag_selector.setter
    def tag_selector(self, value: Optional[pulumi.Input['OceanLaunchSpecElasticIpPoolTagSelectorArgs']]):
        pulumi.set(self, "tag_selector", value)


if not MYPY:
    class OceanLaunchSpecElasticIpPoolTagSelectorArgsDict(TypedDict):
        tag_key: pulumi.Input[str]
        """
        Elastic IP tag key. The Virtual Node Group will consider all Elastic IPs tagged with this tag as a part of the Elastic IP pool to use.
        """
        tag_value: NotRequired[pulumi.Input[str]]
        """
        Elastic IP tag value. Can be null.
        """
elif False:
    OceanLaunchSpecElasticIpPoolTagSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecElasticIpPoolTagSelectorArgs:
    def __init__(__self__, *,
                 tag_key: pulumi.Input[str],
                 tag_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] tag_key: Elastic IP tag key. The Virtual Node Group will consider all Elastic IPs tagged with this tag as a part of the Elastic IP pool to use.
        :param pulumi.Input[str] tag_value: Elastic IP tag value. Can be null.
        """
        pulumi.set(__self__, "tag_key", tag_key)
        if tag_value is not None:
            pulumi.set(__self__, "tag_value", tag_value)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> pulumi.Input[str]:
        """
        Elastic IP tag key. The Virtual Node Group will consider all Elastic IPs tagged with this tag as a part of the Elastic IP pool to use.
        """
        return pulumi.get(self, "tag_key")

    @tag_key.setter
    def tag_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag_key", value)

    @property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> Optional[pulumi.Input[str]]:
        """
        Elastic IP tag value. Can be null.
        """
        return pulumi.get(self, "tag_value")

    @tag_value.setter
    def tag_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_value", value)


if not MYPY:
    class OceanLaunchSpecEphemeralStorageArgsDict(TypedDict):
        ephemeral_storage_device_name: NotRequired[pulumi.Input[str]]
        """
        Specify an alternative device name from which ephemeral storage calculations should be derived. This parameter is used when the ephemeral storage should not utilize the root device. Provide the device name configured in the VNG's BDM or AMI's BDM that differs from the default root device.
        """
elif False:
    OceanLaunchSpecEphemeralStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecEphemeralStorageArgs:
    def __init__(__self__, *,
                 ephemeral_storage_device_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ephemeral_storage_device_name: Specify an alternative device name from which ephemeral storage calculations should be derived. This parameter is used when the ephemeral storage should not utilize the root device. Provide the device name configured in the VNG's BDM or AMI's BDM that differs from the default root device.
        """
        if ephemeral_storage_device_name is not None:
            pulumi.set(__self__, "ephemeral_storage_device_name", ephemeral_storage_device_name)

    @property
    @pulumi.getter(name="ephemeralStorageDeviceName")
    def ephemeral_storage_device_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specify an alternative device name from which ephemeral storage calculations should be derived. This parameter is used when the ephemeral storage should not utilize the root device. Provide the device name configured in the VNG's BDM or AMI's BDM that differs from the default root device.
        """
        return pulumi.get(self, "ephemeral_storage_device_name")

    @ephemeral_storage_device_name.setter
    def ephemeral_storage_device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ephemeral_storage_device_name", value)


if not MYPY:
    class OceanLaunchSpecImageArgsDict(TypedDict):
        image_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the image in AWS. Valid values: any string which is not empty or null.
        """
elif False:
    OceanLaunchSpecImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecImageArgs:
    def __init__(__self__, *,
                 image_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_id: Identifier of the image in AWS. Valid values: any string which is not empty or null.
        """
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the image in AWS. Valid values: any string which is not empty or null.
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_id", value)


if not MYPY:
    class OceanLaunchSpecInstanceMetadataOptionsArgsDict(TypedDict):
        http_tokens: pulumi.Input[str]
        """
        Determines if a signed token is required or not. Valid values: `optional` or `required`.
        """
        http_put_response_hop_limit: NotRequired[pulumi.Input[int]]
        """
        An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
        """
elif False:
    OceanLaunchSpecInstanceMetadataOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecInstanceMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_tokens: pulumi.Input[str],
                 http_put_response_hop_limit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] http_tokens: Determines if a signed token is required or not. Valid values: `optional` or `required`.
        :param pulumi.Input[int] http_put_response_hop_limit: An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
        """
        pulumi.set(__self__, "http_tokens", http_tokens)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> pulumi.Input[str]:
        """
        Determines if a signed token is required or not. Valid values: `optional` or `required`.
        """
        return pulumi.get(self, "http_tokens")

    @http_tokens.setter
    def http_tokens(self, value: pulumi.Input[str]):
        pulumi.set(self, "http_tokens", value)

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[int]]:
        """
        An integer from 1 through 64. The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further the instance metadata requests can travel.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_put_response_hop_limit", value)


if not MYPY:
    class OceanLaunchSpecInstanceTypesFiltersArgsDict(TypedDict):
        categories: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The filtered instance types will belong to one of the categories types from this list. Valid values: `Accelerated_computing`, `Compute_optimized`, `General_purpose`, `Memory_optimized`, `Storage_optimized`.
        """
        disk_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The filtered instance types will have one of the disk type from this list. Valid values: `NVMe`, `EBS`, `SSD`, `HDD`.
        """
        exclude_families: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
        """
        exclude_metal: NotRequired[pulumi.Input[bool]]
        """
        In case excludeMetal is set to true, metal types will not be available for scaling.
        """
        hypervisors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The filtered instance types will have a hypervisor type from this list. Valid values: `nitro`, `xen`.
        """
        include_families: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
        """
        is_ena_supported: NotRequired[pulumi.Input[str]]
        """
        Ena is supported or not.
        """
        max_gpu: NotRequired[pulumi.Input[int]]
        """
        Maximum total number of GPUs.
        """
        max_memory_gib: NotRequired[pulumi.Input[float]]
        """
        Maximum amount of Memory (GiB).
        """
        max_network_performance: NotRequired[pulumi.Input[int]]
        """
        Maximum Bandwidth in Gib/s of network performance.
        """
        max_vcpu: NotRequired[pulumi.Input[int]]
        """
        Maximum number of vcpus available.
        """
        min_enis: NotRequired[pulumi.Input[int]]
        """
        Minimum number of network interfaces (ENIs).
        """
        min_gpu: NotRequired[pulumi.Input[int]]
        """
        Minimum total number of GPUs.
        """
        min_memory_gib: NotRequired[pulumi.Input[float]]
        """
        Minimum amount of Memory (GiB).
        """
        min_network_performance: NotRequired[pulumi.Input[int]]
        """
        Minimum Bandwidth in Gib/s of network performance.
        """
        min_vcpu: NotRequired[pulumi.Input[int]]
        """
        Minimum number of vcpus available.
        """
        root_device_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The filtered instance types will have a root device types from this list. Valid values: `ebs`, or `instance-store`.
        """
        virtualization_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The filtered instance types will support at least one of the virtualization types from this list. Valid values: `hvm`, `paravirtual`.
        """
elif False:
    OceanLaunchSpecInstanceTypesFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecInstanceTypesFiltersArgs:
    def __init__(__self__, *,
                 categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 disk_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exclude_families: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exclude_metal: Optional[pulumi.Input[bool]] = None,
                 hypervisors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_families: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 is_ena_supported: Optional[pulumi.Input[str]] = None,
                 max_gpu: Optional[pulumi.Input[int]] = None,
                 max_memory_gib: Optional[pulumi.Input[float]] = None,
                 max_network_performance: Optional[pulumi.Input[int]] = None,
                 max_vcpu: Optional[pulumi.Input[int]] = None,
                 min_enis: Optional[pulumi.Input[int]] = None,
                 min_gpu: Optional[pulumi.Input[int]] = None,
                 min_memory_gib: Optional[pulumi.Input[float]] = None,
                 min_network_performance: Optional[pulumi.Input[int]] = None,
                 min_vcpu: Optional[pulumi.Input[int]] = None,
                 root_device_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 virtualization_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] categories: The filtered instance types will belong to one of the categories types from this list. Valid values: `Accelerated_computing`, `Compute_optimized`, `General_purpose`, `Memory_optimized`, `Storage_optimized`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] disk_types: The filtered instance types will have one of the disk type from this list. Valid values: `NVMe`, `EBS`, `SSD`, `HDD`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_families: Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
        :param pulumi.Input[bool] exclude_metal: In case excludeMetal is set to true, metal types will not be available for scaling.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hypervisors: The filtered instance types will have a hypervisor type from this list. Valid values: `nitro`, `xen`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_families: Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
        :param pulumi.Input[str] is_ena_supported: Ena is supported or not.
        :param pulumi.Input[int] max_gpu: Maximum total number of GPUs.
        :param pulumi.Input[float] max_memory_gib: Maximum amount of Memory (GiB).
        :param pulumi.Input[int] max_network_performance: Maximum Bandwidth in Gib/s of network performance.
        :param pulumi.Input[int] max_vcpu: Maximum number of vcpus available.
        :param pulumi.Input[int] min_enis: Minimum number of network interfaces (ENIs).
        :param pulumi.Input[int] min_gpu: Minimum total number of GPUs.
        :param pulumi.Input[float] min_memory_gib: Minimum amount of Memory (GiB).
        :param pulumi.Input[int] min_network_performance: Minimum Bandwidth in Gib/s of network performance.
        :param pulumi.Input[int] min_vcpu: Minimum number of vcpus available.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] root_device_types: The filtered instance types will have a root device types from this list. Valid values: `ebs`, or `instance-store`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] virtualization_types: The filtered instance types will support at least one of the virtualization types from this list. Valid values: `hvm`, `paravirtual`.
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if disk_types is not None:
            pulumi.set(__self__, "disk_types", disk_types)
        if exclude_families is not None:
            pulumi.set(__self__, "exclude_families", exclude_families)
        if exclude_metal is not None:
            pulumi.set(__self__, "exclude_metal", exclude_metal)
        if hypervisors is not None:
            pulumi.set(__self__, "hypervisors", hypervisors)
        if include_families is not None:
            pulumi.set(__self__, "include_families", include_families)
        if is_ena_supported is not None:
            pulumi.set(__self__, "is_ena_supported", is_ena_supported)
        if max_gpu is not None:
            pulumi.set(__self__, "max_gpu", max_gpu)
        if max_memory_gib is not None:
            pulumi.set(__self__, "max_memory_gib", max_memory_gib)
        if max_network_performance is not None:
            pulumi.set(__self__, "max_network_performance", max_network_performance)
        if max_vcpu is not None:
            pulumi.set(__self__, "max_vcpu", max_vcpu)
        if min_enis is not None:
            pulumi.set(__self__, "min_enis", min_enis)
        if min_gpu is not None:
            pulumi.set(__self__, "min_gpu", min_gpu)
        if min_memory_gib is not None:
            pulumi.set(__self__, "min_memory_gib", min_memory_gib)
        if min_network_performance is not None:
            pulumi.set(__self__, "min_network_performance", min_network_performance)
        if min_vcpu is not None:
            pulumi.set(__self__, "min_vcpu", min_vcpu)
        if root_device_types is not None:
            pulumi.set(__self__, "root_device_types", root_device_types)
        if virtualization_types is not None:
            pulumi.set(__self__, "virtualization_types", virtualization_types)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will belong to one of the categories types from this list. Valid values: `Accelerated_computing`, `Compute_optimized`, `General_purpose`, `Memory_optimized`, `Storage_optimized`.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter(name="diskTypes")
    def disk_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will have one of the disk type from this list. Valid values: `NVMe`, `EBS`, `SSD`, `HDD`.
        """
        return pulumi.get(self, "disk_types")

    @disk_types.setter
    def disk_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "disk_types", value)

    @property
    @pulumi.getter(name="excludeFamilies")
    def exclude_families(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Types belonging to a family from the ExcludeFamilies will not be available for scaling (asterisk wildcard is also supported). For example, C* will exclude instance types from these families: c5, c4, c4a, etc.
        """
        return pulumi.get(self, "exclude_families")

    @exclude_families.setter
    def exclude_families(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_families", value)

    @property
    @pulumi.getter(name="excludeMetal")
    def exclude_metal(self) -> Optional[pulumi.Input[bool]]:
        """
        In case excludeMetal is set to true, metal types will not be available for scaling.
        """
        return pulumi.get(self, "exclude_metal")

    @exclude_metal.setter
    def exclude_metal(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude_metal", value)

    @property
    @pulumi.getter
    def hypervisors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will have a hypervisor type from this list. Valid values: `nitro`, `xen`.
        """
        return pulumi.get(self, "hypervisors")

    @hypervisors.setter
    def hypervisors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hypervisors", value)

    @property
    @pulumi.getter(name="includeFamilies")
    def include_families(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Types belonging to a family from the IncludeFamilies will be available for scaling (asterisk wildcard is also supported). For example, C* will include instance types from these families: c5, c4, c4a, etc.
        """
        return pulumi.get(self, "include_families")

    @include_families.setter
    def include_families(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_families", value)

    @property
    @pulumi.getter(name="isEnaSupported")
    def is_ena_supported(self) -> Optional[pulumi.Input[str]]:
        """
        Ena is supported or not.
        """
        return pulumi.get(self, "is_ena_supported")

    @is_ena_supported.setter
    def is_ena_supported(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_ena_supported", value)

    @property
    @pulumi.getter(name="maxGpu")
    def max_gpu(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum total number of GPUs.
        """
        return pulumi.get(self, "max_gpu")

    @max_gpu.setter
    def max_gpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_gpu", value)

    @property
    @pulumi.getter(name="maxMemoryGib")
    def max_memory_gib(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum amount of Memory (GiB).
        """
        return pulumi.get(self, "max_memory_gib")

    @max_memory_gib.setter
    def max_memory_gib(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_memory_gib", value)

    @property
    @pulumi.getter(name="maxNetworkPerformance")
    def max_network_performance(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum Bandwidth in Gib/s of network performance.
        """
        return pulumi.get(self, "max_network_performance")

    @max_network_performance.setter
    def max_network_performance(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_network_performance", value)

    @property
    @pulumi.getter(name="maxVcpu")
    def max_vcpu(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of vcpus available.
        """
        return pulumi.get(self, "max_vcpu")

    @max_vcpu.setter
    def max_vcpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_vcpu", value)

    @property
    @pulumi.getter(name="minEnis")
    def min_enis(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of network interfaces (ENIs).
        """
        return pulumi.get(self, "min_enis")

    @min_enis.setter
    def min_enis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_enis", value)

    @property
    @pulumi.getter(name="minGpu")
    def min_gpu(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum total number of GPUs.
        """
        return pulumi.get(self, "min_gpu")

    @min_gpu.setter
    def min_gpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_gpu", value)

    @property
    @pulumi.getter(name="minMemoryGib")
    def min_memory_gib(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum amount of Memory (GiB).
        """
        return pulumi.get(self, "min_memory_gib")

    @min_memory_gib.setter
    def min_memory_gib(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_memory_gib", value)

    @property
    @pulumi.getter(name="minNetworkPerformance")
    def min_network_performance(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum Bandwidth in Gib/s of network performance.
        """
        return pulumi.get(self, "min_network_performance")

    @min_network_performance.setter
    def min_network_performance(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_network_performance", value)

    @property
    @pulumi.getter(name="minVcpu")
    def min_vcpu(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of vcpus available.
        """
        return pulumi.get(self, "min_vcpu")

    @min_vcpu.setter
    def min_vcpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_vcpu", value)

    @property
    @pulumi.getter(name="rootDeviceTypes")
    def root_device_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will have a root device types from this list. Valid values: `ebs`, or `instance-store`.
        """
        return pulumi.get(self, "root_device_types")

    @root_device_types.setter
    def root_device_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "root_device_types", value)

    @property
    @pulumi.getter(name="virtualizationTypes")
    def virtualization_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filtered instance types will support at least one of the virtualization types from this list. Valid values: `hvm`, `paravirtual`.
        """
        return pulumi.get(self, "virtualization_types")

    @virtualization_types.setter
    def virtualization_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "virtualization_types", value)


if not MYPY:
    class OceanLaunchSpecLabelArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The label key.
        """
        value: pulumi.Input[str]
        """
        The label value.
        """
elif False:
    OceanLaunchSpecLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The label key.
        :param pulumi.Input[str] value: The label value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The label key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The label value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OceanLaunchSpecResourceLimitArgsDict(TypedDict):
        max_instance_count: NotRequired[pulumi.Input[int]]
        """
        Set a maximum number of instances per Virtual Node Group. Can be null. If set, value must be greater than or equal to 0.
        """
        min_instance_count: NotRequired[pulumi.Input[int]]
        """
        Set a minimum number of instances per Virtual Node Group. Can be null. If set, value must be greater than or equal to 0.
        """
elif False:
    OceanLaunchSpecResourceLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecResourceLimitArgs:
    def __init__(__self__, *,
                 max_instance_count: Optional[pulumi.Input[int]] = None,
                 min_instance_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_instance_count: Set a maximum number of instances per Virtual Node Group. Can be null. If set, value must be greater than or equal to 0.
        :param pulumi.Input[int] min_instance_count: Set a minimum number of instances per Virtual Node Group. Can be null. If set, value must be greater than or equal to 0.
        """
        if max_instance_count is not None:
            pulumi.set(__self__, "max_instance_count", max_instance_count)
        if min_instance_count is not None:
            pulumi.set(__self__, "min_instance_count", min_instance_count)

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        Set a maximum number of instances per Virtual Node Group. Can be null. If set, value must be greater than or equal to 0.
        """
        return pulumi.get(self, "max_instance_count")

    @max_instance_count.setter
    def max_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_instance_count", value)

    @property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        Set a minimum number of instances per Virtual Node Group. Can be null. If set, value must be greater than or equal to 0.
        """
        return pulumi.get(self, "min_instance_count")

    @min_instance_count.setter
    def min_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_instance_count", value)


if not MYPY:
    class OceanLaunchSpecSchedulingShutdownHoursArgsDict(TypedDict):
        time_windows: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The times that the shutdown hours will apply.
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Flag to enable or disable the shutdown hours mechanism. When `false`, the mechanism is deactivated, and the virtual node group remains in its current state.
        """
elif False:
    OceanLaunchSpecSchedulingShutdownHoursArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecSchedulingShutdownHoursArgs:
    def __init__(__self__, *,
                 time_windows: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] time_windows: The times that the shutdown hours will apply.
        :param pulumi.Input[bool] is_enabled: Flag to enable or disable the shutdown hours mechanism. When `false`, the mechanism is deactivated, and the virtual node group remains in its current state.
        """
        pulumi.set(__self__, "time_windows", time_windows)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The times that the shutdown hours will apply.
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag to enable or disable the shutdown hours mechanism. When `false`, the mechanism is deactivated, and the virtual node group remains in its current state.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class OceanLaunchSpecSchedulingTaskArgsDict(TypedDict):
        cron_expression: pulumi.Input[str]
        """
        A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
        """
        is_enabled: pulumi.Input[bool]
        """
        Describes whether the task is enabled. When `true`, the task runs. When `false`, it does not run.
        """
        task_type: pulumi.Input[str]
        """
        The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
        """
        task_headrooms: NotRequired[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgsDict']]]]
        """
        The config of this scheduled task. Depends on the value of taskType.
        """
elif False:
    OceanLaunchSpecSchedulingTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecSchedulingTaskArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[str],
                 is_enabled: pulumi.Input[bool],
                 task_type: pulumi.Input[str],
                 task_headrooms: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]] = None):
        """
        :param pulumi.Input[str] cron_expression: A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
        :param pulumi.Input[bool] is_enabled: Describes whether the task is enabled. When `true`, the task runs. When `false`, it does not run.
        :param pulumi.Input[str] task_type: The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
        :param pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]] task_headrooms: The config of this scheduled task. Depends on the value of taskType.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "task_type", task_type)
        if task_headrooms is not None:
            pulumi.set(__self__, "task_headrooms", task_headrooms)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[str]:
        """
        A valid cron expression. For example : " * * * * * ". The cron job runs in UTC time and is in Unix cron format.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Describes whether the task is enabled. When `true`, the task runs. When `false`, it does not run.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input[str]:
        """
        The activity that you are scheduling. Valid values: "manualHeadroomUpdate".
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_type", value)

    @property
    @pulumi.getter(name="taskHeadrooms")
    def task_headrooms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]]:
        """
        The config of this scheduled task. Depends on the value of taskType.
        """
        return pulumi.get(self, "task_headrooms")

    @task_headrooms.setter
    def task_headrooms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLaunchSpecSchedulingTaskTaskHeadroomArgs']]]]):
        pulumi.set(self, "task_headrooms", value)


if not MYPY:
    class OceanLaunchSpecSchedulingTaskTaskHeadroomArgsDict(TypedDict):
        num_of_units: pulumi.Input[int]
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        cpu_per_unit: NotRequired[pulumi.Input[int]]
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        gpu_per_unit: NotRequired[pulumi.Input[int]]
        """
        Optionally configure the number of GPUS to allocate for each headroom unit.
        """
        memory_per_unit: NotRequired[pulumi.Input[int]]
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
elif False:
    OceanLaunchSpecSchedulingTaskTaskHeadroomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecSchedulingTaskTaskHeadroomArgs:
    def __init__(__self__, *,
                 num_of_units: pulumi.Input[int],
                 cpu_per_unit: Optional[pulumi.Input[int]] = None,
                 gpu_per_unit: Optional[pulumi.Input[int]] = None,
                 memory_per_unit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] num_of_units: The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        :param pulumi.Input[int] cpu_per_unit: Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        :param pulumi.Input[int] gpu_per_unit: Optionally configure the number of GPUS to allocate for each headroom unit.
        :param pulumi.Input[int] memory_per_unit: Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        pulumi.set(__self__, "num_of_units", num_of_units)
        if cpu_per_unit is not None:
            pulumi.set(__self__, "cpu_per_unit", cpu_per_unit)
        if gpu_per_unit is not None:
            pulumi.set(__self__, "gpu_per_unit", gpu_per_unit)
        if memory_per_unit is not None:
            pulumi.set(__self__, "memory_per_unit", memory_per_unit)

    @property
    @pulumi.getter(name="numOfUnits")
    def num_of_units(self) -> pulumi.Input[int]:
        """
        The number of units to retain as headroom, where each unit has the defined headroom CPU, memory and GPU.
        """
        return pulumi.get(self, "num_of_units")

    @num_of_units.setter
    def num_of_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "num_of_units", value)

    @property
    @pulumi.getter(name="cpuPerUnit")
    def cpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of CPUs to allocate for each headroom unit. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        """
        return pulumi.get(self, "cpu_per_unit")

    @cpu_per_unit.setter
    def cpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_per_unit", value)

    @property
    @pulumi.getter(name="gpuPerUnit")
    def gpu_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the number of GPUS to allocate for each headroom unit.
        """
        return pulumi.get(self, "gpu_per_unit")

    @gpu_per_unit.setter
    def gpu_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gpu_per_unit", value)

    @property
    @pulumi.getter(name="memoryPerUnit")
    def memory_per_unit(self) -> Optional[pulumi.Input[int]]:
        """
        Optionally configure the amount of memory (MiB) to allocate for each headroom unit.
        """
        return pulumi.get(self, "memory_per_unit")

    @memory_per_unit.setter
    def memory_per_unit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_per_unit", value)


if not MYPY:
    class OceanLaunchSpecStrategyArgsDict(TypedDict):
        draining_timeout: NotRequired[pulumi.Input[int]]
        """
        The configurable amount of time that Ocean will wait for the draining process to complete before terminating an instance. If you have not defined a draining timeout, the default of 300 seconds will be used.
        """
        spot_percentage: NotRequired[pulumi.Input[int]]
        """
        The desired percentage of the Spot instances out of all running instances for this VNG. Only available when the field is not set in the cluster directly (cluster.strategy.spotPercentage).
        """
        utilize_commitments: NotRequired[pulumi.Input[bool]]
        """
        When set as true, if savings plans commitments have available capacity, Ocean will utilize them alongside RIs (if exist) to maximize cost efficiency. If the value is set as 'null', it will automatically be inherited from the cluster level.
        """
        utilize_reserved_instances: NotRequired[pulumi.Input[bool]]
        """
        When set as true, if reserved instances exist, Ocean will utilize them before launching spot instances. If the value is set as 'null', it will automatically be inherited from the cluster level.
        """
elif False:
    OceanLaunchSpecStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecStrategyArgs:
    def __init__(__self__, *,
                 draining_timeout: Optional[pulumi.Input[int]] = None,
                 spot_percentage: Optional[pulumi.Input[int]] = None,
                 utilize_commitments: Optional[pulumi.Input[bool]] = None,
                 utilize_reserved_instances: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] draining_timeout: The configurable amount of time that Ocean will wait for the draining process to complete before terminating an instance. If you have not defined a draining timeout, the default of 300 seconds will be used.
        :param pulumi.Input[int] spot_percentage: The desired percentage of the Spot instances out of all running instances for this VNG. Only available when the field is not set in the cluster directly (cluster.strategy.spotPercentage).
        :param pulumi.Input[bool] utilize_commitments: When set as true, if savings plans commitments have available capacity, Ocean will utilize them alongside RIs (if exist) to maximize cost efficiency. If the value is set as 'null', it will automatically be inherited from the cluster level.
        :param pulumi.Input[bool] utilize_reserved_instances: When set as true, if reserved instances exist, Ocean will utilize them before launching spot instances. If the value is set as 'null', it will automatically be inherited from the cluster level.
        """
        if draining_timeout is not None:
            pulumi.set(__self__, "draining_timeout", draining_timeout)
        if spot_percentage is not None:
            pulumi.set(__self__, "spot_percentage", spot_percentage)
        if utilize_commitments is not None:
            pulumi.set(__self__, "utilize_commitments", utilize_commitments)
        if utilize_reserved_instances is not None:
            pulumi.set(__self__, "utilize_reserved_instances", utilize_reserved_instances)

    @property
    @pulumi.getter(name="drainingTimeout")
    def draining_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The configurable amount of time that Ocean will wait for the draining process to complete before terminating an instance. If you have not defined a draining timeout, the default of 300 seconds will be used.
        """
        return pulumi.get(self, "draining_timeout")

    @draining_timeout.setter
    def draining_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "draining_timeout", value)

    @property
    @pulumi.getter(name="spotPercentage")
    def spot_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        The desired percentage of the Spot instances out of all running instances for this VNG. Only available when the field is not set in the cluster directly (cluster.strategy.spotPercentage).
        """
        return pulumi.get(self, "spot_percentage")

    @spot_percentage.setter
    def spot_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spot_percentage", value)

    @property
    @pulumi.getter(name="utilizeCommitments")
    def utilize_commitments(self) -> Optional[pulumi.Input[bool]]:
        """
        When set as true, if savings plans commitments have available capacity, Ocean will utilize them alongside RIs (if exist) to maximize cost efficiency. If the value is set as 'null', it will automatically be inherited from the cluster level.
        """
        return pulumi.get(self, "utilize_commitments")

    @utilize_commitments.setter
    def utilize_commitments(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "utilize_commitments", value)

    @property
    @pulumi.getter(name="utilizeReservedInstances")
    def utilize_reserved_instances(self) -> Optional[pulumi.Input[bool]]:
        """
        When set as true, if reserved instances exist, Ocean will utilize them before launching spot instances. If the value is set as 'null', it will automatically be inherited from the cluster level.
        """
        return pulumi.get(self, "utilize_reserved_instances")

    @utilize_reserved_instances.setter
    def utilize_reserved_instances(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "utilize_reserved_instances", value)


if not MYPY:
    class OceanLaunchSpecTagArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    OceanLaunchSpecTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OceanLaunchSpecTaintArgsDict(TypedDict):
        effect: pulumi.Input[str]
        """
        The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
        """
        key: pulumi.Input[str]
        """
        The taint key.
        """
        value: pulumi.Input[str]
        """
        The taint value.
        """
elif False:
    OceanLaunchSpecTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[str],
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] effect: The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
        :param pulumi.Input[str] key: The taint key.
        :param pulumi.Input[str] value: The taint value.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[str]:
        """
        The effect of the taint. Valid values: `"NoSchedule"`, `"PreferNoSchedule"`, `"NoExecute"`.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The taint key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The taint value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OceanLaunchSpecUpdatePolicyArgsDict(TypedDict):
        should_roll: pulumi.Input[bool]
        """
        Enables the roll.
        """
        roll_config: NotRequired[pulumi.Input['OceanLaunchSpecUpdatePolicyRollConfigArgsDict']]
        """
        Holds the roll configuration.
        """
elif False:
    OceanLaunchSpecUpdatePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecUpdatePolicyArgs:
    def __init__(__self__, *,
                 should_roll: pulumi.Input[bool],
                 roll_config: Optional[pulumi.Input['OceanLaunchSpecUpdatePolicyRollConfigArgs']] = None):
        """
        :param pulumi.Input[bool] should_roll: Enables the roll.
        :param pulumi.Input['OceanLaunchSpecUpdatePolicyRollConfigArgs'] roll_config: Holds the roll configuration.
        """
        pulumi.set(__self__, "should_roll", should_roll)
        if roll_config is not None:
            pulumi.set(__self__, "roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> pulumi.Input[bool]:
        """
        Enables the roll.
        """
        return pulumi.get(self, "should_roll")

    @should_roll.setter
    def should_roll(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_roll", value)

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional[pulumi.Input['OceanLaunchSpecUpdatePolicyRollConfigArgs']]:
        """
        Holds the roll configuration.
        """
        return pulumi.get(self, "roll_config")

    @roll_config.setter
    def roll_config(self, value: Optional[pulumi.Input['OceanLaunchSpecUpdatePolicyRollConfigArgs']]):
        pulumi.set(self, "roll_config", value)


if not MYPY:
    class OceanLaunchSpecUpdatePolicyRollConfigArgsDict(TypedDict):
        batch_size_percentage: pulumi.Input[int]
        """
        Sets the percentage of the instances to deploy in each batch.
        """
        respect_pdb: NotRequired[pulumi.Input[bool]]
        """
        During the roll, if the parameter is set to `true` we honor PDB during the instance replacement.
        """
elif False:
    OceanLaunchSpecUpdatePolicyRollConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLaunchSpecUpdatePolicyRollConfigArgs:
    def __init__(__self__, *,
                 batch_size_percentage: pulumi.Input[int],
                 respect_pdb: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] batch_size_percentage: Sets the percentage of the instances to deploy in each batch.
        :param pulumi.Input[bool] respect_pdb: During the roll, if the parameter is set to `true` we honor PDB during the instance replacement.
        """
        pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if respect_pdb is not None:
            pulumi.set(__self__, "respect_pdb", respect_pdb)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> pulumi.Input[int]:
        """
        Sets the percentage of the instances to deploy in each batch.
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: pulumi.Input[int]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter(name="respectPdb")
    def respect_pdb(self) -> Optional[pulumi.Input[bool]]:
        """
        During the roll, if the parameter is set to `true` we honor PDB during the instance replacement.
        """
        return pulumi.get(self, "respect_pdb")

    @respect_pdb.setter
    def respect_pdb(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "respect_pdb", value)


if not MYPY:
    class OceanLoadBalancerArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[str]]
        """
        Required if type is set to `TARGET_GROUP`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Required if type is set to `CLASSIC`
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Can be set to `CLASSIC` or `TARGET_GROUP`
        """
elif False:
    OceanLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLoadBalancerArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] arn: Required if type is set to `TARGET_GROUP`
        :param pulumi.Input[str] name: Required if type is set to `CLASSIC`
        :param pulumi.Input[str] type: Can be set to `CLASSIC` or `TARGET_GROUP`
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        """
        Required if type is set to `TARGET_GROUP`
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Required if type is set to `CLASSIC`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Can be set to `CLASSIC` or `TARGET_GROUP`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class OceanLoggingArgsDict(TypedDict):
        export: NotRequired[pulumi.Input['OceanLoggingExportArgsDict']]
        """
        Logging Export configuration.
        """
elif False:
    OceanLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLoggingArgs:
    def __init__(__self__, *,
                 export: Optional[pulumi.Input['OceanLoggingExportArgs']] = None):
        """
        :param pulumi.Input['OceanLoggingExportArgs'] export: Logging Export configuration.
        """
        if export is not None:
            pulumi.set(__self__, "export", export)

    @property
    @pulumi.getter
    def export(self) -> Optional[pulumi.Input['OceanLoggingExportArgs']]:
        """
        Logging Export configuration.
        """
        return pulumi.get(self, "export")

    @export.setter
    def export(self, value: Optional[pulumi.Input['OceanLoggingExportArgs']]):
        pulumi.set(self, "export", value)


if not MYPY:
    class OceanLoggingExportArgsDict(TypedDict):
        s3s: NotRequired[pulumi.Input[Sequence[pulumi.Input['OceanLoggingExportS3ArgsDict']]]]
        """
        Exports your cluster's logs to the S3 bucket and subdir configured on the S3 data integration given.
        """
elif False:
    OceanLoggingExportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLoggingExportArgs:
    def __init__(__self__, *,
                 s3s: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLoggingExportS3Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OceanLoggingExportS3Args']]] s3s: Exports your cluster's logs to the S3 bucket and subdir configured on the S3 data integration given.
        """
        if s3s is not None:
            pulumi.set(__self__, "s3s", s3s)

    @property
    @pulumi.getter
    def s3s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanLoggingExportS3Args']]]]:
        """
        Exports your cluster's logs to the S3 bucket and subdir configured on the S3 data integration given.
        """
        return pulumi.get(self, "s3s")

    @s3s.setter
    def s3s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanLoggingExportS3Args']]]]):
        pulumi.set(self, "s3s", value)


if not MYPY:
    class OceanLoggingExportS3ArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The identifier of The S3 data integration to export the logs to.
        """
elif False:
    OceanLoggingExportS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanLoggingExportS3Args:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The identifier of The S3 data integration to export the logs to.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The identifier of The S3 data integration to export the logs to.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class OceanResourceTagSpecificationArgsDict(TypedDict):
        should_tag_volumes: NotRequired[pulumi.Input[bool]]
        """
        Specify if Volume resources will be tagged with Virtual Node Group tags or Ocean tags.
        """
elif False:
    OceanResourceTagSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanResourceTagSpecificationArgs:
    def __init__(__self__, *,
                 should_tag_volumes: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] should_tag_volumes: Specify if Volume resources will be tagged with Virtual Node Group tags or Ocean tags.
        """
        if should_tag_volumes is not None:
            pulumi.set(__self__, "should_tag_volumes", should_tag_volumes)

    @property
    @pulumi.getter(name="shouldTagVolumes")
    def should_tag_volumes(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if Volume resources will be tagged with Virtual Node Group tags or Ocean tags.
        """
        return pulumi.get(self, "should_tag_volumes")

    @should_tag_volumes.setter
    def should_tag_volumes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_tag_volumes", value)


if not MYPY:
    class OceanScheduledTaskArgsDict(TypedDict):
        shutdown_hours: NotRequired[pulumi.Input['OceanScheduledTaskShutdownHoursArgsDict']]
        """
        Set shutdown hours for cluster object.
        """
        tasks: NotRequired[pulumi.Input[Sequence[pulumi.Input['OceanScheduledTaskTaskArgsDict']]]]
        """
        The scheduling tasks for the cluster.
        """
elif False:
    OceanScheduledTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanScheduledTaskArgs:
    def __init__(__self__, *,
                 shutdown_hours: Optional[pulumi.Input['OceanScheduledTaskShutdownHoursArgs']] = None,
                 tasks: Optional[pulumi.Input[Sequence[pulumi.Input['OceanScheduledTaskTaskArgs']]]] = None):
        """
        :param pulumi.Input['OceanScheduledTaskShutdownHoursArgs'] shutdown_hours: Set shutdown hours for cluster object.
        :param pulumi.Input[Sequence[pulumi.Input['OceanScheduledTaskTaskArgs']]] tasks: The scheduling tasks for the cluster.
        """
        if shutdown_hours is not None:
            pulumi.set(__self__, "shutdown_hours", shutdown_hours)
        if tasks is not None:
            pulumi.set(__self__, "tasks", tasks)

    @property
    @pulumi.getter(name="shutdownHours")
    def shutdown_hours(self) -> Optional[pulumi.Input['OceanScheduledTaskShutdownHoursArgs']]:
        """
        Set shutdown hours for cluster object.
        """
        return pulumi.get(self, "shutdown_hours")

    @shutdown_hours.setter
    def shutdown_hours(self, value: Optional[pulumi.Input['OceanScheduledTaskShutdownHoursArgs']]):
        pulumi.set(self, "shutdown_hours", value)

    @property
    @pulumi.getter
    def tasks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OceanScheduledTaskTaskArgs']]]]:
        """
        The scheduling tasks for the cluster.
        """
        return pulumi.get(self, "tasks")

    @tasks.setter
    def tasks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OceanScheduledTaskTaskArgs']]]]):
        pulumi.set(self, "tasks", value)


if not MYPY:
    class OceanScheduledTaskShutdownHoursArgsDict(TypedDict):
        time_windows: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Set time windows for shutdown hours. Specify a list of `timeWindows` with at least one time window Each string is in the format of: `ddd:hh:mm-ddd:hh:mm` where `ddd` = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat, `hh` = hour 24 = 0 -23, `mm` = minute = 0 - 59. Time windows should not overlap. Required if `cluster.scheduling.isEnabled` is `true`. (Example: `Fri:15:30-Wed:14:30`).
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Toggle the shutdown hours task. (Example: `true`).
        """
elif False:
    OceanScheduledTaskShutdownHoursArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanScheduledTaskShutdownHoursArgs:
    def __init__(__self__, *,
                 time_windows: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] time_windows: Set time windows for shutdown hours. Specify a list of `timeWindows` with at least one time window Each string is in the format of: `ddd:hh:mm-ddd:hh:mm` where `ddd` = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat, `hh` = hour 24 = 0 -23, `mm` = minute = 0 - 59. Time windows should not overlap. Required if `cluster.scheduling.isEnabled` is `true`. (Example: `Fri:15:30-Wed:14:30`).
        :param pulumi.Input[bool] is_enabled: Toggle the shutdown hours task. (Example: `true`).
        """
        pulumi.set(__self__, "time_windows", time_windows)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set time windows for shutdown hours. Specify a list of `timeWindows` with at least one time window Each string is in the format of: `ddd:hh:mm-ddd:hh:mm` where `ddd` = day of week = Sun | Mon | Tue | Wed | Thu | Fri | Sat, `hh` = hour 24 = 0 -23, `mm` = minute = 0 - 59. Time windows should not overlap. Required if `cluster.scheduling.isEnabled` is `true`. (Example: `Fri:15:30-Wed:14:30`).
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Toggle the shutdown hours task. (Example: `true`).
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class OceanScheduledTaskTaskArgsDict(TypedDict):
        cron_expression: pulumi.Input[str]
        """
        A valid cron expression. The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of `frequency` or `cronExpression` should be used at a time. Required for `cluster.scheduling.tasks` object. (Example: `0 1 * * *`).
        """
        is_enabled: pulumi.Input[bool]
        """
        Describes whether the task is enabled. When true the task should run when false it should not run. Required for `cluster.scheduling.tasks` object.
        """
        task_type: pulumi.Input[str]
        """
        Valid values: `clusterRoll` `amiAutoUpdate`. Required for `cluster.scheduling.tasks`
        """
        parameters: NotRequired[pulumi.Input['OceanScheduledTaskTaskParametersArgsDict']]
        """
        This filed will be compatible to the `task_type` field. If `task_type` is defined as `clusterRoll`, user cluster roll object in parameters.
        """
elif False:
    OceanScheduledTaskTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanScheduledTaskTaskArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[str],
                 is_enabled: pulumi.Input[bool],
                 task_type: pulumi.Input[str],
                 parameters: Optional[pulumi.Input['OceanScheduledTaskTaskParametersArgs']] = None):
        """
        :param pulumi.Input[str] cron_expression: A valid cron expression. The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of `frequency` or `cronExpression` should be used at a time. Required for `cluster.scheduling.tasks` object. (Example: `0 1 * * *`).
        :param pulumi.Input[bool] is_enabled: Describes whether the task is enabled. When true the task should run when false it should not run. Required for `cluster.scheduling.tasks` object.
        :param pulumi.Input[str] task_type: Valid values: `clusterRoll` `amiAutoUpdate`. Required for `cluster.scheduling.tasks`
        :param pulumi.Input['OceanScheduledTaskTaskParametersArgs'] parameters: This filed will be compatible to the `task_type` field. If `task_type` is defined as `clusterRoll`, user cluster roll object in parameters.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "task_type", task_type)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[str]:
        """
        A valid cron expression. The cron is running in UTC time zone and is in Unix cron format Cron Expression Validator Script. Only one of `frequency` or `cronExpression` should be used at a time. Required for `cluster.scheduling.tasks` object. (Example: `0 1 * * *`).
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Describes whether the task is enabled. When true the task should run when false it should not run. Required for `cluster.scheduling.tasks` object.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input[str]:
        """
        Valid values: `clusterRoll` `amiAutoUpdate`. Required for `cluster.scheduling.tasks`
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_type", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input['OceanScheduledTaskTaskParametersArgs']]:
        """
        This filed will be compatible to the `task_type` field. If `task_type` is defined as `clusterRoll`, user cluster roll object in parameters.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input['OceanScheduledTaskTaskParametersArgs']]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class OceanScheduledTaskTaskParametersArgsDict(TypedDict):
        ami_auto_update: NotRequired[pulumi.Input['OceanScheduledTaskTaskParametersAmiAutoUpdateArgsDict']]
        """
        Set amiAutoUpdate object
        """
        parameters_cluster_roll: NotRequired[pulumi.Input['OceanScheduledTaskTaskParametersParametersClusterRollArgsDict']]
        """
        Set clusterRoll object
        """
elif False:
    OceanScheduledTaskTaskParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanScheduledTaskTaskParametersArgs:
    def __init__(__self__, *,
                 ami_auto_update: Optional[pulumi.Input['OceanScheduledTaskTaskParametersAmiAutoUpdateArgs']] = None,
                 parameters_cluster_roll: Optional[pulumi.Input['OceanScheduledTaskTaskParametersParametersClusterRollArgs']] = None):
        """
        :param pulumi.Input['OceanScheduledTaskTaskParametersAmiAutoUpdateArgs'] ami_auto_update: Set amiAutoUpdate object
        :param pulumi.Input['OceanScheduledTaskTaskParametersParametersClusterRollArgs'] parameters_cluster_roll: Set clusterRoll object
        """
        if ami_auto_update is not None:
            pulumi.set(__self__, "ami_auto_update", ami_auto_update)
        if parameters_cluster_roll is not None:
            pulumi.set(__self__, "parameters_cluster_roll", parameters_cluster_roll)

    @property
    @pulumi.getter(name="amiAutoUpdate")
    def ami_auto_update(self) -> Optional[pulumi.Input['OceanScheduledTaskTaskParametersAmiAutoUpdateArgs']]:
        """
        Set amiAutoUpdate object
        """
        return pulumi.get(self, "ami_auto_update")

    @ami_auto_update.setter
    def ami_auto_update(self, value: Optional[pulumi.Input['OceanScheduledTaskTaskParametersAmiAutoUpdateArgs']]):
        pulumi.set(self, "ami_auto_update", value)

    @property
    @pulumi.getter(name="parametersClusterRoll")
    def parameters_cluster_roll(self) -> Optional[pulumi.Input['OceanScheduledTaskTaskParametersParametersClusterRollArgs']]:
        """
        Set clusterRoll object
        """
        return pulumi.get(self, "parameters_cluster_roll")

    @parameters_cluster_roll.setter
    def parameters_cluster_roll(self, value: Optional[pulumi.Input['OceanScheduledTaskTaskParametersParametersClusterRollArgs']]):
        pulumi.set(self, "parameters_cluster_roll", value)


if not MYPY:
    class OceanScheduledTaskTaskParametersAmiAutoUpdateArgsDict(TypedDict):
        ami_auto_update_cluster_roll: NotRequired[pulumi.Input['OceanScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRollArgsDict']]
        """
        Set clusterRoll object
        """
        apply_roll: NotRequired[pulumi.Input[bool]]
        """
        When the AMI is updated according to the configuration set, a cluster roll can be triggered
        """
        minor_version: NotRequired[pulumi.Input[bool]]
        """
        When set to 'true', the auto-update process will update the VNGs AMI with the AMI to match the Kubernetes control plane version. either "patch" or "minor_version" must be true.
        """
        patch: NotRequired[pulumi.Input[bool]]
        """
        When set to 'true', the auto-update process will update the VNGs images with the latest security patches. either "patch" or "minorVersion" must be true.
        """
elif False:
    OceanScheduledTaskTaskParametersAmiAutoUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanScheduledTaskTaskParametersAmiAutoUpdateArgs:
    def __init__(__self__, *,
                 ami_auto_update_cluster_roll: Optional[pulumi.Input['OceanScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRollArgs']] = None,
                 apply_roll: Optional[pulumi.Input[bool]] = None,
                 minor_version: Optional[pulumi.Input[bool]] = None,
                 patch: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['OceanScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRollArgs'] ami_auto_update_cluster_roll: Set clusterRoll object
        :param pulumi.Input[bool] apply_roll: When the AMI is updated according to the configuration set, a cluster roll can be triggered
        :param pulumi.Input[bool] minor_version: When set to 'true', the auto-update process will update the VNGs AMI with the AMI to match the Kubernetes control plane version. either "patch" or "minor_version" must be true.
        :param pulumi.Input[bool] patch: When set to 'true', the auto-update process will update the VNGs images with the latest security patches. either "patch" or "minorVersion" must be true.
        """
        if ami_auto_update_cluster_roll is not None:
            pulumi.set(__self__, "ami_auto_update_cluster_roll", ami_auto_update_cluster_roll)
        if apply_roll is not None:
            pulumi.set(__self__, "apply_roll", apply_roll)
        if minor_version is not None:
            pulumi.set(__self__, "minor_version", minor_version)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @property
    @pulumi.getter(name="amiAutoUpdateClusterRoll")
    def ami_auto_update_cluster_roll(self) -> Optional[pulumi.Input['OceanScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRollArgs']]:
        """
        Set clusterRoll object
        """
        return pulumi.get(self, "ami_auto_update_cluster_roll")

    @ami_auto_update_cluster_roll.setter
    def ami_auto_update_cluster_roll(self, value: Optional[pulumi.Input['OceanScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRollArgs']]):
        pulumi.set(self, "ami_auto_update_cluster_roll", value)

    @property
    @pulumi.getter(name="applyRoll")
    def apply_roll(self) -> Optional[pulumi.Input[bool]]:
        """
        When the AMI is updated according to the configuration set, a cluster roll can be triggered
        """
        return pulumi.get(self, "apply_roll")

    @apply_roll.setter
    def apply_roll(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_roll", value)

    @property
    @pulumi.getter(name="minorVersion")
    def minor_version(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to 'true', the auto-update process will update the VNGs AMI with the AMI to match the Kubernetes control plane version. either "patch" or "minor_version" must be true.
        """
        return pulumi.get(self, "minor_version")

    @minor_version.setter
    def minor_version(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "minor_version", value)

    @property
    @pulumi.getter
    def patch(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to 'true', the auto-update process will update the VNGs images with the latest security patches. either "patch" or "minorVersion" must be true.
        """
        return pulumi.get(self, "patch")

    @patch.setter
    def patch(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "patch", value)


if not MYPY:
    class OceanScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRollArgsDict(TypedDict):
        batch_min_healthy_percentage: NotRequired[pulumi.Input[int]]
        """
        Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        """
        batch_size_percentage: NotRequired[pulumi.Input[int]]
        """
        Value as a percent to set the size of a batch in a roll. Valid values are 0-100.
        """
        comment: NotRequired[pulumi.Input[str]]
        """
        Add a `comment` description for the roll. The `comment` is limited to 256 chars
        """
        respect_pdb: NotRequired[pulumi.Input[bool]]
        """
        During the roll, if the parameter is set to true we honor PDB during the instance replacement.
        """
elif False:
    OceanScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRollArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRollArgs:
    def __init__(__self__, *,
                 batch_min_healthy_percentage: Optional[pulumi.Input[int]] = None,
                 batch_size_percentage: Optional[pulumi.Input[int]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 respect_pdb: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] batch_min_healthy_percentage: Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        :param pulumi.Input[int] batch_size_percentage: Value as a percent to set the size of a batch in a roll. Valid values are 0-100.
        :param pulumi.Input[str] comment: Add a `comment` description for the roll. The `comment` is limited to 256 chars
        :param pulumi.Input[bool] respect_pdb: During the roll, if the parameter is set to true we honor PDB during the instance replacement.
        """
        if batch_min_healthy_percentage is not None:
            pulumi.set(__self__, "batch_min_healthy_percentage", batch_min_healthy_percentage)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if respect_pdb is not None:
            pulumi.set(__self__, "respect_pdb", respect_pdb)

    @property
    @pulumi.getter(name="batchMinHealthyPercentage")
    def batch_min_healthy_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        """
        return pulumi.get(self, "batch_min_healthy_percentage")

    @batch_min_healthy_percentage.setter
    def batch_min_healthy_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_min_healthy_percentage", value)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Value as a percent to set the size of a batch in a roll. Valid values are 0-100.
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        Add a `comment` description for the roll. The `comment` is limited to 256 chars
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="respectPdb")
    def respect_pdb(self) -> Optional[pulumi.Input[bool]]:
        """
        During the roll, if the parameter is set to true we honor PDB during the instance replacement.
        """
        return pulumi.get(self, "respect_pdb")

    @respect_pdb.setter
    def respect_pdb(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "respect_pdb", value)


if not MYPY:
    class OceanScheduledTaskTaskParametersParametersClusterRollArgsDict(TypedDict):
        batch_min_healthy_percentage: NotRequired[pulumi.Input[int]]
        """
        Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        """
        batch_size_percentage: NotRequired[pulumi.Input[int]]
        """
        Value as a percent to set the size of a batch in a roll. Valid values are 0-100.
        """
        comment: NotRequired[pulumi.Input[str]]
        """
        Add a `comment` description for the roll. The `comment` is limited to 256 chars
        """
        respect_pdb: NotRequired[pulumi.Input[bool]]
        """
        During the roll, if the parameter is set to true we honor PDB during the instance replacement.
        """
elif False:
    OceanScheduledTaskTaskParametersParametersClusterRollArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanScheduledTaskTaskParametersParametersClusterRollArgs:
    def __init__(__self__, *,
                 batch_min_healthy_percentage: Optional[pulumi.Input[int]] = None,
                 batch_size_percentage: Optional[pulumi.Input[int]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 respect_pdb: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] batch_min_healthy_percentage: Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        :param pulumi.Input[int] batch_size_percentage: Value as a percent to set the size of a batch in a roll. Valid values are 0-100.
        :param pulumi.Input[str] comment: Add a `comment` description for the roll. The `comment` is limited to 256 chars
        :param pulumi.Input[bool] respect_pdb: During the roll, if the parameter is set to true we honor PDB during the instance replacement.
        """
        if batch_min_healthy_percentage is not None:
            pulumi.set(__self__, "batch_min_healthy_percentage", batch_min_healthy_percentage)
        if batch_size_percentage is not None:
            pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if respect_pdb is not None:
            pulumi.set(__self__, "respect_pdb", respect_pdb)

    @property
    @pulumi.getter(name="batchMinHealthyPercentage")
    def batch_min_healthy_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        """
        return pulumi.get(self, "batch_min_healthy_percentage")

    @batch_min_healthy_percentage.setter
    def batch_min_healthy_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_min_healthy_percentage", value)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Value as a percent to set the size of a batch in a roll. Valid values are 0-100.
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        Add a `comment` description for the roll. The `comment` is limited to 256 chars
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="respectPdb")
    def respect_pdb(self) -> Optional[pulumi.Input[bool]]:
        """
        During the roll, if the parameter is set to true we honor PDB during the instance replacement.
        """
        return pulumi.get(self, "respect_pdb")

    @respect_pdb.setter
    def respect_pdb(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "respect_pdb", value)


if not MYPY:
    class OceanTagArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The tag key.
        """
        value: pulumi.Input[str]
        """
        The tag value.
        """
elif False:
    OceanTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The tag key.
        :param pulumi.Input[str] value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OceanUpdatePolicyArgsDict(TypedDict):
        should_roll: pulumi.Input[bool]
        """
        Enables the roll.
        """
        auto_apply_tags: NotRequired[pulumi.Input[bool]]
        """
        will update instance tags on the fly without rolling the cluster.
        """
        conditioned_roll: NotRequired[pulumi.Input[bool]]
        """
        Spot will perform a cluster Roll in accordance with a relevant modification of the clusters settings. When set to true , only specific changes in the clusters configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
        """
        conditioned_roll_params: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A custom list of attributes will trigger the cluster roll operation (overrides the predefined list of parameters). Valid only when the `conditioned_roll` parameter is set to true. (Valid values: `"subnet_ids"`,`"whitelist"`,`"blacklist"`,`"user_data"`,`"image_id"`,`"security_groups"`,`"key_name"`,`"iam_instance_profile"`,`"associate_public_ip_address"`,`"load_balancers"`,`"instance_metadata_options"`,`"ebs_optimized"`,`"root_volume_size"`)
        """
        roll_config: NotRequired[pulumi.Input['OceanUpdatePolicyRollConfigArgsDict']]
        """
        While used, you can control whether the group should perform a deployment after an update to the configuration.
        """
elif False:
    OceanUpdatePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanUpdatePolicyArgs:
    def __init__(__self__, *,
                 should_roll: pulumi.Input[bool],
                 auto_apply_tags: Optional[pulumi.Input[bool]] = None,
                 conditioned_roll: Optional[pulumi.Input[bool]] = None,
                 conditioned_roll_params: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 roll_config: Optional[pulumi.Input['OceanUpdatePolicyRollConfigArgs']] = None):
        """
        :param pulumi.Input[bool] should_roll: Enables the roll.
        :param pulumi.Input[bool] auto_apply_tags: will update instance tags on the fly without rolling the cluster.
        :param pulumi.Input[bool] conditioned_roll: Spot will perform a cluster Roll in accordance with a relevant modification of the clusters settings. When set to true , only specific changes in the clusters configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] conditioned_roll_params: A custom list of attributes will trigger the cluster roll operation (overrides the predefined list of parameters). Valid only when the `conditioned_roll` parameter is set to true. (Valid values: `"subnet_ids"`,`"whitelist"`,`"blacklist"`,`"user_data"`,`"image_id"`,`"security_groups"`,`"key_name"`,`"iam_instance_profile"`,`"associate_public_ip_address"`,`"load_balancers"`,`"instance_metadata_options"`,`"ebs_optimized"`,`"root_volume_size"`)
        :param pulumi.Input['OceanUpdatePolicyRollConfigArgs'] roll_config: While used, you can control whether the group should perform a deployment after an update to the configuration.
        """
        pulumi.set(__self__, "should_roll", should_roll)
        if auto_apply_tags is not None:
            pulumi.set(__self__, "auto_apply_tags", auto_apply_tags)
        if conditioned_roll is not None:
            pulumi.set(__self__, "conditioned_roll", conditioned_roll)
        if conditioned_roll_params is not None:
            pulumi.set(__self__, "conditioned_roll_params", conditioned_roll_params)
        if roll_config is not None:
            pulumi.set(__self__, "roll_config", roll_config)

    @property
    @pulumi.getter(name="shouldRoll")
    def should_roll(self) -> pulumi.Input[bool]:
        """
        Enables the roll.
        """
        return pulumi.get(self, "should_roll")

    @should_roll.setter
    def should_roll(self, value: pulumi.Input[bool]):
        pulumi.set(self, "should_roll", value)

    @property
    @pulumi.getter(name="autoApplyTags")
    def auto_apply_tags(self) -> Optional[pulumi.Input[bool]]:
        """
        will update instance tags on the fly without rolling the cluster.
        """
        return pulumi.get(self, "auto_apply_tags")

    @auto_apply_tags.setter
    def auto_apply_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_apply_tags", value)

    @property
    @pulumi.getter(name="conditionedRoll")
    def conditioned_roll(self) -> Optional[pulumi.Input[bool]]:
        """
        Spot will perform a cluster Roll in accordance with a relevant modification of the clusters settings. When set to true , only specific changes in the clusters configuration will trigger a cluster roll (such as AMI, Key Pair, user data, instance types, load balancers, etc).
        """
        return pulumi.get(self, "conditioned_roll")

    @conditioned_roll.setter
    def conditioned_roll(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "conditioned_roll", value)

    @property
    @pulumi.getter(name="conditionedRollParams")
    def conditioned_roll_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A custom list of attributes will trigger the cluster roll operation (overrides the predefined list of parameters). Valid only when the `conditioned_roll` parameter is set to true. (Valid values: `"subnet_ids"`,`"whitelist"`,`"blacklist"`,`"user_data"`,`"image_id"`,`"security_groups"`,`"key_name"`,`"iam_instance_profile"`,`"associate_public_ip_address"`,`"load_balancers"`,`"instance_metadata_options"`,`"ebs_optimized"`,`"root_volume_size"`)
        """
        return pulumi.get(self, "conditioned_roll_params")

    @conditioned_roll_params.setter
    def conditioned_roll_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "conditioned_roll_params", value)

    @property
    @pulumi.getter(name="rollConfig")
    def roll_config(self) -> Optional[pulumi.Input['OceanUpdatePolicyRollConfigArgs']]:
        """
        While used, you can control whether the group should perform a deployment after an update to the configuration.
        """
        return pulumi.get(self, "roll_config")

    @roll_config.setter
    def roll_config(self, value: Optional[pulumi.Input['OceanUpdatePolicyRollConfigArgs']]):
        pulumi.set(self, "roll_config", value)


if not MYPY:
    class OceanUpdatePolicyRollConfigArgsDict(TypedDict):
        batch_size_percentage: pulumi.Input[int]
        """
        Sets the percentage of the instances to deploy in each batch.
        """
        batch_min_healthy_percentage: NotRequired[pulumi.Input[int]]
        """
        Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        """
        launch_spec_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of virtual node group identifiers to be rolled.
        """
        respect_pdb: NotRequired[pulumi.Input[bool]]
        """
        During the roll, if the parameter is set to `true` we honor PDB during the instance replacement.
        """
elif False:
    OceanUpdatePolicyRollConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OceanUpdatePolicyRollConfigArgs:
    def __init__(__self__, *,
                 batch_size_percentage: pulumi.Input[int],
                 batch_min_healthy_percentage: Optional[pulumi.Input[int]] = None,
                 launch_spec_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 respect_pdb: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] batch_size_percentage: Sets the percentage of the instances to deploy in each batch.
        :param pulumi.Input[int] batch_min_healthy_percentage: Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] launch_spec_ids: List of virtual node group identifiers to be rolled.
        :param pulumi.Input[bool] respect_pdb: During the roll, if the parameter is set to `true` we honor PDB during the instance replacement.
        """
        pulumi.set(__self__, "batch_size_percentage", batch_size_percentage)
        if batch_min_healthy_percentage is not None:
            pulumi.set(__self__, "batch_min_healthy_percentage", batch_min_healthy_percentage)
        if launch_spec_ids is not None:
            pulumi.set(__self__, "launch_spec_ids", launch_spec_ids)
        if respect_pdb is not None:
            pulumi.set(__self__, "respect_pdb", respect_pdb)

    @property
    @pulumi.getter(name="batchSizePercentage")
    def batch_size_percentage(self) -> pulumi.Input[int]:
        """
        Sets the percentage of the instances to deploy in each batch.
        """
        return pulumi.get(self, "batch_size_percentage")

    @batch_size_percentage.setter
    def batch_size_percentage(self, value: pulumi.Input[int]):
        pulumi.set(self, "batch_size_percentage", value)

    @property
    @pulumi.getter(name="batchMinHealthyPercentage")
    def batch_min_healthy_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        Default: 50. Indicates the threshold of minimum healthy instances in single batch. If the amount of healthy instances in single batch is under the threshold, the cluster roll will fail. If exists, the parameter value will be in range of 1-100. In case of null as value, the default value in the backend will be 50%. Value of param should represent the number in percentage (%) of the batch.
        """
        return pulumi.get(self, "batch_min_healthy_percentage")

    @batch_min_healthy_percentage.setter
    def batch_min_healthy_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_min_healthy_percentage", value)

    @property
    @pulumi.getter(name="launchSpecIds")
    def launch_spec_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of virtual node group identifiers to be rolled.
        """
        return pulumi.get(self, "launch_spec_ids")

    @launch_spec_ids.setter
    def launch_spec_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "launch_spec_ids", value)

    @property
    @pulumi.getter(name="respectPdb")
    def respect_pdb(self) -> Optional[pulumi.Input[bool]]:
        """
        During the roll, if the parameter is set to `true` we honor PDB during the instance replacement.
        """
        return pulumi.get(self, "respect_pdb")

    @respect_pdb.setter
    def respect_pdb(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "respect_pdb", value)


if not MYPY:
    class SuspensionSuspensionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of process to suspend. Valid values: `"AUTO_HEALING" , "OUT_OF_STRATEGY", "PREVENTIVE_REPLACEMENT", "REVERT_PREFERRED", or "SCHEDULING"`.
        """
elif False:
    SuspensionSuspensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SuspensionSuspensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of process to suspend. Valid values: `"AUTO_HEALING" , "OUT_OF_STRATEGY", "PREVENTIVE_REPLACEMENT", "REVERT_PREFERRED", or "SCHEDULING"`.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of process to suspend. Valid values: `"AUTO_HEALING" , "OUT_OF_STRATEGY", "PREVENTIVE_REPLACEMENT", "REVERT_PREFERRED", or "SCHEDULING"`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


