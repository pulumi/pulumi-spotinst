// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.SpotInst
{
    /// <summary>
    /// Provides a Spotinst stateful node Azure resource.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using SpotInst = Pulumi.SpotInst;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var testStatefulNodeAzure = new SpotInst.StatefulNodeAzure("test_stateful_node_azure", new()
    ///     {
    ///         Name = "example_stateful_node_azure",
    ///         Region = "eastus",
    ///         ResourceGroupName = "spotinst-azure",
    ///         Description = "example_stateful_node_azure_description",
    ///         Strategy = new SpotInst.Inputs.StatefulNodeAzureStrategyArgs
    ///         {
    ///             DrainingTimeout = 30,
    ///             FallbackToOnDemand = true,
    ///             OptimizationWindows = new[]
    ///             {
    ///                 "Tue:19:46-Tue:20:46",
    ///             },
    ///             OdWindows = new[]
    ///             {
    ///                 "Wed:19:46-Wed:21:46",
    ///             },
    ///             AvailabilityVsCost = 100,
    ///             RevertToSpot = new SpotInst.Inputs.StatefulNodeAzureStrategyRevertToSpotArgs
    ///             {
    ///                 PerformAt = "timeWindow",
    ///             },
    ///             PreferredLifeCycle = "od",
    ///             CapacityReservations = new[]
    ///             {
    ///                 new SpotInst.Inputs.StatefulNodeAzureStrategyCapacityReservationArgs
    ///                 {
    ///                     ShouldUtilize = true,
    ///                     UtilizationStrategy = "utilizeOverOD",
    ///                     CapacityReservationGroups = new[]
    ///                     {
    ///                         new SpotInst.Inputs.StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroupArgs
    ///                         {
    ///                             CrgName = "crg name",
    ///                             CrgResourceGroupName = "resourceGroupName",
    ///                             CrgShouldPrioritize = true,
    ///                         },
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///         Os = "Linux",
    ///         OdSizes = new[]
    ///         {
    ///             "standard_ds1_v2",
    ///             "standard_ds2_v2",
    ///         },
    ///         SpotSizes = new[]
    ///         {
    ///             "standard_ds1_v2",
    ///             "standard_ds2_v2",
    ///         },
    ///         PreferredSpotSizes = new[]
    ///         {
    ///             "standard_ds1_v2",
    ///         },
    ///         Zones = new[]
    ///         {
    ///             "1",
    ///             "3",
    ///         },
    ///         PreferredZone = "1",
    ///         CustomData = "",
    ///         ShutdownScript = "",
    ///         UserData = "",
    ///         VmName = "VMName",
    ///         VmNamePrefix = "VMNamePrefix",
    ///         LicenseType = "SLES_BYOS",
    ///         BootDiagnostics = new[]
    ///         {
    ///             new SpotInst.Inputs.StatefulNodeAzureBootDiagnosticArgs
    ///             {
    ///                 IsEnabled = true,
    ///                 StorageUrl = "https://.blob.core.windows.net/test",
    ///                 Type = "unmanaged",
    ///             },
    ///         },
    ///         DataDisks = new[]
    ///         {
    ///             new SpotInst.Inputs.StatefulNodeAzureDataDiskArgs
    ///             {
    ///                 SizeGb = 1,
    ///                 Lun = 1,
    ///                 Type = "Standard_LRS",
    ///             },
    ///             new SpotInst.Inputs.StatefulNodeAzureDataDiskArgs
    ///             {
    ///                 SizeGb = 10,
    ///                 Lun = 2,
    ///                 Type = "Standard_LRS",
    ///             },
    ///         },
    ///         Extensions = new[]
    ///         {
    ///             new SpotInst.Inputs.StatefulNodeAzureExtensionArgs
    ///             {
    ///                 Name = "extensionName",
    ///                 Type = "customScript",
    ///                 Publisher = "Microsoft.Azure.Extensions",
    ///                 ApiVersion = "2.0",
    ///                 MinorVersionAutoUpgrade = true,
    ///                 ProtectedSettings = 
    ///                 {
    ///                     { "script", "IyEvYmluL2Jhc2gKZWNobyAibmlyIiA+IC9ob29uaXIudHh0Cg==" },
    ///                 },
    ///                 PublicSettings = 
    ///                 {
    ///                     { "fileUris", new[]
    ///                     {
    ///                         "https://testspot/Azuretest.sh",
    ///                     } },
    ///                 },
    ///             },
    ///         },
    ///         Image = new SpotInst.Inputs.StatefulNodeAzureImageArgs
    ///         {
    ///             MarketplaceImages = new[]
    ///             {
    ///                 new SpotInst.Inputs.StatefulNodeAzureImageMarketplaceImageArgs
    ///                 {
    ///                     Publisher = "Canonical",
    ///                     Offer = "UbuntuServer",
    ///                     Sku = "16.04-LTS",
    ///                     Version = "latest",
    ///                 },
    ///             },
    ///             CustomImages = new[]
    ///             {
    ///                 new SpotInst.Inputs.StatefulNodeAzureImageCustomImageArgs
    ///                 {
    ///                     CustomImageResourceGroupName = "resourceGroupName",
    ///                     Name = "imageName",
    ///                 },
    ///             },
    ///             Galleries = new[]
    ///             {
    ///                 new SpotInst.Inputs.StatefulNodeAzureImageGalleryArgs
    ///                 {
    ///                     GalleryResourceGroupName = "resourceGroupName",
    ///                     GalleryName = "galleryName",
    ///                     ImageName = "imageName",
    ///                     VersionName = "1.1.0",
    ///                 },
    ///             },
    ///         },
    ///         LoadBalancers = new[]
    ///         {
    ///             new SpotInst.Inputs.StatefulNodeAzureLoadBalancerArgs
    ///             {
    ///                 Type = "loadBalancer",
    ///                 ResourceGroupName = "testResourceGroup",
    ///                 Name = "testLoadBalancer",
    ///                 Sku = "Standard",
    ///                 BackendPoolNames = new[]
    ///                 {
    ///                     "testBackendPool1",
    ///                     "testBackendPool2",
    ///                 },
    ///             },
    ///         },
    ///         Login = new SpotInst.Inputs.StatefulNodeAzureLoginArgs
    ///         {
    ///             UserName = "admin",
    ///             SshPublicKey = "33a2s1f3g5a1df5g1ad3f2g1adfg56dfg==",
    ///         },
    ///         ManagedServiceIdentities = new[]
    ///         {
    ///             new SpotInst.Inputs.StatefulNodeAzureManagedServiceIdentityArgs
    ///             {
    ///                 Name = "mySI2",
    ///                 ResourceGroupName = "myResourceGroup",
    ///             },
    ///         },
    ///         Network = new SpotInst.Inputs.StatefulNodeAzureNetworkArgs
    ///         {
    ///             NetworkResourceGroupName = "subnetResourceGroup",
    ///             VirtualNetworkName = "vname",
    ///             NetworkInterfaces = new[]
    ///             {
    ///                 new SpotInst.Inputs.StatefulNodeAzureNetworkNetworkInterfaceArgs
    ///                 {
    ///                     IsPrimary = true,
    ///                     SubnetName = "testSubnet",
    ///                     AssignPublicIp = true,
    ///                     PublicIpSku = "Standard",
    ///                     NetworkSecurityGroups = new[]
    ///                     {
    ///                         new SpotInst.Inputs.StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroupArgs
    ///                         {
    ///                             NetworkResourceGroupName = "test",
    ///                             Name = "test",
    ///                         },
    ///                     },
    ///                     EnableIpForwarding = true,
    ///                     PrivateIpAddresses = new[]
    ///                     {
    ///                         "172.23.4.20",
    ///                     },
    ///                     AdditionalIpConfigurations = new[]
    ///                     {
    ///                         new SpotInst.Inputs.StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfigurationArgs
    ///                         {
    ///                             Name = "test",
    ///                             PrivateIpAddressVersion = "IPv4",
    ///                         },
    ///                     },
    ///                     PublicIps = new[]
    ///                     {
    ///                         new SpotInst.Inputs.StatefulNodeAzureNetworkNetworkInterfacePublicIpArgs
    ///                         {
    ///                             NetworkResourceGroupName = "resourceGroup",
    ///                             Name = "test",
    ///                         },
    ///                     },
    ///                     ApplicationSecurityGroups = new[]
    ///                     {
    ///                         new SpotInst.Inputs.StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroupArgs
    ///                         {
    ///                             NetworkResourceGroupName = "AsgResourceGroup",
    ///                             Name = "AsgName",
    ///                         },
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///         OsDisk = new SpotInst.Inputs.StatefulNodeAzureOsDiskArgs
    ///         {
    ///             SizeGb = 30,
    ///             Type = "Standard_LRS",
    ///             Caching = "ReadOnly",
    ///         },
    ///         Secrets = new[]
    ///         {
    ///             new SpotInst.Inputs.StatefulNodeAzureSecretArgs
    ///             {
    ///                 SourceVaults = new[]
    ///                 {
    ///                     new SpotInst.Inputs.StatefulNodeAzureSecretSourceVaultArgs
    ///                     {
    ///                         Name = "string",
    ///                         ResourceGroupName = "string",
    ///                     },
    ///                 },
    ///                 VaultCertificates = new[]
    ///                 {
    ///                     new SpotInst.Inputs.StatefulNodeAzureSecretVaultCertificateArgs
    ///                     {
    ///                         CertificateUrl = "string",
    ///                         CertificateStore = "string",
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///         Security = new SpotInst.Inputs.StatefulNodeAzureSecurityArgs
    ///         {
    ///             SecurityType = "Standard",
    ///             SecureBootEnabled = false,
    ///             VtpmEnabled = false,
    ///         },
    ///         Tags = new[]
    ///         {
    ///             new SpotInst.Inputs.StatefulNodeAzureTagArgs
    ///             {
    ///                 TagKey = "Creator",
    ///                 TagValue = "string",
    ///             },
    ///         },
    ///         Health = new SpotInst.Inputs.StatefulNodeAzureHealthArgs
    ///         {
    ///             HealthCheckTypes = new[]
    ///             {
    ///                 "vmState",
    ///             },
    ///             UnhealthyDuration = 300,
    ///             GracePeriod = 120,
    ///             AutoHealing = true,
    ///         },
    ///         ShouldPersistOsDisk = false,
    ///         OsDiskPersistenceMode = "reattach",
    ///         ShouldPersistDataDisks = true,
    ///         DataDisksPersistenceMode = "reattach",
    ///         ShouldPersistNetwork = true,
    ///         SchedulingTasks = new[]
    ///         {
    ///             new SpotInst.Inputs.StatefulNodeAzureSchedulingTaskArgs
    ///             {
    ///                 IsEnabled = true,
    ///                 Type = "pause",
    ///                 CronExpression = "44 10 * * *",
    ///             },
    ///             new SpotInst.Inputs.StatefulNodeAzureSchedulingTaskArgs
    ///             {
    ///                 IsEnabled = true,
    ///                 Type = "resume",
    ///                 CronExpression = "48 10 * * *",
    ///             },
    ///             new SpotInst.Inputs.StatefulNodeAzureSchedulingTaskArgs
    ///             {
    ///                 IsEnabled = true,
    ///                 Type = "recycle",
    ///                 CronExpression = "52 10 * * *",
    ///             },
    ///         },
    ///         Signals = new[]
    ///         {
    ///             new SpotInst.Inputs.StatefulNodeAzureSignalArgs
    ///             {
    ///                 Type = "vmReady",
    ///                 Timeout = 20,
    ///             },
    ///             new SpotInst.Inputs.StatefulNodeAzureSignalArgs
    ///             {
    ///                 Type = "vmReady",
    ///                 Timeout = 40,
    ///             },
    ///         },
    ///         ProximityPlacementGroups = new[]
    ///         {
    ///             new SpotInst.Inputs.StatefulNodeAzureProximityPlacementGroupArgs
    ///             {
    ///                 Name = "TestPPG",
    ///                 ResourceGroupName = "TestResourceGroup",
    ///             },
    ///         },
    ///         Deletes = new[]
    ///         {
    ///             new SpotInst.Inputs.StatefulNodeAzureDeleteArgs
    ///             {
    ///                 ShouldTerminateVm = true,
    ///                 NetworkShouldDeallocate = true,
    ///                 NetworkTtlInHours = 0,
    ///                 DiskShouldDeallocate = true,
    ///                 DiskTtlInHours = 0,
    ///                 SnapshotShouldDeallocate = true,
    ///                 SnapshotTtlInHours = 0,
    ///                 PublicIpShouldDeallocate = true,
    ///                 PublicIpTtlInHours = 0,
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// # Argument Reference
    /// 
    /// The following arguments are supported:
    /// 
    /// * `name` - (Required) Azure stateful node name.
    /// * `region` - (Required) The Azure region your stateful node will be created in.
    /// * `resource_group_name` - (Required) Name of the Resource Group for stateful node.
    /// * `description` - (Optional) Describe your Azure stateful node.
    /// 
    /// &lt;a id="strategy"&gt;&lt;/a&gt;
    /// ## Strategy
    /// 
    /// * `strategy` - (Required) Strategy for stateful node.
    ///   * `draining_timeout` - (Optional, Default `120`) Time (in seconds) to allow the VM be drained from incoming TCP connections and detached from MLB before terminating it during a scale down operation.
    ///   * `availability_vs_cost` - (Optional) Set the desired preference for the Spot market VM selection. (100- Availability, 0- cost).
    ///   * `fallback_to_on_demand` - (Required) In case of no spots available, Stateful Node will launch an On-demand instance instead.
    ///   * `optimization_windows` - (Optional) Valid format: "ddd:hh:mm-ddd:hh:mm (day:hour(0-23):minute(0-59))", not empty if revertToSpot.performAt = timeWindow.
    ///   * `od_windows` - (Optional) Define the time windows in which the underlying VM will be set as an on-demand lifecycle type. During the entire time window, the rest of the strategy processes will be paused.
    ///     Switching between on-demand and Spot VM types at the enter/exit of the time window will trigger the recycling of the stateful node. Valid format: "ddd:hh:mm-ddd:hh:mm (day:hour(0-23):minute(0-59))".
    ///   * `preferred_life_cycle` - (Optional, Enum `"od", "spot"`, Default `"spot"`) The desired type of VM.
    ///   * `revert_to_spot` - (Optional) Hold settings for strategy correction - replacing On-Demand for Spot VMs.
    ///     * `perform_at` - (Required, Enum `"timeWindow", "never", "always"`, Default `"always"`) Settings for maintenance strategy.
    ///   * `capacity_reservation` - (Optional) On-demand Capacity Reservation group enables you to reserve Compute capacity in an Azure region or an Availability Zone for any duration of time. [CRG can only be created on the Azure end.](https://learn.microsoft.com/en-us/azure/virtual-machines/capacity-reservation-create)
    ///     * `should_utilize` - (Required) Determines whether capacity reservations should be utilized.
    ///     * `utilization_strategy` - (Required, Enum `"utilizeOverSpot", "utilizeOverOD"`) The priority requested for using CRG. This value will determine if CRG is used ahead of spot VMs or On-demand VMs. (`"utilizeOverOD"`- If picked, we will use CRG only in case On demand should be launched. `"utilizeOverSpot"`- CRG will be preferred over Spot. Only after CRG is fully used, spot VMs can be used.)
    ///     * `capacity_reservation_groups` - (Optional) List of the desired CRGs to use under the associated Azure subscription. When null we will utilize any available reservation that matches the launch specification.
    ///       * `crg_name` - (Required) The name of the CRG.
    ///       * `crg_resource_group_name` - (Required) Azure resource group name
    ///       * `crg_should_prioritize` - The desired CRG to utilize ahead of other CRGs in the subscription.
    /// 
    /// &lt;a id="compute"&gt;&lt;/a&gt;
    /// ## Compute
    /// 
    /// * `os` - (Required, Enum `"Linux", "Windows"`) Type of operating system.
    /// * `od_sizes` - (Required) Available On-Demand sizes.
    /// * `spot_sizes` - (Required) Available Spot-VM sizes.
    /// * `preferred_spot_sizes` - (Optional) Prioritize Spot VM sizes when launching Spot VMs for the group. If set, must be a sublist of compute.vmSizes.spotSizes.
    /// * `zones` - (Optional, Enum `"1", "2", "3"`) List of Azure Availability Zones in the defined region. If not defined, Virtual machines will be launched regionally.
    /// * `preferred_zone` - (Optional, Enum `"1", "2", "3"`) The AZ to prioritize when launching VMs. If no markets are available in the Preferred AZ, VMs are launched in the non-preferred AZ. Must be a sublist of compute.zones.
    /// * `custom_data` - (Optional) This value will hold the YAML in base64 and will be executed upon VM launch.
    /// * `shutdown_script` - (Optional) Shutdown script for the stateful node. Value should be passed as a string encoded at Base64 only.
    /// * `user_data` - (Optional) Define a set of scripts or other metadata that's inserted to an Azure virtual machine at provision time. (Base64 encoded)
    /// * `vm_name` - (Optional) Set a VM name that will be persisted throughout the entire node lifecycle. This can't be set if `vm_name_prefix` is set.
    /// * `vm_name_prefix` - (Optional) Set a VM name prefix to be used for all launched VMs and the VM resources. This can't be set if `vm_name` is set.
    /// * `license_type` - (Optional) Specify an existing Azure license type to use when launching new VMs. Valid values for Windows OS: "Windows_Server", "Windows_Client", Valid values for Linux OS: "RHEL_BYOS", "SLES_BYOS"
    /// 
    /// &lt;a id="boot_diagnostics"&gt;&lt;/a&gt;
    /// ## Boot Diagnostics
    /// 
    /// * `boot_diagnostics`
    ///   * `is_enabled` - (Optional) Allows you to enable and disable the configuration of boot diagnostics at launch.
    ///   * `storage_url` - (Optional) The storage URI that is used if a type is unmanaged. The storage URI must follow the blob storage URI format ("https://.blob.core.windows.net/"). StorageUri is required if the type is unmanaged. StorageUri must be ‘null’ in case the boot diagnostics type is managed.
    ///   * `type` - (Optional, Enum `"managed", "unmanaged"`) Defines the storage type on VM launch in Azure.
    /// 
    /// &lt;a id="data_disks"&gt;&lt;/a&gt;
    /// ## Data Disks
    /// 
    /// * `data_disk` - (Optional) The definitions of data disks that will be created and attached to the stateful node's VM.
    ///   * `size_gb` - (Required) The size of the data disk in GB, required if dataDisks is specified.
    ///   * `lun` - (Required) The LUN of the data disk.
    ///   * `type` - (Required, Enum `"Standard_LRS", "Premium_LRS", "StandardSSD_LRS", "UltraSSD_LRS"`) The type of the data disk.
    /// 
    /// &lt;a id="extensions"&gt;&lt;/a&gt;
    /// ## Extensions
    /// 
    /// * `extension` - (Optional) An object for an azure extension.
    ///   * `name` - (Required) Required on compute.launchSpecification.extensions object.
    ///   * `type` - (Required) Required on compute.launchSpecification.extensions object.
    ///   * `publisher` - (Required) Required on compute.launchSpecification.extensions object.
    ///   * `api_version` - (Required) The API version of the extension. Required if extension specified.
    ///   * `minor_version_auto_upgrade` - (Required) Required on compute.launchSpecification.extensions object.
    ///   * `protected_settings` - (Optional) Object for protected settings.
    ///   * `public_settings` - (Optional) Object for public settings.
    /// 
    /// &lt;a id="image"&gt;&lt;/a&gt;
    /// ## Image
    /// 
    /// * `image`
    ///   * `marketplace_image` - (Optional) Select an image from Azure's Marketplace image catalogue. Required if the custom image or gallery image are not specified.
    ///     * `publisher` - (Required) Image publisher.
    ///     * `offer` - (Required) Image offer.
    ///     * `sku` - (Required) Image Stock Keeping Unit, which is the specific version of the image.
    ///     * `version` - (Required, Default `"latest"`) Image's version. if version not provided we use "latest".
    ///   * `gallery` - (Optional) Gallery image definitions. Required if custom image or marketplace image are not specified.
    ///     * `gallery_resource_group_name` - (Required) The resource group name for gallery image.
    ///     * `gallery_name` - (Required) Name of the gallery.
    ///     * `image_name` - (Required) Name of the gallery image.
    ///     * `version_name` - (Required) Image's version. Can be in the format x.x.x or 'latest'.
    ///   * `custom_image` - (Optional) Custom image definitions. Required if marketplace image or gallery image are not specified.
    ///     * `custom_image_resource_group_name` - (Required) The resource group name for custom image.
    ///     * `name` - (Required) The name of the custom image.
    /// 
    /// &lt;a id="load balancer"&gt;&lt;/a&gt;
    /// ## Load Balancer
    /// 
    /// * `load_balancer` - (Optional) Add a load balancer. For Azure Gateway, each Backend Pool is a separate load balancer.
    ///   * `type` - (Required, Enum `"loadBalancer", "applicationGateway"`) The type of load balancer.
    ///   * `resource_group_name` - (Required) The Resource Group name of the Load Balancer.
    ///   * `name` - (Required) Name of the Application Gateway/Load Balancer.
    ///   * `sku` - (Optional)
    ///     * if type is `"LoadBalancer"` then possible values are `“Standard", "Basic”`.
    ///     * If ApplicationGateway then possible values are
    ///       `“Standard_Large”, “Standard_Medium”, “Standard_Small”, “Standard_v2", “WAF_Large”, “WAF_Medium", “WAF_v2"`.
    ///   * `backend_pool_names` - (Optional) Name of the Backend Pool to register the Stateful Node VMs to. Each Backend Pool is a separate load balancer. Required if Type is APPLICATION_GATEWAY.
    /// 
    /// &lt;a id="login"&gt;&lt;/a&gt;
    /// ## Login
    /// 
    /// * `login` - (Required) Set admin access for accessing your VMs. Password/SSH is required for Linux.
    ///   * `user_name` - (Required) username for admin access to VMs.
    ///   * `ssh_public_key` - (Optional) SSH for admin access to Linux VMs. Optional for Linux.
    ///   * `password` - (Optional) Password for admin access to Windows VMs. Required for Windows.
    /// 
    /// &lt;a id="managed_service_identities"&gt;&lt;/a&gt;
    /// ## Managed Service Identities
    /// 
    /// * `managed_service_identities` - (Optional) Add a user-assigned managed identity to the Stateful Node's VM.
    ///   * `name` - (Required) name of the managed identity.
    ///   * `resource_group_name` - (Required) The Resource Group that the user-assigned managed identity resides in.
    /// 
    /// &lt;a id="proximity_placement_groups"&gt;&lt;/a&gt;
    /// ## Proximity Placement Groups
    /// 
    /// * `proximity_placement_groups` - (Optional) Defines the proximity placement group in which the VM will be launched.
    ///   * `name` - (Required) name of the proximity placement group.
    ///   * `resource_group_name` - (Required) The Resource Group name of the proximity placement group.
    /// 
    /// &lt;a id="network"&gt;&lt;/a&gt;
    /// ## Network
    /// 
    /// * `network` - (Required) Define the Virtual Network and Subnet for your Stateful Node.
    ///   * `network_resource_group_name` - (Required) Vnet Resource Group Name.
    ///   * `virtual_network_name` - (Required) Virtual Network.
    ///   * `network_interface` - (Required) Define a network interface
    ///     * `is_primary` - (Required) Defines whether the network interface is primary or not.
    ///     * `subnet_name` - (Required) Subnet name.
    ///     * `assign_public_ip` - (Optional) Assign public IP.
    ///     * `public_ip_sku` - (Optional) Required if assignPublicIp=true values=[Standard/Basic].
    ///     * `network_security_group` - (Optional) Network Security Group.
    ///       * `network_resource_group_name` - (Required) Requires valid security group name.
    ///       * `name` - (Required) Requires valid resource group name.
    ///     * `enable_ip_forwarding` - (Optional) Enable IP Forwarding.
    ///     * `private_ip_addresses` - (Optional) A list with unique items that every item is a valid IP.
    ///     * `additional_ip_configurations` - (Optional) Additional configuration of network interface.
    ///       * `name` - (Required) Configuration name.
    ///       * `private_ip_address_version` - (Required, Enum `"IPv4", "IPv6"` Default `"IPv4"`) Version of the private IP address.
    ///     * `public_ips` - (Optional) Defined a pool of Public Ips (from Azure), that will be associated to the network interface. We will associate one public ip per instance until the pool is exhausted, in which case, we will create a new one.
    ///       * `resource_group_name` - (Required) The resource group of the public ip.
    ///       * `name` - (Required) - The name of the public ip.
    ///     * `application_security_groups` - (Optional) Network Security Group.
    ///       * `resource_group_name` - (Required) Requires valid security group name.
    ///       * `name` - (Required) Requires valid resource group name.
    /// 
    /// &lt;a id="os_disk"&gt;&lt;/a&gt;
    /// ## OS Disk
    /// 
    /// * `os_disk` - (Optional) Specify OS disk specification other than default.
    ///   * `size_gb` - (Optional, Default `"30"`) The size of the data disk in GB.
    ///   * `type` - (Required, Enum `"Standard_LRS", "Premium_LRS", "StandardSSD_LRS"`) The type of the OS disk.
    ///   * `caching` - (Optional, Enum `"None", "ReadOnly", "ReadWrite"`) Specifies the host caching requirements. With disk caching enabled, VMs can achieve higher levels of performance. If not specified, the Azure default behavior will be applied.
    /// 
    /// &lt;a id="secret"&gt;&lt;/a&gt;
    /// ## Secret
    /// 
    /// * `secret` - (Optional) Set of certificates that should be installed on the VM.
    ///   * `source_vault` - (Required) The key vault reference, contains the required certificates.
    ///     * `name` - (Required) The name of the key vault.
    ///     * `resource_group_name` - (Required) The resource group name of the key vault.
    ///   * `vault_certificates` - (Required) The required certificate references.
    ///     * `certificate_url` - (Optional) The URL of the certificate under the key vault.
    ///     * `certificate_store` - (Required) The certificate store directory the VM. The directory is created in the LocalMachine account.
    ///       * This field is required only when using Windows OS type
    ///       * This field must be ‘null’ when the OS type is Linux
    /// 
    /// &lt;a id="secutiry"&gt;&lt;/a&gt;
    /// ## Security
    /// 
    /// * `security` - (Optional) Specifies the Security related profile settings for the virtual machine.
    ///     * `secure_boot_enabled` - (Optional) Specifies whether secure boot should be enabled on the virtual machine.
    ///     * `security_type` - (Optional) Enum: `"Standard", "TrustedLaunch"` Security type refers to the different security features of a virtual machine. Security features like Trusted launch virtual machines help to improve the security of Azure generation 2 virtual machines.
    ///     * `vtpm_enabled` - (Optional) Specifies whether vTPM should be enabled on the virtual machine.
    /// 
    /// &lt;a id="tag"&gt;&lt;/a&gt;
    /// ## Tag
    /// 
    /// * `tag` - (Optional) Unique Key-Value pair for all Stateful Node Resources.
    ///   * `tag_key` - (Optional) Tag Key for Stateful Node Resources.
    ///   * `tag_value` - (Optional) Tag Value for Stateful Node Resources.
    /// 
    /// &lt;a id="health"&gt;&lt;/a&gt;
    /// ## Health
    /// 
    /// * `health` - (Optional) Set the auto healing preferences for unhealthy VMs.
    ///   * `health_check_types` - (Optional, Enum `"vmState", "applicationGateway"`) Healthcheck to use to validate VM health.
    ///   * `unhealthy_duration` - (Optional) Amount of time to be unhealthy before a replacement is triggered.
    ///   * `auto_healing` - (Required) Enable Autohealing of unhealthy VMs.
    ///   * `grace_period` - (Optional) Period of time to wait for VM to reach healthiness before monitoring for unhealthiness.
    /// 
    /// &lt;a id="persistence"&gt;&lt;/a&gt;
    /// ## Persistence
    /// 
    /// * `should_persist_os_disk` - (Required) Should persist os disk.
    /// * `os_disk_persistence_mode` - (Optional, Enum `"reattach", "onLaunch"`)
    /// * `should_persist_data_disks` - (Required) Should persist data disks.
    /// * `data_disks_persistence_mode` - (Optional, Enum `"reattach", "onLaunch"`)
    /// * `should_persist_network` - (Required) Should persist network.
    /// 
    /// &lt;a id="scheduling_tasks"&gt;&lt;/a&gt;
    /// ## Scheduling Tasks
    /// 
    /// * `scheduling_task` - (Optional) Scheduling settings object for stateful node.
    ///   * `is_enabled` - (Required) Is scheduled task enabled for stateful node.
    ///   * `type` - (Required, Enum `"pause", "resume", "recycle") The type of the scheduled task
    ///   * `cron_expression` (Required) A expression which describes when to execute the scheduled task (UTC).
    /// 
    /// &lt;a id="signals"&gt;&lt;/a&gt;
    /// ## Signals
    /// 
    /// * `signal` - (Optional) A signal object defined for the stateful node.
    ///   * `type` - (Required, Enum `"vmReady", "vmReadyToShutdown"`) The type of the signal defined for the stateful node.
    ///   * `timeout` - (Required, Default `"1800"`) The timeout in seconds to hold the vm until a signal is sent. If no signal is sent the vm will be replaced (vmReady) or we will terminate the vm (vmReadyToShutdown) after the timeout.
    /// 
    /// ***
    /// 
    /// &lt;a id="attach_data_disk"&gt;&lt;/a&gt;
    /// ## Attach Data Disk
    /// 
    /// * `attach_data_disk` - (Optional) Create a new data disk and attach it to the stateful node.
    ///   * `data_disk_name` - (Required) The name of the created data disk.
    ///   * `data_disk_resource_group_name` - (Required) The resource group name in which the data disk will be created.
    ///   * `storage_account_type` - (Required, Enum `"Standard_LRS", "Premium_LRS", "StandardSSD_LRS", "UltraSSD_LRS"`) The type of the data disk.
    ///   * `size_gb` - (Required) The size of the data disk in GB, Required if dataDisks is specified.
    ///   * `zone` - (Optional, Enum `"1", "2", "3"`) The Availability Zone in which the data disk will be created. If not defined, the data disk will be created regionally.
    ///   * `lun` - (Optional, Default `"orginal"`) The LUN of the data disk. If not defined, the LUN will be set in order.
    /// 
    /// &lt;a id="detach_data_disk"&gt;&lt;/a&gt;
    /// ## Detach Data Disk
    /// 
    /// * `detach_data_disk` - (Optional) Detach a data disk from a stateful node.
    ///   * `data_disk_name` - (Required) The name of the detached data disk.
    ///   * `data_disk_resource_group_name` - (Required) The resource group name in which the data disk exists.
    ///   * `should_deallocate` - (Required) Indicates whether to delete the data disk in addition to detach.
    ///   * `ttl_in_hours` - (Required, Default `"0"`) Hours to keep the disk alive before deletion.
    /// 
    /// &lt;a id="update_state"&gt;&lt;/a&gt;
    /// ## Update State
    /// 
    /// * `update_state` - (Optional) Update the stateful node state.
    ///   * `state` - (Required, Enum `"pause", "resume", "recycle"`) New state for the stateful node.
    /// 
    /// &lt;a id="import_vm"&gt;&lt;/a&gt;
    /// ## Import VM
    /// 
    /// * `import_vm` - (Optional) Import an Azure VM and create a stateful node by providing a node configuration.
    ///   * `resource_group_name` - (Required) Name of the Resource Group for Stateful Node.
    ///   * `original_vm_name` - (Required) Azure Import Stateful Node Name.
    ///   * `draining_timeout` - (Optional) Hours to keep resources alive.
    ///   * `resources_retention_time` - (Optional) Hours to keep resources alive.
    /// 
    /// &lt;a id="delete"&gt;&lt;/a&gt;
    /// ## Deallocation Config
    /// 
    /// * `delete` - (Required) Specify deallocation parameters for stateful node deletion.
    ///     * `should_terminate_vm` - (Required) Indicates whether to delete the stateful node's VM.
    ///     * `network_should_deallocate` - (Required) Indicates whether to delete the stateful node's network resources.
    ///     * `network_ttl_in_hours` - (Optional, Default: 96) Hours to keep the network resource alive before deletion.
    ///     * `disk_should_deallocate` - (Required) Indicates whether to delete the stateful node's disk resources.
    ///     * `disk_ttl_in_hours` - (Optional, Default: 96) Hours to keep the disk resource alive before deletion.
    ///     * `snapshot_should_deallocate` - (Required) Indicates whether to delete the stateful node's snapshot resources.
    ///     * `snapshot_ttl_in_hours` - (Optional, Default: 96) Hours to keep the snapshots alive before deletion.
    ///     * `public_ip_should_deallocate` - (Required) Indicates whether to delete the stateful node's public ip resources.
    ///     * `public_ip_ttl_in_hours` - (Optional, Default: 96) Hours to keep the public ip alive before deletion.
    /// </summary>
    [SpotInstResourceType("spotinst:index/statefulNodeAzure:StatefulNodeAzure")]
    public partial class StatefulNodeAzure : global::Pulumi.CustomResource
    {
        [Output("attachDataDisks")]
        public Output<ImmutableArray<Outputs.StatefulNodeAzureAttachDataDisk>> AttachDataDisks { get; private set; } = null!;

        [Output("bootDiagnostics")]
        public Output<ImmutableArray<Outputs.StatefulNodeAzureBootDiagnostic>> BootDiagnostics { get; private set; } = null!;

        [Output("customData")]
        public Output<string> CustomData { get; private set; } = null!;

        [Output("dataDisks")]
        public Output<ImmutableArray<Outputs.StatefulNodeAzureDataDisk>> DataDisks { get; private set; } = null!;

        [Output("dataDisksPersistenceMode")]
        public Output<string> DataDisksPersistenceMode { get; private set; } = null!;

        [Output("deletes")]
        public Output<ImmutableArray<Outputs.StatefulNodeAzureDelete>> Deletes { get; private set; } = null!;

        [Output("description")]
        public Output<string> Description { get; private set; } = null!;

        [Output("detachDataDisks")]
        public Output<ImmutableArray<Outputs.StatefulNodeAzureDetachDataDisk>> DetachDataDisks { get; private set; } = null!;

        [Output("extensions")]
        public Output<ImmutableArray<Outputs.StatefulNodeAzureExtension>> Extensions { get; private set; } = null!;

        [Output("health")]
        public Output<Outputs.StatefulNodeAzureHealth> Health { get; private set; } = null!;

        [Output("image")]
        public Output<Outputs.StatefulNodeAzureImage?> Image { get; private set; } = null!;

        [Output("importVms")]
        public Output<ImmutableArray<Outputs.StatefulNodeAzureImportVm>> ImportVms { get; private set; } = null!;

        [Output("licenseType")]
        public Output<string?> LicenseType { get; private set; } = null!;

        [Output("loadBalancers")]
        public Output<ImmutableArray<Outputs.StatefulNodeAzureLoadBalancer>> LoadBalancers { get; private set; } = null!;

        [Output("login")]
        public Output<Outputs.StatefulNodeAzureLogin?> Login { get; private set; } = null!;

        [Output("managedServiceIdentities")]
        public Output<ImmutableArray<Outputs.StatefulNodeAzureManagedServiceIdentity>> ManagedServiceIdentities { get; private set; } = null!;

        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        [Output("network")]
        public Output<Outputs.StatefulNodeAzureNetwork?> Network { get; private set; } = null!;

        [Output("odSizes")]
        public Output<ImmutableArray<string>> OdSizes { get; private set; } = null!;

        [Output("os")]
        public Output<string> Os { get; private set; } = null!;

        [Output("osDisk")]
        public Output<Outputs.StatefulNodeAzureOsDisk?> OsDisk { get; private set; } = null!;

        [Output("osDiskPersistenceMode")]
        public Output<string> OsDiskPersistenceMode { get; private set; } = null!;

        [Output("preferredSpotSizes")]
        public Output<ImmutableArray<string>> PreferredSpotSizes { get; private set; } = null!;

        [Output("preferredZone")]
        public Output<string> PreferredZone { get; private set; } = null!;

        [Output("proximityPlacementGroups")]
        public Output<ImmutableArray<Outputs.StatefulNodeAzureProximityPlacementGroup>> ProximityPlacementGroups { get; private set; } = null!;

        [Output("region")]
        public Output<string> Region { get; private set; } = null!;

        [Output("resourceGroupName")]
        public Output<string> ResourceGroupName { get; private set; } = null!;

        [Output("schedulingTasks")]
        public Output<ImmutableArray<Outputs.StatefulNodeAzureSchedulingTask>> SchedulingTasks { get; private set; } = null!;

        [Output("secrets")]
        public Output<ImmutableArray<Outputs.StatefulNodeAzureSecret>> Secrets { get; private set; } = null!;

        [Output("security")]
        public Output<Outputs.StatefulNodeAzureSecurity?> Security { get; private set; } = null!;

        [Output("shouldPersistDataDisks")]
        public Output<bool> ShouldPersistDataDisks { get; private set; } = null!;

        [Output("shouldPersistNetwork")]
        public Output<bool> ShouldPersistNetwork { get; private set; } = null!;

        [Output("shouldPersistOsDisk")]
        public Output<bool> ShouldPersistOsDisk { get; private set; } = null!;

        [Output("shouldPersistVm")]
        public Output<bool> ShouldPersistVm { get; private set; } = null!;

        [Output("shutdownScript")]
        public Output<string> ShutdownScript { get; private set; } = null!;

        [Output("signals")]
        public Output<ImmutableArray<Outputs.StatefulNodeAzureSignal>> Signals { get; private set; } = null!;

        [Output("spotSizes")]
        public Output<ImmutableArray<string>> SpotSizes { get; private set; } = null!;

        [Output("strategy")]
        public Output<Outputs.StatefulNodeAzureStrategy> Strategy { get; private set; } = null!;

        [Output("tags")]
        public Output<ImmutableArray<Outputs.StatefulNodeAzureTag>> Tags { get; private set; } = null!;

        [Output("updateStates")]
        public Output<ImmutableArray<Outputs.StatefulNodeAzureUpdateState>> UpdateStates { get; private set; } = null!;

        [Output("userData")]
        public Output<string> UserData { get; private set; } = null!;

        [Output("vmName")]
        public Output<string?> VmName { get; private set; } = null!;

        [Output("vmNamePrefix")]
        public Output<string?> VmNamePrefix { get; private set; } = null!;

        [Output("zones")]
        public Output<ImmutableArray<string>> Zones { get; private set; } = null!;


        /// <summary>
        /// Create a StatefulNodeAzure resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public StatefulNodeAzure(string name, StatefulNodeAzureArgs args, CustomResourceOptions? options = null)
            : base("spotinst:index/statefulNodeAzure:StatefulNodeAzure", name, args ?? new StatefulNodeAzureArgs(), MakeResourceOptions(options, ""))
        {
        }

        private StatefulNodeAzure(string name, Input<string> id, StatefulNodeAzureState? state = null, CustomResourceOptions? options = null)
            : base("spotinst:index/statefulNodeAzure:StatefulNodeAzure", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing StatefulNodeAzure resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static StatefulNodeAzure Get(string name, Input<string> id, StatefulNodeAzureState? state = null, CustomResourceOptions? options = null)
        {
            return new StatefulNodeAzure(name, id, state, options);
        }
    }

    public sealed class StatefulNodeAzureArgs : global::Pulumi.ResourceArgs
    {
        [Input("attachDataDisks")]
        private InputList<Inputs.StatefulNodeAzureAttachDataDiskArgs>? _attachDataDisks;
        public InputList<Inputs.StatefulNodeAzureAttachDataDiskArgs> AttachDataDisks
        {
            get => _attachDataDisks ?? (_attachDataDisks = new InputList<Inputs.StatefulNodeAzureAttachDataDiskArgs>());
            set => _attachDataDisks = value;
        }

        [Input("bootDiagnostics")]
        private InputList<Inputs.StatefulNodeAzureBootDiagnosticArgs>? _bootDiagnostics;
        public InputList<Inputs.StatefulNodeAzureBootDiagnosticArgs> BootDiagnostics
        {
            get => _bootDiagnostics ?? (_bootDiagnostics = new InputList<Inputs.StatefulNodeAzureBootDiagnosticArgs>());
            set => _bootDiagnostics = value;
        }

        [Input("customData")]
        public Input<string>? CustomData { get; set; }

        [Input("dataDisks")]
        private InputList<Inputs.StatefulNodeAzureDataDiskArgs>? _dataDisks;
        public InputList<Inputs.StatefulNodeAzureDataDiskArgs> DataDisks
        {
            get => _dataDisks ?? (_dataDisks = new InputList<Inputs.StatefulNodeAzureDataDiskArgs>());
            set => _dataDisks = value;
        }

        [Input("dataDisksPersistenceMode")]
        public Input<string>? DataDisksPersistenceMode { get; set; }

        [Input("deletes")]
        private InputList<Inputs.StatefulNodeAzureDeleteArgs>? _deletes;
        public InputList<Inputs.StatefulNodeAzureDeleteArgs> Deletes
        {
            get => _deletes ?? (_deletes = new InputList<Inputs.StatefulNodeAzureDeleteArgs>());
            set => _deletes = value;
        }

        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("detachDataDisks")]
        private InputList<Inputs.StatefulNodeAzureDetachDataDiskArgs>? _detachDataDisks;
        public InputList<Inputs.StatefulNodeAzureDetachDataDiskArgs> DetachDataDisks
        {
            get => _detachDataDisks ?? (_detachDataDisks = new InputList<Inputs.StatefulNodeAzureDetachDataDiskArgs>());
            set => _detachDataDisks = value;
        }

        [Input("extensions")]
        private InputList<Inputs.StatefulNodeAzureExtensionArgs>? _extensions;
        public InputList<Inputs.StatefulNodeAzureExtensionArgs> Extensions
        {
            get => _extensions ?? (_extensions = new InputList<Inputs.StatefulNodeAzureExtensionArgs>());
            set => _extensions = value;
        }

        [Input("health")]
        public Input<Inputs.StatefulNodeAzureHealthArgs>? Health { get; set; }

        [Input("image")]
        public Input<Inputs.StatefulNodeAzureImageArgs>? Image { get; set; }

        [Input("importVms")]
        private InputList<Inputs.StatefulNodeAzureImportVmArgs>? _importVms;
        public InputList<Inputs.StatefulNodeAzureImportVmArgs> ImportVms
        {
            get => _importVms ?? (_importVms = new InputList<Inputs.StatefulNodeAzureImportVmArgs>());
            set => _importVms = value;
        }

        [Input("licenseType")]
        public Input<string>? LicenseType { get; set; }

        [Input("loadBalancers")]
        private InputList<Inputs.StatefulNodeAzureLoadBalancerArgs>? _loadBalancers;
        public InputList<Inputs.StatefulNodeAzureLoadBalancerArgs> LoadBalancers
        {
            get => _loadBalancers ?? (_loadBalancers = new InputList<Inputs.StatefulNodeAzureLoadBalancerArgs>());
            set => _loadBalancers = value;
        }

        [Input("login")]
        public Input<Inputs.StatefulNodeAzureLoginArgs>? Login { get; set; }

        [Input("managedServiceIdentities")]
        private InputList<Inputs.StatefulNodeAzureManagedServiceIdentityArgs>? _managedServiceIdentities;
        public InputList<Inputs.StatefulNodeAzureManagedServiceIdentityArgs> ManagedServiceIdentities
        {
            get => _managedServiceIdentities ?? (_managedServiceIdentities = new InputList<Inputs.StatefulNodeAzureManagedServiceIdentityArgs>());
            set => _managedServiceIdentities = value;
        }

        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("network")]
        public Input<Inputs.StatefulNodeAzureNetworkArgs>? Network { get; set; }

        [Input("odSizes", required: true)]
        private InputList<string>? _odSizes;
        public InputList<string> OdSizes
        {
            get => _odSizes ?? (_odSizes = new InputList<string>());
            set => _odSizes = value;
        }

        [Input("os", required: true)]
        public Input<string> Os { get; set; } = null!;

        [Input("osDisk")]
        public Input<Inputs.StatefulNodeAzureOsDiskArgs>? OsDisk { get; set; }

        [Input("osDiskPersistenceMode")]
        public Input<string>? OsDiskPersistenceMode { get; set; }

        [Input("preferredSpotSizes")]
        private InputList<string>? _preferredSpotSizes;
        public InputList<string> PreferredSpotSizes
        {
            get => _preferredSpotSizes ?? (_preferredSpotSizes = new InputList<string>());
            set => _preferredSpotSizes = value;
        }

        [Input("preferredZone")]
        public Input<string>? PreferredZone { get; set; }

        [Input("proximityPlacementGroups")]
        private InputList<Inputs.StatefulNodeAzureProximityPlacementGroupArgs>? _proximityPlacementGroups;
        public InputList<Inputs.StatefulNodeAzureProximityPlacementGroupArgs> ProximityPlacementGroups
        {
            get => _proximityPlacementGroups ?? (_proximityPlacementGroups = new InputList<Inputs.StatefulNodeAzureProximityPlacementGroupArgs>());
            set => _proximityPlacementGroups = value;
        }

        [Input("region", required: true)]
        public Input<string> Region { get; set; } = null!;

        [Input("resourceGroupName", required: true)]
        public Input<string> ResourceGroupName { get; set; } = null!;

        [Input("schedulingTasks")]
        private InputList<Inputs.StatefulNodeAzureSchedulingTaskArgs>? _schedulingTasks;
        public InputList<Inputs.StatefulNodeAzureSchedulingTaskArgs> SchedulingTasks
        {
            get => _schedulingTasks ?? (_schedulingTasks = new InputList<Inputs.StatefulNodeAzureSchedulingTaskArgs>());
            set => _schedulingTasks = value;
        }

        [Input("secrets")]
        private InputList<Inputs.StatefulNodeAzureSecretArgs>? _secrets;
        public InputList<Inputs.StatefulNodeAzureSecretArgs> Secrets
        {
            get => _secrets ?? (_secrets = new InputList<Inputs.StatefulNodeAzureSecretArgs>());
            set => _secrets = value;
        }

        [Input("security")]
        public Input<Inputs.StatefulNodeAzureSecurityArgs>? Security { get; set; }

        [Input("shouldPersistDataDisks", required: true)]
        public Input<bool> ShouldPersistDataDisks { get; set; } = null!;

        [Input("shouldPersistNetwork", required: true)]
        public Input<bool> ShouldPersistNetwork { get; set; } = null!;

        [Input("shouldPersistOsDisk", required: true)]
        public Input<bool> ShouldPersistOsDisk { get; set; } = null!;

        [Input("shouldPersistVm")]
        public Input<bool>? ShouldPersistVm { get; set; }

        [Input("shutdownScript")]
        public Input<string>? ShutdownScript { get; set; }

        [Input("signals")]
        private InputList<Inputs.StatefulNodeAzureSignalArgs>? _signals;
        public InputList<Inputs.StatefulNodeAzureSignalArgs> Signals
        {
            get => _signals ?? (_signals = new InputList<Inputs.StatefulNodeAzureSignalArgs>());
            set => _signals = value;
        }

        [Input("spotSizes", required: true)]
        private InputList<string>? _spotSizes;
        public InputList<string> SpotSizes
        {
            get => _spotSizes ?? (_spotSizes = new InputList<string>());
            set => _spotSizes = value;
        }

        [Input("strategy", required: true)]
        public Input<Inputs.StatefulNodeAzureStrategyArgs> Strategy { get; set; } = null!;

        [Input("tags")]
        private InputList<Inputs.StatefulNodeAzureTagArgs>? _tags;
        public InputList<Inputs.StatefulNodeAzureTagArgs> Tags
        {
            get => _tags ?? (_tags = new InputList<Inputs.StatefulNodeAzureTagArgs>());
            set => _tags = value;
        }

        [Input("updateStates")]
        private InputList<Inputs.StatefulNodeAzureUpdateStateArgs>? _updateStates;
        public InputList<Inputs.StatefulNodeAzureUpdateStateArgs> UpdateStates
        {
            get => _updateStates ?? (_updateStates = new InputList<Inputs.StatefulNodeAzureUpdateStateArgs>());
            set => _updateStates = value;
        }

        [Input("userData")]
        public Input<string>? UserData { get; set; }

        [Input("vmName")]
        public Input<string>? VmName { get; set; }

        [Input("vmNamePrefix")]
        public Input<string>? VmNamePrefix { get; set; }

        [Input("zones")]
        private InputList<string>? _zones;
        public InputList<string> Zones
        {
            get => _zones ?? (_zones = new InputList<string>());
            set => _zones = value;
        }

        public StatefulNodeAzureArgs()
        {
        }
        public static new StatefulNodeAzureArgs Empty => new StatefulNodeAzureArgs();
    }

    public sealed class StatefulNodeAzureState : global::Pulumi.ResourceArgs
    {
        [Input("attachDataDisks")]
        private InputList<Inputs.StatefulNodeAzureAttachDataDiskGetArgs>? _attachDataDisks;
        public InputList<Inputs.StatefulNodeAzureAttachDataDiskGetArgs> AttachDataDisks
        {
            get => _attachDataDisks ?? (_attachDataDisks = new InputList<Inputs.StatefulNodeAzureAttachDataDiskGetArgs>());
            set => _attachDataDisks = value;
        }

        [Input("bootDiagnostics")]
        private InputList<Inputs.StatefulNodeAzureBootDiagnosticGetArgs>? _bootDiagnostics;
        public InputList<Inputs.StatefulNodeAzureBootDiagnosticGetArgs> BootDiagnostics
        {
            get => _bootDiagnostics ?? (_bootDiagnostics = new InputList<Inputs.StatefulNodeAzureBootDiagnosticGetArgs>());
            set => _bootDiagnostics = value;
        }

        [Input("customData")]
        public Input<string>? CustomData { get; set; }

        [Input("dataDisks")]
        private InputList<Inputs.StatefulNodeAzureDataDiskGetArgs>? _dataDisks;
        public InputList<Inputs.StatefulNodeAzureDataDiskGetArgs> DataDisks
        {
            get => _dataDisks ?? (_dataDisks = new InputList<Inputs.StatefulNodeAzureDataDiskGetArgs>());
            set => _dataDisks = value;
        }

        [Input("dataDisksPersistenceMode")]
        public Input<string>? DataDisksPersistenceMode { get; set; }

        [Input("deletes")]
        private InputList<Inputs.StatefulNodeAzureDeleteGetArgs>? _deletes;
        public InputList<Inputs.StatefulNodeAzureDeleteGetArgs> Deletes
        {
            get => _deletes ?? (_deletes = new InputList<Inputs.StatefulNodeAzureDeleteGetArgs>());
            set => _deletes = value;
        }

        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("detachDataDisks")]
        private InputList<Inputs.StatefulNodeAzureDetachDataDiskGetArgs>? _detachDataDisks;
        public InputList<Inputs.StatefulNodeAzureDetachDataDiskGetArgs> DetachDataDisks
        {
            get => _detachDataDisks ?? (_detachDataDisks = new InputList<Inputs.StatefulNodeAzureDetachDataDiskGetArgs>());
            set => _detachDataDisks = value;
        }

        [Input("extensions")]
        private InputList<Inputs.StatefulNodeAzureExtensionGetArgs>? _extensions;
        public InputList<Inputs.StatefulNodeAzureExtensionGetArgs> Extensions
        {
            get => _extensions ?? (_extensions = new InputList<Inputs.StatefulNodeAzureExtensionGetArgs>());
            set => _extensions = value;
        }

        [Input("health")]
        public Input<Inputs.StatefulNodeAzureHealthGetArgs>? Health { get; set; }

        [Input("image")]
        public Input<Inputs.StatefulNodeAzureImageGetArgs>? Image { get; set; }

        [Input("importVms")]
        private InputList<Inputs.StatefulNodeAzureImportVmGetArgs>? _importVms;
        public InputList<Inputs.StatefulNodeAzureImportVmGetArgs> ImportVms
        {
            get => _importVms ?? (_importVms = new InputList<Inputs.StatefulNodeAzureImportVmGetArgs>());
            set => _importVms = value;
        }

        [Input("licenseType")]
        public Input<string>? LicenseType { get; set; }

        [Input("loadBalancers")]
        private InputList<Inputs.StatefulNodeAzureLoadBalancerGetArgs>? _loadBalancers;
        public InputList<Inputs.StatefulNodeAzureLoadBalancerGetArgs> LoadBalancers
        {
            get => _loadBalancers ?? (_loadBalancers = new InputList<Inputs.StatefulNodeAzureLoadBalancerGetArgs>());
            set => _loadBalancers = value;
        }

        [Input("login")]
        public Input<Inputs.StatefulNodeAzureLoginGetArgs>? Login { get; set; }

        [Input("managedServiceIdentities")]
        private InputList<Inputs.StatefulNodeAzureManagedServiceIdentityGetArgs>? _managedServiceIdentities;
        public InputList<Inputs.StatefulNodeAzureManagedServiceIdentityGetArgs> ManagedServiceIdentities
        {
            get => _managedServiceIdentities ?? (_managedServiceIdentities = new InputList<Inputs.StatefulNodeAzureManagedServiceIdentityGetArgs>());
            set => _managedServiceIdentities = value;
        }

        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("network")]
        public Input<Inputs.StatefulNodeAzureNetworkGetArgs>? Network { get; set; }

        [Input("odSizes")]
        private InputList<string>? _odSizes;
        public InputList<string> OdSizes
        {
            get => _odSizes ?? (_odSizes = new InputList<string>());
            set => _odSizes = value;
        }

        [Input("os")]
        public Input<string>? Os { get; set; }

        [Input("osDisk")]
        public Input<Inputs.StatefulNodeAzureOsDiskGetArgs>? OsDisk { get; set; }

        [Input("osDiskPersistenceMode")]
        public Input<string>? OsDiskPersistenceMode { get; set; }

        [Input("preferredSpotSizes")]
        private InputList<string>? _preferredSpotSizes;
        public InputList<string> PreferredSpotSizes
        {
            get => _preferredSpotSizes ?? (_preferredSpotSizes = new InputList<string>());
            set => _preferredSpotSizes = value;
        }

        [Input("preferredZone")]
        public Input<string>? PreferredZone { get; set; }

        [Input("proximityPlacementGroups")]
        private InputList<Inputs.StatefulNodeAzureProximityPlacementGroupGetArgs>? _proximityPlacementGroups;
        public InputList<Inputs.StatefulNodeAzureProximityPlacementGroupGetArgs> ProximityPlacementGroups
        {
            get => _proximityPlacementGroups ?? (_proximityPlacementGroups = new InputList<Inputs.StatefulNodeAzureProximityPlacementGroupGetArgs>());
            set => _proximityPlacementGroups = value;
        }

        [Input("region")]
        public Input<string>? Region { get; set; }

        [Input("resourceGroupName")]
        public Input<string>? ResourceGroupName { get; set; }

        [Input("schedulingTasks")]
        private InputList<Inputs.StatefulNodeAzureSchedulingTaskGetArgs>? _schedulingTasks;
        public InputList<Inputs.StatefulNodeAzureSchedulingTaskGetArgs> SchedulingTasks
        {
            get => _schedulingTasks ?? (_schedulingTasks = new InputList<Inputs.StatefulNodeAzureSchedulingTaskGetArgs>());
            set => _schedulingTasks = value;
        }

        [Input("secrets")]
        private InputList<Inputs.StatefulNodeAzureSecretGetArgs>? _secrets;
        public InputList<Inputs.StatefulNodeAzureSecretGetArgs> Secrets
        {
            get => _secrets ?? (_secrets = new InputList<Inputs.StatefulNodeAzureSecretGetArgs>());
            set => _secrets = value;
        }

        [Input("security")]
        public Input<Inputs.StatefulNodeAzureSecurityGetArgs>? Security { get; set; }

        [Input("shouldPersistDataDisks")]
        public Input<bool>? ShouldPersistDataDisks { get; set; }

        [Input("shouldPersistNetwork")]
        public Input<bool>? ShouldPersistNetwork { get; set; }

        [Input("shouldPersistOsDisk")]
        public Input<bool>? ShouldPersistOsDisk { get; set; }

        [Input("shouldPersistVm")]
        public Input<bool>? ShouldPersistVm { get; set; }

        [Input("shutdownScript")]
        public Input<string>? ShutdownScript { get; set; }

        [Input("signals")]
        private InputList<Inputs.StatefulNodeAzureSignalGetArgs>? _signals;
        public InputList<Inputs.StatefulNodeAzureSignalGetArgs> Signals
        {
            get => _signals ?? (_signals = new InputList<Inputs.StatefulNodeAzureSignalGetArgs>());
            set => _signals = value;
        }

        [Input("spotSizes")]
        private InputList<string>? _spotSizes;
        public InputList<string> SpotSizes
        {
            get => _spotSizes ?? (_spotSizes = new InputList<string>());
            set => _spotSizes = value;
        }

        [Input("strategy")]
        public Input<Inputs.StatefulNodeAzureStrategyGetArgs>? Strategy { get; set; }

        [Input("tags")]
        private InputList<Inputs.StatefulNodeAzureTagGetArgs>? _tags;
        public InputList<Inputs.StatefulNodeAzureTagGetArgs> Tags
        {
            get => _tags ?? (_tags = new InputList<Inputs.StatefulNodeAzureTagGetArgs>());
            set => _tags = value;
        }

        [Input("updateStates")]
        private InputList<Inputs.StatefulNodeAzureUpdateStateGetArgs>? _updateStates;
        public InputList<Inputs.StatefulNodeAzureUpdateStateGetArgs> UpdateStates
        {
            get => _updateStates ?? (_updateStates = new InputList<Inputs.StatefulNodeAzureUpdateStateGetArgs>());
            set => _updateStates = value;
        }

        [Input("userData")]
        public Input<string>? UserData { get; set; }

        [Input("vmName")]
        public Input<string>? VmName { get; set; }

        [Input("vmNamePrefix")]
        public Input<string>? VmNamePrefix { get; set; }

        [Input("zones")]
        private InputList<string>? _zones;
        public InputList<string> Zones
        {
            get => _zones ?? (_zones = new InputList<string>());
            set => _zones = value;
        }

        public StatefulNodeAzureState()
        {
        }
        public static new StatefulNodeAzureState Empty => new StatefulNodeAzureState();
    }
}
