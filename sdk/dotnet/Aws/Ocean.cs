// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.SpotInst.Aws
{
    /// <summary>
    /// Provides a Spotinst Ocean AWS resource.
    /// 
    /// 
    /// 
    /// &gt; This content is derived from https://github.com/terraform-providers/terraform-provider-spotinst/blob/master/website/docs/r/ocean_aws.html.markdown.
    /// </summary>
    public partial class Ocean : Pulumi.CustomResource
    {
        /// <summary>
        /// Configure public IP address allocation.
        /// </summary>
        [Output("associatePublicIpAddress")]
        public Output<bool?> AssociatePublicIpAddress { get; private set; } = null!;

        /// <summary>
        /// Describes the Ocean Kubernetes autoscaler.
        /// </summary>
        [Output("autoscaler")]
        public Output<Outputs.OceanAutoscaler?> Autoscaler { get; private set; } = null!;

        /// <summary>
        /// Instance types not allowed in the Ocean cluster. Cannot be configured if `whitelist` is configured.
        /// </summary>
        [Output("blacklists")]
        public Output<ImmutableArray<string>> Blacklists { get; private set; } = null!;

        /// <summary>
        /// The ocean cluster identifier. Example: `ocean.k8s`
        /// </summary>
        [Output("controllerId")]
        public Output<string?> ControllerId { get; private set; } = null!;

        /// <summary>
        /// The number of instances to launch and maintain in the cluster.
        /// </summary>
        [Output("desiredCapacity")]
        public Output<int> DesiredCapacity { get; private set; } = null!;

        /// <summary>
        /// The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
        /// </summary>
        [Output("drainingTimeout")]
        public Output<int?> DrainingTimeout { get; private set; } = null!;

        /// <summary>
        /// Enable EBS optimized for cluster. Flag will enable optimized capacity for high bandwidth connectivity to the EB service for non EBS optimized instance types. For instances that are EBS optimized this flag will be ignored.
        /// </summary>
        [Output("ebsOptimized")]
        public Output<bool?> EbsOptimized { get; private set; } = null!;

        /// <summary>
        /// If not Spot instance markets are available, enable Ocean to launch On-Demand instances instead.
        /// </summary>
        [Output("fallbackToOndemand")]
        public Output<bool?> FallbackToOndemand { get; private set; } = null!;

        /// <summary>
        /// The amount of time, in seconds, after the instance has launched to start checking its health.
        /// </summary>
        [Output("gracePeriod")]
        public Output<int?> GracePeriod { get; private set; } = null!;

        /// <summary>
        /// The instance profile iam role.
        /// </summary>
        [Output("iamInstanceProfile")]
        public Output<string?> IamInstanceProfile { get; private set; } = null!;

        /// <summary>
        /// ID of the image used to launch the instances.
        /// </summary>
        [Output("imageId")]
        public Output<string?> ImageId { get; private set; } = null!;

        /// <summary>
        /// The key pair to attach the instances.
        /// </summary>
        [Output("keyName")]
        public Output<string?> KeyName { get; private set; } = null!;

        /// <summary>
        /// - Array of load balancer objects to add to ocean cluster
        /// </summary>
        [Output("loadBalancers")]
        public Output<ImmutableArray<Outputs.OceanLoadBalancers>> LoadBalancers { get; private set; } = null!;

        /// <summary>
        /// The upper limit of instances the cluster can scale up to.
        /// </summary>
        [Output("maxSize")]
        public Output<int> MaxSize { get; private set; } = null!;

        /// <summary>
        /// The lower limit of instances the cluster can scale down to.
        /// </summary>
        [Output("minSize")]
        public Output<int> MinSize { get; private set; } = null!;

        /// <summary>
        /// Enable detailed monitoring for cluster. Flag will enable Cloud Watch detailed detailed monitoring (one minute increments). Note: there are additional hourly costs for this service based on the region used.
        /// </summary>
        [Output("monitoring")]
        public Output<bool?> Monitoring { get; private set; } = null!;

        /// <summary>
        /// Required if type is set to CLASSIC
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The region the cluster will run in.
        /// </summary>
        [Output("region")]
        public Output<string?> Region { get; private set; } = null!;

        /// <summary>
        /// The size (in Gb) to allocate for the root volume. Minimum `20`.
        /// </summary>
        [Output("rootVolumeSize")]
        public Output<int?> RootVolumeSize { get; private set; } = null!;

        [Output("scheduledTasks")]
        public Output<ImmutableArray<Outputs.OceanScheduledTasks>> ScheduledTasks { get; private set; } = null!;

        /// <summary>
        /// One or more security group ids.
        /// </summary>
        [Output("securityGroups")]
        public Output<ImmutableArray<string>> SecurityGroups { get; private set; } = null!;

        [Output("spotPercentage")]
        public Output<double?> SpotPercentage { get; private set; } = null!;

        /// <summary>
        /// A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public ip.
        /// </summary>
        [Output("subnetIds")]
        public Output<ImmutableArray<string>> SubnetIds { get; private set; } = null!;

        /// <summary>
        /// Optionally adds tags to instances launched in an Ocean cluster.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<Outputs.OceanTags>> Tags { get; private set; } = null!;

        [Output("updatePolicy")]
        public Output<Outputs.OceanUpdatePolicy?> UpdatePolicy { get; private set; } = null!;

        /// <summary>
        /// Base64-encoded MIME user data to make available to the instances.
        /// </summary>
        [Output("userData")]
        public Output<string?> UserData { get; private set; } = null!;

        /// <summary>
        /// If Reserved instances exist, OCean will utilize them before launching Spot instances.
        /// </summary>
        [Output("utilizeReservedInstances")]
        public Output<bool?> UtilizeReservedInstances { get; private set; } = null!;

        /// <summary>
        /// Instance types allowed in the Ocean cluster. Cannot be configured if `blacklist` is configured.
        /// </summary>
        [Output("whitelists")]
        public Output<ImmutableArray<string>> Whitelists { get; private set; } = null!;


        /// <summary>
        /// Create a Ocean resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Ocean(string name, OceanArgs args, CustomResourceOptions? options = null)
            : base("spotinst:aws/ocean:Ocean", name, args ?? ResourceArgs.Empty, MakeResourceOptions(options, ""))
        {
        }

        private Ocean(string name, Input<string> id, OceanState? state = null, CustomResourceOptions? options = null)
            : base("spotinst:aws/ocean:Ocean", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Ocean resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Ocean Get(string name, Input<string> id, OceanState? state = null, CustomResourceOptions? options = null)
        {
            return new Ocean(name, id, state, options);
        }
    }

    public sealed class OceanArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Configure public IP address allocation.
        /// </summary>
        [Input("associatePublicIpAddress")]
        public Input<bool>? AssociatePublicIpAddress { get; set; }

        /// <summary>
        /// Describes the Ocean Kubernetes autoscaler.
        /// </summary>
        [Input("autoscaler")]
        public Input<Inputs.OceanAutoscalerArgs>? Autoscaler { get; set; }

        [Input("blacklists")]
        private InputList<string>? _blacklists;

        /// <summary>
        /// Instance types not allowed in the Ocean cluster. Cannot be configured if `whitelist` is configured.
        /// </summary>
        public InputList<string> Blacklists
        {
            get => _blacklists ?? (_blacklists = new InputList<string>());
            set => _blacklists = value;
        }

        /// <summary>
        /// The ocean cluster identifier. Example: `ocean.k8s`
        /// </summary>
        [Input("controllerId")]
        public Input<string>? ControllerId { get; set; }

        /// <summary>
        /// The number of instances to launch and maintain in the cluster.
        /// </summary>
        [Input("desiredCapacity")]
        public Input<int>? DesiredCapacity { get; set; }

        /// <summary>
        /// The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
        /// </summary>
        [Input("drainingTimeout")]
        public Input<int>? DrainingTimeout { get; set; }

        /// <summary>
        /// Enable EBS optimized for cluster. Flag will enable optimized capacity for high bandwidth connectivity to the EB service for non EBS optimized instance types. For instances that are EBS optimized this flag will be ignored.
        /// </summary>
        [Input("ebsOptimized")]
        public Input<bool>? EbsOptimized { get; set; }

        /// <summary>
        /// If not Spot instance markets are available, enable Ocean to launch On-Demand instances instead.
        /// </summary>
        [Input("fallbackToOndemand")]
        public Input<bool>? FallbackToOndemand { get; set; }

        /// <summary>
        /// The amount of time, in seconds, after the instance has launched to start checking its health.
        /// </summary>
        [Input("gracePeriod")]
        public Input<int>? GracePeriod { get; set; }

        /// <summary>
        /// The instance profile iam role.
        /// </summary>
        [Input("iamInstanceProfile")]
        public Input<string>? IamInstanceProfile { get; set; }

        /// <summary>
        /// ID of the image used to launch the instances.
        /// </summary>
        [Input("imageId")]
        public Input<string>? ImageId { get; set; }

        /// <summary>
        /// The key pair to attach the instances.
        /// </summary>
        [Input("keyName")]
        public Input<string>? KeyName { get; set; }

        [Input("loadBalancers")]
        private InputList<Inputs.OceanLoadBalancersArgs>? _loadBalancers;

        /// <summary>
        /// - Array of load balancer objects to add to ocean cluster
        /// </summary>
        public InputList<Inputs.OceanLoadBalancersArgs> LoadBalancers
        {
            get => _loadBalancers ?? (_loadBalancers = new InputList<Inputs.OceanLoadBalancersArgs>());
            set => _loadBalancers = value;
        }

        /// <summary>
        /// The upper limit of instances the cluster can scale up to.
        /// </summary>
        [Input("maxSize")]
        public Input<int>? MaxSize { get; set; }

        /// <summary>
        /// The lower limit of instances the cluster can scale down to.
        /// </summary>
        [Input("minSize")]
        public Input<int>? MinSize { get; set; }

        /// <summary>
        /// Enable detailed monitoring for cluster. Flag will enable Cloud Watch detailed detailed monitoring (one minute increments). Note: there are additional hourly costs for this service based on the region used.
        /// </summary>
        [Input("monitoring")]
        public Input<bool>? Monitoring { get; set; }

        /// <summary>
        /// Required if type is set to CLASSIC
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The region the cluster will run in.
        /// </summary>
        [Input("region")]
        public Input<string>? Region { get; set; }

        /// <summary>
        /// The size (in Gb) to allocate for the root volume. Minimum `20`.
        /// </summary>
        [Input("rootVolumeSize")]
        public Input<int>? RootVolumeSize { get; set; }

        [Input("scheduledTasks")]
        private InputList<Inputs.OceanScheduledTasksArgs>? _scheduledTasks;
        public InputList<Inputs.OceanScheduledTasksArgs> ScheduledTasks
        {
            get => _scheduledTasks ?? (_scheduledTasks = new InputList<Inputs.OceanScheduledTasksArgs>());
            set => _scheduledTasks = value;
        }

        [Input("securityGroups", required: true)]
        private InputList<string>? _securityGroups;

        /// <summary>
        /// One or more security group ids.
        /// </summary>
        public InputList<string> SecurityGroups
        {
            get => _securityGroups ?? (_securityGroups = new InputList<string>());
            set => _securityGroups = value;
        }

        [Input("spotPercentage")]
        public Input<double>? SpotPercentage { get; set; }

        [Input("subnetIds", required: true)]
        private InputList<string>? _subnetIds;

        /// <summary>
        /// A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public ip.
        /// </summary>
        public InputList<string> SubnetIds
        {
            get => _subnetIds ?? (_subnetIds = new InputList<string>());
            set => _subnetIds = value;
        }

        [Input("tags")]
        private InputList<Inputs.OceanTagsArgs>? _tags;

        /// <summary>
        /// Optionally adds tags to instances launched in an Ocean cluster.
        /// </summary>
        public InputList<Inputs.OceanTagsArgs> Tags
        {
            get => _tags ?? (_tags = new InputList<Inputs.OceanTagsArgs>());
            set => _tags = value;
        }

        [Input("updatePolicy")]
        public Input<Inputs.OceanUpdatePolicyArgs>? UpdatePolicy { get; set; }

        /// <summary>
        /// Base64-encoded MIME user data to make available to the instances.
        /// </summary>
        [Input("userData")]
        public Input<string>? UserData { get; set; }

        /// <summary>
        /// If Reserved instances exist, OCean will utilize them before launching Spot instances.
        /// </summary>
        [Input("utilizeReservedInstances")]
        public Input<bool>? UtilizeReservedInstances { get; set; }

        [Input("whitelists")]
        private InputList<string>? _whitelists;

        /// <summary>
        /// Instance types allowed in the Ocean cluster. Cannot be configured if `blacklist` is configured.
        /// </summary>
        public InputList<string> Whitelists
        {
            get => _whitelists ?? (_whitelists = new InputList<string>());
            set => _whitelists = value;
        }

        public OceanArgs()
        {
        }
    }

    public sealed class OceanState : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Configure public IP address allocation.
        /// </summary>
        [Input("associatePublicIpAddress")]
        public Input<bool>? AssociatePublicIpAddress { get; set; }

        /// <summary>
        /// Describes the Ocean Kubernetes autoscaler.
        /// </summary>
        [Input("autoscaler")]
        public Input<Inputs.OceanAutoscalerGetArgs>? Autoscaler { get; set; }

        [Input("blacklists")]
        private InputList<string>? _blacklists;

        /// <summary>
        /// Instance types not allowed in the Ocean cluster. Cannot be configured if `whitelist` is configured.
        /// </summary>
        public InputList<string> Blacklists
        {
            get => _blacklists ?? (_blacklists = new InputList<string>());
            set => _blacklists = value;
        }

        /// <summary>
        /// The ocean cluster identifier. Example: `ocean.k8s`
        /// </summary>
        [Input("controllerId")]
        public Input<string>? ControllerId { get; set; }

        /// <summary>
        /// The number of instances to launch and maintain in the cluster.
        /// </summary>
        [Input("desiredCapacity")]
        public Input<int>? DesiredCapacity { get; set; }

        /// <summary>
        /// The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
        /// </summary>
        [Input("drainingTimeout")]
        public Input<int>? DrainingTimeout { get; set; }

        /// <summary>
        /// Enable EBS optimized for cluster. Flag will enable optimized capacity for high bandwidth connectivity to the EB service for non EBS optimized instance types. For instances that are EBS optimized this flag will be ignored.
        /// </summary>
        [Input("ebsOptimized")]
        public Input<bool>? EbsOptimized { get; set; }

        /// <summary>
        /// If not Spot instance markets are available, enable Ocean to launch On-Demand instances instead.
        /// </summary>
        [Input("fallbackToOndemand")]
        public Input<bool>? FallbackToOndemand { get; set; }

        /// <summary>
        /// The amount of time, in seconds, after the instance has launched to start checking its health.
        /// </summary>
        [Input("gracePeriod")]
        public Input<int>? GracePeriod { get; set; }

        /// <summary>
        /// The instance profile iam role.
        /// </summary>
        [Input("iamInstanceProfile")]
        public Input<string>? IamInstanceProfile { get; set; }

        /// <summary>
        /// ID of the image used to launch the instances.
        /// </summary>
        [Input("imageId")]
        public Input<string>? ImageId { get; set; }

        /// <summary>
        /// The key pair to attach the instances.
        /// </summary>
        [Input("keyName")]
        public Input<string>? KeyName { get; set; }

        [Input("loadBalancers")]
        private InputList<Inputs.OceanLoadBalancersGetArgs>? _loadBalancers;

        /// <summary>
        /// - Array of load balancer objects to add to ocean cluster
        /// </summary>
        public InputList<Inputs.OceanLoadBalancersGetArgs> LoadBalancers
        {
            get => _loadBalancers ?? (_loadBalancers = new InputList<Inputs.OceanLoadBalancersGetArgs>());
            set => _loadBalancers = value;
        }

        /// <summary>
        /// The upper limit of instances the cluster can scale up to.
        /// </summary>
        [Input("maxSize")]
        public Input<int>? MaxSize { get; set; }

        /// <summary>
        /// The lower limit of instances the cluster can scale down to.
        /// </summary>
        [Input("minSize")]
        public Input<int>? MinSize { get; set; }

        /// <summary>
        /// Enable detailed monitoring for cluster. Flag will enable Cloud Watch detailed detailed monitoring (one minute increments). Note: there are additional hourly costs for this service based on the region used.
        /// </summary>
        [Input("monitoring")]
        public Input<bool>? Monitoring { get; set; }

        /// <summary>
        /// Required if type is set to CLASSIC
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The region the cluster will run in.
        /// </summary>
        [Input("region")]
        public Input<string>? Region { get; set; }

        /// <summary>
        /// The size (in Gb) to allocate for the root volume. Minimum `20`.
        /// </summary>
        [Input("rootVolumeSize")]
        public Input<int>? RootVolumeSize { get; set; }

        [Input("scheduledTasks")]
        private InputList<Inputs.OceanScheduledTasksGetArgs>? _scheduledTasks;
        public InputList<Inputs.OceanScheduledTasksGetArgs> ScheduledTasks
        {
            get => _scheduledTasks ?? (_scheduledTasks = new InputList<Inputs.OceanScheduledTasksGetArgs>());
            set => _scheduledTasks = value;
        }

        [Input("securityGroups")]
        private InputList<string>? _securityGroups;

        /// <summary>
        /// One or more security group ids.
        /// </summary>
        public InputList<string> SecurityGroups
        {
            get => _securityGroups ?? (_securityGroups = new InputList<string>());
            set => _securityGroups = value;
        }

        [Input("spotPercentage")]
        public Input<double>? SpotPercentage { get; set; }

        [Input("subnetIds")]
        private InputList<string>? _subnetIds;

        /// <summary>
        /// A comma-separated list of subnet identifiers for the Ocean cluster. Subnet IDs should be configured with auto assign public ip.
        /// </summary>
        public InputList<string> SubnetIds
        {
            get => _subnetIds ?? (_subnetIds = new InputList<string>());
            set => _subnetIds = value;
        }

        [Input("tags")]
        private InputList<Inputs.OceanTagsGetArgs>? _tags;

        /// <summary>
        /// Optionally adds tags to instances launched in an Ocean cluster.
        /// </summary>
        public InputList<Inputs.OceanTagsGetArgs> Tags
        {
            get => _tags ?? (_tags = new InputList<Inputs.OceanTagsGetArgs>());
            set => _tags = value;
        }

        [Input("updatePolicy")]
        public Input<Inputs.OceanUpdatePolicyGetArgs>? UpdatePolicy { get; set; }

        /// <summary>
        /// Base64-encoded MIME user data to make available to the instances.
        /// </summary>
        [Input("userData")]
        public Input<string>? UserData { get; set; }

        /// <summary>
        /// If Reserved instances exist, OCean will utilize them before launching Spot instances.
        /// </summary>
        [Input("utilizeReservedInstances")]
        public Input<bool>? UtilizeReservedInstances { get; set; }

        [Input("whitelists")]
        private InputList<string>? _whitelists;

        /// <summary>
        /// Instance types allowed in the Ocean cluster. Cannot be configured if `blacklist` is configured.
        /// </summary>
        public InputList<string> Whitelists
        {
            get => _whitelists ?? (_whitelists = new InputList<string>());
            set => _whitelists = value;
        }

        public OceanState()
        {
        }
    }

    namespace Inputs
    {

    public sealed class OceanAutoscalerArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Set the auto headroom percentage (a number in the range [0, 200]) which controls the percentage of headroom from the cluster. Relevant only when `isAutoConfig` toggled on.
        /// </summary>
        [Input("autoHeadroomPercentage")]
        public Input<int>? AutoHeadroomPercentage { get; set; }

        /// <summary>
        /// Cooldown period between scaling actions.
        /// </summary>
        [Input("autoscaleCooldown")]
        public Input<int>? AutoscaleCooldown { get; set; }

        /// <summary>
        /// Auto Scaling scale down operations.
        /// </summary>
        [Input("autoscaleDown")]
        public Input<OceanAutoscalerAutoscaleDownArgs>? AutoscaleDown { get; set; }

        /// <summary>
        /// Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
        /// </summary>
        [Input("autoscaleHeadroom")]
        public Input<OceanAutoscalerAutoscaleHeadroomArgs>? AutoscaleHeadroom { get; set; }

        /// <summary>
        /// Automatically configure and optimize headroom resources.
        /// </summary>
        [Input("autoscaleIsAutoConfig")]
        public Input<bool>? AutoscaleIsAutoConfig { get; set; }

        /// <summary>
        /// Enable the Ocean Kubernetes autoscaler.
        /// </summary>
        [Input("autoscaleIsEnabled")]
        public Input<bool>? AutoscaleIsEnabled { get; set; }

        /// <summary>
        /// Optionally set upper and lower bounds on the resource usage of the cluster.
        /// </summary>
        [Input("resourceLimits")]
        public Input<OceanAutoscalerResourceLimitsArgs>? ResourceLimits { get; set; }

        public OceanAutoscalerArgs()
        {
        }
    }

    public sealed class OceanAutoscalerAutoscaleDownArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The number of evaluation periods that should accumulate before a scale down action takes place.
        /// </summary>
        [Input("evaluationPeriods")]
        public Input<int>? EvaluationPeriods { get; set; }

        /// <summary>
        /// Would represent the maximum % to scale-down. Number between 1-100.
        /// </summary>
        [Input("maxScaleDownPercentage")]
        public Input<int>? MaxScaleDownPercentage { get; set; }

        public OceanAutoscalerAutoscaleDownArgs()
        {
        }
    }

    public sealed class OceanAutoscalerAutoscaleDownGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The number of evaluation periods that should accumulate before a scale down action takes place.
        /// </summary>
        [Input("evaluationPeriods")]
        public Input<int>? EvaluationPeriods { get; set; }

        /// <summary>
        /// Would represent the maximum % to scale-down. Number between 1-100.
        /// </summary>
        [Input("maxScaleDownPercentage")]
        public Input<int>? MaxScaleDownPercentage { get; set; }

        public OceanAutoscalerAutoscaleDownGetArgs()
        {
        }
    }

    public sealed class OceanAutoscalerAutoscaleHeadroomArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        /// </summary>
        [Input("cpuPerUnit")]
        public Input<int>? CpuPerUnit { get; set; }

        /// <summary>
        /// Optionally configure the number of GPUS to allocate the headroom.
        /// </summary>
        [Input("gpuPerUnit")]
        public Input<int>? GpuPerUnit { get; set; }

        /// <summary>
        /// Optionally configure the amount of memory (MB) to allocate the headroom.
        /// </summary>
        [Input("memoryPerUnit")]
        public Input<int>? MemoryPerUnit { get; set; }

        /// <summary>
        /// The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        /// </summary>
        [Input("numOfUnits")]
        public Input<int>? NumOfUnits { get; set; }

        public OceanAutoscalerAutoscaleHeadroomArgs()
        {
        }
    }

    public sealed class OceanAutoscalerAutoscaleHeadroomGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        /// </summary>
        [Input("cpuPerUnit")]
        public Input<int>? CpuPerUnit { get; set; }

        /// <summary>
        /// Optionally configure the number of GPUS to allocate the headroom.
        /// </summary>
        [Input("gpuPerUnit")]
        public Input<int>? GpuPerUnit { get; set; }

        /// <summary>
        /// Optionally configure the amount of memory (MB) to allocate the headroom.
        /// </summary>
        [Input("memoryPerUnit")]
        public Input<int>? MemoryPerUnit { get; set; }

        /// <summary>
        /// The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        /// </summary>
        [Input("numOfUnits")]
        public Input<int>? NumOfUnits { get; set; }

        public OceanAutoscalerAutoscaleHeadroomGetArgs()
        {
        }
    }

    public sealed class OceanAutoscalerGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Set the auto headroom percentage (a number in the range [0, 200]) which controls the percentage of headroom from the cluster. Relevant only when `isAutoConfig` toggled on.
        /// </summary>
        [Input("autoHeadroomPercentage")]
        public Input<int>? AutoHeadroomPercentage { get; set; }

        /// <summary>
        /// Cooldown period between scaling actions.
        /// </summary>
        [Input("autoscaleCooldown")]
        public Input<int>? AutoscaleCooldown { get; set; }

        /// <summary>
        /// Auto Scaling scale down operations.
        /// </summary>
        [Input("autoscaleDown")]
        public Input<OceanAutoscalerAutoscaleDownGetArgs>? AutoscaleDown { get; set; }

        /// <summary>
        /// Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
        /// </summary>
        [Input("autoscaleHeadroom")]
        public Input<OceanAutoscalerAutoscaleHeadroomGetArgs>? AutoscaleHeadroom { get; set; }

        /// <summary>
        /// Automatically configure and optimize headroom resources.
        /// </summary>
        [Input("autoscaleIsAutoConfig")]
        public Input<bool>? AutoscaleIsAutoConfig { get; set; }

        /// <summary>
        /// Enable the Ocean Kubernetes autoscaler.
        /// </summary>
        [Input("autoscaleIsEnabled")]
        public Input<bool>? AutoscaleIsEnabled { get; set; }

        /// <summary>
        /// Optionally set upper and lower bounds on the resource usage of the cluster.
        /// </summary>
        [Input("resourceLimits")]
        public Input<OceanAutoscalerResourceLimitsGetArgs>? ResourceLimits { get; set; }

        public OceanAutoscalerGetArgs()
        {
        }
    }

    public sealed class OceanAutoscalerResourceLimitsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The maximum memory in GiB units that can be allocated to the cluster.
        /// </summary>
        [Input("maxMemoryGib")]
        public Input<int>? MaxMemoryGib { get; set; }

        /// <summary>
        /// The maximum cpu in vCPU units that can be allocated to the cluster.
        /// </summary>
        [Input("maxVcpu")]
        public Input<int>? MaxVcpu { get; set; }

        public OceanAutoscalerResourceLimitsArgs()
        {
        }
    }

    public sealed class OceanAutoscalerResourceLimitsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The maximum memory in GiB units that can be allocated to the cluster.
        /// </summary>
        [Input("maxMemoryGib")]
        public Input<int>? MaxMemoryGib { get; set; }

        /// <summary>
        /// The maximum cpu in vCPU units that can be allocated to the cluster.
        /// </summary>
        [Input("maxVcpu")]
        public Input<int>? MaxVcpu { get; set; }

        public OceanAutoscalerResourceLimitsGetArgs()
        {
        }
    }

    public sealed class OceanLoadBalancersArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Required if type is set to TARGET_GROUP
        /// </summary>
        [Input("arn")]
        public Input<string>? Arn { get; set; }

        /// <summary>
        /// Required if type is set to CLASSIC
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Can be set to CLASSIC or TARGET_GROUP
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        public OceanLoadBalancersArgs()
        {
        }
    }

    public sealed class OceanLoadBalancersGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// Required if type is set to TARGET_GROUP
        /// </summary>
        [Input("arn")]
        public Input<string>? Arn { get; set; }

        /// <summary>
        /// Required if type is set to CLASSIC
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Can be set to CLASSIC or TARGET_GROUP
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        public OceanLoadBalancersGetArgs()
        {
        }
    }

    public sealed class OceanScheduledTasksArgs : Pulumi.ResourceArgs
    {
        [Input("shutdownHours")]
        public Input<OceanScheduledTasksShutdownHoursArgs>? ShutdownHours { get; set; }

        [Input("tasks")]
        private InputList<OceanScheduledTasksTasksArgs>? _tasks;
        public InputList<OceanScheduledTasksTasksArgs> Tasks
        {
            get => _tasks ?? (_tasks = new InputList<OceanScheduledTasksTasksArgs>());
            set => _tasks = value;
        }

        public OceanScheduledTasksArgs()
        {
        }
    }

    public sealed class OceanScheduledTasksGetArgs : Pulumi.ResourceArgs
    {
        [Input("shutdownHours")]
        public Input<OceanScheduledTasksShutdownHoursGetArgs>? ShutdownHours { get; set; }

        [Input("tasks")]
        private InputList<OceanScheduledTasksTasksGetArgs>? _tasks;
        public InputList<OceanScheduledTasksTasksGetArgs> Tasks
        {
            get => _tasks ?? (_tasks = new InputList<OceanScheduledTasksTasksGetArgs>());
            set => _tasks = value;
        }

        public OceanScheduledTasksGetArgs()
        {
        }
    }

    public sealed class OceanScheduledTasksShutdownHoursArgs : Pulumi.ResourceArgs
    {
        [Input("isEnabled")]
        public Input<bool>? IsEnabled { get; set; }

        [Input("timeWindows", required: true)]
        private InputList<string>? _timeWindows;
        public InputList<string> TimeWindows
        {
            get => _timeWindows ?? (_timeWindows = new InputList<string>());
            set => _timeWindows = value;
        }

        public OceanScheduledTasksShutdownHoursArgs()
        {
        }
    }

    public sealed class OceanScheduledTasksShutdownHoursGetArgs : Pulumi.ResourceArgs
    {
        [Input("isEnabled")]
        public Input<bool>? IsEnabled { get; set; }

        [Input("timeWindows", required: true)]
        private InputList<string>? _timeWindows;
        public InputList<string> TimeWindows
        {
            get => _timeWindows ?? (_timeWindows = new InputList<string>());
            set => _timeWindows = value;
        }

        public OceanScheduledTasksShutdownHoursGetArgs()
        {
        }
    }

    public sealed class OceanScheduledTasksTasksArgs : Pulumi.ResourceArgs
    {
        [Input("cronExpression", required: true)]
        public Input<string> CronExpression { get; set; } = null!;

        [Input("isEnabled", required: true)]
        public Input<bool> IsEnabled { get; set; } = null!;

        [Input("taskType", required: true)]
        public Input<string> TaskType { get; set; } = null!;

        public OceanScheduledTasksTasksArgs()
        {
        }
    }

    public sealed class OceanScheduledTasksTasksGetArgs : Pulumi.ResourceArgs
    {
        [Input("cronExpression", required: true)]
        public Input<string> CronExpression { get; set; } = null!;

        [Input("isEnabled", required: true)]
        public Input<bool> IsEnabled { get; set; } = null!;

        [Input("taskType", required: true)]
        public Input<string> TaskType { get; set; } = null!;

        public OceanScheduledTasksTasksGetArgs()
        {
        }
    }

    public sealed class OceanTagsArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The tag key.
        /// </summary>
        [Input("key", required: true)]
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// The tag value.
        /// </summary>
        [Input("value", required: true)]
        public Input<string> Value { get; set; } = null!;

        public OceanTagsArgs()
        {
        }
    }

    public sealed class OceanTagsGetArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// The tag key.
        /// </summary>
        [Input("key", required: true)]
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// The tag value.
        /// </summary>
        [Input("value", required: true)]
        public Input<string> Value { get; set; } = null!;

        public OceanTagsGetArgs()
        {
        }
    }

    public sealed class OceanUpdatePolicyArgs : Pulumi.ResourceArgs
    {
        [Input("rollConfig")]
        public Input<OceanUpdatePolicyRollConfigArgs>? RollConfig { get; set; }

        [Input("shouldRoll", required: true)]
        public Input<bool> ShouldRoll { get; set; } = null!;

        public OceanUpdatePolicyArgs()
        {
        }
    }

    public sealed class OceanUpdatePolicyGetArgs : Pulumi.ResourceArgs
    {
        [Input("rollConfig")]
        public Input<OceanUpdatePolicyRollConfigGetArgs>? RollConfig { get; set; }

        [Input("shouldRoll", required: true)]
        public Input<bool> ShouldRoll { get; set; } = null!;

        public OceanUpdatePolicyGetArgs()
        {
        }
    }

    public sealed class OceanUpdatePolicyRollConfigArgs : Pulumi.ResourceArgs
    {
        [Input("batchSizePercentage", required: true)]
        public Input<int> BatchSizePercentage { get; set; } = null!;

        public OceanUpdatePolicyRollConfigArgs()
        {
        }
    }

    public sealed class OceanUpdatePolicyRollConfigGetArgs : Pulumi.ResourceArgs
    {
        [Input("batchSizePercentage", required: true)]
        public Input<int> BatchSizePercentage { get; set; } = null!;

        public OceanUpdatePolicyRollConfigGetArgs()
        {
        }
    }
    }

    namespace Outputs
    {

    [OutputType]
    public sealed class OceanAutoscaler
    {
        /// <summary>
        /// Set the auto headroom percentage (a number in the range [0, 200]) which controls the percentage of headroom from the cluster. Relevant only when `isAutoConfig` toggled on.
        /// </summary>
        public readonly int? AutoHeadroomPercentage;
        /// <summary>
        /// Cooldown period between scaling actions.
        /// </summary>
        public readonly int? AutoscaleCooldown;
        /// <summary>
        /// Auto Scaling scale down operations.
        /// </summary>
        public readonly OceanAutoscalerAutoscaleDown? AutoscaleDown;
        /// <summary>
        /// Spare resource capacity management enabling fast assignment of Pods without waiting for new resources to launch.
        /// </summary>
        public readonly OceanAutoscalerAutoscaleHeadroom? AutoscaleHeadroom;
        /// <summary>
        /// Automatically configure and optimize headroom resources.
        /// </summary>
        public readonly bool? AutoscaleIsAutoConfig;
        /// <summary>
        /// Enable the Ocean Kubernetes autoscaler.
        /// </summary>
        public readonly bool? AutoscaleIsEnabled;
        /// <summary>
        /// Optionally set upper and lower bounds on the resource usage of the cluster.
        /// </summary>
        public readonly OceanAutoscalerResourceLimits? ResourceLimits;

        [OutputConstructor]
        private OceanAutoscaler(
            int? autoHeadroomPercentage,
            int? autoscaleCooldown,
            OceanAutoscalerAutoscaleDown? autoscaleDown,
            OceanAutoscalerAutoscaleHeadroom? autoscaleHeadroom,
            bool? autoscaleIsAutoConfig,
            bool? autoscaleIsEnabled,
            OceanAutoscalerResourceLimits? resourceLimits)
        {
            AutoHeadroomPercentage = autoHeadroomPercentage;
            AutoscaleCooldown = autoscaleCooldown;
            AutoscaleDown = autoscaleDown;
            AutoscaleHeadroom = autoscaleHeadroom;
            AutoscaleIsAutoConfig = autoscaleIsAutoConfig;
            AutoscaleIsEnabled = autoscaleIsEnabled;
            ResourceLimits = resourceLimits;
        }
    }

    [OutputType]
    public sealed class OceanAutoscalerAutoscaleDown
    {
        /// <summary>
        /// The number of evaluation periods that should accumulate before a scale down action takes place.
        /// </summary>
        public readonly int? EvaluationPeriods;
        /// <summary>
        /// Would represent the maximum % to scale-down. Number between 1-100.
        /// </summary>
        public readonly int? MaxScaleDownPercentage;

        [OutputConstructor]
        private OceanAutoscalerAutoscaleDown(
            int? evaluationPeriods,
            int? maxScaleDownPercentage)
        {
            EvaluationPeriods = evaluationPeriods;
            MaxScaleDownPercentage = maxScaleDownPercentage;
        }
    }

    [OutputType]
    public sealed class OceanAutoscalerAutoscaleHeadroom
    {
        /// <summary>
        /// Optionally configure the number of CPUs to allocate the headroom. CPUs are denoted in millicores, where 1000 millicores = 1 vCPU.
        /// </summary>
        public readonly int? CpuPerUnit;
        /// <summary>
        /// Optionally configure the number of GPUS to allocate the headroom.
        /// </summary>
        public readonly int? GpuPerUnit;
        /// <summary>
        /// Optionally configure the amount of memory (MB) to allocate the headroom.
        /// </summary>
        public readonly int? MemoryPerUnit;
        /// <summary>
        /// The number of units to retain as headroom, where each unit has the defined headroom CPU and memory.
        /// </summary>
        public readonly int? NumOfUnits;

        [OutputConstructor]
        private OceanAutoscalerAutoscaleHeadroom(
            int? cpuPerUnit,
            int? gpuPerUnit,
            int? memoryPerUnit,
            int? numOfUnits)
        {
            CpuPerUnit = cpuPerUnit;
            GpuPerUnit = gpuPerUnit;
            MemoryPerUnit = memoryPerUnit;
            NumOfUnits = numOfUnits;
        }
    }

    [OutputType]
    public sealed class OceanAutoscalerResourceLimits
    {
        /// <summary>
        /// The maximum memory in GiB units that can be allocated to the cluster.
        /// </summary>
        public readonly int? MaxMemoryGib;
        /// <summary>
        /// The maximum cpu in vCPU units that can be allocated to the cluster.
        /// </summary>
        public readonly int? MaxVcpu;

        [OutputConstructor]
        private OceanAutoscalerResourceLimits(
            int? maxMemoryGib,
            int? maxVcpu)
        {
            MaxMemoryGib = maxMemoryGib;
            MaxVcpu = maxVcpu;
        }
    }

    [OutputType]
    public sealed class OceanLoadBalancers
    {
        /// <summary>
        /// Required if type is set to TARGET_GROUP
        /// </summary>
        public readonly string? Arn;
        /// <summary>
        /// Required if type is set to CLASSIC
        /// </summary>
        public readonly string? Name;
        /// <summary>
        /// Can be set to CLASSIC or TARGET_GROUP
        /// </summary>
        public readonly string? Type;

        [OutputConstructor]
        private OceanLoadBalancers(
            string? arn,
            string? name,
            string? type)
        {
            Arn = arn;
            Name = name;
            Type = type;
        }
    }

    [OutputType]
    public sealed class OceanScheduledTasks
    {
        public readonly OceanScheduledTasksShutdownHours? ShutdownHours;
        public readonly ImmutableArray<OceanScheduledTasksTasks> Tasks;

        [OutputConstructor]
        private OceanScheduledTasks(
            OceanScheduledTasksShutdownHours? shutdownHours,
            ImmutableArray<OceanScheduledTasksTasks> tasks)
        {
            ShutdownHours = shutdownHours;
            Tasks = tasks;
        }
    }

    [OutputType]
    public sealed class OceanScheduledTasksShutdownHours
    {
        public readonly bool? IsEnabled;
        public readonly ImmutableArray<string> TimeWindows;

        [OutputConstructor]
        private OceanScheduledTasksShutdownHours(
            bool? isEnabled,
            ImmutableArray<string> timeWindows)
        {
            IsEnabled = isEnabled;
            TimeWindows = timeWindows;
        }
    }

    [OutputType]
    public sealed class OceanScheduledTasksTasks
    {
        public readonly string CronExpression;
        public readonly bool IsEnabled;
        public readonly string TaskType;

        [OutputConstructor]
        private OceanScheduledTasksTasks(
            string cronExpression,
            bool isEnabled,
            string taskType)
        {
            CronExpression = cronExpression;
            IsEnabled = isEnabled;
            TaskType = taskType;
        }
    }

    [OutputType]
    public sealed class OceanTags
    {
        /// <summary>
        /// The tag key.
        /// </summary>
        public readonly string Key;
        /// <summary>
        /// The tag value.
        /// </summary>
        public readonly string Value;

        [OutputConstructor]
        private OceanTags(
            string key,
            string value)
        {
            Key = key;
            Value = value;
        }
    }

    [OutputType]
    public sealed class OceanUpdatePolicy
    {
        public readonly OceanUpdatePolicyRollConfig? RollConfig;
        public readonly bool ShouldRoll;

        [OutputConstructor]
        private OceanUpdatePolicy(
            OceanUpdatePolicyRollConfig? rollConfig,
            bool shouldRoll)
        {
            RollConfig = rollConfig;
            ShouldRoll = shouldRoll;
        }
    }

    [OutputType]
    public sealed class OceanUpdatePolicyRollConfig
    {
        public readonly int BatchSizePercentage;

        [OutputConstructor]
        private OceanUpdatePolicyRollConfig(int batchSizePercentage)
        {
            BatchSizePercentage = batchSizePercentage;
        }
    }
    }
}
