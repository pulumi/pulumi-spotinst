// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.SpotInst.Aws
{
    /// <summary>
    /// Manages a Spotinst Ocean AWS [Virtual Node Group](https://docs.spot.io/ocean/features/launch-specifications) resource.
    /// 
    /// ## Import
    /// 
    /// Launch_Specs can be imported using the Launch_Spec `id`, e.g.,
    /// 
    /// hcl
    /// 
    /// ```sh
    /// $ pulumi import spotinst:aws/oceanLaunchSpec:OceanLaunchSpec nameOfTheResource ols-1a2b576
    /// ```
    /// </summary>
    [SpotInstResourceType("spotinst:aws/oceanLaunchSpec:OceanLaunchSpec")]
    public partial class OceanLaunchSpec : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Configure public IP address allocation.
        /// </summary>
        [Output("associatePublicIpAddress")]
        public Output<bool?> AssociatePublicIpAddress { get; private set; } = null!;

        /// <summary>
        /// Auto Scaling scale down operations.
        /// </summary>
        [Output("autoscaleDowns")]
        public Output<ImmutableArray<Outputs.OceanLaunchSpecAutoscaleDown>> AutoscaleDowns { get; private set; } = null!;

        /// <summary>
        /// Set custom headroom per Virtual Node Group. Provide a list of headrooms object.
        /// </summary>
        [Output("autoscaleHeadrooms")]
        public Output<ImmutableArray<Outputs.OceanLaunchSpecAutoscaleHeadroom>> AutoscaleHeadrooms { get; private set; } = null!;

        /// <summary>
        /// Set automatic headroom per launch spec.
        /// </summary>
        [Output("autoscaleHeadroomsAutomatics")]
        public Output<ImmutableArray<Outputs.OceanLaunchSpecAutoscaleHeadroomsAutomatic>> AutoscaleHeadroomsAutomatics { get; private set; } = null!;

        /// <summary>
        /// Object. Array list of block devices that are exposed to the instance, specify either virtual devices and EBS volumes.
        /// </summary>
        [Output("blockDeviceMappings")]
        public Output<ImmutableArray<Outputs.OceanLaunchSpecBlockDeviceMapping>> BlockDeviceMappings { get; private set; } = null!;

        [Output("createOptions")]
        public Output<Outputs.OceanLaunchSpecCreateOptions?> CreateOptions { get; private set; } = null!;

        [Output("deleteOptions")]
        public Output<Outputs.OceanLaunchSpecDeleteOptions?> DeleteOptions { get; private set; } = null!;

        /// <summary>
        /// Assign an Elastic IP to the instances spun by the Virtual Node Group. Can be null.
        /// </summary>
        [Output("elasticIpPools")]
        public Output<ImmutableArray<Outputs.OceanLaunchSpecElasticIpPool>> ElasticIpPools { get; private set; } = null!;

        [Output("ephemeralStorages")]
        public Output<ImmutableArray<Outputs.OceanLaunchSpecEphemeralStorage>> EphemeralStorages { get; private set; } = null!;

        /// <summary>
        /// The ARN or name of an IAM instance profile to associate with launched instances.
        /// </summary>
        [Output("iamInstanceProfile")]
        public Output<string?> IamInstanceProfile { get; private set; } = null!;

        /// <summary>
        /// ID of the image used to launch the instances.
        /// </summary>
        [Output("imageId")]
        public Output<string?> ImageId { get; private set; } = null!;

        /// <summary>
        /// Array of objects (Image object, containing the id of the image used to launch instances.) You can configure VNG with either the imageId or images objects, but not both simultaneously.
        /// For each architecture type (amd64, arm64) only one AMI is allowed. Valid values: null, or an array with at least one element.
        /// </summary>
        [Output("images")]
        public Output<ImmutableArray<Outputs.OceanLaunchSpecImage>> Images { get; private set; } = null!;

        /// <summary>
        /// Ocean instance metadata options object for IMDSv2.
        /// </summary>
        [Output("instanceMetadataOptions")]
        public Output<Outputs.OceanLaunchSpecInstanceMetadataOptions?> InstanceMetadataOptions { get; private set; } = null!;

        /// <summary>
        /// Determines the utilization of instance store volumes. If not defined, instance store volumes will not be used.
        /// </summary>
        [Output("instanceStorePolicy")]
        public Output<Outputs.OceanLaunchSpecInstanceStorePolicy?> InstanceStorePolicy { get; private set; } = null!;

        /// <summary>
        /// A list of instance types allowed to be provisioned for pods pending under the specified launch specification. The list overrides the list defined for the cluster.
        /// </summary>
        [Output("instanceTypes")]
        public Output<ImmutableArray<string>> InstanceTypes { get; private set; } = null!;

        /// <summary>
        /// The instance types that match with all filters compose the Virtual Node Group's instanceTypes parameter.
        /// The architectures that come from the Virtual Node Group's images will be taken into account when using this parameter. Cannot be configured together with Virtual Node Group's instanceTypes and with the Cluster's whitelist/blacklist/filters.
        /// </summary>
        [Output("instanceTypesFilters")]
        public Output<Outputs.OceanLaunchSpecInstanceTypesFilters?> InstanceTypesFilters { get; private set; } = null!;

        /// <summary>
        /// Optionally adds labels to instances launched in the cluster.
        /// </summary>
        [Output("labels")]
        public Output<ImmutableArray<Outputs.OceanLaunchSpecLabel>> Labels { get; private set; } = null!;

        /// <summary>
        /// Array of load balancer objects to add to VNG
        /// </summary>
        [Output("loadBalancers")]
        public Output<ImmutableArray<Outputs.OceanLaunchSpecLoadBalancer>> LoadBalancers { get; private set; } = null!;

        /// <summary>
        /// The name of the Virtual Node Group.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The ID of the Ocean cluster.
        /// </summary>
        [Output("oceanId")]
        public Output<string> OceanId { get; private set; } = null!;

        /// <summary>
        /// A list of instance types. Takes the preferred types into consideration while maintaining a variety of machine types running for optimized distribution.
        /// </summary>
        [Output("preferredOdTypes")]
        public Output<ImmutableArray<string>> PreferredOdTypes { get; private set; } = null!;

        /// <summary>
        /// A list of instance types. Takes the preferred types into consideration while maintaining a variety of machine types running for optimized distribution.
        /// </summary>
        [Output("preferredSpotTypes")]
        public Output<ImmutableArray<string>> PreferredSpotTypes { get; private set; } = null!;

        /// <summary>
        /// Specifies the count of ENIs to reserve per instance type for scaling purposes.
        /// </summary>
        [Output("reservedEnis")]
        public Output<int?> ReservedEnis { get; private set; } = null!;

        [Output("resourceLimits")]
        public Output<ImmutableArray<Outputs.OceanLaunchSpecResourceLimit>> ResourceLimits { get; private set; } = null!;

        /// <summary>
        /// Boolean. When set to `True`, nodes will be treated as if all pods running have the restrict-scale-down label. Therefore, Ocean will not scale nodes down unless empty.
        /// </summary>
        [Output("restrictScaleDown")]
        public Output<bool?> RestrictScaleDown { get; private set; } = null!;

        /// <summary>
        /// Set root volume size (in GB).
        /// </summary>
        [Output("rootVolumeSize")]
        public Output<int?> RootVolumeSize { get; private set; } = null!;

        /// <summary>
        /// Used to specify times that the nodes in the virtual node group will be taken down.
        /// </summary>
        [Output("schedulingShutdownHours")]
        public Output<Outputs.OceanLaunchSpecSchedulingShutdownHours?> SchedulingShutdownHours { get; private set; } = null!;

        /// <summary>
        /// Used to define scheduled tasks such as a manual headroom update.
        /// </summary>
        [Output("schedulingTasks")]
        public Output<ImmutableArray<Outputs.OceanLaunchSpecSchedulingTask>> SchedulingTasks { get; private set; } = null!;

        /// <summary>
        /// Optionally adds security group IDs.
        /// </summary>
        [Output("securityGroups")]
        public Output<ImmutableArray<string>> SecurityGroups { get; private set; } = null!;

        /// <summary>
        /// Temporary taints applied to a node during its initialization phase. For a startup taint to work, it must also be set as a regular taint in the userData for the cluster.
        /// </summary>
        [Output("startupTaints")]
        public Output<ImmutableArray<Outputs.OceanLaunchSpecStartupTaint>> StartupTaints { get; private set; } = null!;

        [Output("strategies")]
        public Output<ImmutableArray<Outputs.OceanLaunchSpecStrategy>> Strategies { get; private set; } = null!;

        /// <summary>
        /// A list of subnet IDs.
        /// </summary>
        [Output("subnetIds")]
        public Output<ImmutableArray<string>> SubnetIds { get; private set; } = null!;

        /// <summary>
        /// A key/value mapping of tags to assign to the resource.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<Outputs.OceanLaunchSpecTag>> Tags { get; private set; } = null!;

        /// <summary>
        /// Optionally adds labels to instances launched in the cluster.
        /// </summary>
        [Output("taints")]
        public Output<ImmutableArray<Outputs.OceanLaunchSpecTaint>> Taints { get; private set; } = null!;

        [Output("updatePolicy")]
        public Output<Outputs.OceanLaunchSpecUpdatePolicy?> UpdatePolicy { get; private set; } = null!;

        /// <summary>
        /// Base64-encoded MIME user data to make available to the instances.
        /// </summary>
        [Output("userData")]
        public Output<string?> UserData { get; private set; } = null!;


        /// <summary>
        /// Create a OceanLaunchSpec resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public OceanLaunchSpec(string name, OceanLaunchSpecArgs args, CustomResourceOptions? options = null)
            : base("spotinst:aws/oceanLaunchSpec:OceanLaunchSpec", name, args ?? new OceanLaunchSpecArgs(), MakeResourceOptions(options, ""))
        {
        }

        private OceanLaunchSpec(string name, Input<string> id, OceanLaunchSpecState? state = null, CustomResourceOptions? options = null)
            : base("spotinst:aws/oceanLaunchSpec:OceanLaunchSpec", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing OceanLaunchSpec resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static OceanLaunchSpec Get(string name, Input<string> id, OceanLaunchSpecState? state = null, CustomResourceOptions? options = null)
        {
            return new OceanLaunchSpec(name, id, state, options);
        }
    }

    public sealed class OceanLaunchSpecArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Configure public IP address allocation.
        /// </summary>
        [Input("associatePublicIpAddress")]
        public Input<bool>? AssociatePublicIpAddress { get; set; }

        [Input("autoscaleDowns")]
        private InputList<Inputs.OceanLaunchSpecAutoscaleDownArgs>? _autoscaleDowns;

        /// <summary>
        /// Auto Scaling scale down operations.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecAutoscaleDownArgs> AutoscaleDowns
        {
            get => _autoscaleDowns ?? (_autoscaleDowns = new InputList<Inputs.OceanLaunchSpecAutoscaleDownArgs>());
            set => _autoscaleDowns = value;
        }

        [Input("autoscaleHeadrooms")]
        private InputList<Inputs.OceanLaunchSpecAutoscaleHeadroomArgs>? _autoscaleHeadrooms;

        /// <summary>
        /// Set custom headroom per Virtual Node Group. Provide a list of headrooms object.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecAutoscaleHeadroomArgs> AutoscaleHeadrooms
        {
            get => _autoscaleHeadrooms ?? (_autoscaleHeadrooms = new InputList<Inputs.OceanLaunchSpecAutoscaleHeadroomArgs>());
            set => _autoscaleHeadrooms = value;
        }

        [Input("autoscaleHeadroomsAutomatics")]
        private InputList<Inputs.OceanLaunchSpecAutoscaleHeadroomsAutomaticArgs>? _autoscaleHeadroomsAutomatics;

        /// <summary>
        /// Set automatic headroom per launch spec.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecAutoscaleHeadroomsAutomaticArgs> AutoscaleHeadroomsAutomatics
        {
            get => _autoscaleHeadroomsAutomatics ?? (_autoscaleHeadroomsAutomatics = new InputList<Inputs.OceanLaunchSpecAutoscaleHeadroomsAutomaticArgs>());
            set => _autoscaleHeadroomsAutomatics = value;
        }

        [Input("blockDeviceMappings")]
        private InputList<Inputs.OceanLaunchSpecBlockDeviceMappingArgs>? _blockDeviceMappings;

        /// <summary>
        /// Object. Array list of block devices that are exposed to the instance, specify either virtual devices and EBS volumes.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecBlockDeviceMappingArgs> BlockDeviceMappings
        {
            get => _blockDeviceMappings ?? (_blockDeviceMappings = new InputList<Inputs.OceanLaunchSpecBlockDeviceMappingArgs>());
            set => _blockDeviceMappings = value;
        }

        [Input("createOptions")]
        public Input<Inputs.OceanLaunchSpecCreateOptionsArgs>? CreateOptions { get; set; }

        [Input("deleteOptions")]
        public Input<Inputs.OceanLaunchSpecDeleteOptionsArgs>? DeleteOptions { get; set; }

        [Input("elasticIpPools")]
        private InputList<Inputs.OceanLaunchSpecElasticIpPoolArgs>? _elasticIpPools;

        /// <summary>
        /// Assign an Elastic IP to the instances spun by the Virtual Node Group. Can be null.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecElasticIpPoolArgs> ElasticIpPools
        {
            get => _elasticIpPools ?? (_elasticIpPools = new InputList<Inputs.OceanLaunchSpecElasticIpPoolArgs>());
            set => _elasticIpPools = value;
        }

        [Input("ephemeralStorages")]
        private InputList<Inputs.OceanLaunchSpecEphemeralStorageArgs>? _ephemeralStorages;
        public InputList<Inputs.OceanLaunchSpecEphemeralStorageArgs> EphemeralStorages
        {
            get => _ephemeralStorages ?? (_ephemeralStorages = new InputList<Inputs.OceanLaunchSpecEphemeralStorageArgs>());
            set => _ephemeralStorages = value;
        }

        /// <summary>
        /// The ARN or name of an IAM instance profile to associate with launched instances.
        /// </summary>
        [Input("iamInstanceProfile")]
        public Input<string>? IamInstanceProfile { get; set; }

        /// <summary>
        /// ID of the image used to launch the instances.
        /// </summary>
        [Input("imageId")]
        public Input<string>? ImageId { get; set; }

        [Input("images")]
        private InputList<Inputs.OceanLaunchSpecImageArgs>? _images;

        /// <summary>
        /// Array of objects (Image object, containing the id of the image used to launch instances.) You can configure VNG with either the imageId or images objects, but not both simultaneously.
        /// For each architecture type (amd64, arm64) only one AMI is allowed. Valid values: null, or an array with at least one element.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecImageArgs> Images
        {
            get => _images ?? (_images = new InputList<Inputs.OceanLaunchSpecImageArgs>());
            set => _images = value;
        }

        /// <summary>
        /// Ocean instance metadata options object for IMDSv2.
        /// </summary>
        [Input("instanceMetadataOptions")]
        public Input<Inputs.OceanLaunchSpecInstanceMetadataOptionsArgs>? InstanceMetadataOptions { get; set; }

        /// <summary>
        /// Determines the utilization of instance store volumes. If not defined, instance store volumes will not be used.
        /// </summary>
        [Input("instanceStorePolicy")]
        public Input<Inputs.OceanLaunchSpecInstanceStorePolicyArgs>? InstanceStorePolicy { get; set; }

        [Input("instanceTypes")]
        private InputList<string>? _instanceTypes;

        /// <summary>
        /// A list of instance types allowed to be provisioned for pods pending under the specified launch specification. The list overrides the list defined for the cluster.
        /// </summary>
        public InputList<string> InstanceTypes
        {
            get => _instanceTypes ?? (_instanceTypes = new InputList<string>());
            set => _instanceTypes = value;
        }

        /// <summary>
        /// The instance types that match with all filters compose the Virtual Node Group's instanceTypes parameter.
        /// The architectures that come from the Virtual Node Group's images will be taken into account when using this parameter. Cannot be configured together with Virtual Node Group's instanceTypes and with the Cluster's whitelist/blacklist/filters.
        /// </summary>
        [Input("instanceTypesFilters")]
        public Input<Inputs.OceanLaunchSpecInstanceTypesFiltersArgs>? InstanceTypesFilters { get; set; }

        [Input("labels")]
        private InputList<Inputs.OceanLaunchSpecLabelArgs>? _labels;

        /// <summary>
        /// Optionally adds labels to instances launched in the cluster.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecLabelArgs> Labels
        {
            get => _labels ?? (_labels = new InputList<Inputs.OceanLaunchSpecLabelArgs>());
            set => _labels = value;
        }

        [Input("loadBalancers")]
        private InputList<Inputs.OceanLaunchSpecLoadBalancerArgs>? _loadBalancers;

        /// <summary>
        /// Array of load balancer objects to add to VNG
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecLoadBalancerArgs> LoadBalancers
        {
            get => _loadBalancers ?? (_loadBalancers = new InputList<Inputs.OceanLaunchSpecLoadBalancerArgs>());
            set => _loadBalancers = value;
        }

        /// <summary>
        /// The name of the Virtual Node Group.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The ID of the Ocean cluster.
        /// </summary>
        [Input("oceanId", required: true)]
        public Input<string> OceanId { get; set; } = null!;

        [Input("preferredOdTypes")]
        private InputList<string>? _preferredOdTypes;

        /// <summary>
        /// A list of instance types. Takes the preferred types into consideration while maintaining a variety of machine types running for optimized distribution.
        /// </summary>
        public InputList<string> PreferredOdTypes
        {
            get => _preferredOdTypes ?? (_preferredOdTypes = new InputList<string>());
            set => _preferredOdTypes = value;
        }

        [Input("preferredSpotTypes")]
        private InputList<string>? _preferredSpotTypes;

        /// <summary>
        /// A list of instance types. Takes the preferred types into consideration while maintaining a variety of machine types running for optimized distribution.
        /// </summary>
        public InputList<string> PreferredSpotTypes
        {
            get => _preferredSpotTypes ?? (_preferredSpotTypes = new InputList<string>());
            set => _preferredSpotTypes = value;
        }

        /// <summary>
        /// Specifies the count of ENIs to reserve per instance type for scaling purposes.
        /// </summary>
        [Input("reservedEnis")]
        public Input<int>? ReservedEnis { get; set; }

        [Input("resourceLimits")]
        private InputList<Inputs.OceanLaunchSpecResourceLimitArgs>? _resourceLimits;
        public InputList<Inputs.OceanLaunchSpecResourceLimitArgs> ResourceLimits
        {
            get => _resourceLimits ?? (_resourceLimits = new InputList<Inputs.OceanLaunchSpecResourceLimitArgs>());
            set => _resourceLimits = value;
        }

        /// <summary>
        /// Boolean. When set to `True`, nodes will be treated as if all pods running have the restrict-scale-down label. Therefore, Ocean will not scale nodes down unless empty.
        /// </summary>
        [Input("restrictScaleDown")]
        public Input<bool>? RestrictScaleDown { get; set; }

        /// <summary>
        /// Set root volume size (in GB).
        /// </summary>
        [Input("rootVolumeSize")]
        public Input<int>? RootVolumeSize { get; set; }

        /// <summary>
        /// Used to specify times that the nodes in the virtual node group will be taken down.
        /// </summary>
        [Input("schedulingShutdownHours")]
        public Input<Inputs.OceanLaunchSpecSchedulingShutdownHoursArgs>? SchedulingShutdownHours { get; set; }

        [Input("schedulingTasks")]
        private InputList<Inputs.OceanLaunchSpecSchedulingTaskArgs>? _schedulingTasks;

        /// <summary>
        /// Used to define scheduled tasks such as a manual headroom update.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecSchedulingTaskArgs> SchedulingTasks
        {
            get => _schedulingTasks ?? (_schedulingTasks = new InputList<Inputs.OceanLaunchSpecSchedulingTaskArgs>());
            set => _schedulingTasks = value;
        }

        [Input("securityGroups")]
        private InputList<string>? _securityGroups;

        /// <summary>
        /// Optionally adds security group IDs.
        /// </summary>
        public InputList<string> SecurityGroups
        {
            get => _securityGroups ?? (_securityGroups = new InputList<string>());
            set => _securityGroups = value;
        }

        [Input("startupTaints")]
        private InputList<Inputs.OceanLaunchSpecStartupTaintArgs>? _startupTaints;

        /// <summary>
        /// Temporary taints applied to a node during its initialization phase. For a startup taint to work, it must also be set as a regular taint in the userData for the cluster.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecStartupTaintArgs> StartupTaints
        {
            get => _startupTaints ?? (_startupTaints = new InputList<Inputs.OceanLaunchSpecStartupTaintArgs>());
            set => _startupTaints = value;
        }

        [Input("strategies")]
        private InputList<Inputs.OceanLaunchSpecStrategyArgs>? _strategies;
        public InputList<Inputs.OceanLaunchSpecStrategyArgs> Strategies
        {
            get => _strategies ?? (_strategies = new InputList<Inputs.OceanLaunchSpecStrategyArgs>());
            set => _strategies = value;
        }

        [Input("subnetIds")]
        private InputList<string>? _subnetIds;

        /// <summary>
        /// A list of subnet IDs.
        /// </summary>
        public InputList<string> SubnetIds
        {
            get => _subnetIds ?? (_subnetIds = new InputList<string>());
            set => _subnetIds = value;
        }

        [Input("tags")]
        private InputList<Inputs.OceanLaunchSpecTagArgs>? _tags;

        /// <summary>
        /// A key/value mapping of tags to assign to the resource.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecTagArgs> Tags
        {
            get => _tags ?? (_tags = new InputList<Inputs.OceanLaunchSpecTagArgs>());
            set => _tags = value;
        }

        [Input("taints")]
        private InputList<Inputs.OceanLaunchSpecTaintArgs>? _taints;

        /// <summary>
        /// Optionally adds labels to instances launched in the cluster.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecTaintArgs> Taints
        {
            get => _taints ?? (_taints = new InputList<Inputs.OceanLaunchSpecTaintArgs>());
            set => _taints = value;
        }

        [Input("updatePolicy")]
        public Input<Inputs.OceanLaunchSpecUpdatePolicyArgs>? UpdatePolicy { get; set; }

        /// <summary>
        /// Base64-encoded MIME user data to make available to the instances.
        /// </summary>
        [Input("userData")]
        public Input<string>? UserData { get; set; }

        public OceanLaunchSpecArgs()
        {
        }
        public static new OceanLaunchSpecArgs Empty => new OceanLaunchSpecArgs();
    }

    public sealed class OceanLaunchSpecState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Configure public IP address allocation.
        /// </summary>
        [Input("associatePublicIpAddress")]
        public Input<bool>? AssociatePublicIpAddress { get; set; }

        [Input("autoscaleDowns")]
        private InputList<Inputs.OceanLaunchSpecAutoscaleDownGetArgs>? _autoscaleDowns;

        /// <summary>
        /// Auto Scaling scale down operations.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecAutoscaleDownGetArgs> AutoscaleDowns
        {
            get => _autoscaleDowns ?? (_autoscaleDowns = new InputList<Inputs.OceanLaunchSpecAutoscaleDownGetArgs>());
            set => _autoscaleDowns = value;
        }

        [Input("autoscaleHeadrooms")]
        private InputList<Inputs.OceanLaunchSpecAutoscaleHeadroomGetArgs>? _autoscaleHeadrooms;

        /// <summary>
        /// Set custom headroom per Virtual Node Group. Provide a list of headrooms object.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecAutoscaleHeadroomGetArgs> AutoscaleHeadrooms
        {
            get => _autoscaleHeadrooms ?? (_autoscaleHeadrooms = new InputList<Inputs.OceanLaunchSpecAutoscaleHeadroomGetArgs>());
            set => _autoscaleHeadrooms = value;
        }

        [Input("autoscaleHeadroomsAutomatics")]
        private InputList<Inputs.OceanLaunchSpecAutoscaleHeadroomsAutomaticGetArgs>? _autoscaleHeadroomsAutomatics;

        /// <summary>
        /// Set automatic headroom per launch spec.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecAutoscaleHeadroomsAutomaticGetArgs> AutoscaleHeadroomsAutomatics
        {
            get => _autoscaleHeadroomsAutomatics ?? (_autoscaleHeadroomsAutomatics = new InputList<Inputs.OceanLaunchSpecAutoscaleHeadroomsAutomaticGetArgs>());
            set => _autoscaleHeadroomsAutomatics = value;
        }

        [Input("blockDeviceMappings")]
        private InputList<Inputs.OceanLaunchSpecBlockDeviceMappingGetArgs>? _blockDeviceMappings;

        /// <summary>
        /// Object. Array list of block devices that are exposed to the instance, specify either virtual devices and EBS volumes.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecBlockDeviceMappingGetArgs> BlockDeviceMappings
        {
            get => _blockDeviceMappings ?? (_blockDeviceMappings = new InputList<Inputs.OceanLaunchSpecBlockDeviceMappingGetArgs>());
            set => _blockDeviceMappings = value;
        }

        [Input("createOptions")]
        public Input<Inputs.OceanLaunchSpecCreateOptionsGetArgs>? CreateOptions { get; set; }

        [Input("deleteOptions")]
        public Input<Inputs.OceanLaunchSpecDeleteOptionsGetArgs>? DeleteOptions { get; set; }

        [Input("elasticIpPools")]
        private InputList<Inputs.OceanLaunchSpecElasticIpPoolGetArgs>? _elasticIpPools;

        /// <summary>
        /// Assign an Elastic IP to the instances spun by the Virtual Node Group. Can be null.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecElasticIpPoolGetArgs> ElasticIpPools
        {
            get => _elasticIpPools ?? (_elasticIpPools = new InputList<Inputs.OceanLaunchSpecElasticIpPoolGetArgs>());
            set => _elasticIpPools = value;
        }

        [Input("ephemeralStorages")]
        private InputList<Inputs.OceanLaunchSpecEphemeralStorageGetArgs>? _ephemeralStorages;
        public InputList<Inputs.OceanLaunchSpecEphemeralStorageGetArgs> EphemeralStorages
        {
            get => _ephemeralStorages ?? (_ephemeralStorages = new InputList<Inputs.OceanLaunchSpecEphemeralStorageGetArgs>());
            set => _ephemeralStorages = value;
        }

        /// <summary>
        /// The ARN or name of an IAM instance profile to associate with launched instances.
        /// </summary>
        [Input("iamInstanceProfile")]
        public Input<string>? IamInstanceProfile { get; set; }

        /// <summary>
        /// ID of the image used to launch the instances.
        /// </summary>
        [Input("imageId")]
        public Input<string>? ImageId { get; set; }

        [Input("images")]
        private InputList<Inputs.OceanLaunchSpecImageGetArgs>? _images;

        /// <summary>
        /// Array of objects (Image object, containing the id of the image used to launch instances.) You can configure VNG with either the imageId or images objects, but not both simultaneously.
        /// For each architecture type (amd64, arm64) only one AMI is allowed. Valid values: null, or an array with at least one element.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecImageGetArgs> Images
        {
            get => _images ?? (_images = new InputList<Inputs.OceanLaunchSpecImageGetArgs>());
            set => _images = value;
        }

        /// <summary>
        /// Ocean instance metadata options object for IMDSv2.
        /// </summary>
        [Input("instanceMetadataOptions")]
        public Input<Inputs.OceanLaunchSpecInstanceMetadataOptionsGetArgs>? InstanceMetadataOptions { get; set; }

        /// <summary>
        /// Determines the utilization of instance store volumes. If not defined, instance store volumes will not be used.
        /// </summary>
        [Input("instanceStorePolicy")]
        public Input<Inputs.OceanLaunchSpecInstanceStorePolicyGetArgs>? InstanceStorePolicy { get; set; }

        [Input("instanceTypes")]
        private InputList<string>? _instanceTypes;

        /// <summary>
        /// A list of instance types allowed to be provisioned for pods pending under the specified launch specification. The list overrides the list defined for the cluster.
        /// </summary>
        public InputList<string> InstanceTypes
        {
            get => _instanceTypes ?? (_instanceTypes = new InputList<string>());
            set => _instanceTypes = value;
        }

        /// <summary>
        /// The instance types that match with all filters compose the Virtual Node Group's instanceTypes parameter.
        /// The architectures that come from the Virtual Node Group's images will be taken into account when using this parameter. Cannot be configured together with Virtual Node Group's instanceTypes and with the Cluster's whitelist/blacklist/filters.
        /// </summary>
        [Input("instanceTypesFilters")]
        public Input<Inputs.OceanLaunchSpecInstanceTypesFiltersGetArgs>? InstanceTypesFilters { get; set; }

        [Input("labels")]
        private InputList<Inputs.OceanLaunchSpecLabelGetArgs>? _labels;

        /// <summary>
        /// Optionally adds labels to instances launched in the cluster.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecLabelGetArgs> Labels
        {
            get => _labels ?? (_labels = new InputList<Inputs.OceanLaunchSpecLabelGetArgs>());
            set => _labels = value;
        }

        [Input("loadBalancers")]
        private InputList<Inputs.OceanLaunchSpecLoadBalancerGetArgs>? _loadBalancers;

        /// <summary>
        /// Array of load balancer objects to add to VNG
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecLoadBalancerGetArgs> LoadBalancers
        {
            get => _loadBalancers ?? (_loadBalancers = new InputList<Inputs.OceanLaunchSpecLoadBalancerGetArgs>());
            set => _loadBalancers = value;
        }

        /// <summary>
        /// The name of the Virtual Node Group.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// The ID of the Ocean cluster.
        /// </summary>
        [Input("oceanId")]
        public Input<string>? OceanId { get; set; }

        [Input("preferredOdTypes")]
        private InputList<string>? _preferredOdTypes;

        /// <summary>
        /// A list of instance types. Takes the preferred types into consideration while maintaining a variety of machine types running for optimized distribution.
        /// </summary>
        public InputList<string> PreferredOdTypes
        {
            get => _preferredOdTypes ?? (_preferredOdTypes = new InputList<string>());
            set => _preferredOdTypes = value;
        }

        [Input("preferredSpotTypes")]
        private InputList<string>? _preferredSpotTypes;

        /// <summary>
        /// A list of instance types. Takes the preferred types into consideration while maintaining a variety of machine types running for optimized distribution.
        /// </summary>
        public InputList<string> PreferredSpotTypes
        {
            get => _preferredSpotTypes ?? (_preferredSpotTypes = new InputList<string>());
            set => _preferredSpotTypes = value;
        }

        /// <summary>
        /// Specifies the count of ENIs to reserve per instance type for scaling purposes.
        /// </summary>
        [Input("reservedEnis")]
        public Input<int>? ReservedEnis { get; set; }

        [Input("resourceLimits")]
        private InputList<Inputs.OceanLaunchSpecResourceLimitGetArgs>? _resourceLimits;
        public InputList<Inputs.OceanLaunchSpecResourceLimitGetArgs> ResourceLimits
        {
            get => _resourceLimits ?? (_resourceLimits = new InputList<Inputs.OceanLaunchSpecResourceLimitGetArgs>());
            set => _resourceLimits = value;
        }

        /// <summary>
        /// Boolean. When set to `True`, nodes will be treated as if all pods running have the restrict-scale-down label. Therefore, Ocean will not scale nodes down unless empty.
        /// </summary>
        [Input("restrictScaleDown")]
        public Input<bool>? RestrictScaleDown { get; set; }

        /// <summary>
        /// Set root volume size (in GB).
        /// </summary>
        [Input("rootVolumeSize")]
        public Input<int>? RootVolumeSize { get; set; }

        /// <summary>
        /// Used to specify times that the nodes in the virtual node group will be taken down.
        /// </summary>
        [Input("schedulingShutdownHours")]
        public Input<Inputs.OceanLaunchSpecSchedulingShutdownHoursGetArgs>? SchedulingShutdownHours { get; set; }

        [Input("schedulingTasks")]
        private InputList<Inputs.OceanLaunchSpecSchedulingTaskGetArgs>? _schedulingTasks;

        /// <summary>
        /// Used to define scheduled tasks such as a manual headroom update.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecSchedulingTaskGetArgs> SchedulingTasks
        {
            get => _schedulingTasks ?? (_schedulingTasks = new InputList<Inputs.OceanLaunchSpecSchedulingTaskGetArgs>());
            set => _schedulingTasks = value;
        }

        [Input("securityGroups")]
        private InputList<string>? _securityGroups;

        /// <summary>
        /// Optionally adds security group IDs.
        /// </summary>
        public InputList<string> SecurityGroups
        {
            get => _securityGroups ?? (_securityGroups = new InputList<string>());
            set => _securityGroups = value;
        }

        [Input("startupTaints")]
        private InputList<Inputs.OceanLaunchSpecStartupTaintGetArgs>? _startupTaints;

        /// <summary>
        /// Temporary taints applied to a node during its initialization phase. For a startup taint to work, it must also be set as a regular taint in the userData for the cluster.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecStartupTaintGetArgs> StartupTaints
        {
            get => _startupTaints ?? (_startupTaints = new InputList<Inputs.OceanLaunchSpecStartupTaintGetArgs>());
            set => _startupTaints = value;
        }

        [Input("strategies")]
        private InputList<Inputs.OceanLaunchSpecStrategyGetArgs>? _strategies;
        public InputList<Inputs.OceanLaunchSpecStrategyGetArgs> Strategies
        {
            get => _strategies ?? (_strategies = new InputList<Inputs.OceanLaunchSpecStrategyGetArgs>());
            set => _strategies = value;
        }

        [Input("subnetIds")]
        private InputList<string>? _subnetIds;

        /// <summary>
        /// A list of subnet IDs.
        /// </summary>
        public InputList<string> SubnetIds
        {
            get => _subnetIds ?? (_subnetIds = new InputList<string>());
            set => _subnetIds = value;
        }

        [Input("tags")]
        private InputList<Inputs.OceanLaunchSpecTagGetArgs>? _tags;

        /// <summary>
        /// A key/value mapping of tags to assign to the resource.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecTagGetArgs> Tags
        {
            get => _tags ?? (_tags = new InputList<Inputs.OceanLaunchSpecTagGetArgs>());
            set => _tags = value;
        }

        [Input("taints")]
        private InputList<Inputs.OceanLaunchSpecTaintGetArgs>? _taints;

        /// <summary>
        /// Optionally adds labels to instances launched in the cluster.
        /// </summary>
        public InputList<Inputs.OceanLaunchSpecTaintGetArgs> Taints
        {
            get => _taints ?? (_taints = new InputList<Inputs.OceanLaunchSpecTaintGetArgs>());
            set => _taints = value;
        }

        [Input("updatePolicy")]
        public Input<Inputs.OceanLaunchSpecUpdatePolicyGetArgs>? UpdatePolicy { get; set; }

        /// <summary>
        /// Base64-encoded MIME user data to make available to the instances.
        /// </summary>
        [Input("userData")]
        public Input<string>? UserData { get; set; }

        public OceanLaunchSpecState()
        {
        }
        public static new OceanLaunchSpecState Empty => new OceanLaunchSpecState();
    }
}
