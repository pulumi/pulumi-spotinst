// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.SpotInst.Aws
{
    public partial class Elastigroup : Pulumi.CustomResource
    {
        /// <summary>
        /// List of Strings of availability zones. When this parameter is set, `subnet_ids` should be left unused.
        /// Note: `availability_zones` naming syntax follows the convention `availability-zone:subnet:placement-group-name`. For example, to set an AZ in `us-east-1` with subnet `subnet-123456` and placement group `ClusterI03`, you would set:
        /// `availability_zones = ["us-east-1a:subnet-123456:ClusterI03"]`
        /// </summary>
        [Output("availabilityZones")]
        public Output<ImmutableArray<string>> AvailabilityZones { get; private set; } = null!;

        [Output("blockDevicesMode")]
        public Output<string?> BlockDevicesMode { get; private set; } = null!;

        /// <summary>
        /// The capacity unit to launch instances by. If not specified, when choosing the weight unit, each instance will weight as the number of its vCPUs.
        /// </summary>
        [Output("capacityUnit")]
        public Output<string> CapacityUnit { get; private set; } = null!;

        /// <summary>
        /// Controls how T3 instances are launched. Valid values: `standard`, `unlimited`.
        /// </summary>
        [Output("cpuCredits")]
        public Output<string?> CpuCredits { get; private set; } = null!;

        /// <summary>
        /// The group description.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// The desired number of instances the group should have at any time.
        /// </summary>
        [Output("desiredCapacity")]
        public Output<int?> DesiredCapacity { get; private set; } = null!;

        /// <summary>
        /// The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
        /// </summary>
        [Output("drainingTimeout")]
        public Output<int> DrainingTimeout { get; private set; } = null!;

        [Output("ebsBlockDevices")]
        public Output<ImmutableArray<Outputs.ElastigroupEbsBlockDevice>> EbsBlockDevices { get; private set; } = null!;

        /// <summary>
        /// Enable high bandwidth connectivity between instances and AWS’s Elastic Block Store (EBS). For instance types that are EBS-optimized by default this parameter will be ignored.
        /// </summary>
        [Output("ebsOptimized")]
        public Output<bool> EbsOptimized { get; private set; } = null!;

        /// <summary>
        /// A list of [AWS Elastic IP](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html) allocation IDs to associate to the group instances.
        /// </summary>
        [Output("elasticIps")]
        public Output<ImmutableArray<string>> ElasticIps { get; private set; } = null!;

        [Output("elasticLoadBalancers")]
        public Output<ImmutableArray<string>> ElasticLoadBalancers { get; private set; } = null!;

        /// <summary>
        /// Indicates whether monitoring is enabled for the instance.
        /// </summary>
        [Output("enableMonitoring")]
        public Output<bool?> EnableMonitoring { get; private set; } = null!;

        [Output("ephemeralBlockDevices")]
        public Output<ImmutableArray<Outputs.ElastigroupEphemeralBlockDevice>> EphemeralBlockDevices { get; private set; } = null!;

        /// <summary>
        /// In a case of no Spot instances available, Elastigroup will launch on-demand instances instead.
        /// </summary>
        [Output("fallbackToOndemand")]
        public Output<bool> FallbackToOndemand { get; private set; } = null!;

        /// <summary>
        /// The amount of time, in seconds, after the instance has launched to starts and check its health.
        /// </summary>
        [Output("healthCheckGracePeriod")]
        public Output<int?> HealthCheckGracePeriod { get; private set; } = null!;

        /// <summary>
        /// The service that will perform health checks for the instance. Valid values: `"ELB"`, `"HCS"`, `"TARGET_GROUP"`, `"MLB"`, `"EC2"`, `"MULTAI_TARGET_SET"`, `"MLB_RUNTIME"`, `"K8S_NODE"`, `"NOMAD_NODE"`, `"ECS_CLUSTER_INSTANCE"`.
        /// </summary>
        [Output("healthCheckType")]
        public Output<string?> HealthCheckType { get; private set; } = null!;

        /// <summary>
        /// The amount of time, in seconds, that we will wait before replacing an instance that is running and became unhealthy (this is only applicable for instances that were once healthy).
        /// </summary>
        [Output("healthCheckUnhealthyDurationBeforeReplacement")]
        public Output<int?> HealthCheckUnhealthyDurationBeforeReplacement { get; private set; } = null!;

        /// <summary>
        /// The ARN or name of an IAM instance profile to associate with launched instances.
        /// </summary>
        [Output("iamInstanceProfile")]
        public Output<string?> IamInstanceProfile { get; private set; } = null!;

        /// <summary>
        /// The ID of the AMI used to launch the instance.
        /// </summary>
        [Output("imageId")]
        public Output<string?> ImageId { get; private set; } = null!;

        /// <summary>
        /// The type of instance determines your instance's CPU capacity, memory and storage (e.g., m1.small, c1.xlarge).
        /// </summary>
        [Output("instanceTypesOndemand")]
        public Output<string> InstanceTypesOndemand { get; private set; } = null!;

        /// <summary>
        /// Prioritize a subset of spot instance types. Must be a subset of the selected spot instance types.
        /// </summary>
        [Output("instanceTypesPreferredSpots")]
        public Output<ImmutableArray<string>> InstanceTypesPreferredSpots { get; private set; } = null!;

        /// <summary>
        /// One or more instance types.
        /// </summary>
        [Output("instanceTypesSpots")]
        public Output<ImmutableArray<string>> InstanceTypesSpots { get; private set; } = null!;

        /// <summary>
        /// List of weights per instance type for weighted groups. Each object in the list should have the following attributes:
        /// </summary>
        [Output("instanceTypesWeights")]
        public Output<ImmutableArray<Outputs.ElastigroupInstanceTypesWeight>> InstanceTypesWeights { get; private set; } = null!;

        [Output("integrationBeanstalk")]
        public Output<Outputs.ElastigroupIntegrationBeanstalk?> IntegrationBeanstalk { get; private set; } = null!;

        [Output("integrationCodedeploy")]
        public Output<Outputs.ElastigroupIntegrationCodedeploy?> IntegrationCodedeploy { get; private set; } = null!;

        [Output("integrationDockerSwarm")]
        public Output<Outputs.ElastigroupIntegrationDockerSwarm?> IntegrationDockerSwarm { get; private set; } = null!;

        [Output("integrationEcs")]
        public Output<Outputs.ElastigroupIntegrationEcs?> IntegrationEcs { get; private set; } = null!;

        [Output("integrationGitlab")]
        public Output<Outputs.ElastigroupIntegrationGitlab?> IntegrationGitlab { get; private set; } = null!;

        [Output("integrationKubernetes")]
        public Output<Outputs.ElastigroupIntegrationKubernetes?> IntegrationKubernetes { get; private set; } = null!;

        [Output("integrationMesosphere")]
        public Output<Outputs.ElastigroupIntegrationMesosphere?> IntegrationMesosphere { get; private set; } = null!;

        [Output("integrationMultaiRuntime")]
        public Output<Outputs.ElastigroupIntegrationMultaiRuntime?> IntegrationMultaiRuntime { get; private set; } = null!;

        [Output("integrationNomad")]
        public Output<Outputs.ElastigroupIntegrationNomad?> IntegrationNomad { get; private set; } = null!;

        [Output("integrationRancher")]
        public Output<Outputs.ElastigroupIntegrationRancher?> IntegrationRancher { get; private set; } = null!;

        [Output("integrationRoute53")]
        public Output<Outputs.ElastigroupIntegrationRoute53?> IntegrationRoute53 { get; private set; } = null!;

        /// <summary>
        /// The key name that should be used for the instance.
        /// </summary>
        [Output("keyName")]
        public Output<string?> KeyName { get; private set; } = null!;

        [Output("lifetimePeriod")]
        public Output<string?> LifetimePeriod { get; private set; } = null!;

        /// <summary>
        /// The maximum number of instances the group should have at any time.
        /// </summary>
        [Output("maxSize")]
        public Output<int> MaxSize { get; private set; } = null!;

        /// <summary>
        /// Data that used to configure or manage the running instances:
        /// </summary>
        [Output("metadataOptions")]
        public Output<Outputs.ElastigroupMetadataOptions?> MetadataOptions { get; private set; } = null!;

        /// <summary>
        /// The minimum number of instances the group should have at any time.
        /// </summary>
        [Output("minSize")]
        public Output<int> MinSize { get; private set; } = null!;

        [Output("multaiTargetSets")]
        public Output<ImmutableArray<Outputs.ElastigroupMultaiTargetSet>> MultaiTargetSets { get; private set; } = null!;

        /// <summary>
        /// The group name.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        [Output("networkInterfaces")]
        public Output<ImmutableArray<Outputs.ElastigroupNetworkInterface>> NetworkInterfaces { get; private set; } = null!;

        /// <summary>
        /// Number of on demand instances to launch in the group. All other instances will be spot instances. When this parameter is set the `spot_percentage` parameter is being ignored.
        /// </summary>
        [Output("ondemandCount")]
        public Output<int?> OndemandCount { get; private set; } = null!;

        /// <summary>
        /// Select a prediction strategy. Valid values: `"balanced"`, `"costOriented"`, `"equalAzDistribution"`, `"availabilityOriented"`.
        /// </summary>
        [Output("orientation")]
        public Output<string> Orientation { get; private set; } = null!;

        [Output("persistBlockDevices")]
        public Output<bool?> PersistBlockDevices { get; private set; } = null!;

        [Output("persistPrivateIp")]
        public Output<bool?> PersistPrivateIp { get; private set; } = null!;

        [Output("persistRootDevice")]
        public Output<bool?> PersistRootDevice { get; private set; } = null!;

        /// <summary>
        /// Enable dedicated tenancy. Note: There is a flat hourly fee for each region in which dedicated tenancy is used.
        /// </summary>
        [Output("placementTenancy")]
        public Output<string?> PlacementTenancy { get; private set; } = null!;

        /// <summary>
        /// The AZs to prioritize when launching Spot instances. If no markets are available in the Preferred AZs, Spot instances are launched in the non-preferred AZs. 
        /// Note: Must be a sublist of `availability_zones` and `orientation` value must not be `"equalAzDistribution"`.
        /// </summary>
        [Output("preferredAvailabilityZones")]
        public Output<ImmutableArray<string>> PreferredAvailabilityZones { get; private set; } = null!;

        [Output("privateIps")]
        public Output<ImmutableArray<string>> PrivateIps { get; private set; } = null!;

        /// <summary>
        /// Operation system type. Valid values: `"Linux/UNIX"`, `"SUSE Linux"`, `"Windows"`. 
        /// For EC2 Classic instances:  `"Linux/UNIX (Amazon VPC)"`, `"SUSE Linux (Amazon VPC)"`, `"Windows (Amazon VPC)"`.
        /// </summary>
        [Output("product")]
        public Output<string> Product { get; private set; } = null!;

        /// <summary>
        /// The AWS region your group will be created in.
        /// Note: This parameter is required if you specify subnets (through subnet_ids). This parameter is optional if you specify Availability Zones (through availability_zones).
        /// </summary>
        [Output("region")]
        public Output<string?> Region { get; private set; } = null!;

        /// <summary>
        /// Hold settings for strategy correction – replacing On-Demand for Spot instances. Supported Values: `"never"`, `"always"`, `"timeWindow"`
        /// </summary>
        [Output("revertToSpot")]
        public Output<Outputs.ElastigroupRevertToSpot?> RevertToSpot { get; private set; } = null!;

        [Output("scalingDownPolicies")]
        public Output<ImmutableArray<Outputs.ElastigroupScalingDownPolicy>> ScalingDownPolicies { get; private set; } = null!;

        /// <summary>
        /// Set termination policy.
        /// </summary>
        [Output("scalingStrategies")]
        public Output<ImmutableArray<Outputs.ElastigroupScalingStrategy>> ScalingStrategies { get; private set; } = null!;

        [Output("scalingTargetPolicies")]
        public Output<ImmutableArray<Outputs.ElastigroupScalingTargetPolicy>> ScalingTargetPolicies { get; private set; } = null!;

        [Output("scalingUpPolicies")]
        public Output<ImmutableArray<Outputs.ElastigroupScalingUpPolicy>> ScalingUpPolicies { get; private set; } = null!;

        [Output("scheduledTasks")]
        public Output<ImmutableArray<Outputs.ElastigroupScheduledTask>> ScheduledTasks { get; private set; } = null!;

        /// <summary>
        /// A list of associated security group IDS.
        /// </summary>
        [Output("securityGroups")]
        public Output<ImmutableArray<string>> SecurityGroups { get; private set; } = null!;

        /// <summary>
        /// The Base64-encoded shutdown script that executes prior to instance termination, for more information please see: [Shutdown Script](https://api.spotinst.com/integration-docs/elastigroup/concepts/compute-concepts/shutdown-scripts/)
        /// </summary>
        [Output("shutdownScript")]
        public Output<string?> ShutdownScript { get; private set; } = null!;

        [Output("signals")]
        public Output<ImmutableArray<Outputs.ElastigroupSignal>> Signals { get; private set; } = null!;

        /// <summary>
        /// The percentage of Spot instances that would spin up from the `desired_capacity` number.
        /// </summary>
        [Output("spotPercentage")]
        public Output<int?> SpotPercentage { get; private set; } = null!;

        [Output("statefulDeallocation")]
        public Output<Outputs.ElastigroupStatefulDeallocation?> StatefulDeallocation { get; private set; } = null!;

        /// <summary>
        /// List of Strings of subnet identifiers.
        /// Note: When this parameter is set, `availability_zones` should be left unused.
        /// </summary>
        [Output("subnetIds")]
        public Output<ImmutableArray<string>> SubnetIds { get; private set; } = null!;

        /// <summary>
        /// A key/value mapping of tags to assign to the resource.
        /// </summary>
        [Output("tags")]
        public Output<ImmutableArray<Outputs.ElastigroupTag>> Tags { get; private set; } = null!;

        [Output("targetGroupArns")]
        public Output<ImmutableArray<string>> TargetGroupArns { get; private set; } = null!;

        [Output("updatePolicy")]
        public Output<Outputs.ElastigroupUpdatePolicy?> UpdatePolicy { get; private set; } = null!;

        /// <summary>
        /// The user data to provide when launching the instance.
        /// </summary>
        [Output("userData")]
        public Output<string?> UserData { get; private set; } = null!;

        /// <summary>
        /// In a case of any available reserved instances, Elastigroup will utilize them first before purchasing Spot instances.
        /// </summary>
        [Output("utilizeReservedInstances")]
        public Output<bool?> UtilizeReservedInstances { get; private set; } = null!;

        /// <summary>
        /// Minimum number of instances in a 'HEALTHY' status that is required before continuing. This is ignored when updating with blue/green deployment. Cannot exceed `desired_capacity`.
        /// </summary>
        [Output("waitForCapacity")]
        public Output<int?> WaitForCapacity { get; private set; } = null!;

        /// <summary>
        /// Time (seconds) to wait for instances to report a 'HEALTHY' status. Useful for plans with multiple dependencies that take some time to initialize. Leave undefined or set to `0` to indicate no wait. This is ignored when updating with blue/green deployment.
        /// </summary>
        [Output("waitForCapacityTimeout")]
        public Output<int?> WaitForCapacityTimeout { get; private set; } = null!;


        /// <summary>
        /// Create a Elastigroup resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Elastigroup(string name, ElastigroupArgs args, CustomResourceOptions? options = null)
            : base("spotinst:aws/elastigroup:Elastigroup", name, args ?? new ElastigroupArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Elastigroup(string name, Input<string> id, ElastigroupState? state = null, CustomResourceOptions? options = null)
            : base("spotinst:aws/elastigroup:Elastigroup", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Elastigroup resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Elastigroup Get(string name, Input<string> id, ElastigroupState? state = null, CustomResourceOptions? options = null)
        {
            return new Elastigroup(name, id, state, options);
        }
    }

    public sealed class ElastigroupArgs : Pulumi.ResourceArgs
    {
        [Input("availabilityZones")]
        private InputList<string>? _availabilityZones;

        /// <summary>
        /// List of Strings of availability zones. When this parameter is set, `subnet_ids` should be left unused.
        /// Note: `availability_zones` naming syntax follows the convention `availability-zone:subnet:placement-group-name`. For example, to set an AZ in `us-east-1` with subnet `subnet-123456` and placement group `ClusterI03`, you would set:
        /// `availability_zones = ["us-east-1a:subnet-123456:ClusterI03"]`
        /// </summary>
        public InputList<string> AvailabilityZones
        {
            get => _availabilityZones ?? (_availabilityZones = new InputList<string>());
            set => _availabilityZones = value;
        }

        [Input("blockDevicesMode")]
        public Input<string>? BlockDevicesMode { get; set; }

        /// <summary>
        /// The capacity unit to launch instances by. If not specified, when choosing the weight unit, each instance will weight as the number of its vCPUs.
        /// </summary>
        [Input("capacityUnit")]
        public Input<string>? CapacityUnit { get; set; }

        /// <summary>
        /// Controls how T3 instances are launched. Valid values: `standard`, `unlimited`.
        /// </summary>
        [Input("cpuCredits")]
        public Input<string>? CpuCredits { get; set; }

        /// <summary>
        /// The group description.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The desired number of instances the group should have at any time.
        /// </summary>
        [Input("desiredCapacity")]
        public Input<int>? DesiredCapacity { get; set; }

        /// <summary>
        /// The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
        /// </summary>
        [Input("drainingTimeout")]
        public Input<int>? DrainingTimeout { get; set; }

        [Input("ebsBlockDevices")]
        private InputList<Inputs.ElastigroupEbsBlockDeviceArgs>? _ebsBlockDevices;
        public InputList<Inputs.ElastigroupEbsBlockDeviceArgs> EbsBlockDevices
        {
            get => _ebsBlockDevices ?? (_ebsBlockDevices = new InputList<Inputs.ElastigroupEbsBlockDeviceArgs>());
            set => _ebsBlockDevices = value;
        }

        /// <summary>
        /// Enable high bandwidth connectivity between instances and AWS’s Elastic Block Store (EBS). For instance types that are EBS-optimized by default this parameter will be ignored.
        /// </summary>
        [Input("ebsOptimized")]
        public Input<bool>? EbsOptimized { get; set; }

        [Input("elasticIps")]
        private InputList<string>? _elasticIps;

        /// <summary>
        /// A list of [AWS Elastic IP](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html) allocation IDs to associate to the group instances.
        /// </summary>
        public InputList<string> ElasticIps
        {
            get => _elasticIps ?? (_elasticIps = new InputList<string>());
            set => _elasticIps = value;
        }

        [Input("elasticLoadBalancers")]
        private InputList<string>? _elasticLoadBalancers;
        public InputList<string> ElasticLoadBalancers
        {
            get => _elasticLoadBalancers ?? (_elasticLoadBalancers = new InputList<string>());
            set => _elasticLoadBalancers = value;
        }

        /// <summary>
        /// Indicates whether monitoring is enabled for the instance.
        /// </summary>
        [Input("enableMonitoring")]
        public Input<bool>? EnableMonitoring { get; set; }

        [Input("ephemeralBlockDevices")]
        private InputList<Inputs.ElastigroupEphemeralBlockDeviceArgs>? _ephemeralBlockDevices;
        public InputList<Inputs.ElastigroupEphemeralBlockDeviceArgs> EphemeralBlockDevices
        {
            get => _ephemeralBlockDevices ?? (_ephemeralBlockDevices = new InputList<Inputs.ElastigroupEphemeralBlockDeviceArgs>());
            set => _ephemeralBlockDevices = value;
        }

        /// <summary>
        /// In a case of no Spot instances available, Elastigroup will launch on-demand instances instead.
        /// </summary>
        [Input("fallbackToOndemand", required: true)]
        public Input<bool> FallbackToOndemand { get; set; } = null!;

        /// <summary>
        /// The amount of time, in seconds, after the instance has launched to starts and check its health.
        /// </summary>
        [Input("healthCheckGracePeriod")]
        public Input<int>? HealthCheckGracePeriod { get; set; }

        /// <summary>
        /// The service that will perform health checks for the instance. Valid values: `"ELB"`, `"HCS"`, `"TARGET_GROUP"`, `"MLB"`, `"EC2"`, `"MULTAI_TARGET_SET"`, `"MLB_RUNTIME"`, `"K8S_NODE"`, `"NOMAD_NODE"`, `"ECS_CLUSTER_INSTANCE"`.
        /// </summary>
        [Input("healthCheckType")]
        public Input<string>? HealthCheckType { get; set; }

        /// <summary>
        /// The amount of time, in seconds, that we will wait before replacing an instance that is running and became unhealthy (this is only applicable for instances that were once healthy).
        /// </summary>
        [Input("healthCheckUnhealthyDurationBeforeReplacement")]
        public Input<int>? HealthCheckUnhealthyDurationBeforeReplacement { get; set; }

        /// <summary>
        /// The ARN or name of an IAM instance profile to associate with launched instances.
        /// </summary>
        [Input("iamInstanceProfile")]
        public Input<string>? IamInstanceProfile { get; set; }

        /// <summary>
        /// The ID of the AMI used to launch the instance.
        /// </summary>
        [Input("imageId")]
        public Input<string>? ImageId { get; set; }

        /// <summary>
        /// The type of instance determines your instance's CPU capacity, memory and storage (e.g., m1.small, c1.xlarge).
        /// </summary>
        [Input("instanceTypesOndemand", required: true)]
        public Input<string> InstanceTypesOndemand { get; set; } = null!;

        [Input("instanceTypesPreferredSpots")]
        private InputList<string>? _instanceTypesPreferredSpots;

        /// <summary>
        /// Prioritize a subset of spot instance types. Must be a subset of the selected spot instance types.
        /// </summary>
        public InputList<string> InstanceTypesPreferredSpots
        {
            get => _instanceTypesPreferredSpots ?? (_instanceTypesPreferredSpots = new InputList<string>());
            set => _instanceTypesPreferredSpots = value;
        }

        [Input("instanceTypesSpots", required: true)]
        private InputList<string>? _instanceTypesSpots;

        /// <summary>
        /// One or more instance types.
        /// </summary>
        public InputList<string> InstanceTypesSpots
        {
            get => _instanceTypesSpots ?? (_instanceTypesSpots = new InputList<string>());
            set => _instanceTypesSpots = value;
        }

        [Input("instanceTypesWeights")]
        private InputList<Inputs.ElastigroupInstanceTypesWeightArgs>? _instanceTypesWeights;

        /// <summary>
        /// List of weights per instance type for weighted groups. Each object in the list should have the following attributes:
        /// </summary>
        public InputList<Inputs.ElastigroupInstanceTypesWeightArgs> InstanceTypesWeights
        {
            get => _instanceTypesWeights ?? (_instanceTypesWeights = new InputList<Inputs.ElastigroupInstanceTypesWeightArgs>());
            set => _instanceTypesWeights = value;
        }

        [Input("integrationBeanstalk")]
        public Input<Inputs.ElastigroupIntegrationBeanstalkArgs>? IntegrationBeanstalk { get; set; }

        [Input("integrationCodedeploy")]
        public Input<Inputs.ElastigroupIntegrationCodedeployArgs>? IntegrationCodedeploy { get; set; }

        [Input("integrationDockerSwarm")]
        public Input<Inputs.ElastigroupIntegrationDockerSwarmArgs>? IntegrationDockerSwarm { get; set; }

        [Input("integrationEcs")]
        public Input<Inputs.ElastigroupIntegrationEcsArgs>? IntegrationEcs { get; set; }

        [Input("integrationGitlab")]
        public Input<Inputs.ElastigroupIntegrationGitlabArgs>? IntegrationGitlab { get; set; }

        [Input("integrationKubernetes")]
        public Input<Inputs.ElastigroupIntegrationKubernetesArgs>? IntegrationKubernetes { get; set; }

        [Input("integrationMesosphere")]
        public Input<Inputs.ElastigroupIntegrationMesosphereArgs>? IntegrationMesosphere { get; set; }

        [Input("integrationMultaiRuntime")]
        public Input<Inputs.ElastigroupIntegrationMultaiRuntimeArgs>? IntegrationMultaiRuntime { get; set; }

        [Input("integrationNomad")]
        public Input<Inputs.ElastigroupIntegrationNomadArgs>? IntegrationNomad { get; set; }

        [Input("integrationRancher")]
        public Input<Inputs.ElastigroupIntegrationRancherArgs>? IntegrationRancher { get; set; }

        [Input("integrationRoute53")]
        public Input<Inputs.ElastigroupIntegrationRoute53Args>? IntegrationRoute53 { get; set; }

        /// <summary>
        /// The key name that should be used for the instance.
        /// </summary>
        [Input("keyName")]
        public Input<string>? KeyName { get; set; }

        [Input("lifetimePeriod")]
        public Input<string>? LifetimePeriod { get; set; }

        /// <summary>
        /// The maximum number of instances the group should have at any time.
        /// </summary>
        [Input("maxSize")]
        public Input<int>? MaxSize { get; set; }

        /// <summary>
        /// Data that used to configure or manage the running instances:
        /// </summary>
        [Input("metadataOptions")]
        public Input<Inputs.ElastigroupMetadataOptionsArgs>? MetadataOptions { get; set; }

        /// <summary>
        /// The minimum number of instances the group should have at any time.
        /// </summary>
        [Input("minSize")]
        public Input<int>? MinSize { get; set; }

        [Input("multaiTargetSets")]
        private InputList<Inputs.ElastigroupMultaiTargetSetArgs>? _multaiTargetSets;
        public InputList<Inputs.ElastigroupMultaiTargetSetArgs> MultaiTargetSets
        {
            get => _multaiTargetSets ?? (_multaiTargetSets = new InputList<Inputs.ElastigroupMultaiTargetSetArgs>());
            set => _multaiTargetSets = value;
        }

        /// <summary>
        /// The group name.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("networkInterfaces")]
        private InputList<Inputs.ElastigroupNetworkInterfaceArgs>? _networkInterfaces;
        public InputList<Inputs.ElastigroupNetworkInterfaceArgs> NetworkInterfaces
        {
            get => _networkInterfaces ?? (_networkInterfaces = new InputList<Inputs.ElastigroupNetworkInterfaceArgs>());
            set => _networkInterfaces = value;
        }

        /// <summary>
        /// Number of on demand instances to launch in the group. All other instances will be spot instances. When this parameter is set the `spot_percentage` parameter is being ignored.
        /// </summary>
        [Input("ondemandCount")]
        public Input<int>? OndemandCount { get; set; }

        /// <summary>
        /// Select a prediction strategy. Valid values: `"balanced"`, `"costOriented"`, `"equalAzDistribution"`, `"availabilityOriented"`.
        /// </summary>
        [Input("orientation", required: true)]
        public Input<string> Orientation { get; set; } = null!;

        [Input("persistBlockDevices")]
        public Input<bool>? PersistBlockDevices { get; set; }

        [Input("persistPrivateIp")]
        public Input<bool>? PersistPrivateIp { get; set; }

        [Input("persistRootDevice")]
        public Input<bool>? PersistRootDevice { get; set; }

        /// <summary>
        /// Enable dedicated tenancy. Note: There is a flat hourly fee for each region in which dedicated tenancy is used.
        /// </summary>
        [Input("placementTenancy")]
        public Input<string>? PlacementTenancy { get; set; }

        [Input("preferredAvailabilityZones")]
        private InputList<string>? _preferredAvailabilityZones;

        /// <summary>
        /// The AZs to prioritize when launching Spot instances. If no markets are available in the Preferred AZs, Spot instances are launched in the non-preferred AZs. 
        /// Note: Must be a sublist of `availability_zones` and `orientation` value must not be `"equalAzDistribution"`.
        /// </summary>
        public InputList<string> PreferredAvailabilityZones
        {
            get => _preferredAvailabilityZones ?? (_preferredAvailabilityZones = new InputList<string>());
            set => _preferredAvailabilityZones = value;
        }

        [Input("privateIps")]
        private InputList<string>? _privateIps;
        public InputList<string> PrivateIps
        {
            get => _privateIps ?? (_privateIps = new InputList<string>());
            set => _privateIps = value;
        }

        /// <summary>
        /// Operation system type. Valid values: `"Linux/UNIX"`, `"SUSE Linux"`, `"Windows"`. 
        /// For EC2 Classic instances:  `"Linux/UNIX (Amazon VPC)"`, `"SUSE Linux (Amazon VPC)"`, `"Windows (Amazon VPC)"`.
        /// </summary>
        [Input("product", required: true)]
        public Input<string> Product { get; set; } = null!;

        /// <summary>
        /// The AWS region your group will be created in.
        /// Note: This parameter is required if you specify subnets (through subnet_ids). This parameter is optional if you specify Availability Zones (through availability_zones).
        /// </summary>
        [Input("region")]
        public Input<string>? Region { get; set; }

        /// <summary>
        /// Hold settings for strategy correction – replacing On-Demand for Spot instances. Supported Values: `"never"`, `"always"`, `"timeWindow"`
        /// </summary>
        [Input("revertToSpot")]
        public Input<Inputs.ElastigroupRevertToSpotArgs>? RevertToSpot { get; set; }

        [Input("scalingDownPolicies")]
        private InputList<Inputs.ElastigroupScalingDownPolicyArgs>? _scalingDownPolicies;
        public InputList<Inputs.ElastigroupScalingDownPolicyArgs> ScalingDownPolicies
        {
            get => _scalingDownPolicies ?? (_scalingDownPolicies = new InputList<Inputs.ElastigroupScalingDownPolicyArgs>());
            set => _scalingDownPolicies = value;
        }

        [Input("scalingStrategies")]
        private InputList<Inputs.ElastigroupScalingStrategyArgs>? _scalingStrategies;

        /// <summary>
        /// Set termination policy.
        /// </summary>
        public InputList<Inputs.ElastigroupScalingStrategyArgs> ScalingStrategies
        {
            get => _scalingStrategies ?? (_scalingStrategies = new InputList<Inputs.ElastigroupScalingStrategyArgs>());
            set => _scalingStrategies = value;
        }

        [Input("scalingTargetPolicies")]
        private InputList<Inputs.ElastigroupScalingTargetPolicyArgs>? _scalingTargetPolicies;
        public InputList<Inputs.ElastigroupScalingTargetPolicyArgs> ScalingTargetPolicies
        {
            get => _scalingTargetPolicies ?? (_scalingTargetPolicies = new InputList<Inputs.ElastigroupScalingTargetPolicyArgs>());
            set => _scalingTargetPolicies = value;
        }

        [Input("scalingUpPolicies")]
        private InputList<Inputs.ElastigroupScalingUpPolicyArgs>? _scalingUpPolicies;
        public InputList<Inputs.ElastigroupScalingUpPolicyArgs> ScalingUpPolicies
        {
            get => _scalingUpPolicies ?? (_scalingUpPolicies = new InputList<Inputs.ElastigroupScalingUpPolicyArgs>());
            set => _scalingUpPolicies = value;
        }

        [Input("scheduledTasks")]
        private InputList<Inputs.ElastigroupScheduledTaskArgs>? _scheduledTasks;
        public InputList<Inputs.ElastigroupScheduledTaskArgs> ScheduledTasks
        {
            get => _scheduledTasks ?? (_scheduledTasks = new InputList<Inputs.ElastigroupScheduledTaskArgs>());
            set => _scheduledTasks = value;
        }

        [Input("securityGroups", required: true)]
        private InputList<string>? _securityGroups;

        /// <summary>
        /// A list of associated security group IDS.
        /// </summary>
        public InputList<string> SecurityGroups
        {
            get => _securityGroups ?? (_securityGroups = new InputList<string>());
            set => _securityGroups = value;
        }

        /// <summary>
        /// The Base64-encoded shutdown script that executes prior to instance termination, for more information please see: [Shutdown Script](https://api.spotinst.com/integration-docs/elastigroup/concepts/compute-concepts/shutdown-scripts/)
        /// </summary>
        [Input("shutdownScript")]
        public Input<string>? ShutdownScript { get; set; }

        [Input("signals")]
        private InputList<Inputs.ElastigroupSignalArgs>? _signals;
        public InputList<Inputs.ElastigroupSignalArgs> Signals
        {
            get => _signals ?? (_signals = new InputList<Inputs.ElastigroupSignalArgs>());
            set => _signals = value;
        }

        /// <summary>
        /// The percentage of Spot instances that would spin up from the `desired_capacity` number.
        /// </summary>
        [Input("spotPercentage")]
        public Input<int>? SpotPercentage { get; set; }

        [Input("statefulDeallocation")]
        public Input<Inputs.ElastigroupStatefulDeallocationArgs>? StatefulDeallocation { get; set; }

        [Input("subnetIds")]
        private InputList<string>? _subnetIds;

        /// <summary>
        /// List of Strings of subnet identifiers.
        /// Note: When this parameter is set, `availability_zones` should be left unused.
        /// </summary>
        public InputList<string> SubnetIds
        {
            get => _subnetIds ?? (_subnetIds = new InputList<string>());
            set => _subnetIds = value;
        }

        [Input("tags")]
        private InputList<Inputs.ElastigroupTagArgs>? _tags;

        /// <summary>
        /// A key/value mapping of tags to assign to the resource.
        /// </summary>
        public InputList<Inputs.ElastigroupTagArgs> Tags
        {
            get => _tags ?? (_tags = new InputList<Inputs.ElastigroupTagArgs>());
            set => _tags = value;
        }

        [Input("targetGroupArns")]
        private InputList<string>? _targetGroupArns;
        public InputList<string> TargetGroupArns
        {
            get => _targetGroupArns ?? (_targetGroupArns = new InputList<string>());
            set => _targetGroupArns = value;
        }

        [Input("updatePolicy")]
        public Input<Inputs.ElastigroupUpdatePolicyArgs>? UpdatePolicy { get; set; }

        /// <summary>
        /// The user data to provide when launching the instance.
        /// </summary>
        [Input("userData")]
        public Input<string>? UserData { get; set; }

        /// <summary>
        /// In a case of any available reserved instances, Elastigroup will utilize them first before purchasing Spot instances.
        /// </summary>
        [Input("utilizeReservedInstances")]
        public Input<bool>? UtilizeReservedInstances { get; set; }

        /// <summary>
        /// Minimum number of instances in a 'HEALTHY' status that is required before continuing. This is ignored when updating with blue/green deployment. Cannot exceed `desired_capacity`.
        /// </summary>
        [Input("waitForCapacity")]
        public Input<int>? WaitForCapacity { get; set; }

        /// <summary>
        /// Time (seconds) to wait for instances to report a 'HEALTHY' status. Useful for plans with multiple dependencies that take some time to initialize. Leave undefined or set to `0` to indicate no wait. This is ignored when updating with blue/green deployment.
        /// </summary>
        [Input("waitForCapacityTimeout")]
        public Input<int>? WaitForCapacityTimeout { get; set; }

        public ElastigroupArgs()
        {
        }
    }

    public sealed class ElastigroupState : Pulumi.ResourceArgs
    {
        [Input("availabilityZones")]
        private InputList<string>? _availabilityZones;

        /// <summary>
        /// List of Strings of availability zones. When this parameter is set, `subnet_ids` should be left unused.
        /// Note: `availability_zones` naming syntax follows the convention `availability-zone:subnet:placement-group-name`. For example, to set an AZ in `us-east-1` with subnet `subnet-123456` and placement group `ClusterI03`, you would set:
        /// `availability_zones = ["us-east-1a:subnet-123456:ClusterI03"]`
        /// </summary>
        public InputList<string> AvailabilityZones
        {
            get => _availabilityZones ?? (_availabilityZones = new InputList<string>());
            set => _availabilityZones = value;
        }

        [Input("blockDevicesMode")]
        public Input<string>? BlockDevicesMode { get; set; }

        /// <summary>
        /// The capacity unit to launch instances by. If not specified, when choosing the weight unit, each instance will weight as the number of its vCPUs.
        /// </summary>
        [Input("capacityUnit")]
        public Input<string>? CapacityUnit { get; set; }

        /// <summary>
        /// Controls how T3 instances are launched. Valid values: `standard`, `unlimited`.
        /// </summary>
        [Input("cpuCredits")]
        public Input<string>? CpuCredits { get; set; }

        /// <summary>
        /// The group description.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The desired number of instances the group should have at any time.
        /// </summary>
        [Input("desiredCapacity")]
        public Input<int>? DesiredCapacity { get; set; }

        /// <summary>
        /// The time in seconds, the instance is allowed to run while detached from the ELB. This is to allow the instance time to be drained from incoming TCP connections before terminating it, during a scale down operation.
        /// </summary>
        [Input("drainingTimeout")]
        public Input<int>? DrainingTimeout { get; set; }

        [Input("ebsBlockDevices")]
        private InputList<Inputs.ElastigroupEbsBlockDeviceGetArgs>? _ebsBlockDevices;
        public InputList<Inputs.ElastigroupEbsBlockDeviceGetArgs> EbsBlockDevices
        {
            get => _ebsBlockDevices ?? (_ebsBlockDevices = new InputList<Inputs.ElastigroupEbsBlockDeviceGetArgs>());
            set => _ebsBlockDevices = value;
        }

        /// <summary>
        /// Enable high bandwidth connectivity between instances and AWS’s Elastic Block Store (EBS). For instance types that are EBS-optimized by default this parameter will be ignored.
        /// </summary>
        [Input("ebsOptimized")]
        public Input<bool>? EbsOptimized { get; set; }

        [Input("elasticIps")]
        private InputList<string>? _elasticIps;

        /// <summary>
        /// A list of [AWS Elastic IP](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html) allocation IDs to associate to the group instances.
        /// </summary>
        public InputList<string> ElasticIps
        {
            get => _elasticIps ?? (_elasticIps = new InputList<string>());
            set => _elasticIps = value;
        }

        [Input("elasticLoadBalancers")]
        private InputList<string>? _elasticLoadBalancers;
        public InputList<string> ElasticLoadBalancers
        {
            get => _elasticLoadBalancers ?? (_elasticLoadBalancers = new InputList<string>());
            set => _elasticLoadBalancers = value;
        }

        /// <summary>
        /// Indicates whether monitoring is enabled for the instance.
        /// </summary>
        [Input("enableMonitoring")]
        public Input<bool>? EnableMonitoring { get; set; }

        [Input("ephemeralBlockDevices")]
        private InputList<Inputs.ElastigroupEphemeralBlockDeviceGetArgs>? _ephemeralBlockDevices;
        public InputList<Inputs.ElastigroupEphemeralBlockDeviceGetArgs> EphemeralBlockDevices
        {
            get => _ephemeralBlockDevices ?? (_ephemeralBlockDevices = new InputList<Inputs.ElastigroupEphemeralBlockDeviceGetArgs>());
            set => _ephemeralBlockDevices = value;
        }

        /// <summary>
        /// In a case of no Spot instances available, Elastigroup will launch on-demand instances instead.
        /// </summary>
        [Input("fallbackToOndemand")]
        public Input<bool>? FallbackToOndemand { get; set; }

        /// <summary>
        /// The amount of time, in seconds, after the instance has launched to starts and check its health.
        /// </summary>
        [Input("healthCheckGracePeriod")]
        public Input<int>? HealthCheckGracePeriod { get; set; }

        /// <summary>
        /// The service that will perform health checks for the instance. Valid values: `"ELB"`, `"HCS"`, `"TARGET_GROUP"`, `"MLB"`, `"EC2"`, `"MULTAI_TARGET_SET"`, `"MLB_RUNTIME"`, `"K8S_NODE"`, `"NOMAD_NODE"`, `"ECS_CLUSTER_INSTANCE"`.
        /// </summary>
        [Input("healthCheckType")]
        public Input<string>? HealthCheckType { get; set; }

        /// <summary>
        /// The amount of time, in seconds, that we will wait before replacing an instance that is running and became unhealthy (this is only applicable for instances that were once healthy).
        /// </summary>
        [Input("healthCheckUnhealthyDurationBeforeReplacement")]
        public Input<int>? HealthCheckUnhealthyDurationBeforeReplacement { get; set; }

        /// <summary>
        /// The ARN or name of an IAM instance profile to associate with launched instances.
        /// </summary>
        [Input("iamInstanceProfile")]
        public Input<string>? IamInstanceProfile { get; set; }

        /// <summary>
        /// The ID of the AMI used to launch the instance.
        /// </summary>
        [Input("imageId")]
        public Input<string>? ImageId { get; set; }

        /// <summary>
        /// The type of instance determines your instance's CPU capacity, memory and storage (e.g., m1.small, c1.xlarge).
        /// </summary>
        [Input("instanceTypesOndemand")]
        public Input<string>? InstanceTypesOndemand { get; set; }

        [Input("instanceTypesPreferredSpots")]
        private InputList<string>? _instanceTypesPreferredSpots;

        /// <summary>
        /// Prioritize a subset of spot instance types. Must be a subset of the selected spot instance types.
        /// </summary>
        public InputList<string> InstanceTypesPreferredSpots
        {
            get => _instanceTypesPreferredSpots ?? (_instanceTypesPreferredSpots = new InputList<string>());
            set => _instanceTypesPreferredSpots = value;
        }

        [Input("instanceTypesSpots")]
        private InputList<string>? _instanceTypesSpots;

        /// <summary>
        /// One or more instance types.
        /// </summary>
        public InputList<string> InstanceTypesSpots
        {
            get => _instanceTypesSpots ?? (_instanceTypesSpots = new InputList<string>());
            set => _instanceTypesSpots = value;
        }

        [Input("instanceTypesWeights")]
        private InputList<Inputs.ElastigroupInstanceTypesWeightGetArgs>? _instanceTypesWeights;

        /// <summary>
        /// List of weights per instance type for weighted groups. Each object in the list should have the following attributes:
        /// </summary>
        public InputList<Inputs.ElastigroupInstanceTypesWeightGetArgs> InstanceTypesWeights
        {
            get => _instanceTypesWeights ?? (_instanceTypesWeights = new InputList<Inputs.ElastigroupInstanceTypesWeightGetArgs>());
            set => _instanceTypesWeights = value;
        }

        [Input("integrationBeanstalk")]
        public Input<Inputs.ElastigroupIntegrationBeanstalkGetArgs>? IntegrationBeanstalk { get; set; }

        [Input("integrationCodedeploy")]
        public Input<Inputs.ElastigroupIntegrationCodedeployGetArgs>? IntegrationCodedeploy { get; set; }

        [Input("integrationDockerSwarm")]
        public Input<Inputs.ElastigroupIntegrationDockerSwarmGetArgs>? IntegrationDockerSwarm { get; set; }

        [Input("integrationEcs")]
        public Input<Inputs.ElastigroupIntegrationEcsGetArgs>? IntegrationEcs { get; set; }

        [Input("integrationGitlab")]
        public Input<Inputs.ElastigroupIntegrationGitlabGetArgs>? IntegrationGitlab { get; set; }

        [Input("integrationKubernetes")]
        public Input<Inputs.ElastigroupIntegrationKubernetesGetArgs>? IntegrationKubernetes { get; set; }

        [Input("integrationMesosphere")]
        public Input<Inputs.ElastigroupIntegrationMesosphereGetArgs>? IntegrationMesosphere { get; set; }

        [Input("integrationMultaiRuntime")]
        public Input<Inputs.ElastigroupIntegrationMultaiRuntimeGetArgs>? IntegrationMultaiRuntime { get; set; }

        [Input("integrationNomad")]
        public Input<Inputs.ElastigroupIntegrationNomadGetArgs>? IntegrationNomad { get; set; }

        [Input("integrationRancher")]
        public Input<Inputs.ElastigroupIntegrationRancherGetArgs>? IntegrationRancher { get; set; }

        [Input("integrationRoute53")]
        public Input<Inputs.ElastigroupIntegrationRoute53GetArgs>? IntegrationRoute53 { get; set; }

        /// <summary>
        /// The key name that should be used for the instance.
        /// </summary>
        [Input("keyName")]
        public Input<string>? KeyName { get; set; }

        [Input("lifetimePeriod")]
        public Input<string>? LifetimePeriod { get; set; }

        /// <summary>
        /// The maximum number of instances the group should have at any time.
        /// </summary>
        [Input("maxSize")]
        public Input<int>? MaxSize { get; set; }

        /// <summary>
        /// Data that used to configure or manage the running instances:
        /// </summary>
        [Input("metadataOptions")]
        public Input<Inputs.ElastigroupMetadataOptionsGetArgs>? MetadataOptions { get; set; }

        /// <summary>
        /// The minimum number of instances the group should have at any time.
        /// </summary>
        [Input("minSize")]
        public Input<int>? MinSize { get; set; }

        [Input("multaiTargetSets")]
        private InputList<Inputs.ElastigroupMultaiTargetSetGetArgs>? _multaiTargetSets;
        public InputList<Inputs.ElastigroupMultaiTargetSetGetArgs> MultaiTargetSets
        {
            get => _multaiTargetSets ?? (_multaiTargetSets = new InputList<Inputs.ElastigroupMultaiTargetSetGetArgs>());
            set => _multaiTargetSets = value;
        }

        /// <summary>
        /// The group name.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("networkInterfaces")]
        private InputList<Inputs.ElastigroupNetworkInterfaceGetArgs>? _networkInterfaces;
        public InputList<Inputs.ElastigroupNetworkInterfaceGetArgs> NetworkInterfaces
        {
            get => _networkInterfaces ?? (_networkInterfaces = new InputList<Inputs.ElastigroupNetworkInterfaceGetArgs>());
            set => _networkInterfaces = value;
        }

        /// <summary>
        /// Number of on demand instances to launch in the group. All other instances will be spot instances. When this parameter is set the `spot_percentage` parameter is being ignored.
        /// </summary>
        [Input("ondemandCount")]
        public Input<int>? OndemandCount { get; set; }

        /// <summary>
        /// Select a prediction strategy. Valid values: `"balanced"`, `"costOriented"`, `"equalAzDistribution"`, `"availabilityOriented"`.
        /// </summary>
        [Input("orientation")]
        public Input<string>? Orientation { get; set; }

        [Input("persistBlockDevices")]
        public Input<bool>? PersistBlockDevices { get; set; }

        [Input("persistPrivateIp")]
        public Input<bool>? PersistPrivateIp { get; set; }

        [Input("persistRootDevice")]
        public Input<bool>? PersistRootDevice { get; set; }

        /// <summary>
        /// Enable dedicated tenancy. Note: There is a flat hourly fee for each region in which dedicated tenancy is used.
        /// </summary>
        [Input("placementTenancy")]
        public Input<string>? PlacementTenancy { get; set; }

        [Input("preferredAvailabilityZones")]
        private InputList<string>? _preferredAvailabilityZones;

        /// <summary>
        /// The AZs to prioritize when launching Spot instances. If no markets are available in the Preferred AZs, Spot instances are launched in the non-preferred AZs. 
        /// Note: Must be a sublist of `availability_zones` and `orientation` value must not be `"equalAzDistribution"`.
        /// </summary>
        public InputList<string> PreferredAvailabilityZones
        {
            get => _preferredAvailabilityZones ?? (_preferredAvailabilityZones = new InputList<string>());
            set => _preferredAvailabilityZones = value;
        }

        [Input("privateIps")]
        private InputList<string>? _privateIps;
        public InputList<string> PrivateIps
        {
            get => _privateIps ?? (_privateIps = new InputList<string>());
            set => _privateIps = value;
        }

        /// <summary>
        /// Operation system type. Valid values: `"Linux/UNIX"`, `"SUSE Linux"`, `"Windows"`. 
        /// For EC2 Classic instances:  `"Linux/UNIX (Amazon VPC)"`, `"SUSE Linux (Amazon VPC)"`, `"Windows (Amazon VPC)"`.
        /// </summary>
        [Input("product")]
        public Input<string>? Product { get; set; }

        /// <summary>
        /// The AWS region your group will be created in.
        /// Note: This parameter is required if you specify subnets (through subnet_ids). This parameter is optional if you specify Availability Zones (through availability_zones).
        /// </summary>
        [Input("region")]
        public Input<string>? Region { get; set; }

        /// <summary>
        /// Hold settings for strategy correction – replacing On-Demand for Spot instances. Supported Values: `"never"`, `"always"`, `"timeWindow"`
        /// </summary>
        [Input("revertToSpot")]
        public Input<Inputs.ElastigroupRevertToSpotGetArgs>? RevertToSpot { get; set; }

        [Input("scalingDownPolicies")]
        private InputList<Inputs.ElastigroupScalingDownPolicyGetArgs>? _scalingDownPolicies;
        public InputList<Inputs.ElastigroupScalingDownPolicyGetArgs> ScalingDownPolicies
        {
            get => _scalingDownPolicies ?? (_scalingDownPolicies = new InputList<Inputs.ElastigroupScalingDownPolicyGetArgs>());
            set => _scalingDownPolicies = value;
        }

        [Input("scalingStrategies")]
        private InputList<Inputs.ElastigroupScalingStrategyGetArgs>? _scalingStrategies;

        /// <summary>
        /// Set termination policy.
        /// </summary>
        public InputList<Inputs.ElastigroupScalingStrategyGetArgs> ScalingStrategies
        {
            get => _scalingStrategies ?? (_scalingStrategies = new InputList<Inputs.ElastigroupScalingStrategyGetArgs>());
            set => _scalingStrategies = value;
        }

        [Input("scalingTargetPolicies")]
        private InputList<Inputs.ElastigroupScalingTargetPolicyGetArgs>? _scalingTargetPolicies;
        public InputList<Inputs.ElastigroupScalingTargetPolicyGetArgs> ScalingTargetPolicies
        {
            get => _scalingTargetPolicies ?? (_scalingTargetPolicies = new InputList<Inputs.ElastigroupScalingTargetPolicyGetArgs>());
            set => _scalingTargetPolicies = value;
        }

        [Input("scalingUpPolicies")]
        private InputList<Inputs.ElastigroupScalingUpPolicyGetArgs>? _scalingUpPolicies;
        public InputList<Inputs.ElastigroupScalingUpPolicyGetArgs> ScalingUpPolicies
        {
            get => _scalingUpPolicies ?? (_scalingUpPolicies = new InputList<Inputs.ElastigroupScalingUpPolicyGetArgs>());
            set => _scalingUpPolicies = value;
        }

        [Input("scheduledTasks")]
        private InputList<Inputs.ElastigroupScheduledTaskGetArgs>? _scheduledTasks;
        public InputList<Inputs.ElastigroupScheduledTaskGetArgs> ScheduledTasks
        {
            get => _scheduledTasks ?? (_scheduledTasks = new InputList<Inputs.ElastigroupScheduledTaskGetArgs>());
            set => _scheduledTasks = value;
        }

        [Input("securityGroups")]
        private InputList<string>? _securityGroups;

        /// <summary>
        /// A list of associated security group IDS.
        /// </summary>
        public InputList<string> SecurityGroups
        {
            get => _securityGroups ?? (_securityGroups = new InputList<string>());
            set => _securityGroups = value;
        }

        /// <summary>
        /// The Base64-encoded shutdown script that executes prior to instance termination, for more information please see: [Shutdown Script](https://api.spotinst.com/integration-docs/elastigroup/concepts/compute-concepts/shutdown-scripts/)
        /// </summary>
        [Input("shutdownScript")]
        public Input<string>? ShutdownScript { get; set; }

        [Input("signals")]
        private InputList<Inputs.ElastigroupSignalGetArgs>? _signals;
        public InputList<Inputs.ElastigroupSignalGetArgs> Signals
        {
            get => _signals ?? (_signals = new InputList<Inputs.ElastigroupSignalGetArgs>());
            set => _signals = value;
        }

        /// <summary>
        /// The percentage of Spot instances that would spin up from the `desired_capacity` number.
        /// </summary>
        [Input("spotPercentage")]
        public Input<int>? SpotPercentage { get; set; }

        [Input("statefulDeallocation")]
        public Input<Inputs.ElastigroupStatefulDeallocationGetArgs>? StatefulDeallocation { get; set; }

        [Input("subnetIds")]
        private InputList<string>? _subnetIds;

        /// <summary>
        /// List of Strings of subnet identifiers.
        /// Note: When this parameter is set, `availability_zones` should be left unused.
        /// </summary>
        public InputList<string> SubnetIds
        {
            get => _subnetIds ?? (_subnetIds = new InputList<string>());
            set => _subnetIds = value;
        }

        [Input("tags")]
        private InputList<Inputs.ElastigroupTagGetArgs>? _tags;

        /// <summary>
        /// A key/value mapping of tags to assign to the resource.
        /// </summary>
        public InputList<Inputs.ElastigroupTagGetArgs> Tags
        {
            get => _tags ?? (_tags = new InputList<Inputs.ElastigroupTagGetArgs>());
            set => _tags = value;
        }

        [Input("targetGroupArns")]
        private InputList<string>? _targetGroupArns;
        public InputList<string> TargetGroupArns
        {
            get => _targetGroupArns ?? (_targetGroupArns = new InputList<string>());
            set => _targetGroupArns = value;
        }

        [Input("updatePolicy")]
        public Input<Inputs.ElastigroupUpdatePolicyGetArgs>? UpdatePolicy { get; set; }

        /// <summary>
        /// The user data to provide when launching the instance.
        /// </summary>
        [Input("userData")]
        public Input<string>? UserData { get; set; }

        /// <summary>
        /// In a case of any available reserved instances, Elastigroup will utilize them first before purchasing Spot instances.
        /// </summary>
        [Input("utilizeReservedInstances")]
        public Input<bool>? UtilizeReservedInstances { get; set; }

        /// <summary>
        /// Minimum number of instances in a 'HEALTHY' status that is required before continuing. This is ignored when updating with blue/green deployment. Cannot exceed `desired_capacity`.
        /// </summary>
        [Input("waitForCapacity")]
        public Input<int>? WaitForCapacity { get; set; }

        /// <summary>
        /// Time (seconds) to wait for instances to report a 'HEALTHY' status. Useful for plans with multiple dependencies that take some time to initialize. Leave undefined or set to `0` to indicate no wait. This is ignored when updating with blue/green deployment.
        /// </summary>
        [Input("waitForCapacityTimeout")]
        public Input<int>? WaitForCapacityTimeout { get; set; }

        public ElastigroupState()
        {
        }
    }
}
