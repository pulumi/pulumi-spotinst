// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package multai

import (
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// Provides a Spotinst Multai Routing Rule.
//
// > This content is derived from https://github.com/terraform-providers/terraform-provider-spotinst/blob/master/website/docs/r/multai_routing_rule.html.markdown.
type RoutingRule struct {
	s *pulumi.ResourceState
}

// NewRoutingRule registers a new resource with the given unique name, arguments, and options.
func NewRoutingRule(ctx *pulumi.Context,
	name string, args *RoutingRuleArgs, opts ...pulumi.ResourceOpt) (*RoutingRule, error) {
	if args == nil || args.BalancerId == nil {
		return nil, errors.New("missing required argument 'BalancerId'")
	}
	if args == nil || args.ListenerId == nil {
		return nil, errors.New("missing required argument 'ListenerId'")
	}
	if args == nil || args.Route == nil {
		return nil, errors.New("missing required argument 'Route'")
	}
	if args == nil || args.TargetSetIds == nil {
		return nil, errors.New("missing required argument 'TargetSetIds'")
	}
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["balancerId"] = nil
		inputs["listenerId"] = nil
		inputs["middlewareIds"] = nil
		inputs["priority"] = nil
		inputs["route"] = nil
		inputs["strategy"] = nil
		inputs["tags"] = nil
		inputs["targetSetIds"] = nil
	} else {
		inputs["balancerId"] = args.BalancerId
		inputs["listenerId"] = args.ListenerId
		inputs["middlewareIds"] = args.MiddlewareIds
		inputs["priority"] = args.Priority
		inputs["route"] = args.Route
		inputs["strategy"] = args.Strategy
		inputs["tags"] = args.Tags
		inputs["targetSetIds"] = args.TargetSetIds
	}
	s, err := ctx.RegisterResource("spotinst:multai/routingRule:RoutingRule", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &RoutingRule{s: s}, nil
}

// GetRoutingRule gets an existing RoutingRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRoutingRule(ctx *pulumi.Context,
	name string, id pulumi.ID, state *RoutingRuleState, opts ...pulumi.ResourceOpt) (*RoutingRule, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["balancerId"] = state.BalancerId
		inputs["listenerId"] = state.ListenerId
		inputs["middlewareIds"] = state.MiddlewareIds
		inputs["priority"] = state.Priority
		inputs["route"] = state.Route
		inputs["strategy"] = state.Strategy
		inputs["tags"] = state.Tags
		inputs["targetSetIds"] = state.TargetSetIds
	}
	s, err := ctx.ReadResource("spotinst:multai/routingRule:RoutingRule", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &RoutingRule{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *RoutingRule) URN() pulumi.URNOutput {
	return r.s.URN()
}

// ID is this resource's unique identifier assigned by its provider.
func (r *RoutingRule) ID() pulumi.IDOutput {
	return r.s.ID()
}

// The ID of the balancer.
func (r *RoutingRule) BalancerId() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["balancerId"])
}

// The ID of the listener.
func (r *RoutingRule) ListenerId() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["listenerId"])
}

func (r *RoutingRule) MiddlewareIds() pulumi.ArrayOutput {
	return (pulumi.ArrayOutput)(r.s.State["middlewareIds"])
}

func (r *RoutingRule) Priority() pulumi.IntOutput {
	return (pulumi.IntOutput)(r.s.State["priority"])
}

// Route defines a simple language for matching HTTP requests and route the traffic accordingly. Route provides series of matchers that follow the syntax: Path matcher: — Path("/foo/bar") // trie-based PathRegexp(“/foo/.*”) // regexp-based Method matcher: — Method(“GET”) // trie-based MethodRegexp(“POST|PUT”) // regexp based Header matcher: — Header(“Content-Type”, “application/json”) // trie-based HeaderRegexp(“Content-Type”, “application/.*”) // regexp based Matchers can be combined using && operator: — Method(“POST”) && Path("/v1")
func (r *RoutingRule) Route() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["route"])
}

// Balancing strategy. Valid values: `ROUNDROBIN`, `RANDOM`, `LEASTCONN`, `IPHASH`.
func (r *RoutingRule) Strategy() pulumi.StringOutput {
	return (pulumi.StringOutput)(r.s.State["strategy"])
}

// A list of key:value paired tags.
func (r *RoutingRule) Tags() pulumi.ArrayOutput {
	return (pulumi.ArrayOutput)(r.s.State["tags"])
}

func (r *RoutingRule) TargetSetIds() pulumi.ArrayOutput {
	return (pulumi.ArrayOutput)(r.s.State["targetSetIds"])
}

// Input properties used for looking up and filtering RoutingRule resources.
type RoutingRuleState struct {
	// The ID of the balancer.
	BalancerId interface{}
	// The ID of the listener.
	ListenerId interface{}
	MiddlewareIds interface{}
	Priority interface{}
	// Route defines a simple language for matching HTTP requests and route the traffic accordingly. Route provides series of matchers that follow the syntax: Path matcher: — Path("/foo/bar") // trie-based PathRegexp(“/foo/.*”) // regexp-based Method matcher: — Method(“GET”) // trie-based MethodRegexp(“POST|PUT”) // regexp based Header matcher: — Header(“Content-Type”, “application/json”) // trie-based HeaderRegexp(“Content-Type”, “application/.*”) // regexp based Matchers can be combined using && operator: — Method(“POST”) && Path("/v1")
	Route interface{}
	// Balancing strategy. Valid values: `ROUNDROBIN`, `RANDOM`, `LEASTCONN`, `IPHASH`.
	Strategy interface{}
	// A list of key:value paired tags.
	Tags interface{}
	TargetSetIds interface{}
}

// The set of arguments for constructing a RoutingRule resource.
type RoutingRuleArgs struct {
	// The ID of the balancer.
	BalancerId interface{}
	// The ID of the listener.
	ListenerId interface{}
	MiddlewareIds interface{}
	Priority interface{}
	// Route defines a simple language for matching HTTP requests and route the traffic accordingly. Route provides series of matchers that follow the syntax: Path matcher: — Path("/foo/bar") // trie-based PathRegexp(“/foo/.*”) // regexp-based Method matcher: — Method(“GET”) // trie-based MethodRegexp(“POST|PUT”) // regexp based Header matcher: — Header(“Content-Type”, “application/json”) // trie-based HeaderRegexp(“Content-Type”, “application/.*”) // regexp based Matchers can be combined using && operator: — Method(“POST”) && Path("/v1")
	Route interface{}
	// Balancing strategy. Valid values: `ROUNDROBIN`, `RANDOM`, `LEASTCONN`, `IPHASH`.
	Strategy interface{}
	// A list of key:value paired tags.
	Tags interface{}
	TargetSetIds interface{}
}
